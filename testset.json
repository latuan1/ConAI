[
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int waysToPartition. /*FC*/class Solution {\n/*FM*/int waysToPartition(vector<int>& nums, int k) \n    {        \n        int n = nums.size(); \n        long sum = accumulate(nums.begin(), nums.end(), 0L); \n        vector<long>rets(n);         \n        \n        vector<long>pre(n);         \n        pre[0] = nums[0]; \n        for (int i=1;  i<n;  i++)\n            pre[i] = pre[i-1]+nums[i];         \n        unordered_map<int,int>count; \n        for (int i=0;  i<n;  i++)\n        {\n            int new_sum = sum + k-nums[i]; \n            if (new_sum % 2 == 0)\n                rets[i] += count[new_sum/2]; \n            count[pre[i]]++; \n        }\n        \n        vector<long>suf(n);         \n        suf[n-1] = nums[n-1]; \n        for (int i=n-2;  i>=0;  i--)\n            suf[i] = suf[i+1]+nums[i]; \n        count.clear(); \n        for (int i=n-1;  i>=0;  i--)\n        {\n            int new_sum = sum + k-nums[i]; \n            if (new_sum % 2 == 0)\n                rets[i] += count[new_sum/2]; \n            count[suf[i]]++; \n        }         \n        \n        long ret = 0; \n        for (int i=0;  i<n-1;  i++)\n        {\n            if (pre[i]==sum-pre[i])\n                \n        }\n        \n        for (int i=0;  i<n;  i++)\n            ret = max(ret, rets[i]); \n        \n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1076724343\"], \"nums_element1\": [\"-1816985020\"], \"k\": [\"-880383522\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isRectangleCover. /*FC*/class Solution {\n/*FM*/bool isRectangleCover(vector<vector<int>>& rectangles) \n    {\n        long long area=0; \n        unordered_set<string>Set; \n        for (int i=0;  i<rectangles.size();  i++)\n        {\n            string str; \n            str=to_string(rectangles[i][0]); \n            str+=\",\"; \n            str+=to_string(rectangles[i][1]); \n            if (Set.find(str)==Set.end())\n                Set.insert(str); \n            else\n                \n            \n            str=to_string(rectangles[i][0]); \n            str+=\",\"; \n            str+=to_string(rectangles[i][3]); \n            if (Set.find(str)==Set.end())\n                Set.insert(str); \n            else\n                \n            \n            str=to_string(rectangles[i][2]); \n            str+=\",\"; \n            str+=to_string(rectangles[i][1]); \n            if (Set.find(str)==Set.end())\n                Set.insert(str); \n            else\n                \n            \n            str=to_string(rectangles[i][2]); \n            str+=\",\"; \n            str+=to_string(rectangles[i][3]); \n            if (Set.find(str)==Set.end())\n                Set.insert(str); \n            else\n                         \n            \n            area+= (long long)(rectangles[i][3]-rectangles[i][1])*(long long)(rectangles[i][2]-rectangles[i][0]); \n        }\n        \n        if (Set.size()!=4) return false; \n        \n        \n        for (:Set)\n        {\n            \n            \n            \n            \n            \n        }\n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"rectangles\": [2], \"rectangles_element0\": [3], \"rectangles_element0_element0\": [\"1123643571\"], \"rectangles_element0_element1\": [\"-681234629\"], \"rectangles_element0_element2\": [\"1883473777\"], \"rectangles_element1\": [2], \"rectangles_element1_element0\": [\"-1864677497\"], \"rectangles_element1_element1\": [\"454832797\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minFlips. /*FC*/class Solution {\n/*FM*/int minFlips(string s) \n    {\n        int n = s.size(); \n        \n        vector<int>left0(n); \n        vector<int>left1(n); \n        vector<int>right0(n); \n        vector<int>right1(n); \n        \n        int sumLeft0 = 0, sumLeft1 = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            if (i%2==0 && s[i]=='1' || i%2==1 && s[i]=='0')\n                \n            if (i%2==0 && s[i]=='0' || i%2==1 && s[i]=='1')\n                \n            left0[i] = sumLeft0; \n            left1[i] = sumLeft1; \n        }\n        \n        int sumRight0 = 0, sumRight1 = 0; \n        for (int i=n-1;  i>=0;  i--)\n        {\n            int j = n-1-i; \n            if (j%2==0 && s[i]=='1' || j%2==1 && s[i]=='0')\n                \n            if (j%2==0 && s[i]=='0' || j%2==1 && s[i]=='1')\n                \n            right0[i] = sumRight0; \n            right1[i] = sumRight1; \n        }\n        \n        int ret = n; \n        ret = min(ret, sumLeft0); \n        ret = min(ret, sumLeft1); \n        ret = min(ret, sumRight0); \n        ret = min(ret, sumRight1); \n        \n        for (int i=0;  i<n-1;  )\n        {\n            \n            \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int cherryPickup. /*FC*/class Solution {\n/*FM*/int cherryPickup(vector<vector<int>>& grid) {\n        int N = grid.size(); \n        vector<vector<int>> dp(N, vector<int>(N)); \n        dp[0][0] = grid[0][0]; \n        int maxStep = 2 * N - 2; \n        for (int k = 1;  k <= maxStep;  ++k) {\n            for (int i = N - 1;  i >= 0;  --i) {\n                for (int p = N - 1;  p >= 0;  --p) {\n                    int j = k - i; \n                    int q = k - p; \n                    if (j < 0 || j >= N || q < 0 || q >= N || grid[i][j] == -1 || grid[p][q] == -1) {\n                        dp[i][p] = -1; \n                        continue; \n                    }\n                    \n                    if (i > 0) {\n                        dp[i][p] = max(dp[i][p], dp[i - 1][p]); \n                    }\n                    if (p > 0) {\n                        dp[i][p] = max(dp[i][p], dp[i][p - 1]); \n                    }\n                    if (i > 0 && p > 0) {\n                        dp[i][p] = max(dp[i][p], dp[i - 1][p - 1]); \n                    }\n                    if (dp[i][p] >= 0) {\n                        dp[i][p] += grid[i][j] + ((i != p) ? grid[p][q] : 0); \n                    }                    \n                }\n            }\n        }\n        \n        return dp[N - 1][N - 1] > 0 ? dp[N - 1][N - 1] : 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"-678361803\"], \"grid_element0_element1\": [\"1811102028\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"394180560\"], \"grid_element1_element1\": [\"515962137\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<pair<int, int> > getSkyline. /*FC*/class Solution {\n/*FM*/vector<pair<int, int> > getSkyline(vector<vector<int> >& buildings) {\r\n        map<int, vector<Endpoint>> point_to_height;   \n        for (const auto& building : buildings) {\r\n            point_to_height[building[start]].emplace_back(Endpoint{building[height], true}); \r\n            point_to_height[building[end]].emplace_back(Endpoint{building[height], false}); \r\n        }\r\n\r\n        vector<pair<int, int>> res; \r\n        map<int, int> height_to_count;   \n        int curr_max = 0; \r\n        \n        for (const auto& kvp : point_to_height) {\r\n            const auto& point = kvp.first; \r\n            const auto& heights = kvp.second; \r\n\r\n            for (const auto& h : heights) {\r\n                if (h.isStart) {\r\n                    ++height_to_count[h.height]; \r\n                } else {\r\n                    --height_to_count[h.height]; \r\n                    if (height_to_count[h.height] == 0) {\r\n                        height_to_count.erase(h.height); \r\n                    }\r\n                }\r\n            }\r\n\r\n            if (height_to_count.empty() ||\r\n                curr_max != height_to_count.crbegin()->first) {\r\n                curr_max = height_to_count.empty() ?\r\n                           0 : height_to_count.crbegin()->first; \r\n                res.emplace_back(point, curr_max); \r\n            }\r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"buildings\": [2], \"buildings_element0\": [3], \"buildings_element0_element0\": [\"0\"], \"buildings_element0_element1\": [\"2\"], \"buildings_element0_element2\": [\"3\"], \"buildings_element1\": [3], \"buildings_element1_element0\": [\"2\"], \"buildings_element1_element1\": [\"5\"], \"buildings_element1_element2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *sortList. /*FC*/class Solution {\n/*FM*/ListNode *sortList(ListNode *head) {\n\t\t\n\t\tListNode* p = head; \n\t\tint len = 0; \n\t\twhile (p != NULL)\n\t\t{\n\t\t\tp = p->next; \n\t\t\tlen++; \n\t\t}\n\n\t\tListNode* fakehead = new ListNode(-1); \n\t\tfakehead->next = head; \n\n\t\tfor (int interval = 1;  interval <= len;  interval = interval * 2)\n\t\t{\n\t\t\tListNode* pre  = fakehead; \n\t\t\tListNode* slow = fakehead->next, *fast = fakehead->next; \n\t\t\twhile (fast != NULL || slow != NULL)\n\t\t\t{\n\t\t\t\tint i = 0; \n\t\t\t\twhile (i < interval && fast != NULL)\n\t\t\t\t{\n\t\t\t\t\tfast = fast->next;  \n\t\t\t\t\ti++; \n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tint fvisit = 0, svisit = 0; \n\t\t\t\twhile (fvisit < interval && svisit < interval && fast != NULL && slow != NULL)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\twhile (fvisit < interval && fast != NULL)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\twhile (svisit < interval && slow != NULL)\n\t\t\t\t{\n\t\t\t\t\tpre->next = slow; \n\t\t\t\t\tpre = slow; \n\t\t\t\t\tslow = slow->next; \n\t\t\t\t\tsvisit++; \n\t\t\t\t}\n\t\t\t\tpre->next = fast; \n\t\t\t\tslow = fast; \n\n\t\t\t}\n\n\n\t\t}\n\n\t\tListNode* newhead = fakehead->next; \n\t\tdelete fakehead; \n\t\treturn newhead; \n\t};/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"0\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"0\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<pair<int, int>> getSkyline. /*FC*/class Solution {\n/*FM*/vector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) {\n        vector<pair<int, int>> result; \n        int n = buildings.size(); \n        if (n == 0) {\n            \n        }\n        \n        vector<Cell> points; \n        for (auto b : buildings) {\n            points.emplace_back(b[0], b[2], 1); \n            points.emplace_back(b[1], b[2], 0); \n        }\n        \n        sort(points.begin(), points.end()); \n        \n        int last = 0; \n        int prev = 0; \n        multiset<int> heights; \n        for (auto& c : points) {\n            if (heights.empty()) {\n                last = c.x; \n                if (prev && c.x > prev) {\n                    \n                }\n            }\n            \n            if (!heights.empty() && (*heights.rbegin()) <= c.h && last < c.x) {\n                \n                \n                if (!(result.size() && result.back().second == (*heights.rbegin()) && prev == last)) {\n                    result.push_back({last, *heights.rbegin()}); \n                }\n                prev = c.x; \n                last = c.x; \n            }\n            \n            if (c.isStart == 1) {\n                heights.insert(c.h); \n            }\n            else {\n                heights.erase(heights.lower_bound(c.h)); \n            }\n        }\n        \n        if (prev) {\n            result.push_back({prev, 0}); \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"buildings\": [2], \"buildings_element0\": [1], \"buildings_element0_element0\": [\"-1886059356\"], \"buildings_element1\": [1], \"buildings_element1_element0\": [\"-715108219\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> shortestAlternatingPaths. /*FC*/class Solution {\n/*FM*/vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& red_edges, vector<vector<int>>& blue_edges) {\r\n        vector<vector<unordered_set<int>>> neighbors(n, vector<unordered_set<int>>(2)); \r\n        for (const auto& edge : red_edges) {\r\n            neighbors[edge[0]][0].emplace(edge[1]); \r\n        }\r\n        for (const auto& edge : blue_edges) {\r\n            \r\n        }\r\n        const auto& INF = max(2 * n - 3, 0) + 1; \r\n        vector<vector<int>> dist(n, vector<int>(2, INF)); \r\n        dist[0] = {0, 0}; \r\n        queue<pair<int, int>> q({{0, 0}, {0, 1}}); \r\n        while (!q.empty()) {\r\n            int i, c; \r\n            tie(i, c) = q.front();  q.pop(); \r\n            for (const auto& j : neighbors[i][c]) {\r\n                if (dist[j][c] != INF) {\r\n                    \r\n                }\r\n                dist[j][c] = dist[i][1 ^ c] + 1; \r\n                q.emplace(j, 1 ^ c); \r\n            }\r\n        }\r\n        vector<int> result; \r\n        for (const auto& d : dist) {\r\n            const auto& x = *min_element(d.cbegin(), d.cend()); \r\n            result.emplace_back((x != INF) ? x : -1); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"3\"], \"red_edges\": [2], \"red_edges_element0\": [2], \"red_edges_element0_element0\": [\"0\"], \"red_edges_element0_element1\": [\"1\"], \"red_edges_element1\": [2], \"red_edges_element1_element0\": [\"1\"], \"red_edges_element1_element1\": [\"2\"], \"blue_edges\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<bool> findAnswer. /*FC*/class Solution2 {\n/*FM*/vector<bool> findAnswer(int n, vector<vector<int>>& edges) {\n        unordered_map<int, unordered_map<int,pair<int,int>>>graph; \n        auto cmp = [](vector<int>& a, vector<int>& b){\n            return a[0] > b[0]; \n        }; \n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)>pq(cmp); \n        for(int i = 0;  i < edges.size();  ++i){\n            vector<int>& e = edges[i]; \n            graph[e[0]][e[1]] = {e[2], i}; \n            graph[e[1]][e[0]] = {e[2], i}; \n        }\n        pq.push({0, 0}); \n        vector<int>dist(n, numeric_limits<int>::max());  \n        dist[0] = 0; \n        while(pq.size()){\n            int far = pq.top()[0]; \n            int point = pq.top()[1]; \n            pq.pop(); \n            if (dist[point] == far){\n                for(auto &nxt: graph[point]){\n                    \n                    \n                }\n            }\n        }\n        pq.push({dist[n-1], n-1}); \n        vector<bool>res(edges.size(), false); \n        while(!pq.empty()){\n            int far = pq.top()[0]; \n            int point = pq.top()[1]; \n            pq.pop(); \n            for(auto &prev: graph[point]){\n                \n                \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"n\": [\"83368426\"], \"edges\": [1], \"edges_element0\": [1], \"edges_element0_element0\": [\"-502166514\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void EditDistDP. /*FC*/ {\n/*FM*/void EditDistDP(string str1, string str2)\r\n{\r\n    int len1 = str1.length(); \r\n    int len2 = str2.length(); \r\n  \r\n    \n    \n    int DP[2][len1 + 1]; \r\n  \r\n    \n    memset(DP, 0, sizeof DP); \r\n  \r\n    \n    \n    for (int i = 0;  i <= len1;  i++)\r\n        DP[0][i] = i; \r\n  \r\n    \n    \n    \n    for (int i = 1;  i <= len2;  i++) {\r\n        \n        \n        \n        for (int j = 0;  j <= len1;  j++) {\r\n            \n            \n            \n            if (j == 0)\r\n                DP[i % 2][j] = i; \r\n  \r\n            \n            \n            \n            \n            else if (str1[j - 1] == str2[i - 1]) {\r\n                DP[i % 2][j] = DP[(i - 1) % 2][j - 1]; \r\n            }\r\n  \r\n            \n            \n            \n            else {\r\n                DP[i % 2][j] = 1 + min(DP[(i - 1) % 2][j],\r\n                                       min(DP[i % 2][j - 1],\r\n                                           DP[(i - 1) % 2][j - 1])); \r\n            }\r\n        }\r\n    }\r\n  \r\n    \n    \n    \n    \n    \n    cout << DP[len2 % 2][len1] << endl; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"str1\": [\"intention\"], \"str2\": [\"execution\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> goodSubsetofBinaryMatrix. /*FC*/class Solution {\n/*FM*/vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) \n    {\n        int m = grid.size(), n = grid[0].size(); \n        unordered_map<int,vector<int>>Map; \n        for (int i=0;  i<m;  i++)\n        {\n            int state = 0; \n            for (int j=0;  j<n;  j++)\n                if (grid[i][j])\n                    state += (1<<j); \n            Map[state].push_back(i); \n            if (state == 0)\n                                    \n        }\n        \n        for (int i=0;  i<m;  )\n        {\n            int state = 0; \n            for (int j=0;  j<n;  j++)\n                if (grid[i][j])\n                    state += (1<<j); \n            \n            for (int s = 0;  s<(1<<5);  s++)\n            {\n                int flag = 1; \n                for (int j=0;  j<n;  j++)\n                {\n                    if (grid[i][j]==1 && ((s>>j)&1))\n                    {\n                        \n                        \n                    }\n                }\n                if (flag==0) \n                if (Map[s].size()==0) continue; \n                \n                for (int k: Map[s])\n                {\n                    if (k!=i)\n                    {\n                        vector<int>rets({i,k}); \n                        sort(rets.begin(), rets.end()); \n                        return rets; \n                    }\n                }\n            }            \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [3], \"grid_element0\": [2], \"grid_element0_element0\": [\"344172555\"], \"grid_element0_element1\": [\"1522855008\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"655072183\"], \"grid_element2\": [2], \"grid_element2_element0\": [\"-1019234746\"], \"grid_element2_element1\": [\"-1209541845\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string originalDigits. /*FC*/class Solution {\n/*FM*/string originalDigits(string s) {\r\n        const vector<string> numbers{\"zero\", \"one\", \"two\", \"three\",\r\n                                     \"four\", \"five\", \"six\", \"seven\",\r\n                                     \"eight\", \"nine\"}; \r\n        vector<vector<int>> cnts(numbers.size(), vector<int>(26)); \r\n        for (int i = 0;  i < numbers.size();  ++i) {\r\n            for (const auto& c : numbers[i]) {\r\n                ++cnts[i][c - 'a']; \r\n            }\r\n        }\r\n        \r\n        \n        vector<int> order{0, 2, 4, 6, 8, 1, 3, 5, 7, 9}; \r\n        \r\n        \n        vector<char> unique_chars{'z', 'o', 'w', 't', 'u', 'f', 'x', 's', 'g', 'n'}; \r\n        vector<int> cnt(26); \r\n        for (const auto& c : s) {\r\n            ++cnt[c - 'a']; \r\n        }\r\n\r\n        string result; \r\n        for (const auto& i : order) {\r\n            while (cnt[unique_chars[i] - 'a'] > 0) {\r\n                for (int j = 0;  j < cnt.size();  ++j) {\r\n                    cnt[j] -= cnts[i][j]; \r\n                }\r\n                result.push_back(i + '0'); \r\n            }\r\n        }\r\n        sort(result.begin(), result.end()); \r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"fviefuro\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<string>> accountsMerge. /*FC*/class Solution {\n/*FM*/vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\n        int n = accounts.size(); \n        vector<int> parent(n); \n        for (int i = 0;  i < n;  ++i) {\n            parent[i] = i; \n        }\n        unordered_map<string, int> table; \n                \n        for (int i = 0;  i < n;  ++i) {\n            for (int j = 1;  j < accounts[i].size();  ++j) {\n                if (table.find(accounts[i][j]) == table.end()) {\n                    table[accounts[i][j]] = i; \n                }\n                else {\n                    \n                    \n                    \n                    \n                }\n            }\n        }\n        \n        unordered_map<int, unordered_set<string>> result; \n        for (int i = 0;  i < n;  ++i) {\n            int index = findParent(parent, i); \n            for (int j = 1;  j < accounts[i].size();  ++j) {\n                result[index].insert(accounts[i][j]); \n            }            \n        }\n        \n        vector<vector<string>> res; \n        for (auto r : result) {\n            vector<string> path = {accounts[r.first][0]}; \n            for (auto s : r.second) {\n                path.push_back(s); \n            }\n            \n            sort(path.begin() + 1, path.end()); \n            res.push_back(path); \n        }\n        \n        return res; \n    };/*F*//*C*//*M*/int findParent(vector<int>& parent, int i) {\n        while (parent[i] != i) {\n            parent[i] = parent[parent[i]]; \n            i = parent[i]; \n        }\n        return i; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"accounts\": [3], \"accounts_element0\": [2], \"accounts_element0_element0\": [\"1\"], \"accounts_element0_element1\": [\"1\"], \"accounts_element1\": [3], \"accounts_element1_element0\": [\"3\"], \"accounts_element1_element1\": [\"2\"], \"accounts_element1_element2\": [\"1\"], \"accounts_element2\": [3], \"accounts_element2_element0\": [\"1\"], \"accounts_element2_element1\": [\"1\"], \"accounts_element2_element2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string alienOrder. /*FC*/class Solution {\n/*FM*/string alienOrder(vector<string>& words) {\n        vector<bool> letters(26); \n        vector<unordered_set<int>> graph(26); \n        string prev; \n        for (string& word : words) {\n            for (char c : word) {\n                letters[c - 'a'] = true; \n            }\n\n            int i; \n            int upper = min(prev.size(), word.size()); \n            for (i = 0;  i < upper;  ) {\n                \n            }\n            \n            if (i == upper && prev.size() > word.size()) {\n                \n            }\n            \n            prev = word; \n        }\n        \n        vector<int> degrees(26); \n        for (int i = 0;  i < graph.size();  ++i) {\n            for (int node : graph[i]) {\n                \n            }\n        }\n        \n        queue<int> Q; \n        string result; \n        for (int i = 0;  i < degrees.size();  ++i) {\n            if (letters[i] && degrees[i] == 0) {\n                Q.push(i); \n                result += 'a' + i; \n            }\n        }\n                \n        while (!Q.empty()) {\n            int curr = Q.front(); \n            Q.pop(); \n            for (int node : graph[curr]) {\n                \n            }\n        }\n        int count = accumulate(letters.begin(), letters.end(), 0); \n        return result.size() == count ? result : \"\"; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method LL solve. /*FC*/class Solution {\n/*FM*/LL solve(string s)\n    {\n        int total = 0; \n        int n = s.size(); \n        for (int i=0;  i<n;  i++)\n            total += (s[i]=='1'); \n        \n        vector<LL>left(n); \n        int lastOne = -1; \n        LL sum = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            if (s[i]=='0')\n            {\n                \n                                \n            }\n            \n            if (i>=1 && s[i-1]=='1')\n                \n            else\n                sum += (i+1) + i; \n\n            left[i] = sum; \n            lastOne = i; \n        }\n        \n        vector<LL>right(n); \n        lastOne = n; \n        sum = 0; \n        for (int i=n-1;  i>=0;  i--)\n        {\n            if (s[i]=='0')\n            {\n                \n                                \n            }\n            \n            if (i+1<n && s[i+1]=='1')\n                \n            else\n                sum += (n-i) + (n-i-1); \n            right[i] = sum; \n            lastOne = i; \n        }\n        \n        LL ret = right[0]; \n        for (int i=0;  i<n-1;  )\n            \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string splitLoopedString. /*FC*/class Solution {\n/*FM*/string splitLoopedString(vector<string>& strs) {\n        int n = strs.size(); \n        if (n == 0) {\n            \n        }\n        vector<string> revs(n); \n        for (int i = 0;  i < n;  ++i) {\n            string rev(strs[i]); \n            reverse(rev.begin(), rev.end()); \n            if (rev > strs[i]) {\n                \n            }\n            else {\n                revs[i] = strs[i]; \n                strs[i] = rev; \n            }\n        }\n        \n        string result; \n        for (int i = 0;  i < n;  ++i) {\n            for (string str : {strs[i], revs[i]}) {\n                for (int j = 0;  j < str.size();  ++j) {\n                    if (result.size() && str[j] < result[0]) {\n                        continue; \n                    }\n                    string curr = str.substr(j); \n                    for (int k = i + 1;  k < n;  ++k) {\n                        curr += revs[k]; \n                    }\n                    \n                    for (int k = 0;  k < i;  ) {\n                        \n                    }\n                    \n                    curr += str.substr(0, j); \n                    if (curr > result) {\n                        result = curr; \n                    }\n                }\n                \n            }            \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [2], \"strs_element0\": [\"2\"], \"strs_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double largestSumOfAverages. /*FC*/class Solution {\n/*FM*/double largestSumOfAverages(vector<int> &A, int K) {\r\n        int n = A.size(); \r\n        if (n == 0) \r\n        vector<int> sum(n, 0); \r\n        sum[0] = A[0]; \r\n        for (int i = 1;  i < n;  ++i)\r\n            sum[i] = sum[i - 1] + A[i]; \r\n        vector<vector<double>> dp(n, vector<double>(K, 0)); \r\n        dp[0][0] = sum[0] * 1.0; \r\n        for (int k = 0;  k < K;  ++k) {\r\n            for (int i = 1;  i < n;  ++i) {\r\n                if (k == 0) {\r\n                    dp[i][0] = (sum[i] * 1.0 / (i + 1)); \r\n                    continue; \r\n                }\r\n                for (int j = 0;  j < i;  ++j) {\r\n                    double t = dp[j][k - 1] + ((sum[i] - sum[j]) * 1.0 / (i - j)); \r\n                    dp[i][k] = dp[i][k] < t ? t : dp[i][k]; \r\n                }\r\n            }\r\n        }\r\n        return dp[n - 1][K - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-318777413\"], \"A_element1\": [\"-307602533\"], \"K\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> splitIntoFibonacci. /*FC*/class Solution {\n/*FM*/vector<int> splitIntoFibonacci(string S) {\r\n        for (int i = 0, a = 0;  i + 2 < S.length();  ) {\r\n            a = 10 * a + S[i] - '0'; \r\n            for (int j = i + 1, b = 0;  j + 1 < S.length();  ++j) {\r\n                b = 10 * b + S[j] - '0'; \r\n                vector<int> fib = {a, b}; \r\n                int k = j + 1; \r\n                while (k < S.length()) {\r\n                    if (fib[fib.size() - 2] > numeric_limits<int>::max() - fib[fib.size() - 1]) {\r\n                        \r\n                    }\r\n                    auto c = fib[fib.size() - 2] + fib[fib.size() - 1]; \r\n                    auto l = startswith(S, k, c); \r\n                    if (l == 0) {\r\n                        break; \r\n                    }\r\n                    \r\n                    \r\n                }\r\n                if (k == S.length()) {\r\n                    \r\n                }\r\n                if (b == 0) {\r\n                    \r\n                }\r\n            }\r\n            if (a == 0) {\r\n                break; \r\n            }\r\n        }\r\n        return {}; \r\n    };/*F*//*C*//*M*/int startswith(const string& S, int k, int x) {\r\n        int y = 0; \r\n        for (int i = k;  i < S.length();  ++i) {\r\n            y = 10 * y + S[i] - '0'; \r\n            if (y == x) {\r\n                return i - k + 1; \r\n            } else if (y > x) {\r\n                break; \r\n            }\r\n        }\r\n        return 0; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"0123\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> kthSmallestPrimeFraction. /*FC*/class Solution {\n/*FM*/vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\n        sort(A.begin(), A.end()); \n        int n = A.size(); \n        double low = 0, high = 1; \n        int total = n * (n - 1) / 2; \n        double err = 1e-8; \n        while (high - low > err) {\n            double mid = (low + high) / 2; \n            int count = 0, left = 0; \n            for (int right = 1;  right < n;  ++right) {\n                while (A[left] <= mid * A[right]) {\n                    ++left; \n                }\n                count += right - left; \n            }\n\n            if (total - count >= K) {\n                \n            }\n            else {\n                low = mid; \n            }\n        }\n\n        \n        vector<int> result(2); \n        int count = 0, left = 0; \n        for (int right = 1;  right < n;  ) {\n            while (A[left] <= (low - err) * A[right]) {\n                ++left; \n            }\n            \n            if (A[left] < (low + err) * A[right]) {\n                result[0] = A[left]; \n                result[1] = A[right]; \n                break; \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"796097175\"], \"A_element1\": [\"1466381794\"], \"K\": [\"748298974\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<pair<int, int>> norm. /*FC*/class Solution {\n/*FM*/vector<pair<int, int>> norm(vector<pair<int, int>>& path) {\n        vector<vector<pair<int, int>>> s(8); \n        for (auto& p : path) {\n            int x = p.first; \n            int y = p.second; \n            s[0].emplace_back(x, y); \n            s[1].emplace_back(x, -y); \n            s[2].emplace_back(-x, y); \n            s[3].emplace_back(-x, -y); \n            s[4].emplace_back(y, x); \n            s[5].emplace_back(y, -x); \n            s[6].emplace_back(-y, x); \n            s[7].emplace_back(-y, -x); \n        }\n        \n        for (auto& v : s) {\n            sort(v.begin(), v.end()); \n        }\n        \n        for (auto& v : s) {\n            for (int i = 1;  i < v.size();  ++i) {\n                v[i] = {v[i].first - v[0].first, v[i].second - v[0].second}; \n            }\n            v[0] = {0, 0}; \n        }\n        sort(s.begin(), s.end()); \n        return s[0]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"path\": [2], \"path_element0.first\": [\"-11971875\"], \"path_element0.second\": [\"-2085762573\"], \"path_element1.first\": [\"-1445735250\"], \"path_element1.second\": [\"-1527010140\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string findTheString. /*FC*/class Solution {\n/*FM*/string findTheString(vector<vector<int>>& lcp) \n    {\n        int n = lcp.size(); \n        string s(n, '0'); \n\n        int i = 0; \n        for (char ch = 'a';  ch<='z';  ch++)\n        {\n            while (i<n && s[i]!='0')\n                i++; \n            if (i==n) break; \n            for (int j=0;  j<n;  j++)\n            {\n                if (lcp[i][j]!=0)\n                    s[j] = ch; \n            }            \n        }        \n        for (int i=0;  i<n;  i++)\n            if (s[i]=='0') \n\n        vector<vector<int>>dp(n, vector<int>(n,0)); \n        for (int i=n-1;  i>=0;  )\n            for (int j=n-1;  j>=0;  )\n            {                \n                if (s[i]==s[j])\n                    dp[i][j] = (i==n-1 || j==n-1)? 1: (dp[i+1][j+1] + 1); \n                if (dp[i][j] != lcp[i][j])\n                    return \"\"; \n            }                \n\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"lcp\": [2], \"lcp_element0\": [2], \"lcp_element0_element0\": [\"-697808429\"], \"lcp_element0_element1\": [\"-566417176\"], \"lcp_element1\": [2], \"lcp_element1_element0\": [\"-1294865178\"], \"lcp_element1_element1\": [\"-1819733522\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findRedundantConnection. /*FC*/class Solution {\n/*FM*/vector<int> findRedundantConnection(vector<vector<int>> &edges) {\r\n        vector<int> ret(2, 0); \r\n        unordered_map<int, int> rank; \r\n        disjoint = vector<int>(1001, 0); \r\n        for (int i = 0;  i < edges.size();  ++i) {\r\n            auto e = edges[i]; \r\n            if (disjoint[e[0]] == 0) {\r\n                disjoint[e[0]] = e[0]; \r\n                rank.insert(pair<int, int>(e[0], 0)); \r\n            }\r\n            if (disjoint[e[1]] == 0) {\r\n                disjoint[e[1]] = e[1]; \r\n                rank.insert(pair<int, int>(e[1], 0)); \r\n            }\r\n            int a = UnionFind(e[0]); \r\n            int b = UnionFind(e[1]); \r\n            if (a == b) {\r\n                \r\n                \r\n            }\r\n            if (rank[a] > rank[b])\r\n                \r\n            else {\r\n                disjoint[a] = b; \r\n                if (rank[a] == rank[b])\r\n                    ++rank[a]; \r\n            }\r\n        }\r\n        return ret; \r\n    };/*F*/vector<int> disjoint;/*C*//*M*/int UnionFind(int &k) {\r\n        if (disjoint[k] != k)\r\n            disjoint[k] = UnionFind(disjoint[k]); \r\n        return disjoint[k]; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"edges\": [1], \"edges_element0\": [2], \"edges_element0_element0\": [\"113\"], \"edges_element0_element1\": [\"977\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> minimumCost. /*FC*/class Solution {\n/*FM*/vector<int> minimumCost(int n, vector<vector<int>>& edges, vector<vector<int>>& query) {\n        vector<int>parent(n); \n        iota(parent.begin(), parent.end(), 0); \n        vector<int>cost(n,-1); \n        function<int(int)> find = [&](int i) -> int {\n            return parent[i] == i ? i: parent[i] = find(parent[i]); \n        }; \n        for(auto & e: edges){\n            cout<<e[0]<<\" e[1] \"<<e[1]<<endl; \n            int p1 = find(e[0]), p2=find(e[1]); \n            if (p1 != p2){\n                cost[p1] &= cost[p2]; \n                parent[p2] = p1; \n            }\n            cost[p1] &= e[2]; \n        }\n        vector<int>res; \n        for(auto q: query){\n            if(q[0] == q[1]){\n                \n            } else{\n                int p1 = find(q[0]); \n                int p2 = find(q[1]); \n                if (p1 != p2) res.push_back(-1); \n                else \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1320019947\"], \"edges\": [1], \"edges_element0\": [1], \"edges_element0_element0\": [\"-1010300696\"], \"query\": [1], \"query_element0\": [1], \"query_element0_element0\": [\"-619183942\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minCost. /*FC*/class Solution {\n/*FM*/long long minCost(vector<int>& nums, vector<int>& cost) {\n        vector<int> idx; \n        int n = nums.size(); \n        for (int i = 0;  i < n;  i++) idx.push_back(i); \n        sort(idx.begin(), idx.end(), [&nums, &cost](int i, int j) {\n            return nums[i] < nums[j]; \n        }); \n        long long s = 0, cl = cost[idx[0]], cr = 0; \n        for (int i = 1;  i < n;  i++) {\n            s += (long long)(nums[idx[i]] - nums[idx[0]]) * (long long)cost[idx[i]]; \n            cr += cost[idx[i]]; \n        }\n        long long ans = s; \n        for (int i = 1;  i < n;  i++) {\n            s -= (long long)(nums[idx[i]] - nums[idx[i - 1]]) * cr; \n            s += (long long)(nums[idx[i]] - nums[idx[i - 1]]) * cl; \n            cl += cost[idx[i]]; \n            cr -= cost[idx[i]]; \n            ans = min(ans, s); \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1294116544\"], \"nums_element1\": [\"-2133163160\"], \"cost\": [1], \"cost_element0\": [\"326508061\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int swimInWater. /*FC*/class Solution {\n/*FM*/int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size(); \n        unordered_set<int> visited; \n        priority_queue<Node> pq; \n        pq.emplace(0, 0, grid[0][0]); \n        visited.insert(0); \n        int t = 0; \n        vector<int> dr = {-1, 1, 0, 0}; \n        vector<int> dc = {0, 0, -1, 1}; \n        while (!pq.empty()) {\n            int row = pq.top().row; \n            int col = pq.top().col; \n            int val = pq.top().val; \n            pq.pop(); \n            t = max(t, val); \n            if (row == n - 1 && col == n - 1) return t; \n            for (int k = 0;  k < dr.size();  ++k) {\n                int nr = row + dr[k]; \n                int nc = col + dc[k]; \n                if (nr >= 0 && nr < n && nc >= 0 && nc < n && !visited.count(nr * n + nc)) {\n                    pq.emplace(nr, nc, grid[nr][nc]); \n                    visited.insert(nr * n + nc); \n                }\n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"-244185188\"], \"grid_element0_element1\": [\"688688044\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"1000789789\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string mostCommonWord. /*FC*/class Solution {\n/*FM*/string mostCommonWord(string paragraph, vector<string> &banned) {\r\n        int start = 0, end = 0; \r\n        unordered_map<string, int> counter; \r\n        unordered_set<string> ban(banned.begin(), banned.end()); \r\n        while (end < paragraph.size()) {\r\n            while ((tolower(paragraph[end]) < 'a' || tolower(paragraph[end]) > 'z') && end < paragraph.size())\r\n                ++end; \r\n            char curr = paragraph[end]; \r\n            string str; \r\n            while (tolower(paragraph[end]) >= 'a' && tolower(paragraph[end]) <= 'z' && end < paragraph.size()) {\r\n                \r\n                \r\n            }\r\n            if (ban.find(str) == ban.end())\r\n                ++counter[str]; \r\n            start = end + 1; \r\n            end = start; \r\n        }\r\n        string most_commont; \r\n        int count = 0; \r\n        for (auto &str : counter) {\r\n            if (str.second > count) {\r\n                most_commont = str.first; \r\n                count = str.second; \r\n            }\r\n        }\r\n        return most_commont; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"paragraph\": [\"1\"], \"banned\": [1], \"banned_element0\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxValue. /*FC*/class Solution {\n/*FM*/int maxValue(vector<vector<int>>& events, int k) \n    {        \n        sort(events.begin(), events.end(), cmp); \n        int m = events.size(); \n        auto dp = vector<vector<int>>(m+1, vector<int>(k+1,INT_MIN/2)); \n        \n        events.insert(events.begin(), events[0]); \n        vector<int>endTime({0}); \n        \n        int ret = 0;         \n        for (int i=0;  i<=m;  i++)\n            dp[i][0] = 0; \n        \n        for (int i=1;  i<=m;  i++)\n        {\n            auto iter = lower_bound(endTime.begin(), endTime.end(), events[i][0]); \n            int t = iter-endTime.begin()-1; \n            \n            for (int j=1;  j<=k;  j++)\n            {\n                dp[i][j] = max(dp[i-1][j], dp[t][j-1]+events[i][2]);                                 \n                ret = max(ret, dp[i][j]); \n            }\n            endTime.push_back(events[i][1]); \n        }\n        \n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"events\": [2], \"events_element0\": [2], \"events_element0_element0\": [\"1382321389\"], \"events_element0_element1\": [\"1674379410\"], \"events_element1\": [1], \"events_element1_element0\": [\"1628105323\"], \"k\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestPathLength. /*FC*/class Solution {\n/*FM*/int shortestPathLength(vector<vector<int>>& graph) {\r\n        static const auto& INF = numeric_limits<int>::max(); \r\n        vector<vector<int>> dp(1 << graph.size(),\r\n                               vector<int>(graph.size(), INF)); \r\n        queue<pair<int, int>> q; \r\n        for (int i = 0;  i < graph.size();  ++i) {\r\n            dp[1 << i][i] = 0; \r\n            q.emplace(1 << i, i); \r\n        }\r\n        while (!q.empty()) {\r\n            int state, node; \r\n            tie(state, node) = q.front();  q.pop(); \r\n            auto steps = dp[state][node]; \r\n            for (const auto& nei : graph[node]) {\r\n                auto new_state = state | (1 << nei); \t\t\t\t\t\t\t\t\r\n                if (dp[new_state][nei] == INF) {\r\n                    dp[new_state][nei] = steps + 1; \r\n                    q.emplace(new_state, nei); \r\n                }\r\n            }\r\n        }\r\n        return *min_element(dp.back().cbegin(), dp.back().cend()); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"graph\": [5], \"graph_element0\": [1], \"graph_element0_element0\": [\"1\"], \"graph_element1\": [3], \"graph_element1_element0\": [\"0\"], \"graph_element1_element1\": [\"2\"], \"graph_element1_element2\": [\"4\"], \"graph_element2\": [3], \"graph_element2_element0\": [\"1\"], \"graph_element2_element1\": [\"3\"], \"graph_element2_element2\": [\"4\"], \"graph_element3\": [1], \"graph_element3_element0\": [\"2\"], \"graph_element4\": [2], \"graph_element4_element0\": [\"1\"], \"graph_element4_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPaths. /*FC*/class Solution {\n/*FM*/int findPaths(int m, int n, int N, int x, int y) {\r\n        vector<vector<vector<unsigned int>>> dp(m, vector<vector<unsigned int>>(n, vector<unsigned int>(N + 1, 0))); \r\n        for (int k = 1;  k <= N;  ++k) {\r\n            for (int i = 0;  i < m;  ++i) {\r\n                for (int j = 0;  j < n;  ++j) {\r\n                    unsigned int up = (i == 0 ? 1 : dp[i - 1][j][k - 1]) % 1000000007; \r\n                    unsigned int down = (i == m - 1 ? 1 : dp[i + 1][j][k - 1]) % 1000000007; \r\n                    unsigned int left = (j == 0 ? 1 : dp[i][j - 1][k - 1]) % 1000000007; \r\n                    unsigned int right = (j == n - 1 ? 1 : dp[i][j + 1][k - 1]) % 1000000007; \r\n                    dp[i][j][k] = (up + down + left + right) % 1000000007; \r\n                }\r\n            }\r\n        }\r\n        return dp[x][y][N]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"4\"], \"n\": [\"1\"], \"N\": [\"8\"], \"x\": [\"612342228\"], \"y\": [\"-1098816969\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSizeSubarray. /*FC*/class Solution {\n/*FM*/int minSizeSubarray(vector<int>& nums, int target) \n    {\n        LL total  = accumulate(nums.begin(), nums.end(), 0LL); \n\n        int n = nums.size(); \n        for (int i=0;  i<n;  i++)\n            nums.push_back(nums[i]); \n\n        vector<LL>presum(2*n, 0); \n        presum[0] = nums[0]; \n        for (int i=1;  i<2*n;  i++)\n            presum[i] = presum[i-1] +  nums[i]; \n\n        LL ret = INT_MAX/2; \n\n        unordered_map<LL, int>Map;  \n        Map[0] = -1; \n        for (int i=0;  i<2*n;  i++)\n        {\n            LL r = ((presum[i] - target) % total + total) % total; \n\n            if (Map.find(r)!=Map.end())\n            {\n                \n                \n                \n            }\n\n            Map[presum[i]%total] = i; \n        }\n\n        if (ret == INT_MAX/2) return -1; \n        else         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1210749115\"], \"target\": [\"1438588647\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumScore. /*FC*/class Solution {\n/*FM*/int minimumScore(string s, string t) \n    {\n        int m = s.size(); \n        int n = t.size(); \n        \n        vector<int>left(n, m); \n        int j = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            while (j<m && s[j]!=t[i])\n                j++; \n            if (j<m)\n            {\n                \n                \n            }                \n        }\n        \n        vector<int>right(n, -1); \n        j = m-1; \n        for (int i=n-1;  i>=0;  i--)\n        {\n            while (j>=0 && s[j]!=t[i])\n                j--; \n            if (j>=0)\n            {\n                \n                \n            }                \n        }\n                \n        int low = 0, high = n; \n        while (low < high)\n        {\n            int mid = low+(high-low)/2; \n            if (isOK(mid, s, t, left, right))\n                \n            else\n                low = mid+1; \n        }\n        \n        return low;         \n    };/*F*//*C*//*M*/bool isOK(int len, string& s, string& t, vector<int>&left, vector<int>&right)\n    {\n        int m = s.size(); \n        int n = t.size(); \n        \n        if (right[len]>=0) return true; \n        if (left[n-len-1] < m) return true; \n        \n        for (int i=1;  i+len<n;  i++)\n        {\n            if (left[i-1] < right[i+len])\n                return true; \n        }\n        return false;         \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *mergeTrees. /*FC*/class Solution {\n/*FM*/TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) {\r\n        if (!t1)\r\n            \r\n        else if (!t2)\r\n            \r\n        queue<TreeNode *> q1, q2; \r\n        q1.push(t1); \r\n        q2.push(t2); \r\n        while (!q1.empty()) {\r\n            TreeNode *temp1 = q1.front(), *temp2 = q2.front(); \r\n            q1.pop(); \r\n            q2.pop(); \r\n            if (temp1) {\r\n                q1.push(temp1->left); \r\n                q1.push(temp1->right); \r\n                q2.push(temp2 ? temp2->left : nullptr); \r\n                q2.push(temp2 ? temp2->right : nullptr); \r\n            }\r\n            if (temp1 && temp2) {\r\n                temp1->val += temp2->val; \r\n                if (!temp1->left)\r\n                    temp1->left = temp2->left; \r\n                if (!temp1->right)\r\n                    temp1->right = temp2->right; \r\n            }\r\n        }\r\n        return t1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"t1\": [2], \"t1[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"t10_x\": [\"1957234281\"], \"t1[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"t11_x\": [\"1127217871\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxTwoEvents. /*FC*/class Solution {\n/*FM*/int maxTwoEvents(vector<vector<int>>& events) \n    {\n        int n = events.size(); \n        sort(events.begin(), events.end(), cmp); \n        \n        vector<int>rollingMax(n); \n        int m = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            m = max(m, events[i][2]); \n            rollingMax[i] = m; \n        }\n        \n        vector<int>endTimes; \n        int ret = 0; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            int a = events[i][0]-1, b = events[i][1], v = events[i][2]; \n            ret = max(ret, v); \n            \n            auto iter = upper_bound(endTimes.begin(), endTimes.end(), a); \n            if (iter!=endTimes.begin())\n            {\n                iter = prev(iter); \n                int idx = iter - endTimes.begin(); \n                ret = max(ret, rollingMax[idx] + v); \n            }\n            \n            endTimes.push_back(b); \n        }\n        \n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"events\": [2], \"events_element0\": [1], \"events_element0_element0\": [\"1264472039\"], \"events_element1\": [3], \"events_element1_element0\": [\"2098457060\"], \"events_element1_element1\": [\"-1445126554\"], \"events_element1_element2\": [\"1211091855\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method RandomListNode *copyRandomList. /*FC*/class Solution {\n/*FM*/RandomListNode *copyRandomList(RandomListNode *head) {\r\n\t\t\n\t\tRandomListNode * cur = head; \r\n\t\twhile (cur != NULL)\r\n\t\t{\r\n\t\t\tRandomListNode* temp = new RandomListNode(cur->label); \r\n\t\t\ttemp->next = cur->next; \r\n\t\t\tcur->next = temp; \r\n\t\t\tcur = temp->next; \r\n\t\t}\r\n\t\t\n\t\tcur = head; \r\n\t\twhile (cur != NULL)\r\n\t\t{\r\n\t\t\tRandomListNode* temp = cur->next; \r\n\t\t\tif (cur->random != NULL)\r\n\t\t\t\t\r\n\t\t\tcur = temp->next; \r\n\t\t}\r\n\t\t\n\t\tcur = head; \r\n\t\tRandomListNode* dup = head == NULL ? NULL : head->next; \r\n\t\twhile (cur != NULL)\r\n\t\t{\r\n\t\t\tRandomListNode* temp = cur->next; \r\n\t\t\tcur->next = temp->next; \r\n\t\t\tif (temp->next != NULL)\r\n\t\t\t\ttemp->next = temp->next->next; \r\n\t\t\tcur = cur->next; \r\n\t\t}\r\n\t\treturn dup; \r\n\t};/*F*//*C*//*M*/RandomListNode(int x) : label(x), next(NULL), random(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"RandomListNode\", \"RandomListNode(int)\"], \"head0_x\": [\"-891618655\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"RandomListNode\", \"RandomListNode(int)\"], \"head0_next0_x\": [\"-1116396653\"], \"head[1]\": [\"RandomListNode\", \"RandomListNode(int)\"], \"head1_x\": [\"-248987037\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> wordBreak. /*FC*/class Solution {\n/*FM*/vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\r\n        const int n = s.length(); \r\n\r\n        size_t max_len = 0; \r\n        for (const auto& str: wordDict) {\r\n            max_len = max(max_len, str.length()); \r\n        }\r\n\r\n        vector<bool> canBreak(n + 1, false); \r\n        vector<vector<bool>> valid(n, vector<bool>(n, false)); \r\n        canBreak[0] = true; \r\n        for (int i = 1;  i <= n;  ++i) {\r\n            for (int l = 1;  l <= max_len && i - l >= 0;  ++l) {\r\n                if (canBreak[i - l] && wordDict.count(s.substr(i - l, l))) {\r\n                    valid[i - l][i - 1] = true; \r\n                    canBreak[i] = true; \r\n                }\r\n            }\r\n        }\r\n\r\n        vector<string> result, path; \r\n        if (canBreak[n]) {\r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"catsandog\"], \"wordDict\": [5], \"wordDict_element0\": [\"cats\"], \"wordDict_element1\": [\"dog\"], \"wordDict_element2\": [\"sand\"], \"wordDict_element3\": [\"and\"], \"wordDict_element4\": [\"cat\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCostII. /*FC*/class Solution {\n/*FM*/int minCostII(vector<vector<int>>& costs) {\n        int n = costs.size(); \n        if (n == 0) {\n            \n        }\n        \n        int k = costs[0].size(); \n        int min1 = -1, min2 = -1; \n        for (int i = 0;  i < n;  ++i) {\n            int currMin1 = -1, currMin2 = -1; \n            for (int j = 0;  j < k;  ++j) {\n                if (min1 != j) {\n                    if (i > 0) {\n                        \n                    }\n                }\n                else {\n                    \n                }\n                \n                if (currMin1 == -1 || costs[i][j] < costs[i][currMin1]) {\n                    currMin2 = currMin1; \n                    currMin1 = j; \n                }\n                else if (currMin2 == -1 || costs[i][j] < costs[i][currMin2]) {\n                    \n                }\n            }\n            min1 = currMin1; \n            min2 = currMin2; \n        }\n        \n        return costs[n - 1][min1]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"costs\": [1], \"costs_element0\": [1], \"costs_element0_element0\": [\"1485351590\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void gameOfLife. /*FC*/class Solution {\n/*FM*/void gameOfLife(vector<vector<int>> &board) {\r\n        vector<vector<int>> ret(board); \r\n        int m = board.size(), n = m == 0 ? 0 : board[0].size(); \r\n        for (int i = 0;  i < m;  ++i) {\r\n            for (int j = 0;  j < n;  ++j) {\r\n                int &&neighbour = 0; \r\n                for (int I = max(0, i - 1);  I < min(m, i + 2);  ++I) {\r\n                    for (int J = max(0, j - 1);  J < min(n, j + 2);  ++J) {\r\n                        if (I == i && J == j)\r\n                            continue; \r\n                        neighbour += board[I][J] & 1; \r\n                    }\r\n                }\r\n                if (board[i][j] == 0) {\r\n                    \r\n                } else {\r\n                    if (neighbour < 2 || neighbour > 3)\r\n                        ret[i][j] = 0; \r\n                }\r\n            }\r\n        }\r\n        board = ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"board\": [3], \"board_element0\": [1], \"board_element0_element0\": [\"615707787\"], \"board_element1\": [1], \"board_element1_element0\": [\"1286897971\"], \"board_element2\": [1], \"board_element2_element0\": [\"-1172156486\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int visibleMountains. /*FC*/class Solution {\n/*FM*/int visibleMountains(vector<vector<int>>& peaks) \n    {        \n        sort(peaks.begin(), peaks.end(), [](vector<int>&a, vector<int>&b){\n            int l1=a[0]-a[1], r1=a[0]+a[1]; \n            int l2=b[0]-b[1], r2=b[0]+b[1]; \n            if (l1!=l2) return l1<l2; \n            else return r1>r2; \n        }); \n        \n        int n = peaks.size(); \n        int rightMost = -1; \n        int ret = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            if (i>0 && peaks[i]==peaks[i-1]) \n            if (peaks[i][0]+peaks[i][1] > rightMost)\n            {\n                rightMost = peaks[i][0]+peaks[i][1]; \n                if (i==n-1 || peaks[i]!=peaks[i+1])\n                    ret++; \n            }            \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"peaks\": [3], \"peaks_element0\": [1], \"peaks_element0_element0\": [\"-1619496055\"], \"peaks_element1\": [1], \"peaks_element1_element0\": [\"1751414832\"], \"peaks_element2\": [2], \"peaks_element2_element0\": [\"-929060214\"], \"peaks_element2_element1\": [\"-119467991\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minFallingPathSum. /*FC*/class Solution {\n/*FM*/int minFallingPathSum(vector<vector<int>> &A) {\r\n        if (A.size() == 0) \r\n        if (A[0].size() == 0) \r\n        int size = A.size(), minSum = INT_MAX; \r\n        vector<vector<int>> dp(size + 2, vector<int>(size + 2, INT_MAX)); \r\n        for (int i = 1;  i <= size;  ++i)\r\n            dp[1][i] = A[0][i - 1]; \r\n        for (int i = 2;  i <= size;  ++i) {\r\n            for (int j = 1;  j <= size;  ++j) {\r\n                dp[i][j] = A[i - 1][j - 1] + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i - 1][j + 1])); \r\n            }\r\n        }\r\n        for (int i = 1;  i <= size;  ++i)\r\n            minSum = min(minSum, dp[size][i]); \r\n        return minSum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [2], \"A_element0_element0\": [\"-735\"], \"A_element0_element1\": [\"-411\"], \"A_element1\": [1], \"A_element1_element0\": [\"-148\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int networkDelayTime. /*FC*/class Solution {\n/*FM*/int networkDelayTime(vector<vector<int>>& times, int N, int K) {\n        unordered_map<int, vector<pair<int, int>>> graph; \n        for (auto& time : times) {\n            graph[time[0]].emplace_back(time[1], time[2]); \n        }\n        \n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \n        pq.emplace(0, K); \n        unordered_map<int, int> distance; \n        while (!pq.empty()) {\n            int d = pq.top().first; \n            int node = pq.top().second; \n            pq.pop(); \n            if (distance.find(node) != distance.end()) {\n                \n            }\n            \n            distance[node] = d; \n            for (auto& p : graph[node]) {\n                \n                \n                \n            }\n        }\n        \n        if (distance.size() != N) {\n            return -1; \n        }\n        \n        \n        for ( : distance) {\n            \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"times\": [1], \"times_element0\": [1], \"times_element0_element0\": [\"-1549161084\"], \"N\": [\"-842245643\"], \"K\": [\"-822433308\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool possibleBipartition. /*FC*/class Solution {\n/*FM*/bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\r\n        vector<vector<int>> adj(N); \r\n        for (const auto& dislike : dislikes) {\r\n            int u = dislike[0] - 1, v = dislike[1] - 1; \r\n            adj[u].emplace_back(v); \r\n            adj[v].emplace_back(u); \r\n        }\r\n        \r\n        vector<int> color(N); \r\n        color[0] = 1; \r\n        queue<int> q({0}); \r\n        while (!q.empty()) {\r\n            const auto cur = q.front();  q.pop(); \r\n            for (const auto& nei : adj[cur]) {\r\n                if (color[nei] == color[cur]) {\r\n                    \r\n                } else if (color[nei] == -color[cur]) {\r\n                    continue; \r\n                }\r\n                color[nei] = -color[cur]; \r\n                q.emplace(nei); \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"N\": [\"4\"], \"dislikes\": [3], \"dislikes_element0\": [2], \"dislikes_element0_element0\": [\"1\"], \"dislikes_element0_element1\": [\"2\"], \"dislikes_element1\": [2], \"dislikes_element1_element0\": [\"1\"], \"dislikes_element1_element1\": [\"3\"], \"dislikes_element2\": [2], \"dislikes_element2_element0\": [\"2\"], \"dislikes_element2_element1\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> prisonAfterNDays. /*FC*/class Solution2 {\n/*FM*/vector<int> prisonAfterNDays(vector<int>& cells, int N) {\r\n        unordered_map<vector<int>, int, VectorHash<int>> lookup; \r\n        while (N) {\r\n            lookup[cells] = N--; \r\n            vector<int> cells2(8); \r\n            for (int i = 1;  i < 7;  ++i) {\r\n                cells2[i] = static_cast<int>(cells[i - 1] == cells[i + 1]); \r\n            }\r\n            cells = move(cells2); \r\n            if (lookup.count(cells)) {\r\n                N %= lookup[cells] - N; \r\n                break; \r\n            }\r\n        }\r\n \r\n        while (N--) {\r\n            vector<int> cells2(8); \r\n            for (int i = 1;  i < 7;  ++i) {\r\n                cells2[i] = static_cast<int>(cells[i - 1] == cells[i + 1]); \r\n            }\r\n            cells = move(cells2); \r\n        }\r\n        return cells; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\"], \"cells\": [8], \"cells_element0\": [\"1\"], \"cells_element1\": [\"0\"], \"cells_element2\": [\"0\"], \"cells_element3\": [\"1\"], \"cells_element4\": [\"0\"], \"cells_element5\": [\"0\"], \"cells_element6\": [\"1\"], \"cells_element7\": [\"0\"], \"N\": [\"1000000000\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> findRelativeRanks. /*FC*/class Solution {\n/*FM*/vector<string> findRelativeRanks(vector<int> &nums) {\r\n        int n = nums.size(), j = 0; \r\n        vector<Athlete> athletes(n, Athlete()); \r\n        vector<string> ret(n, \"\"); \r\n        vector<string> medal{\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"}; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            athletes[i].score = nums[i]; \r\n            athletes[i].pos = i; \r\n        }\r\n        sort(athletes.begin(), athletes.end(), [](const Athlete &a1, const Athlete &a2) {\r\n            return a1.score >= a2.score; \r\n        }); \r\n        for (int i = 0;  i < n;  ++i)\r\n            ret[athletes[i].pos] = j <= 2 ? medal[j++] : to_string(i + 1); \r\n        return ret; \r\n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1803833240\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minTotalDistance. /*FC*/class Solution {\n/*FM*/int minTotalDistance(vector<vector<int>>& grid) \n    {\n        vector<vector<int>>persons; \n        int M = grid.size(); \n        int N = grid[0].size(); \n        \n        vector<int>rows; \n        vector<int>cols; \n        for (int i=0;  i<M;  i++)\n            for (int j=0;  j<N;  j++)\n            {\n                if (grid[i][j]==0) continue; \n                rows.push_back(i); \n                cols.push_back(j); \n            }\n        sort(cols.begin(),cols.end()); \n        int X = rows[rows.size()/2]; \n        int Y = cols[cols.size()/2]; \n                \n        int result=0; \n        for (int i=0;  i<M;  i++)\n            for (int j=0;  j<N;  j++)\n            {\n                if (grid[i][j]==0) continue; \n                result+=abs(i-X)+abs(j-Y); \n            }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [3], \"grid_element0\": [3], \"grid_element0_element0\": [\"804018639\"], \"grid_element0_element1\": [\"1988988422\"], \"grid_element0_element2\": [\"-362687947\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"-246956664\"], \"grid_element2\": [1], \"grid_element2_element0\": [\"959234813\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int snakesAndLadders. /*FC*/class Solution {\n/*FM*/int snakesAndLadders(vector<vector<int>>& board) {\r\n        const int n = board.size(); \r\n        unordered_map<int, int> lookup; \r\n        lookup[1] = 0; \r\n        queue<int> q({1}); \r\n        while (!q.empty()) {\r\n            const auto s = q.front();  q.pop(); \r\n            if (s == n * n) {\r\n                return lookup[s]; \r\n            }\r\n            for (int i = s + 1;  i < min(s + 6, n * n) + 1;  ++i) {\r\n                int r, c; \r\n                tie(r, c) = coordinate(n, i); \r\n                int s2 = i; \r\n                if (board[r][c] != -1) {\r\n                    s2 = board[r][c]; \r\n                }\r\n                if (!lookup.count(s2)) {\r\n                    lookup[s2] = lookup[s] + 1; \r\n                    q.emplace(s2); \r\n                }\r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/pair<int, int> coordinate(int n, int s) {\r\n        const int a = (s - 1) / n; \r\n        const int b = (s - 1) % n; \r\n        const int r = n - 1 - a; \r\n        const int c = (r % 2 != n % 2) ? b : n - 1 - b; \r\n        return {r, c}; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"board\": [2], \"board_element0\": [2], \"board_element0_element0\": [\"-1\"], \"board_element0_element1\": [\"-1\"], \"board_element1\": [2], \"board_element1_element0\": [\"-1\"], \"board_element1_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countDivisibleSubstrings. /*FC*/class Solution {\n/*FM*/int countDivisibleSubstrings(string word) \n    {\n        int n = word.size(); \n        word = \"#\"+word; \n        vector<int>presum(n+1); \n        for (int i=1;  i<=n;  i++)\n            presum[i] = presum[i-1] + ((word[i]-'a'+1)/3+1); \n\n        map<int, map<int,int>>Map; \n        for (int m=1;  m<=9;  m++)\n            Map[m][0] = 1; \n\n        int ret = 0; \n        for (int j=1;  j<=n;  j++)\n        {\n            for (int m = 1;  m <=9;  m++)\n            {\n                int key = presum[j] - m*j; \n                if (Map.find(m)!=Map.end() && Map[m].find(key)!=Map[m].end())\n                    ret += Map[m][key]; \n                Map[m][key]+=1; \n            }\n        }\n\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long sellingWood. /*FC*/class Solution {\n/*FM*/long long sellingWood(int m, int n, vector<vector<int>>& prices) {\r\n        vector<vector<int64_t>> dp(m + 1, vector<int64_t>(n + 1)); \r\n        for (const auto& p : prices) {\r\n            dp[p[0]][p[1]] = p[2]; \r\n        }\r\n        for (int i = 1;  i <= m;  ++i) {\r\n            for (int j = 1;  j <= n;  ++j) {\r\n                for (int k = 1;  k <= i / 2;  ++k) {\r\n                    dp[i][j] = max(dp[i][j], dp[k][j] + dp[i - k][j]); \r\n                }\r\n                for (int k = 1;  k <= j / 2;  ++k) {\r\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j - k]); \r\n                }\r\n            }\r\n        }\r\n        return dp[m][n]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"m\": [\"4\"], \"n\": [\"6\"], \"prices\": [3], \"prices_element0\": [3], \"prices_element0_element0\": [\"3\"], \"prices_element0_element1\": [\"2\"], \"prices_element0_element2\": [\"10\"], \"prices_element1\": [3], \"prices_element1_element0\": [\"1\"], \"prices_element1_element1\": [\"4\"], \"prices_element1_element2\": [\"2\"], \"prices_element2\": [3], \"prices_element2_element0\": [\"4\"], \"prices_element2_element1\": [\"1\"], \"prices_element2_element2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void threeSum. /*FC*/ {\n/*FM*/void threeSum(vector<int> &num, vector<vector<int> > &combs, int start, int end, int target, int cur){\r\n       \r\n       for ( int i = start;  i < end - 1;  i++ ){\r\n           if ( i > start && num[i] == num[i-1] )\r\n               \r\n           int left = i + 1; \r\n           int right = end; \r\n           while (left < right){\r\n               int temp = num[left] + num[right] + num[i]; \r\n               if ( temp < target ){\r\n                   left++; \r\n                   while (num[left] == num[left-1] && left < right )\r\n                       \r\n               }\r\n               else if ( temp > target ){\r\n                   right--; \r\n                   while (num[right] == num[right+1] && left < right)\r\n                       \r\n               }\r\n               else{\r\n                   \r\n                   \r\n                   \r\n                   \r\n                   \r\n                   \r\n                   \r\n                              }\r\n           }\r\n       }\r\n       return; \r\n   };/*F*//*C*//*M*/\n}",
        "target": "{\"num\": [1], \"num_element0\": [\"-700667137\"], \"combs\": [1], \"combs_element0\": [1], \"combs_element0_element0\": [\"1287825506\"], \"start\": [\"4\"], \"end\": [\"10\"], \"target\": [\"-395555877\"], \"cur\": [\"-1943774344\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestAwesome. /*FC*/class Solution {\n/*FM*/int longestAwesome(string s) \n    {\n        vector<int>count(10,0); \n        int n = s.size(); \n        s=\"#\"+s; \n        \n        unordered_map<int,int>Map; \n        Map[0] = 0; \n        int ret = 0; \n        \n        for (int i=1;  i<=n;  i++)\n        {            \n            count[s[i]-'0']+=1; \n            int key = makeKey(count); \n            \n            if (Map.find(key)!=Map.end())\n                ret = max(ret, i - Map[key]); \n            \n            for (int k=0;  k<10;  k++)\n            {\n                int newKey = key; \n                \n                if (((key>>k)&1)==0)\n                    newKey |= (1<<k); \n                else\n                    \n                \n                if (Map.find(newKey)!=Map.end())\n                                        \n            }\n            if (Map.find(key)==Map.end())             \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/int makeKey(vector<int>&count)\n    {\n        int key=0; \n        for (int i=0;  i<10;  i++)\n        {\n            if (count[i]%2==0)\n                key+=(0<<i); \n            else\n                key+=(1<<i); \n        }\n        return key; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumDeleteSum. /*FC*/class Solution {\n/*FM*/int minimumDeleteSum(string s1, string s2) {\n        int m = s1.size(); \n        int n = s2.size(); \n        vector<vector<int>> dp(1 + m, vector<int>(1 + n)); \n        for (int j = 1;  j <= n;  ++j) {\n            dp[0][j] = dp[0][j - 1] + s2[j - 1]; \n        }\n        for (int i = 1;  i <= m;  ++i) {\n            dp[i][0] = dp[i - 1][0] + s1[i - 1]; \n\n            for (int j = 1;  j <= n;  ++j) {\n                if (s1[i - 1] == s2[j - 1]) {\n                    \n                }\n                else {\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]); \n                }\n            }\n        }\n        \n        return dp[m][n]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s1\": [\"2\"], \"s2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countCompleteComponents. /*FC*/class Solution {\n/*FM*/int countCompleteComponents(int n, vector<vector<int>>& edges) {\n        unordered_map<int,unordered_set<int>>graph; \n        for(auto & e: edges){\n            graph[e[0]].insert(e[1]); \n            graph[e[1]].insert(e[0]); \n        }\n        vector<int>visited(n); \n        int res = 0; \n        for(int i = 0 ;  i < n;  ++i){\n            if (visited[i]) \n            visited[i] = 1; \n            unordered_set<int>tmp; \n            queue<int>q;  q.push(i); \n            while(!q.empty()){\n                int top = q.front();  q.pop(); \n                tmp.insert(top); \n                for (auto & nxt: graph[top]){\n                    \n                    \n                    \n                }\n            }\n            res += all_of(tmp.begin(), tmp.end(), [&](int j){return graph[j].size() == tmp.size()-1; }); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"8\"], \"edges\": [3], \"edges_element0\": [1], \"edges_element0_element0\": [\"820958757\"], \"edges_element1\": [2], \"edges_element1_element0\": [\"-1803601568\"], \"edges_element1_element1\": [\"694428049\"], \"edges_element2\": [3], \"edges_element2_element0\": [\"1340189472\"], \"edges_element2_element1\": [\"-1771547678\"], \"edges_element2_element2\": [\"-50573869\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > subsetWithDup. /*FC*/ {\n/*FM*/vector<vector<int> > subsetWithDup(vector<int> &S){\r\n\t\r\n\tsort(S.begin(), S.end()); \r\n\tvector<vector<int> > result; \r\n\tvector<int> buf; \r\n\tresult.push_back(buf); \r\n\tint rsize = 0; \r\n\t\n\t\r\n\tfor ( int i = S.size() - 1;  i >= 0;  i-- ){\r\n\t\tint size = result.size(); \r\n\t\t\r\n\t\tfor ( int j = rsize;  j < size;  j++ ){\r\n\t\t\tif ( i > 0 && S[i] == S[i-1])\r\n\t\t\t\t\r\n\t\t\tbuf = result[j]; \r\n\t\t\tbuf.insert(buf.begin(), S[i]); \r\n\t\t\tresult.push_back(buf); \r\n\t\t\tbuf.clear(); \r\n\t\t}\r\n\t\t\r\n\t\tif ( i > 0 && S[i] != S[i-1])\r\n\t\t\trsize = 0; \r\n\t}\r\n\treturn result; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"S\": [2], \"S_element0\": [\"1731067753\"], \"S_element1\": [\"-109013931\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method Node *copyRandomList. /*FC*/class Solution\r {\n/*FM*/Node *copyRandomList(Node *head)\r\n    {\r\n        Node *front = head; \r\n        for (Node *i = head;  i != NULL; )\r\n        {\r\n            front = i->next; \r\n            Node *copy = new Node(i->val); \r\n            i->next = copy; \r\n            copy->next = front; \r\n            i = front; \r\n        }\r\n        for (Node *i = head;  i != NULL; )\r\n        {\r\n            if (i->random != NULL)\r\n            {\r\n                \r\n            }\r\n            i = i->next->next; \r\n        }\r\n        Node *pseudo = new Node(0); \r\n        Node *copy = pseudo; \r\n        for (Node *i = head;  i != NULL; )\r\n        {\r\n            front = i->next->next; \r\n            copy->next = i->next; \r\n            i->next = front; \r\n            copy = copy->next; \r\n            i = front; \r\n        }\r\n        return pseudo->next; \r\n    };/*F*//*C*//*M*/Node(int x) : val(x), next(NULL), random(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"Node\", \"Node(int)\"], \"head0_x\": [\"266\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > zigzagLevelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int> > zigzagLevelOrder(TreeNode* root) {\r\n    queue<TreeNode *> q; \r\n    vector<vector<int> > ret; \r\n    if (root == NULL) \r\n    q.push(root); \r\n\r\n    int i = 0; \r\n    while (!q.empty())\r\n    {\r\n      queue<TreeNode *> tmpQueue; \r\n      vector<int> tmpVec; \r\n\r\n      while (!q.empty())\r\n      {\r\n        TreeNode *node = q.front(); \r\n\tq.pop(); \r\n\tif (node -> left)\r\n\t{\r\n\t  \r\n\t}\r\n\tif (node -> right)\r\n\t{\r\n\t  \r\n\t}\r\n\ttmpVec.push_back(node -> val); \r\n      }\r\n      q = tmpQueue; \r\n      if (i % 2 != 0)\r\n      {\r\n        \r\n      }\r\n      i ++; \r\n      ret.push_back(tmpVec); \r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1922046510\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"248793587\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfitAssignment. /*FC*/class Solution {\n/*FM*/int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \n    {\n        vector<pair<int,int>>tasks; \n        for (int i=0;  i<difficulty.size();  i++)\n            tasks.push_back({difficulty[i],profit[i]}); \n        \n        sort(tasks.begin(),tasks.end()); \n        \n        int MAX = tasks[0].second; \n        for (int i=1;  i<tasks.size();  i++)\n        {\n            tasks[i].second = max(tasks[i].second,MAX); \n            MAX = tasks[i].second; \n        }        \n        \n        int sum = 0; \n        for (int x:worker)\n        {\n            auto iter = upper_bound(tasks.begin(),tasks.end(),make_pair(x,INT_MAX)); \n            if (iter!=tasks.begin())\n            {\n                iter = prev(iter,1); \n                sum+=iter->second; \n            }\n        }\n        return sum; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"difficulty\": [2], \"difficulty_element0\": [\"-150323780\"], \"difficulty_element1\": [\"-187453815\"], \"profit\": [1], \"profit_element0\": [\"-2056740982\"], \"worker\": [2], \"worker_element0\": [\"-602850553\"], \"worker_element1\": [\"-10282641\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int optimized. /*FC*/class Solution {\n/*FM*/int optimized(string s) {\n        int n = s.length(); \n        memset(f, 0, sizeof f); \n        \n        memset(sum, 0, sizeof sum); \n        f[0][0] = 1, sum[0][1] = 1; \n        for (int i = 1;  i <= n;  i++) {\n            for (int j = 0;  j <= i;  j++) {\n                if (s[i-1] == 'I') {\n                    \n                } else {\n                    f[i][j] += sum[i-1][i] - sum[i-1][j] + P, f[i][j] %= P; \n                }\n                sum[i][j+1] = sum[i][j] + f[i][j], sum[i][j+1] %= P; \n            }\n        }\n        int ans = 0; \n        for (int j = 0;  j <= n;  j++) {\n            ans = (ans + f[n][j]) % P; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"f\": [2], \"f[51][0]\": [\"-8998145523920185890\"], \"f[79][0]\": [\"-6151161138913199093\"], \"f[115][0]\": [\"-819044011027646022\"], \"sum\": [2], \"sum[1][0]\": [\"210\"], \"sum[15][0]\": [\"-1629112366139424414\"], \"sum[83][0]\": [\"5945522172299219678\"], \"sum[101][0]\": [\"-2313672618210494788\"], \"sum[103][0]\": [\"3478090719180249144\"], \"sum[107][0]\": [\"7161491923874080815\"], \"sum[151][0]\": [\"-5548372672872446655\"], \"sum[174][0]\": [\"-8825159838878389774\"], \"sum[183][0]\": [\"-7493785911051810366\"], \"sum[187][0]\": [\"1605017325924599665\"], \"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int totalFruit. /*FC*/class Solution {\n/*FM*/int totalFruit(vector<int> &tree) {\r\n        time_t begin = clock(); \r\n        int size = tree.size(); \r\n        int total = 0; \r\n        for (int i = 0;  i < size;  ) {\r\n            if (i > 0 && tree[i] == tree[i - 1])\r\n                \r\n            int a = tree[i], b = -1; \r\n            int current = 1, j = i + 1; \r\n            for (;  j < size;  ++j) {\r\n                if (b != -1 && (tree[j] != a && tree[j] != b))\r\n                    \r\n                if (b == -1 && tree[j] != a)\r\n                    b = tree[j]; \r\n                ++current; \r\n            }\r\n            total = max(total, current); \r\n            if (j == size)\r\n                break; \r\n        }\r\n        time_t end = clock(); \r\n        cout << end - begin << endl; \r\n        return total; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tree\": [2], \"tree_element0\": [\"635\"], \"tree_element1\": [\"-487\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumWhiteTiles. /*FC*/class Solution {\n/*FM*/int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) \n    {\n        sort(tiles.begin(), tiles.end()); \n        int n = tiles.size();  \n        presum.resize(n); \n        for (int i=0;  i<n;  i++)\n            presum[i] = (i==0?0:presum[i-1]) + (tiles[i][1]-tiles[i][0]+1);         \n        int ret = 0; \n        \n        int j = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            while (j<n && tiles[i][0]+carpetLen-1 >= tiles[j][1])\n                \n            int len = 0; \n            if (j>i) \n                \n            if (j<n)\n                len += max(0, tiles[i][0]+carpetLen-1 - tiles[j][0] + 1);             \n                            \n            ret = max(ret, len); \n        }\n        \n        return ret; \n    };/*F*/vector<int> presum;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tiles\": [1], \"tiles_element0\": [2], \"tiles_element0_element0\": [\"-567337467\"], \"tiles_element0_element1\": [\"1080086582\"], \"carpetLen\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int profitableSchemes. /*FC*/class Solution {\n/*FM*/int profitableSchemes(int G, int P, vector<int>& group, vector<int>& profit) {\r\n        static const int M = 1000000007; \r\n        vector<vector<int>> dp(P + 1, vector<int>(G + 1)); \r\n        dp[0][0] = 1; \r\n        int result = 0; \r\n        for (int k = 0;  k < group.size();  ++k) {\r\n            int g = group[k], p = profit[k]; \r\n            for (int i = P;  i >= 0;  --i)\r\n                for (int j = G - g;  j >= 0;  --j)\r\n                    dp[min(i + p, P)][j + g] = (dp[min(i + p, P)][j + g] + dp[i][j]) % M; \r\n        }\r\n        for (const auto& p : dp[P]) {\r\n            result = (result + p) % M; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"G\": [\"5\"], \"P\": [\"3\"], \"group\": [2], \"group_element0\": [\"2\"], \"group_element1\": [\"2\"], \"profit\": [2], \"profit_element0\": [\"2\"], \"profit_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMaxForm. /*FC*/class Solution {\n/*FM*/int findMaxForm(vector<string> &strs, int m, int n) {\r\n        int size = strs.size(); \r\n        if (size == 0) \r\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0)); \r\n        for (int k = 0;  k < strs.size();  ++k) {\r\n            int num0 = 0, num1 = 0; \r\n            for (int j = 0;  j < strs[k].size();  ++j) {\r\n                if (strs[k][j] == '0')\r\n                    \r\n                else\r\n                    ++num1; \r\n            }\r\n\r\n            for(int i = m;  i >= num0;  --i)\r\n                for(int j = n;  j >= num1;  --j)\r\n                    dp[i][j] = max(dp[i][j], dp[i - num0][j-num1] + 1); \r\n        }\r\n\r\n        return dp[m][n]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [2], \"strs_element0\": [\"1\"], \"strs_element1\": [\"2\"], \"m\": [\"1\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<ListNode *> splitListToParts. /*FC*/class Solution {\n/*FM*/vector<ListNode *> splitListToParts(ListNode *root, int k) {\r\n        vector<ListNode *> ret; \r\n        unsigned int size = 0; \r\n        ListNode *head = root; \r\n        while (head) {\r\n            ++size; \r\n            head = head->next; \r\n        }\r\n        unsigned int part = k >= size ? 1 : size / k; \r\n        unsigned int left = k >= size ? 0 : size % k; \r\n        head = root; \r\n        while (head) {\r\n            int i = 1; \r\n            ListNode *tail = head; \r\n            while (i < part) {\r\n                \r\n                \r\n            }\r\n            if (left > 0) {\r\n                \r\n                \r\n            }\r\n            ret.push_back(head); \r\n            head = tail->next; \r\n            tail->next = nullptr; \r\n        }\r\n        while (ret.size() < k)\r\n            ret.push_back(nullptr); \r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"ListNode\", \"ListNode(int)\"], \"root0_x\": [\"468\"], \"k\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSubarrays. /*FC*/class Solution {\n/*FM*/int countSubarrays(vector<int>& nums, int k) \n    {\n        for (auto& x: nums)\n        {\n            if (x>k) x=1; \n            else if (x==k) \n            else x=-1; \n        }\n        \n        unordered_map<int, int>oddSum; \n        unordered_map<int, int>evenSum; \n        \n        evenSum[0] = 1; \n        \n        int sum = 0; \n        int ret = 0; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            sum += nums[i]; \n            if (i%2==0)\n            {\n                ret += evenSum[sum-0]; \n                ret += oddSum[sum-1]; \n                oddSum[sum] += 1; \n            }\n            else\n            {\n                ret += oddSum[sum-0]; \n                ret += evenSum[sum-1]; \n                evenSum[sum] += 1; \n            }\n        }\n        \n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1569228278\"], \"nums_element1\": [\"-942591592\"], \"nums_element2\": [\"1347910696\"], \"k\": [\"106322952\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int closedIsland. /*FC*/class Solution {\n/*FM*/int closedIsland(vector<vector<int>>& grid) {\r\n        int n = grid.size(), m = grid[0].size(); \r\n        \r\n        \n        \n        for(int i = 0;  i < n;  i++) {\r\n            dfs(i, 0, grid, n, m); \r\n            dfs(i, m - 1, grid, n, m); \r\n        }\r\n        for(int j = 0;  j < m;  j++) {\r\n            dfs(0, j, grid, n, m); \r\n            dfs(n - 1, j, grid, n, m); \r\n        }\r\n        \r\n        \n        \n        int count = 0; \r\n        for(int i = 0;  i < n;  i++) {\r\n            for(int j = 0;  j < m;  j++) {\r\n                if(grid[i][j] == 0) {\r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        \r\n        return count; \r\n    };/*F*//*C*//*M*/void dfs(int i, int j, vector<vector<int>> &grid, int n, int m) {\r\n        if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 1) {\r\n            return; \r\n        }\r\n        \r\n        grid[i][j] = 1; \r\n        dfs(i + 1, j, grid, n, m); \r\n        dfs(i, j + 1, grid, n, m); \r\n        dfs(i - 1, j, grid, n, m); \r\n        dfs(i, j - 1, grid, n, m); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [1], \"grid_element0\": [2], \"grid_element0_element0\": [\"-603\"], \"grid_element0_element1\": [\"-972\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int containVirus. /*FC*/class Solution {\n/*FM*/int containVirus(vector<vector<int>>& grid) {\n        dr = {-1, 1, 0, 0}; \n        dc = {0, 0, -1, 1}; \n        int m = grid.size(); \n        int n = grid[0].size(); \n        int wall = 0; \n        while (true) {\n            vector<vector<int>> regions; \n            vector<unordered_set<int>> frontiers; \n            vector<int> perimeters; \n            unordered_set<int> visited; \n            for (int i = 0;  i < m;  ++i) {\n                for (int j = 0;  j < n;  ++j) {\n                    if (grid[i][j] == 1 && visited.find(i * n + j) == visited.end()) {\n                        \n                        \n                        \n                        \n                    }\n                }\n            }\n            \n            if (regions.size() == 0) {\n                break; \n            }\n\n            \n            \n\n            \n            \n        }\n        \n        return wall; \n    };/*F*/vector<int> dr;  vector<int> dc;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [1], \"grid_element0\": [2], \"grid_element0_element0\": [\"-1421037045\"], \"grid_element0_element1\": [\"-1285202766\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findRotateSteps. /*FC*/class Solution {\n/*FM*/int findRotateSteps(string ring, string key) {\n        int n = ring.size(); \n        \n        unordered_map<char, vector<int>> table; \n        for (int i = 0;  i < n;  ++i) {\n            table[ring[i]].push_back(i); \n        }\n        \n        int m = key.size(); \n        vector<vector<int>> dp(m, vector<int>(n, INT_MAX)); \n        for (int j = 0;  j < n;  ++j) {\n            if (key[0] == ring[j]) {\n                \n            }\n        }\n\n        for (int i = 1;  i < m;  ) {\n            for ( : table[key[i]]) {\n                for ( : table[key[i - 1]]) {\n                    \n                }\n            }\n        }\n        \n        int result = INT_MAX; \n        for (int j : table[key[m - 1]]) {\n            \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ring\": [\"2\"], \"key\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int widthOfBinaryTree. /*FC*/class Solution {\n/*FM*/int widthOfBinaryTree(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        queue<PosNode *> que; \r\n        unsigned long max_width = 1, left = 0, right = 0; \r\n        auto size = 1; \r\n        que.push(new PosNode(root, 1)); \r\n        while (!que.empty()) {\r\n            PosNode *curr = que.front(); \r\n            que.pop(); \r\n            --size; \r\n            if (curr) {\r\n                if (left == 0) {\r\n                    left = curr->pos; \r\n                } else\r\n                    \r\n                if (curr->node->left) \r\n                if (curr->node->right) \r\n            }\r\n            if (size == 0) {\r\n                size = que.size(); \r\n                max_width = max(max_width, right > left ? right - left + 1 : 0); \r\n                left = 0; \r\n                right = 0; \r\n            }\r\n        }\r\n        return max_width; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1009046118\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1463008054\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canFinish. /*FC*/class Solution {\n/*FM*/bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\r\n        vector<int> indegree(numCourses); \r\n        vector<vector<int>> outedges(numCourses); \r\n        for (vector<int> &p : prerequisites) {\r\n            indegree[p[0]]++; \r\n            outedges[p[1]].push_back(p[0]); \r\n        }\r\n        \r\n        queue<int> q; \r\n        for (int i = 0;  i < numCourses;  i++) {\r\n            if (indegree[i] == 0) {\r\n                q.push(i); \r\n            }\r\n        }\r\n        \r\n        while (!q.empty()) {\r\n            int front = q.front(); \r\n            q.pop(); \r\n            for (int i : outedges[front]) {\r\n                \r\n            }\r\n            numCourses--; \r\n        }\r\n        return numCourses == 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numCourses\": [\"4\"], \"prerequisites\": [2], \"prerequisites_element0\": [2], \"prerequisites_element0_element0\": [\"539\"], \"prerequisites_element0_element1\": [\"289\"], \"prerequisites_element1\": [1], \"prerequisites_element1_element0\": [\"902\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> commonChars. /*FC*/class Solution {\n/*FM*/vector<string> commonChars(vector<string>& A) {\r\n        vector<int> ht1(26); \r\n        for (char ch : A[0]) {\r\n            ht1[ch - 'a']++; \r\n        }\r\n        \r\n        for (int i = 1;  i < A.size();  i++) {\r\n            vector<int> ht2(26); \r\n            for (char ch : A[i]) {\r\n                ht2[ch - 'a']++; \r\n            }\r\n            for (int i = 0;  i < 26;  i++) {\r\n                ht1[i] = min(ht1[i], ht2[i]); \r\n            }\r\n        }\r\n        \r\n        vector<string> ans; \r\n        for (int i = 0;  i < 26;  i++) {\r\n            for (int j = 0;  j < ht1[i];  ) {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"2\"], \"A_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string fractionAddition. /*FC*/class Solution {\n/*FM*/string fractionAddition(string expression) {\n        int i = 0; \n        int n = expression.size(); \n        int sign = 1; \n        int numerator = 0, denominator = 0; \n        vector<int> result = {0, 1}; \n        while (i < n) {\n            if (expression[i] == '-') {\n                \n                \n            }\n            else if (expression[i] == '+') {\n                \n            }\n            \n            while (i < n && isdigit(expression[i])) {\n                numerator = numerator * 10 + (expression[i++] - '0'); \n            }\n            \n            ++i;  \n            \n            while (i < n && isdigit(expression[i])) {\n                \n            }\n            \n            result = fractionSum(result[0], result[1], sign * numerator, denominator); \n            sign = 1; \n            numerator = 0; \n            denominator = 0;             \n        }\n        \n        return to_string(result[0]) + '/' + to_string(result[1]); \n    };/*F*//*C*//*M*/vector<int> fractionSum(int num1, int den1, int num2, int den2) {\n        vector<int> result(2); \n        result[1] = den1 * den2; \n        result[0] = num1 * den2 + num2 * den1; \n        int gcd = GCD(result[0], result[1]); \n        result[0] /= gcd; \n        result[1] /= gcd; \n        return result; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"expression\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void recoverTree. /*FC*/ {\n/*FM*/void recoverTree(TreeNode *root){\r\n\tTreeNode *f1 = NULL, *f2 = NULL; \r\n\tTreeNode *current, *pre, *parent = NULL; \r\n\t\r\n\tif ( root == NULL )\r\n\t\t\r\n\t\r\n\tbool found = false; \r\n\tcurrent = root; \r\n\twhile ( current != NULL ){\r\n\t\tif ( current->left == NULL ){\r\n\t\t\tif ( parent && parent->val > current->val ){\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tparent = current; \r\n\t\t\tcurrent = current->right; \r\n\t\t}\r\n\t\t\r\n\t\telse{\r\n\t\t\t\r\n\t\t\t->right == NULL){\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse{\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tif ( f1 && f2 )\r\n\t\t\r\n\treturn; \r\n  \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1329254540\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1809187843\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<long long> minimumCosts. /*FC*/class Solution {\n/*FM*/vector<long long> minimumCosts(vector<int>& regular, vector<int>& express, int expressCost) {\n        int n = regular.size()+1; \n        vector<long long>dp_r(n, numeric_limits<long long>::max()); \n        vector<long long>dp_e(n, numeric_limits<long long>::max()); \n        dp_r[0] = 0; \n        dp_e[0] = expressCost; \n        vector<long long>res; \n        for(int i = 0;  i < n - 1;  ++i){\n            dp_r[i+1] = min(dp_r[i], dp_e[i]) + regular[i]; \n            dp_e[i+1] = min(dp_e[i], dp_r[i] + expressCost) + express[i] ;      \n            res.push_back(min(dp_r[i+1], dp_e[i+1])); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"regular\": [1], \"regular_element0\": [\"-832274488\"], \"express\": [2], \"express_element0\": [\"-1236666097\"], \"express_element1\": [\"-882637804\"], \"expressCost\": [\"1988866142\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestOverlap. /*FC*/class Solution {\n/*FM*/int largestOverlap(vector<vector<int>>& A, vector<vector<int>>& B) {\r\n        int max_overlap = 0, n = A.size(); \r\n        vector<vector<int>> slide(2 * n - 1, vector<int>(2 * n - 1)); \r\n        for (int ai = 0;  ai < n;  ai++) {\r\n            for (int aj = 0;  aj < n;  aj++) {\r\n                if (A[ai][aj]) {\r\n                    for (int bi = 0;  bi < n;  bi++) {\r\n                        for (int bj = 0;  bj < n;  bj++) {\r\n                            if (B[bi][bj]) {\r\n                                max_overlap = max(max_overlap, ++slide[ai - bi + n - 1][aj - bj + n - 1]); \r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return max_overlap; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [1], \"A_element0_element0\": [\"1671175417\"], \"B\": [1], \"B_element0\": [1], \"B_element0_element0\": [\"-1086404528\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int medianOfUniquenessArray. /*FC*/class Solution {\n/*FM*/int medianOfUniquenessArray(vector<int>& nums) {\n        int n = nums.size(); \n        long long total_subarrays = (n+1)*(long long)n/2; \n        function<long long(int)> count = [&](int k){\n            long long res = 0; \n            unordered_map<int,int>mp; \n            for(int i = 0, j = 0;  j < n;  ++j){\n                ++mp[nums[j]]; \n                while(mp.size () > k){\n                    if(--mp[nums[i]] == 0 ){\n                        mp.erase(nums[i]); \n                    }\n                    ++i; \n                }\n                res += j - i + 1; \n            }\n            return res; \n        }; \n        int left = 1, right = unordered_set<int>(nums.begin(), nums.end()).size(); \n        while (left < right){\n            \n            \n            \n        }\n        return left; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-973383172\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseParentheses. /*FC*/class Solution {\n/*FM*/string reverseParentheses(string s) {\r\n        vector<int> stk; \r\n        unordered_map<int, int> lookup; \r\n        for (int i = 0;  i < s.length();  ++i) {\r\n            if (s[i] == '(') {\r\n                stk.emplace_back(i); \r\n            } else if (s[i] == ')') {\r\n                int j = stk.back();  stk.pop_back(); \r\n                lookup[i] = j, lookup[j] = i; \r\n            }\r\n        }\r\n        string result; \r\n        for (int i = 0, d = 1;  i < s.length();  i += d) {\r\n            if (lookup.count(i)) {\r\n                i = lookup[i]; \r\n                d *= -1; \r\n            } else {\r\n                result.push_back(s[i]); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"(u(love)i)\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxVacationDays. /*FC*/class Solution {\n/*FM*/int maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {\n        int N = flights.size(); \n        int K = days[0].size(); \n        \n        vector<vector<int>> dp(2, vector<int>(N)); \n        for (int i = K - 1;  i >= 0;  --i) {\n            for (int j = 0;  j < N;  ++j) {\n                dp[i & 1][j] = dp[(i + 1) & 1][j] + days[j][i]; \n                for (int k = 0;  k < N;  ++k) {\n                    if (flights[j][k]) {\n                        dp[i & 1][j] = max(dp[i & 1][j], dp[(i + 1) & 1][k] + days[k][i]); \n                    }                    \n                }\n            }\n        }\n        \n        return dp[0][0]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"flights\": [2], \"flights_element0\": [2], \"flights_element0_element0\": [\"314823569\"], \"flights_element0_element1\": [\"137806599\"], \"flights_element1\": [1], \"flights_element1_element0\": [\"-460797612\"], \"days\": [2], \"days_element0\": [2], \"days_element0_element0\": [\"-1166730002\"], \"days_element0_element1\": [\"-187922798\"], \"days_element1\": [1], \"days_element1_element0\": [\"1399616999\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheLongestSubstring. /*FC*/class Solution {\n/*FM*/int findTheLongestSubstring(string s) \n    {\n        vector<int>count(5,0); \n        unordered_map<int,int>Map; \n        Map[0] = -1; \n        \n        int ret = 0; \n        \n        for (int i=0;  i<s.size();  i++)\n        {\n            if (s[i]=='a')\n                \n            if (s[i]=='e')\n                \n            if (s[i]=='i')\n                \n            if (s[i]=='o')\n                \n            if (s[i]=='u')\n                \n            \n            int code = 0; \n            for (int i=0;  i<5;  i++)\n                code = code*2 + count[i]; \n            \n            if (Map.find(code)!=Map.end())\n                ret = max(ret, i-Map[code]); \n            else\n                \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestLine. /*FC*/class Solution {\n/*FM*/int longestLine(vector<vector<int>>& M) {\n        int m = M.size(); \n        if (m == 0) {\n            \n        }\n        \n        int n = M[0].size(); \n        int maxLen = 0; \n        vector<int> cols(n); \n        vector<int> diag(m + n - 1); \n        vector<int> anti(m + n - 1); \n        for (int i = 0;  i < m;  ++i) {\n            int rows = 0; \n            for (int j = 0;  j < n;  ++j) {\n                if (M[i][j] == 1) {\n                    \n                    \n                    \n                    \n                    \n                }\n                else {\n                    rows = 0; \n                    cols[j] = 0; \n                    diag[i - j + n - 1] = 0; \n                    anti[i + j] = 0; \n                }                \n            }\n        }\n        \n        return maxLen;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"M\": [1], \"M_element0\": [1], \"M_element0_element0\": [\"-2131090794\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> getOrder. /*FC*/class Solution {\n/*FM*/vector<int> getOrder(vector<vector<int>>& A) {\n        priority_queue<T, vector<T>, greater<>> pq;  \n        long N = A.size(), time = 0, i = 0;  \n        for (int i = 0;  i < N;  ++i) A[i].push_back(i);  \n        sort(begin(A), end(A));  \n        vector<int> ans; \n        while (i < N || pq.size()) { \n            if (pq.empty()) {\n                time = max(time, (long)A[i][0]);  \n            }\n            while (i < N && time >= A[i][0]) { \n                pq.emplace(A[i][1], A[i][2]); \n                ++i; \n            }\n            auto [pro, index] = pq.top(); \n            pq.pop(); \n            time += pro;  \n            ans.push_back(index); \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [1], \"A_element0_element0\": [\"175927184\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubmatrixSumTarget. /*FC*/class Solution {\n/*FM*/int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) \n    {\n        int m = matrix.size(), n = matrix[0].size(); \n        int count = 0; \n        \n        for (int i=0;  i<m;  i++)\n        {\n            vector<int>row(n); \n            for (int t=i;  t<m;  t++)\n            {\n                for (int j=0;  j<n;  j++)\n                    row[j] += matrix[t][j]; \n                \n                unordered_map<int,int>Map; \n                Map[0] = 1; \n                int presum = 0; \n                for (int j=0;  j<n;  j++)\n                {\n                    presum += row[j]; \n                    count += Map[presum - target]; \n                    Map[presum]+=1; \n                }\n            }            \n        }\n        return count; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"-1249167831\"], \"matrix_element0_element1\": [\"-337693642\"], \"matrix_element0_element2\": [\"-45586147\"], \"target\": [\"-382227824\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> wordSubsets. /*FC*/class Solution {\n/*FM*/vector<string> wordSubsets(vector<string>& A, vector<string>& B) {\r\n        vector<int> count(26); \r\n        for (const auto& b : B) {\r\n            const auto& tmp = counter(b); \r\n            for (int i = 0;  i < 26;  ++i) {\r\n                count[i] = max(count[i], tmp[i]); \r\n            }\r\n        }\r\n        vector<string> result; \r\n        for (const auto& a : A) {\r\n            const auto& tmp = counter(a); \r\n            int i = 0; \r\n            for (;  i < 26;  ++i) {\r\n                if (tmp[i] < count[i]) {\r\n                    break; \r\n                }\r\n            }\r\n            if (i == 26) {\r\n                result.emplace_back(a); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/vector<int> counter(const string& word) {\r\n        vector<int> count(26); \r\n        for (const auto& c : word) {\r\n            ++count[c - 'a']; \r\n        }\r\n        return count; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [5], \"A_element0\": [\"amazon\"], \"A_element1\": [\"apple\"], \"A_element2\": [\"facebook\"], \"A_element3\": [\"google\"], \"A_element4\": [\"leetcode\"], \"B\": [2], \"B_element0\": [\"lc\"], \"B_element1\": [\"eo\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestSubmatrix. /*FC*/class Solution {\n/*FM*/int largestSubmatrix(vector<vector<int>>& matrix) \n    {\n        int m = matrix.size(); \n        int n = matrix[0].size(); \n        vector<int>a(n,0); \n        int ret = 0; \n        for (int i=0;  i<m;  i++)\n        {\n            for (int j=0;  j<n;  j++)\n            {\n                if (matrix[i][j]==1)\n                    \n                else\n                    a[j] = 0;                     \n            }\n            auto b = a; \n            sort(b.begin(), b.end()); \n            reverse(b.begin(), b.end()); \n            int h = INT_MAX; \n            for (int j=0;  j<n;  j++)\n            {\n                h = min(h, b[j]); \n                ret = max(ret, h*(j+1)); \n            }\n        }\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"1831700931\"], \"matrix_element0_element1\": [\"-1887801138\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"-1102827107\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<string> > groupAnagrams. /*FC*/class Solution {\n/*FM*/vector<vector<string> > groupAnagrams(vector<string>& strs) {\r\n    multimap<string, string> mmap; \r\n    vector<vector<string> > ret; \r\n    for (auto str : strs)\r\n    {\r\n      string s = str; \r\n      sort(s.begin(), s.end()); \r\n      mmap.insert(pair<string, string>(s, str)); \r\n    }\r\n\r\n    for (multimap<string, string>::iterator iter = mmap.begin();  iter != mmap.end(); )\r\n    {\r\n      int count = mmap.count(iter -> first); \r\n      vector<string> tmp; \r\n\r\n      for (int i = 0;  i < count;  i ++, iter ++)\r\n      {\r\n\ttmp.push_back(iter -> second); \r\n      }\r\n      ret.push_back(tmp); \r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [2], \"strs_element0\": [\"3\"], \"strs_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int checkRecord. /*FC*/class Solution {\n/*FM*/int checkRecord(int n) {\n        int dp[1 + n][2][3] = {1, 1, 1, 1, 1, 1}; \n        int m = 1000000007; \n        for (int i = 1;  i <= n;  ++i) {\n            for (int j = 0;  j <= 1;  ++j) {\n                for (int k = 0;  k <= 2;  ++k) {\n                    int val = dp[i - 1][j][2];  \n                    if (k > 0) {\n                        val = (val + dp[i - 1][j][k - 1]) % m;  \n                    }\n                    \n                    if (j > 0) {\n                        val = (val + dp[i - 1][j - 1][2]) % m;  \n                    }                    \n                    \n                    dp[i][j][k] = val; \n                }\n            }\n        }\n        \n        return dp[n][1][2]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool findRotation. /*FC*/class Solution {\n/*FM*/bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {\n        int n = mat.size(); \n        vector<vector<int>> tmp = mat; \n        for (int k = 0;  k < 5;  k++) {\n            for (int i = 0;  i < n;  i++) {\n                for (int j = 0;  j < n;  j++) {\n                    tmp[j][n - 1 - i] = mat[i][j]; \n                }\n            }\n            mat = tmp; \n\n            bool ok = true; \n            for (int i = 0;  i < n;  i++) {\n                for (int j = 0;  j < n;  ) {\n                    if (mat[i][j] != target[i][j]) {\n                        ok = false; \n                        break; \n                    }\n                }\n            }\n            if (ok) \n        }\n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"mat\": [1], \"mat_element0\": [1], \"mat_element0_element0\": [\"1101740140\"], \"target\": [2], \"target_element0\": [1], \"target_element0_element0\": [\"2124393897\"], \"target_element1\": [2], \"target_element1_element0\": [\"-538453017\"], \"target_element1_element1\": [\"687167232\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> nextGreaterElement. /*FC*/class Solution {\n/*FM*/vector<int> nextGreaterElement(vector<int> &findNums, vector<int> &nums) {\r\n        stack<int> key; \r\n        unordered_map<int, int> map; \r\n        vector<int> ret; \r\n        for (int i = 0;  i < nums.size();  ++i) {\r\n            while (!key.empty() && nums[i] > key.top()) {\r\n                map.insert(pair<int, int>(key.top(), nums[i])); \r\n                key.pop(); \r\n            }\r\n            key.push(nums[i]); \r\n        }\r\n        for (int i = 0;  i < findNums.size();  ++i) {\r\n            if (map.find(findNums[i]) != map.end())\r\n                \r\n            else\r\n                ret.push_back(-1); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"findNums\": [3], \"findNums_element0\": [\"1068798224\"], \"findNums_element1\": [\"-994215407\"], \"findNums_element2\": [\"547604753\"], \"nums\": [3], \"nums_element0\": [\"-696537021\"], \"nums_element1\": [\"387133909\"], \"nums_element2\": [\"-1729970594\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method Node * connect. /*FC*/class Solution {\n/*FM*/Node * connect(Node * root) {\r\n      queue < Node * > q; \r\n      Node * root1 = root; \r\n      if (root1 == NULL)\r\n        \r\n\r\n      q.push(root1); \r\n\r\n      while (!q.empty()) {\r\n        int n = q.size(); \r\n        Node * prev = NULL; \r\n        for (int i = 0;  i < n;  i++) {\r\n          Node * curr = q.front(); \r\n          q.pop(); \r\n\r\n          if (curr -> left != NULL)\r\n            \r\n          if (curr -> right != NULL)\r\n            \r\n\r\n          if (prev == NULL) {\r\n            prev = curr; \r\n            prev -> next = NULL; \r\n            continue; \r\n          }\r\n\r\n          \r\n          \r\n          \r\n        }\r\n      }\r\n      return root; \r\n    };/*F*//*C*//*M*/Node(int x) : val(x), left(NULL), right(NULL), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"Node\", \"Node(int)\"], \"root0_x\": [\"948\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> subsetsWithDup. /*FC*/class Solution {\n/*FM*/vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end()); \n        int len = nums.size(); \n        int maxn = pow(2, len); \n        vector<vector<int>> result(maxn); \n        for (int i = 0;  i < len;  i++) {\n            for (int j = 0;  j < maxn;  j++) {\n                if ((j >> i) & 1)\n                    result[j].push_back(nums[i]); \n            }\n        }\n        set<vector<int>> s; \n        for (int i = 0;  i < result.size();  i++)\n            s.insert(result[i]); \n        result.resize(0); \n        for (auto it = s.begin();  it != s.end();  it++)\n            result.push_back(*it); \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1038922295\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int monotoneIncreasingDigits. /*FC*/class Solution {\n/*FM*/int monotoneIncreasingDigits(int N) {\n        string s = to_string(N); \n        int j = -1; \n        for (int i = 0;  i < s.size() - 1;  ++i) {\n            if (s[i] > s[i + 1]) {\n                j = i; \n                break; \n            }\n        }\n        \n        if (j == -1) {\n            \n        }\n        \n        for (int k = j;  k >= 1;  ) {\n            if (s[k - 1] > s[k] - 1) {\n                \n            }\n            else {\n                break; \n            }\n        }\n        \n        --s[j]; \n        for (int k = j + 1;  k < s.size();  ++k) {\n            s[k] = '9'; \n        }\n        return stoi(s); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"-357547754\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countTriplets. /*FC*/class Solution {\n/*FM*/int countTriplets(vector<int> &A) {\r\n        int total = 0; \r\n        int size = A.size(); \r\n        for (int i = 0;  i < size - 2;  ) {\r\n            \r\n        }\r\n        for (int i = 0;  i < size;  ++i) {\r\n            for (int j = 0;  j < size;  ++j) {\r\n                if (i == j)\r\n                    continue; \r\n                if (static_cast<int>(A[i] & A[i] & A[j]) == 0)\r\n                    \r\n            }\r\n        }\r\n        for (int i = 0;  i < size;  ++i)\r\n            if (static_cast<int>(A[i] & A[i] & A[i] ) == 0)\r\n                \r\n\r\n        return total; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-486\"], \"A_element1\": [\"-469\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > levelOrderBottom. /*FC*/class Solution {\n/*FM*/vector<vector<int> > levelOrderBottom(TreeNode *root) {\r\n    vector<vector<int> > res; \r\n    queue<TreeNode*> Q[2]; \r\n    vector<int> one_level; \r\n    int level = 0; \r\n    if (root) Q[0].push(root); \r\n    while (!Q[level].empty()) {\r\n      TreeNode *n = Q[level].front(); \r\n      one_level.push_back(n->val); \r\n      Q[level].pop(); \r\n      if (n->left) \r\n      if (n->right) \r\n      if (Q[level].empty()) {\r\n\tres.push_back(one_level); \r\n\tone_level.clear(); \r\n\tlevel = !level; \r\n      }\r\n    }\r\n    reverse(res.begin(), res.end()); \r\n    return res; \r\n  };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1260662190\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"322579069\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isBipartite. /*FC*/class Solution {\n/*FM*/bool isBipartite(vector<vector<int>> &graph) {\r\n        int n = graph.size(); \r\n        vector<int> part(n, -1); \r\n        for (int i = 0;  i < n;  ) {\r\n            if (part[i] == -1) {\r\n                queue<int> que; \r\n                que.push(i); \r\n                part[i] = 0; \r\n                int size = 1; \r\n                while (!que.empty()) {\r\n                    auto root = que.front(); \r\n                    que.pop(); \r\n                    for (auto &node:graph[root]) {\r\n                        if (part[node] == -1) {\r\n                            \r\n                            \r\n                        } else if (part[node] == part[root])\r\n                            return false; \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"graph\": [2], \"graph_element0\": [2], \"graph_element0_element0\": [\"430\"], \"graph_element0_element1\": [\"-875\"], \"graph_element1\": [2], \"graph_element1_element0\": [\"-854\"], \"graph_element1_element1\": [\"263\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumBeauty. /*FC*/class Solution {\n/*FM*/int maximumBeauty(vector<int>& flowers) \n    {\n        unordered_map<int,vector<int>>Map; \n        for (int i=0;  i<flowers.size();  i++)\n        {\n            Map[flowers[i]].push_back(i); \n        }\n        \n        int n = flowers.size(); \n        vector<int>presum(n); \n        int sum = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            sum += (flowers[i]<0? 0:flowers[i]); \n            presum[i] = sum; \n        }\n        \n        int ret = INT_MIN; \n        for (auto x: Map)\n        {\n            if (x.second.size()==1) continue; \n                        \n                        \n            \n        }\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"flowers\": [1], \"flowers_element0\": [\"-354319589\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int kBigIndices. /*FC*/class Solution {\n/*FM*/int kBigIndices(vector<int>& nums, int k) {\n        priority_queue<int>pq; \n        int n = nums.size(); \n        vector<int>prefix(n); \n        int res = 0; \n        for(int i = 0;  i < nums.size();  ++i){\n            if(pq.size() == k && pq.top() < nums[i]) \n                \n            pq.push(nums[i]); \n            if (pq.size() > k) \n        }\n        pq = priority_queue <int>(); \n        for(int i = n-1;  i>=0;  --i){\n            if (pq.size() == k && pq.top() < nums[i] && prefix[i]) \n            pq.push(nums[i]); \n            if (pq.size() > k) \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1137799551\"], \"k\": [\"343080948\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string gcdOfStrings. /*FC*/class Solution {\n/*FM*/string gcdOfStrings(string str1, string str2) {\r\n        int m = str1.size(), n = str2.size(); \r\n        if (m < n)\r\n            \r\n        for (int i = 1;  i <= n;  ++i) {\r\n            if (n % i != 0 || m % (n / i) != 0)\r\n                \r\n            string gcd = str2.substr(0, n / i); \r\n            int s = gcd.size(); \r\n            bool flag = true; \r\n            for (int j = 0;  j < m / (n / i);  ) {\r\n                if (str1.substr(j * s, s) != gcd) {\r\n                    flag = false; \r\n                    break; \r\n                }\r\n            }\r\n            if (flag)\r\n                \r\n        }\r\n        return \"\"; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str1\": [\"2\"], \"str2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double champagneTower. /*FC*/class Solution {\n/*FM*/double champagneTower(int poured, int query_row, int query_glass) {\n        vector<vector<double>> dp(2 + query_row, vector<double>(2 + query_row)); \n        dp[0][0] = poured; \n        for (int i = 0;  i <= query_row;  ++i) {\n            for (int j = 0;  j <= i;  ++j) {\n                if (dp[i][j] > 1) {\n                    dp[i + 1][j] += (dp[i][j] - 1) / 2.0; \n                    dp[i + 1][j + 1] += (dp[i][j] - 1) / 2.0; \n                    dp[i][j] = 1; \n                }\n            }\n        }\n        return dp[query_row][query_glass]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"poured\": [\"1415973762\"], \"query_row\": [\"7\"], \"query_glass\": [\"-482713270\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string get_lcs. /*FC*/class Solution {\n/*FM*/string get_lcs(const string& str1, const string& str2){\n        int n = str1.size(), m = str2.size(); \n        vector<vector<string>>dp(2, vector<string>(m+1, \"\")); \n        for(int i = 0;  i < n;  ++i){\n            for(int j = 0;  j < m;  ++j){\n                if (str1[i] == str2[j]){\n                    \n                } else {\n                    dp[(i + 1)%2][j+1] = dp[(i + 1)%2][j].size() > dp[i%2][j+1].size()? dp[(i + 1)%2][j] : dp[i%2][j+1]; \n                }\n            }\n        }\n        return dp[n%2][m]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str1\": [\"1\"], \"str2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numPrimeArrangements. /*FC*/class Solution {\n/*FM*/int numPrimeArrangements(int n) {\r\n        int cnt = 0, ans = 1; \r\n        vector<bool> prime(n + 1, true); \r\n        for (int i = 2;  i <= n;  i++) {\r\n            if (prime[i]) {\r\n                for (int j = 2 * i;  j <= n;  j += i) {\r\n                    prime[j] = false; \r\n                }\r\n                cnt++; \r\n            }\r\n        }\r\n        for (int i = 2;  i <= cnt;  i++) {\r\n            ans = 1l * ans * i % 1000000007; \r\n        }\r\n        for (int i = 2;  i <= n - cnt;  i++) {\r\n            ans = 1l * ans * i % 1000000007; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int stoneGameV. /*FC*/class Solution {\n/*FM*/int stoneGameV(vector<int>& stoneValue) {\r\n        const int n = stoneValue.size(); \r\n        vector<int> prefix(n + 1); \r\n        partial_sum(cbegin(stoneValue), cend(stoneValue), begin(prefix) + 1); \r\n        \r\n        vector<int> mid(n); \r\n        iota(begin(mid), end(mid), 0); \r\n\r\n        vector<vector<int>> dp(n, vector<int>(n)); \r\n        for (int i = 0;  i < n;  ++i) {\r\n            dp[i][i] = stoneValue[i]; \r\n        }\r\n\r\n        int max_score = 0; \r\n        for (int l = 2;  l <= n;  ) {\r\n            \r\n        }\r\n        return max_score; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"stoneValue\": [1], \"stoneValue_element0\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDistToClosest. /*FC*/class Solution {\n/*FM*/int maxDistToClosest(vector<int> &seats) {\r\n        int maxDist = 1; \r\n        int i = 0; \r\n        if (seats[i] == 0) {\r\n                  }\r\n        maxDist = maxDist < i ? i : maxDist; \r\n        i = seats.size() - 1; \r\n        int j = 0; \r\n        if(seats[i] == 0) {\r\n            \r\n        }\r\n        maxDist = maxDist < j ? j : maxDist; \r\n        for (i = 0;  i < seats.size();  ++i) {\r\n            int current = 1; \r\n            if (seats[i] == 0) {\r\n                \r\n                \r\n            }\r\n            if (current > maxDist)\r\n                \r\n        }\r\n        return maxDist; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"seats\": [2], \"seats_element0\": [\"932\"], \"seats_element1\": [\"-105\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector < int > findClosestElements. /*FC*/class Solution {\n/*FM*/vector < int > findClosestElements(vector <int> &arr, int k, int x) {\r\n      priority_queue <pair <int,int>> m; \r\n\r\n      \n\r\n      for (int i = 0;  i < arr.size();  i++) {\r\n        m.push({\r\n          abs(arr[i] - x),\r\n          arr[i]\r\n        }); \r\n\r\n        \n        \n\r\n        if (m.size() > k)\r\n          \r\n      }\r\n\r\n      vector < int > ans; \r\n      while (m.size() > 0) {\r\n        \n        ans.push_back(m.top().second); \r\n        m.pop(); \r\n      }\r\n\r\n      \n\r\n      sort(ans.begin(), ans.end()); \r\n      return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [1], \"arr_element0\": [\"369\"], \"k\": [\"1671789911\"], \"x\": [\"-235544703\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxSatisfied. /*FC*/class Solution {\n/*FM*/int maxSatisfied(vector<int> &customers, vector<int> &grumpy, int X) {\r\n        int n = customers.size(), res = 0; \r\n        for (int i = 0;  i < n;  ++i)\r\n            res += customers[i] * (grumpy[i] ^ 1); \r\n        for (int i = 0;  i < n && i < X;  )\r\n            \r\n        if (X >= n)\r\n            \r\n        int temp = res; \r\n        for (int i = X;  i < n;  ++i) {\r\n            temp = temp - customers[i - X] * grumpy[i - X] + customers[i] * grumpy[i]; \r\n            res = max(res, temp); \r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"customers\": [3], \"customers_element0\": [\"-2109341830\"], \"customers_element1\": [\"-1717688236\"], \"customers_element2\": [\"168371352\"], \"grumpy\": [1], \"grumpy_element0\": [\"1103287778\"], \"X\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestBridge. /*FC*/class Solution {\n/*FM*/int shortestBridge(vector < vector < int >> & grid) {\r\n      vector < pair < int, int >> land1;  \n      vector < pair < int, int >> land2;  \n      int m = grid.size();  \n      int n = grid[0].size();  \n      int count = 0;  \n      for (int i = 0;  i < m;  i++) {\r\n        for (int j = 0;  j < n;  j++) {\r\n          if (grid[i][j] == 1) {\r\n            \r\n            \r\n          }\r\n\r\n        }\r\n      }\r\n      \n      int mini = INT_MAX;  \n      int ans = INT_MAX; \r\n      for (int i = 0;  i < land1.size();  ) {\r\n        \r\n      }\r\n      return mini;  \n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [1], \"grid_element0\": [2], \"grid_element0_element0\": [\"56\"], \"grid_element0_element1\": [\"732\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int kInversePairs. /*FC*/class Solution {\n/*FM*/int kInversePairs(int n, int k) {\n        vector<int> presum(1 + k); \n        int MOD = 1000000007; \n        for (int i = 1;  i <= n;  ++i) {\n            vector<int> temp(1 + k); \n            temp[0] = 1; \n            for (int j = 1;  j <= k;  ++j) {\n                int val = (presum[j] - ((j - i >= 0) ? presum[j - i] : 0) + MOD) % MOD;                 \n                temp[j] = (temp[j - 1] + val) % MOD; \n            }\n            presum = temp; \n        }\n        \n        return (presum[k] - ((k > 0) ? presum[k - 1] : 0) + MOD) % MOD; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"3\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* removeZeroSumSublists. /*FC*/class Solution {\n/*FM*/ListNode* removeZeroSumSublists(ListNode* head) {\n        ListNode* res = new ListNode(); \n        res->next = head; \n        ListNode* cur = res->next; \n        unordered_map<int, ListNode*>mp;  \n        mp[0] = res; \n        int tot = 0, prev = 0; \n        while(cur){\n            tot += cur->val; \n            cout<<\" cur->val \"<<cur->val<<\" tot \"<<tot<<endl; \n            if(mp.count(tot)){\n                \n                \n                \n                \n                \n                \n                \n                \n            } else {\n                cout<<\" [not counter] \"<<endl; \n                mp[tot] = cur; \n            }\n            \n            cur = cur->next; \n        }\n        return res->next; \n    };/*F*//*C*//*M*/ListNode(int val) {\n        this->val = val; \n        this->next = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_val\": [\"81\"], \"head[0].val\": [\"81\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> spiralMatrixIII. /*FC*/class Solution {\n/*FM*/vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\r\n        int r = r0, c = c0; \r\n        vector<vector<int>> result = {{r, c}}; \r\n        int x = 0, y = 1, i = 0, n = 0; \r\n        while (result.size() < R * C) {\r\n            r += x, c += y, ++i; \r\n            if (0 <= r && r < R && 0 <= c && c < C) {\r\n                result.push_back({r, c}); \r\n            }\r\n            if (i == n / 2 + 1) {\r\n                swap(x, y), y *= -1, ++n, i = 0; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"R\": [\"5\"], \"C\": [\"6\"], \"r0\": [\"1\"], \"c0\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfBoomerangs. /*FC*/class Solution {\n/*FM*/int numberOfBoomerangs(vector<pair<int, int>>& points) \n    {\n        int result=0; \n        for (int i=0;  i<points.size();  i++)\n        {\n            unordered_map<int,int>Map; \n            for (int j=0;  j<points.size();  j++)\n            {\n                int dis= (points[i].first-points[j].first)*(points[i].first-points[j].first)+(points[i].second-points[j].second)*(points[i].second-points[j].second); \n                Map[dis]++; \n            }\n            for (auto a:Map)\n            {\n                result+=a.second*(a.second-1); \n            }            \n        }\n        \n        return result; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"points\": [2], \"points_element0.first\": [\"-304248247\"], \"points_element0.second\": [\"-712896157\"], \"points_element1.first\": [\"901885568\"], \"points_element1.second\": [\"-1727556087\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int naive. /*FC*/class Solution {\n/*FM*/int naive(string s) {\n        int n = s.length(); \n        memset(f, 0, sizeof f); \n        f[0][0] = 1; \n        for (int i = 1;  i <= n;  i++) {\n            for (int j = 0;  j <= i;  j++) {\n                if (s[i-1] == 'I') {\n                    \n                } else {\n                    for (int k = j;  k < i;  k++) f[i][j] += f[i-1][k], f[i][j] %= P; \n                }   \n            }\n        }\n        int ans = 0; \n        for (int j = 0;  j <= n;  j++) {\n            ans = (ans + f[n][j]) % P; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"f\": [2], \"f[13][0]\": [\"-8835876337951350181\"], \"f[28][0]\": [\"-4259068855583835738\"], \"f[88][0]\": [\"-4870997362766696669\"], \"f[89][0]\": [\"1118207236336662844\"], \"f[133][0]\": [\"-6457959107635289764\"], \"f[151][0]\": [\"-8276280275306427926\"], \"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void convert. /*FC*/class Solution {\n/*FM*/void convert(long long start, int count, vector<string>& result) {\n        long long curr = start; \n        vector<int> path; \n        while (curr) {\n            path.push_back(curr % 256); \n            curr /= 256; \n        }\n\n        while (path.size() < 4) {\n            \n        }\n\n        string s; \n        for (int i = 3;  i >= 0;  --i) {\n            if (s.size()) {\n                s += '.'; \n            }\n            s += to_string(path[i]); \n        }\n        s += '/'; \n        int num = 0; \n        while (count) {\n            ++num; \n            count >>= 1; \n        }\n        s += to_string(33 - num); \n        result.push_back(s); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"start\": [\"3323724134450766825\"], \"count\": [\"684660380\"], \"result\": [2], \"result_element0\": [\"2\"], \"result_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> shortestToChar. /*FC*/class Solution {\n/*FM*/vector<int> shortestToChar(string S, char C) {\r\n        vector<int> result(S.length(), S.length()); \r\n        int prev = -S.length(); \r\n        for (int i = 0;  i < S.length();  ++i) {\r\n            if (S[i] == C) {\r\n                prev = i; \r\n            }\r\n            result[i] = min(result[i], abs(i - prev)); \r\n        }\r\n        for (int i = S.length() - 1;  i >= 0;  --i) {\r\n            if (S[i] == C) {\r\n                prev = i; \r\n            }\r\n            result[i] = min(result[i], abs(i - prev)); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"loveleetcode\"], \"C\": [\"101\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minFlipsMonoIncr. /*FC*/class Solution {\n/*FM*/int minFlipsMonoIncr(string S) {\r\n        int size = S.size(), res = INT_MAX; \r\n        if (size == 0)\r\n            \r\n        vector<int> pre_one(size, 0), post_zero(size, 0); \r\n        pre_one[0] = S[0] == 1; \r\n        post_zero[size - 1] = S[size - 1] == 0; \r\n        for (int i = 1;  i < size;  )\r\n            \r\n        for (int i = size - 2;  i >= 0;  )\r\n            \r\n        for (int i = 0;  i < size;  ++i)\r\n            res = min(res, pre_one[i] + post_zero[i]); \r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> retrieve. /*FC*/class LogSystem {\n/*FM*/vector<int> retrieve(string s, string e, string gra) {\n        int len = 0; \n        if (gra == \"Year\") {\n            \n        }\n        else if (gra == \"Month\") {\n            \n        }\n        else if (gra == \"Day\") {\n            \n        }\n        else if (gra == \"Hour\") {\n            \n        }\n        else if (gra == \"Minute\") {\n            \n        }\n        else {\n            len = 19; \n        }\n        \n        string low = s.substr(0, len); \n        string high = e.substr(0, len); \n        vector<int> result; \n        for (auto it = table.lower_bound(low);  it != table.end();  ) {\n            \n            \n            \n        }\n        \n        return result; \n    };/*F*/map<string, int> table;/*C*/LogSystem() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___LogSystem\": [\"LogSystem\", \"LogSystem()\"], \"s\": [\"2\"], \"e\": [\"1\"], \"gra\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> fairCandySwap. /*FC*/class Solution {\n/*FM*/vector<int> fairCandySwap(vector<int> &A, vector<int> &B) {\r\n        int sumA = 0, sumB = 0; \r\n        for (int i = 0;  i < A.size();  ++i)\r\n            sumA += A[i]; \r\n        for (int j = 0;  j < B.size();  ++j)\r\n            sumB += B[j]; \r\n        int diff = (sumA - sumB) / 2; \r\n        for (int i = 0;  i < A.size();  ++i)\r\n            for (int j = 0;  j < B.size();  ++j)\r\n                if (A[i] - B[j] == diff)\r\n                    \r\n        return vector<int>(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"184\"], \"A_element1\": [\"-557\"], \"B\": [1], \"B_element0\": [\"305\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestNiceSubarray. /*FC*/class Solution {\n/*FM*/int longestNiceSubarray(vector<int>& nums) {\r\n        int n = nums.size(); \r\n        int i = 0, j = 1; \r\n        int ans = 1; \r\n        long long curOR = nums[0]; \r\n        while (j < n) {\r\n            \n            if ((curOR & nums[j]) == 0) {\r\n                \r\n            } else {\r\n                \n                while (i != j && ((curOR & nums[j]) != 0)) {\r\n                    \n                    curOR ^= nums[i]; \r\n                    \n                    i++; \r\n                }\r\n                curOR |= nums[j]; \r\n            }\r\n            \n            ans = max(ans, j - i + 1); \r\n            j++; \r\n        }\r\n        \n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-87\"], \"nums_element1\": [\"898\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int widestPairOfIndices. /*FC*/class Solution {\n/*FM*/int widestPairOfIndices(vector<int>& nums1, vector<int>& nums2) \n    {                \n        vector<int>arr; \n        for (int i=0;  i<nums1.size();  i++)\n            arr.push_back(nums1[i]-nums2[i]); \n                \n        unordered_map<int,int>Map; \n        Map[0] = -1;         \n        \n        int presum = 0; \n        int ret = 0; \n        for (int i=0;  i<arr.size();  i++)\n        {\n            presum += arr[i]; \n            if (Map.find(presum)!=Map.end())                          \n                                            \n            else\n                Map[presum] = i; \n        }\n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [1], \"nums1_element0\": [\"-1381813980\"], \"nums2\": [1], \"nums2_element0\": [\"1828644984\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int racecar. /*FC*/class Solution {\n/*FM*/int racecar(int target) {\r\n        vector<int> dp(target + 1); \r\n        for (int i = 1;  i <= target;  ++i) {\r\n            int k = bitLength(i); \r\n            if (i == (1 << k) - 1) {\r\n                dp[i] = k; \r\n                continue; \r\n            }\r\n            dp[i] = dp[(1 << k) - 1 - i] + k + 1; \r\n            for (int j = 0;  j < k;  ++j) {\r\n                dp[i] = min(dp[i], dp[i - (1 << (k - 1)) + (1 << j)] + k + j + 1); \r\n            }\r\n        }\r\n        return dp.back(); \r\n    };/*F*//*C*//*M*/uint32_t bitLength(uint32_t n) {\r\n        uint32_t left = 1, right = 32; \r\n        while (left <= right) {\r\n            auto mid = left + (right - left) / 2; \r\n            if ((1 << mid) > n) {\r\n                right = mid - 1; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n        return left; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"target\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> largestValues. /*FC*/class Solution {\n/*FM*/vector<int> largestValues(TreeNode* root) {\n        vector<int> result; \n        if (root == nullptr) {\n            \n        }\n        queue<TreeNode*> Q; \n        Q.push(root); \n        while (!Q.empty()) {\n            int qs = Q.size(); \n            int maxVal = Q.front()->val; \n            for (int i = 0;  i < qs;  ++i) {\n                TreeNode* node = Q.front(); \n                Q.pop(); \n                maxVal = max(maxVal, node->val); \n                if (node->left) {\n                    \n                }\n                \n                if (node->right) {\n                    \n                }\n            }\n            \n            result.push_back(maxVal); \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1071640757\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findIntegers. /*FC*/class Solution {\n/*FM*/int findIntegers(int num) {\n        vector<int> dp(31); \n        dp[0] = 1; \n        dp[1] = 2; \n        for (int i = 2;  i < dp.size();  ++i) {\n            dp[i] = dp[i - 1] + dp[i - 2]; \n        }\n        \n        int count = 0; \n        int prevBit = 0; \n        for (int bit = 30;  bit >= 0;  --bit) {\n            if (num & (1 << bit)) {\n                count += dp[bit]; \n                if (prevBit == 1) {\n                    return count; \n                }\n                prevBit = 1; \n            }\n            else {\n                prevBit = 0; \n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"974623457\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDistinctIslands2. /*FC*/class Solution {\n/*FM*/int numDistinctIslands2(vector<vector<int>>& grid) {\n        int m = grid.size(); \n        if (m == 0) {\n            \n        }\n        \n        int n = grid[0].size(); \n        set<vector<pair<int, int>>> table; \n        vector<int> dx = {-1, 1, 0, 0}; \n        vector<int> dy = {0, 0, -1, 1}; \n        for (int i = 0;  i < m;  ++i) {\n            for (int j = 0;  j < n;  ++j) {\n                if (grid[i][j] == 1) {\n                    \n                    \n                    \n                    \n                    \n                    \n                }\n            }\n        }\n        \n        return table.size(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [1], \"grid_element0_element0\": [\"1134633928\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"-2078468851\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sumEvenAfterQueries. /*FC*/class Solution {\n/*FM*/vector<int> sumEvenAfterQueries(vector<int> &A, vector<vector<int>> &queries) {\r\n        vector<int> ret; \r\n        int sum = 0; \r\n        for (auto &a : A) {\r\n            if (a % 2 == 0)\r\n                sum += a; \r\n        }\r\n        for (int i = 0;  i < queries.size();  ++i) {\r\n            int &temp = A[queries[i][1]]; \r\n            if (temp % 2 == 0)\r\n                sum -= temp; \r\n            temp += queries[i][0]; \r\n            if (temp % 2 == 0)\r\n                sum += temp; \r\n            ret.push_back(sum); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"688\"], \"A_element1\": [\"610\"], \"queries\": [1], \"queries_element0\": [2], \"queries_element0_element0\": [\"-680\"], \"queries_element0_element1\": [\"90\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> generatePalindromes. /*FC*/class Solution {\n/*FM*/vector<string> generatePalindromes(string s) {\n        vector<int> table(128); \n        for (char c : s) {\n            ++table[c]; \n        }\n\n        vector<string> result; \n        int odd = 0; \n        string mid, seed; \n        for (int i = 0;  i < table.size();  ++i) {\n            if (table[i] % 2) {\n                ++odd; \n                mid += i; \n                if (odd > 1) {\n                    \n                }\n            }\n            seed += string(table[i] >> 1, i); \n        }\n        \n        string path; \n        vector<bool> used(seed.size()); \n        dfs(seed, path, mid, used, result); \n        return result; \n    };/*F*//*C*//*M*/void dfs(string& seed, string& path, string mid, vector<bool>& used, vector<string>& result) {\n        if (path.size() == seed.size()) {\n            string rev(path); \n            reverse(rev.begin(), rev.end()); \n            result.push_back(path + mid + rev); \n            return; \n        }\n\n        for (int i = 0;  i < seed.size();  ++i) {\n            if (used[i]) {\n                continue; \n            }\n            if (i > 0 && seed[i] == seed[i - 1] && !used[i - 1]) {\n                continue; \n            }\n            used[i] = true; \n            path.push_back(seed[i]); \n            dfs(seed, path, mid, used, result); \n            path.pop_back(); \n            used[i] = false; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > subsets. /*FC*/ {\n/*FM*/vector<vector<int> > subsets(vector<int> &S){\r\n\t\r\n\tsort(S.begin(), S.end()); \r\n\tvector<vector<int> > result; \r\n\tvector<int> buf; \r\n\tresult.push_back(buf); \r\n\t\r\n\tfor ( int i = S.size() - 1;  i >= 0;  i-- ){\r\n\t\tint size = result.size(); \r\n\t\tfor ( int j = 0;  j < size;  j++ ){\r\n\t\t\tbuf = result[j]; \r\n\t\t\tbuf.insert(buf.begin(), S[i]); \r\n\t\t\tresult.push_back(buf); \r\n\t\t\tbuf.clear(); \r\n\t\t}\r\n\t}\r\n\treturn result; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"S\": [2], \"S_element0\": [\"-553573582\"], \"S_element1\": [\"-819355833\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPalindromicSubsequences. /*FC*/class Solution {\n/*FM*/int countPalindromicSubsequences(string S) {\n        int n = S.size(); \n        prev = vector<vector<int>>(n, vector<int>(4, -1)); \n        next = vector<vector<int>>(n, vector<int>(4, -1)); \n        dp = vector<vector<int>>(n, vector<int>(n)); \n        vector<int> last(4, -1); \n        for (int i = 0;  i < n;  ) {\n            \n            \n        }\n        fill(last.begin(), last.end(), -1); \n        for (int i = n - 1;  i >= 0;  ) {\n            \n            \n        }\n        \n        return dfs(S, 0, n - 1); \n    };/*F*/vector<vector<int>> prev;  vector<vector<int>> next;  vector<vector<int>> dp;/*C*//*M*/int dfs(string S, int start, int end) {\n        if (start > end) {\n            return 0; \n        }\n        \n        if (dp[start][end]) {\n            return dp[start][end]; \n        }\n        \n        int count = 0; \n        for (int k = 0;  k < 4;  ++k) {\n            int i = next[start][k]; \n            int j = prev[end][k]; \n            \n            if (i == -1 || i > j) {\n                continue; \n            }\n                        \n            if (i == j) {\n                ++count; \n            }\n            else {\n                count += 2; \n                count = (count + dfs(S, i + 1, j - 1)) % MOD; \n            }                      \n        }\n        \n        return dp[start][end] = count; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDistinctIslands. /*FC*/class Solution {\n/*FM*/int numDistinctIslands(vector<vector<int>>& grid) {\n        int m = grid.size(); \n        if (m == 0) {\n            \n        }\n        \n        int n = grid[0].size(); \n        set<vector<int>> table; \n        vector<int> dx = {-1, 1, 0, 0}; \n        vector<int> dy = {0, 0, -1, 1}; \n        for (int i = 0;  i < m;  ++i) {\n            for (int j = 0;  j < n;  ++j) {\n                if (grid[i][j] == 1) {\n                    \n                    \n                    \n                    \n                    \n                    \n                }\n            }\n        }\n        \n        return table.size(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"901027431\"], \"grid_element0_element1\": [\"289675479\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"475650763\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool stoneGame. /*FC*/class Solution {\n/*FM*/bool stoneGame(vector<int> &piles) {\r\n        int size = piles.size(); \r\n        vector<vector<int>> dp(size, vector<int>(size, 0)); \r\n        for (int i = 0;  i < size;  ++i)\r\n            dp[i][i] = piles[i]; \r\n        for (int i = 1;  i < size;  ++i) {\r\n            for (int j = i - 1;  j >= 0;  --j)\r\n                dp[j][i] = max(piles[j] - dp[j + 1][i], piles[i] - dp[j][i - 1]); \r\n        }\r\n        return dp[0][size - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"piles\": [3], \"piles_element0\": [\"-424498699\"], \"piles_element1\": [\"-938247431\"], \"piles_element2\": [\"-1529254434\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sumSubseqWidths. /*FC*/class Solution {\n/*FM*/int sumSubseqWidths(vector<int>& A) \n    {\n        long M = 1e9+7; \n        \n        vector<long>Pow2(20000,1); \n        for (int i=1;  i<20000;  i++)\n            Pow2[i] = Pow2[i-1]*2%M; \n        \n        sort(A.begin(),A.end()); \n        long sum = 0; \n        int n = A.size(); \n        for (int i=0;  i<n;  i++)\n        {\n            sum -= A[i]*Pow2[n-1-i]%M; \n            sum += A[i]*Pow2[i]%M; \n            sum %= M; \n        }\n        return sum; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"129329901\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reorganizeString. /*FC*/class Solution {\n/*FM*/string reorganizeString(string S) {\n        int n = S.size(); \n        vector<int> table(26); \n        for (char c : S) {\n            ++table[c - 'a']; \n        }\n        \n        priority_queue<pair<int, char>> pq; \n        for (int i = 0;  i < 26;  ++i) {\n            if (table[i] > 0) {\n                \n            }\n        }\n        \n        string result; \n        char prevChar = ' '; \n        int prevCount = -1; \n        while (!pq.empty()) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n        }\n        \n        return result.size() == n ? result : \"\"; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool closeStrings. /*FC*/class Solution {\n/*FM*/bool closeStrings(string word1, string word2) \n    {\n        unordered_set<char>Set1; \n        unordered_set<char>Set2; \n\n        vector<int>a(26,0); \n        vector<int>b(26,0); \n        for (auto ch:word1)\n        {\n            a[ch-'a']+=1; \n            Set1.insert(ch); \n        }            \n        for (auto ch:word2)\n        {\n            b[ch-'a']+=1; \n            Set2.insert(ch); \n        }\n            \n        sort(a.begin(), a.end()); \n        sort(b.begin(), b.end()); \n        return a==b && Set1==Set2;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word1\": [\"1\"], \"word2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumBuckets. /*FC*/class Solution {\n/*FM*/int minimumBuckets(string street) \n    {\n        int n = street.size(); \n        int ret = 0; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            if (street[i]!='H') continue; \n            \n            if (i-1>=0 && street[i-1]=='#')\n            {\n                \n            }\n            else if (i+1<n && street[i+1]=='.')\n            {\n                \n                \n            }\n            else if (i-1>=0 && street[i-1]=='.')\n            {\n                \n                \n            }            \n            else\n            {\n                \n            }            \n        }\n        \n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"street\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> anagrams. /*FC*/ {\n/*FM*/vector<string> anagrams(vector<string> &strs){\r\n\tmap<string, int> mp; \r\n\tmap<string, string> pre; \r\n\t\r\n\tvector<string> res; \r\n\tfor ( int i = 0;  i < strs.size();  i++ ){\r\n\t\tstring s = strs[i]; \r\n\t\tsort(s.begin(), s.end()); \r\n\t\tif ( mp.find(s) == mp.end() ){\r\n\t\t\tmp[s] = 1; \r\n\t\t\tpre[s] = strs[i]; \r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\treturn res; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"strs\": [1], \"strs_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfWays. /*FC*/class Solution {\n/*FM*/int numberOfWays(int n, int x) {\r\n        static const int MOD = 1e9 + 7; \r\n\r\n        vector<int> dp(n + 1); \r\n        dp[0] = 1; \r\n        for (int i = 1;  i <= n;  ++i) {\r\n            const int i_pow_x = pow(i, x); \r\n            if (i_pow_x > n) {\r\n                \r\n            }\r\n            for (int j = n;  j >= i_pow_x;  --j) {\r\n                dp[j] = (dp[j] + dp[j - i_pow_x]) % MOD; \r\n            }\r\n        }\r\n        return dp.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"4\"], \"x\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int compareVersion. /*FC*/class Solution {\n/*FM*/int compareVersion(string version1, string version2) {\n        int i = 0, j = 0, n1 = version1.size(), n2 = version2.size(); \n        while(i< n1 || j<n2){\n            int c1 = 0, c2 = 0; \n            while(i<n1 && version1[i]!='.')\n                c1 = c1*10 + version1[i++] - '0'; \n            while(j<n2 && version2[j]!='.')\n                c2 = c2*10 + version2[j++] - '0'; \n            if(c1 != c2)\n                return c1 > c2 ? 1 : -1; \n             \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"version1\": [\"1\"], \"version2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findErrorNums. /*FC*/class Solution2 {\n/*FM*/vector<int> findErrorNums(vector<int>& nums) {\r\n        vector<int> result(2); \r\n        for (const auto& i : nums) {\r\n            if (nums[abs(i) - 1] < 0) {  \n                result[0] = abs(i); \r\n            } else {\r\n                nums[abs(i) - 1] *= -1; \r\n            }\r\n        }\r\n        for (int i = 0;  i < nums.size();  ++i) {\r\n            if (nums[i] > 0) {  \n                result[1] = i + 1; \r\n            } else {\r\n                nums[i] *= -1; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\"], \"nums\": [4], \"nums_element0\": [\"1\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"2\"], \"nums_element3\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestBeautifulString. /*FC*/class Solution {\n/*FM*/string smallestBeautifulString(string s, int k) \n    {\n        string original = s; \n        int n = s.size(); \n        int flag = 0; \n        for (int i=n-1;  i>=0;  )\n        {\n            for (char ch=s[i]+1;  ch<'a'+k;  )\n            {\n                if (!checkOK(s, i, ch)) \n                s[i] = ch; \n\n                for (int j=i+1;  j<n;  )\n                {\n                    \n                }\n\n                flag = 1; \n                break; \n            }\n            if (flag) break; \n        }\n\n        if (s==original) \n        return s; \n    };/*F*//*C*//*M*/bool checkOK(string&s, int i, char ch)\n    {\n        if (i>=1 && s[i-1]==ch) return false; \n        if (i>=2 && s[i-2]==ch) return false; \n        return true; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"k\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumLengthEncoding. /*FC*/class Solution {\n/*FM*/int minimumLengthEncoding(vector<string>& words) {\r\n        unordered_set<string> unique_words(words.cbegin(), words.cend()); \r\n        vector<TrieNode *> leaves; \r\n        TrieNode trie; \r\n        for (auto word : unique_words) {\r\n            reverse(word.begin(), word.end()); \r\n            leaves.emplace_back(trie.Insert(word)); \r\n        }\r\n        int result = 0; \r\n        int i = 0; \r\n        for (const auto& word: unique_words) {\r\n            if (leaves[i++]->leaves.empty()) {\r\n                result += word.length() + 1; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/TrieNode *Insert(const string& s) {\r\n            auto* p = this; \r\n            for (const auto& c : s) {\r\n                if (!p->leaves[c - 'a']) {\r\n                    p->leaves[c - 'a'] = new TrieNode; \r\n                }\r\n                p = p->leaves[c - 'a']; \r\n            }\r\n            return p; \r\n        };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"words\": [1], \"words_element0\": [\"t\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> killProcess. /*FC*/class Solution {\n/*FM*/vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {\n        unordered_map<int, vector<int>> table; \n        int n = pid.size(); \n        for (int i = 0;  i < n;  ++i) {\n            table[ppid[i]].push_back(pid[i]); \n        }\n        \n        vector<int> result; \n        queue<int> Q; \n        Q.push(kill); \n        while (!Q.empty()) {\n            int parent = Q.front(); \n            result.push_back(parent); \n            Q.pop(); \n            for (int child : table[parent]) {\n                \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pid\": [1], \"pid_element0\": [\"-1053794\"], \"ppid\": [1], \"ppid_element0\": [\"180415385\"], \"kill\": [\"1255815190\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isScramble. /*FC*/class Solution {\n/*FM*/bool isScramble(string s1, string s2) {\r\n        int len=s1.size(); \r\n        bool ans[len][len][len+1]; \r\n        for(int k=1; k<=len+1; k++){\r\n            for(int i=0; i+k<=len; i++){\r\n                for(int j=0; j+k<=len; j++){\r\n                    if(k==1){\r\n                        ans[i][j][k]=(s1[i]==s2[j]); \r\n                    }\r\n                    else{\r\n                        \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ans[0][0][len]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s1\": [\"1\"], \"s2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> fallingSquares. /*FC*/class Solution {\n/*FM*/vector<int> fallingSquares(vector<pair<int, int>>& positions) {\n        int n = positions.size(); \n        vector<int> result(n); \n        vector<Interval> intervals; \n        int maxh = 0; \n        for (int i = 0;  i < n;  ++i) {\n            int left = positions[i].first; \n            int right = positions[i].first + positions[i].second - 1; \n            int currh = getHeight(intervals, left, right) + right - left + 1; \n            intervals.emplace_back(left, right, currh); \n            maxh = max(maxh, currh); \n            result[i] = maxh; \n        }\n        return result; \n    };/*F*//*C*//*M*/int getHeight(vector<Interval>& intervals, int left, int right) {\n        int h = 0; \n        for (Interval& interval : intervals) {\n            if (interval.right < left || interval.left > right) {\n                continue; \n            }\n            h = max(h, interval.height); \n        }\n        return h; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"positions\": [2], \"positions_element0.first\": [\"-918827454\"], \"positions_element0.second\": [\"179058404\"], \"positions_element1.first\": [\"-1040398710\"], \"positions_element1.second\": [\"-244356305\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int>Eratosthenes. /*FC*/class Solution {\n/*FM*/vector<int>Eratosthenes(int n)\n    {\n        vector<int>q(n+1,0); \n        vector<int>primes; \n        for (int i=2;  i<=sqrt(n);  i++)\n        {\n            if (q[i]==1) \n            int j=i*2; \n            while (j<=n)\n            {\n                q[j]=1; \n                j+=i; \n            }\n        }        \n        for (int i=2;  i<=n;  i++)\n        {\n            if (q[i]==0)\n                primes.push_back(i);                 \n        }\n        return primes; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* partition. /*FC*/class Solution {\n/*FM*/ListNode* partition(ListNode* head, int x) {\r\n        ListNode fake1(0), fake2(0); \r\n        fake1.next = head; \r\n        \r\n        ListNode *pi = &fake1, *pj = &fake2; \r\n        while (head) {\r\n            if (head->val < x) {\r\n                pi->next = head; \r\n                pi = head; \r\n            } else {\r\n                pj->next = head; \r\n                pj = head; \r\n            }\r\n            head = head->next; \r\n        }\r\n        pi->next = fake2.next; \r\n        pj->next = NULL; \r\n        return fake1.next; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1374230585\"], \"head[0].val\": [\"-1040448674\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-2058899048\"], \"head[0].next[0].val\": [\"953053293\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"-851713223\"], \"head[0].next[1].val\": [\"1471961280\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"-1963255062\"], \"head[0].next[2].val\": [\"-819035779\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-75575492\"], \"head[1].val\": [\"1944744034\"], \"head[1].next\": [2], \"head[1].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head1_next0_x\": [\"-1452582339\"], \"head[1].next[0].val\": [\"86819085\"], \"head[1].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_next1_x\": [\"-66286044\"], \"head[1].next[1].val\": [\"-1824464664\"], \"x\": [\"572509079\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<bool> camelMatch. /*FC*/class Solution {\n/*FM*/vector<bool> camelMatch(vector<string> &queries, string &pattern) {\r\n        vector<bool> ret; \r\n        int n = pattern.size(); \r\n        for (auto &query:queries) {\r\n            bool res = true; \r\n            int i = 0; \r\n            for (auto &q:query) {\r\n                if (q < 'Z') {\r\n                    if (i >= n || q != pattern[i]) {\r\n                        res = false; \r\n                        break; \r\n                    }\r\n                    \r\n                } else if (q == pattern[i])\r\n                    \r\n            }\r\n            ret.push_back(res && i == n); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"queries\": [3], \"queries_element0\": [\"1\"], \"queries_element1\": [\"1\"], \"queries_element2\": [\"2\"], \"pattern\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string decodeAtIndex. /*FC*/class Solution {\n/*FM*/string decodeAtIndex(string S, int K) {\r\n        long long size = 0, i = 0; \r\n        while (i < S.size()) {\r\n            if (isdigit(S[i]))\r\n                \r\n            else\r\n                ++size; \r\n            ++i; \r\n        }\r\n        i == S.size() ? --i : 1; \r\n        cout << i; \r\n        while (i >= 0) {\r\n            K %= size; \r\n            if (K == 0 && !isdigit(S[i]))\r\n                return S.substr(i, 1); \r\n            if (isdigit(S[i]))\r\n                \r\n            else\r\n                \r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"], \"K\": [\"-649113940\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxSubArrayLen. /*FC*/class Solution {\n/*FM*/int maxSubArrayLen(vector<int>& nums, int k) \n    {\n        unordered_map<long,vector<int>>Map; \n        long sum=0; \n        int result=INT_MIN; \n        \n        nums.insert(nums.begin(),0); \n        \n        for (int i=0;  i<nums.size();  i++)\n        {\n            sum+=nums[i]; \n            Map[sum].push_back(i); \n            \n            int temp = sum-k; \n            if (Map.find(temp)!=Map.end())\n            {\n                \n            }\n        }\n        \n        if (result==INT_MIN) result=0; \n        \n        return result; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1250203778\"], \"nums_element1\": [\"-2115959448\"], \"nums_element2\": [\"1618849271\"], \"k\": [\"-627395169\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findPermutation. /*FC*/class Solution {\n/*FM*/vector<int> findPermutation(string pattern) \n    {\n        pattern = \"I\" + pattern; \n        int n = pattern.size(); \n        \n        int mx = 0; \n        vector<int>arr; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            int j = i+1; \n            while (j<n && pattern[j]=='D')\n                \n            int count = j-i;             \n            for (int k= mx+count;  k>=mx+1;  k--)\n                arr.push_back(k);             \n            mx = mx+count;             \n            i = j-1;             \n        }\n        \n        return arr; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pattern\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> findRestaurant. /*FC*/class Solution {\n/*FM*/vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {\n        int m = list1.size(), n = list2.size(); \n        int maxSum = m + n - 1; \n        unordered_map<string, int> table; \n        vector<string> result; \n        for (int i = 0;  i < list1.size();  ++i) {\n            table[list1[i]] = i; \n        }\n        \n        for (int j = 0;  j < list2.size();  ++j) {\n            if (table.find(list2[j]) != table.end()) {\n                \n                \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"list1\": [1], \"list1_element0\": [\"1\"], \"list2\": [1], \"list2_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode * rotateRight. /*FC*/class Solution {\n/*FM*/ListNode * rotateRight(ListNode * head, int k) {\r\n      ListNode * last = head; \r\n      int c = 0; \r\n      if (head == NULL || k == 0)\r\n        \r\n      while (last -> next != nullptr) {\r\n        c++; \r\n        last = last -> next; \r\n      }\r\n\r\n      last -> next = head; \r\n      k = k % (c + 1); \r\n      int jump = c - k; \r\n      last = head; \r\n      while (jump--) {\r\n        \r\n      }\r\n      ListNode * newhead = last -> next; \r\n      last -> next = NULL; \r\n\r\n      return newhead; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int,ListNode*)\"], \"head0_x\": [\"-678\"], \"head0_next\": [1], \"head0_next[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode()\"], \"k\": [\"915183429\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countCornerRectangles. /*FC*/class Solution {\n/*FM*/int countCornerRectangles(vector<vector<int>>& grid) {\n        int m = grid.size(); \n        int n = grid[0].size(); \n        int count = 0; \n        for (int i = 0;  i < m - 1;  ++i) {\n            for (int j = i + 1;  j < m;  ++j) {\n                int num = 0; \n                for (int k = 0;  k < n;  ++k) {\n                    if (grid[i][k] == 1 && grid[j][k] == 1) {\n                        \n                    }\n                }\n                count += num * (num - 1) / 2; \n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"1394239046\"], \"grid_element0_element1\": [\"-105412885\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"-2138663409\"], \"grid_element1_element1\": [\"1298032468\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canTransform. /*FC*/class Solution {\n/*FM*/bool canTransform(string start, string end) {\n        int n = start.size(); \n        int i = 0, j = 0; \n        while (i < n && j < n) {\n            while (i < n && start[i] == 'X') \n            while (j < n && end[j] == 'X') \n            if ((i < n) ^ (j < n)) \n            if (i < n && j < n) {\n                if (start[i] != end[j] || (start[i] == 'L' && i < j) || (start[i] == 'R' && i > j)) {\n                    return false; \n                }\n            }\n            \n            \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"start\": [\"2\"], \"end\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBoldTag. /*FC*/class Solution {\n/*FM*/string addBoldTag(string s, vector<string>& dict) {\n        vector<bool> bold(s.size()); \n        for (string str : dict) {\n            for (int i = 0;  i < int(s.size()) - int(str.size()) + 1;  ++i) {\n                if (str == s.substr(i, str.size())) {\n                    \n                }\n            }\n        }\n        \n        string result; \n        int i = 0; \n        while (i < bold.size()) {\n            if (bold[i]) {\n                \n                \n                \n            }\n            else {\n                result += s[i++]; \n            }\n        }\n        return result;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"dict\": [1], \"dict_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string shiftingLetters. /*FC*/class Solution {\n/*FM*/string shiftingLetters(string S, vector<int> &shifts) {\r\n        vector<char> shift; \r\n        int num = 'z' - 'a' + 1; \r\n        for (int i = S.size() - 2;  i >= 0;  ) {\r\n            \r\n            \r\n        }\r\n        for (int i = 0;  i < S.size();  ++i) {\r\n            int temp = S[i] + shifts[i]; \r\n            while (temp > 'z')\r\n                temp -= num; \r\n            shift.push_back(temp); \r\n        }\r\n        string ret(shift.begin(), shift.end()); \r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"], \"shifts\": [2], \"shifts_element0\": [\"287\"], \"shifts_element1\": [\"838\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canConvertString. /*FC*/class Solution {\n/*FM*/bool canConvertString(string s, string t, int k) \n    {\n        if (s.size()!=t.size()) \n        int n = s.size(); \n        vector<int>count(26); \n        \n        for (int i=0;  i<n;  i++)        \n            count[(t[i]-s[i]+26)%26] += 1;                 \n        \n        int ret = 0; \n        for (int i=1;  i<26;  i++)        \n        {\n            if (count[i]>=1)\n                ret = max(ret, (count[i]-1)*26+i);         \n        }\n        return ret<=k; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"], \"k\": [\"1370155429\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double minmaxGasDist. /*FC*/class Solution {\n/*FM*/double minmaxGasDist(vector<int>& stations, int K) {\n        int n = stations.size(); \n        double start = 0, end = stations[n - 1] - stations[0]; \n        while (end - start > 1e-6) {\n            double mid = (start + end) / 2; \n            int count = 0; \n            for (int i = 1;  i < n;  ++i) {\n                int dist = stations[i] - stations[i - 1]; \n                count += ceil(dist / mid) - 1; \n            }\n            if (count <= K) {\n                \n            }\n            else {\n                start = mid; \n            }            \n        }\n        \n        return start; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"stations\": [2], \"stations_element0\": [\"-135263333\"], \"stations_element1\": [\"1705141065\"], \"K\": [\"-957803885\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sequentialDigits. /*FC*/class Solution {\n/*FM*/vector<int> sequentialDigits(int low, int high) {\r\n        vector<int> result; \r\n        queue<int> q{{1, 2, 3, 4, 5, 6, 7, 8}}; \r\n        while (!q.empty()) {\r\n            const auto num = q.front();  q.pop(); \r\n            if (num > high) {\r\n                continue; \r\n            }\r\n            if (low <= num) {\r\n                result.emplace_back(num); \r\n            }\r\n            if (num % 10 + 1 < 10) {\r\n                q.emplace(num * 10 + num % 10 + 1); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"low\": [\"100\"], \"high\": [\"300\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumDeletions. /*FC*/class Solution {\n/*FM*/int minimumDeletions(string s) \n    {\n        int n = s.size(); \n\n        vector<int>pre(n);         \n        pre[0] = (s[0]=='b'); \n        for (int i=1;  i<n;  )\n            \n        \n        vector<int>suf(n); \n        suf[n-1] = (s[n-1]=='a'); \n        for (int i=n-2;  i>=0;  )\n            \n        \n        int ret = min(pre[n-1], suf[0]); \n        for (int i=0;  i<n-1;  )\n            \n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> parse. /*FC*/class Solution {\n/*FM*/vector<string> parse(const string& expression) {\n        vector<string> result; \n        int bal = 0; \n        stringstream ss(expression); \n        string token; \n        string buf; \n        while (getline(ss, token, ' ')) {\n            for (char c : token) {\n                if (c == '(') \n                if (c == ')') \n            }\n            if (buf.size() > 0) \n            buf += token; \n            if (bal == 0) {\n                result.push_back(buf); \n                buf = \"\"; \n            }            \n        }\n        \n        if (buf.size() > 0) {\n            \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"expression\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string boldWords. /*FC*/class Solution {\n/*FM*/string boldWords(vector<string>& words, string S) {\n        int n = S.size(); \n        vector<bool> bold(n); \n        for (string word : words) {\n            int m = word.size(); \n            for (int i = 0;  i < n - m + 1;  ++i) {\n                if (word == S.substr(i, m)) {\n                    \n                }\n            }\n        }\n        \n        string result; \n        int i = 0; \n        while (i < n) {\n            if (bold[i]) {\n                \n                \n                \n            }\n            else {\n                result += S[i++]; \n            }\n        }\n        return result;   \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"2\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> groupThePeople. /*FC*/class Solution {\n/*FM*/vector<vector<int>> groupThePeople(vector<int>& groupSizes) {\r\n        vector<vector<int>> ans; \r\n        unordered_map<int, int> m; \r\n        for (int i = 0;  i < groupSizes.size();  i++) {\r\n            if (m.find(groupSizes[i]) == m.end() || ans[m[groupSizes[i]]].size() >= groupSizes[i]) {\r\n                ans.emplace_back(); \r\n                m[groupSizes[i]] = ans.size() - 1; \r\n            }\r\n            ans[m[groupSizes[i]]].push_back(i); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"groupSizes\": [1], \"groupSizes_element0\": [\"-1553753786\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> minOperations. /*FC*/class Solution {\n/*FM*/vector<int> minOperations(string boxes) \n    {\n        int n = boxes.size(); \n        vector<int>leftMoves(n); \n        vector<int>rightMoves(n); \n        int left = 0; \n        for (int i = 1;  i<n;  )\n        {\n            \n            \n        }\n        int right = 0; \n        for (int i = n-2;  i>=0;  )\n        {\n            \n            \n        }\n        vector<int>rets(n); \n        for (int i=0;  i<n;  i++)\n            rets[i] = leftMoves[i]+rightMoves[i]; \n        return rets; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"boxes\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int kEmptySlots. /*FC*/class Solution {\n/*FM*/int kEmptySlots(vector<int>& flowers, int k) {\n        int N = flowers.size(); \n        set<int> table; \n        for (int i = 0;  i < N;  ++i) {\n            auto it = table.insert(flowers[i]).first; \n            auto it1 = it; \n            --it1; \n            if (it1 != table.end() && *it - *it1 == k + 1) {\n                \n            }\n            auto it2 = it; \n            ++it2; \n            if (it2 != table.end() && *it2 - *it == k + 1) {\n                \n            }\n        }\n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"flowers\": [2], \"flowers_element0\": [\"1867806125\"], \"flowers_element1\": [\"-1073617703\"], \"k\": [\"-507151569\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numComponents. /*FC*/class Solution {\n/*FM*/int numComponents(ListNode *head, vector<int> &G) {\r\n        unordered_set<int> exist; \r\n        for (int i = 0;  i < G.size();  ++i)\r\n            exist.insert(G[i]); \r\n        int num = 0; \r\n        bool connected = false; \r\n        while (head) {\r\n            if (connected && exist.find(head->val) == exist.end()) {\r\n                \r\n                \r\n            }\r\n            if (exist.find(head->val) != exist.end())\r\n                \r\n            head = head->next; \r\n        }\r\n        if (connected) \r\n        return num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].val\": [\"958220808\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[0].val\": [\"-1036005835\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[1].val\": [\"-1827252602\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[2].val\": [\"765792432\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1638930843\"], \"head[1].val\": [\"1152438419\"], \"head[1].next\": [3], \"head[1].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head1_next0_x\": [\"1703442721\"], \"head[1].next[0].val\": [\"-890744968\"], \"head[1].next[1]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head1_next1_x\": [\"-1655607309\"], \"head[1].next[1].val\": [\"406501493\"], \"head[1].next[2]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head1_next2_x\": [\"957505339\"], \"head[1].next[2].val\": [\"1734022436\"], \"G\": [2], \"G_element0\": [\"-85937012\"], \"G_element1\": [\"1322877316\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findNthDigit. /*FC*/class Solution {\n/*FM*/int findNthDigit(int N) \n    {\n        int k = 0; \n        long n = N; \n        long nums = 0; \n        while (n > 0)\n        {        \n            k++;     \n            nums = kDigitNums(k); \n            n -= nums; \n        }\n\n        if (n==0) \n\n        n += nums; \n        int m = n/k; \n        if (n%k==0) m--; \n        int r = n%k; \n        if (r==0) r=k; \n\n        int ret = pow(10,k-1) + m; \n        return to_string(ret)[r-1] - '0'; \n    };/*F*//*C*//*M*/long kDigitNums(int k)\n    {\n        return  (pow(10, k) - pow(10, k-1)) * k; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long wonderfulSubstrings. /*FC*/class Solution {\n/*FM*/long long wonderfulSubstrings(string word) \n    {\n        int n = word.size(); \n        int state = 0; \n        vector<int>count(1<<10); \n        count[0]+=1; \n        \n        ll ret = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            int j = word[i]-'a'; \n            state ^= (1<<j); \n            \n            ret += count[state]; \n            \n            for (int j=0;  j<10;  j++)            \n                ret += count[state ^ (1<<j)];                                 \n\n            count[state]++; \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestValidSubstring. /*FC*/class Solution {\n/*FM*/int longestValidSubstring(string word, vector<string>& forbidden) {\n        unordered_set<string>st(forbidden.begin(), forbidden.end()); \n        int n = word.size(); \n        int res = 0, right = n -1; \n        for (int left = n-1;  left >= 0;  --left){\n            for(int k = left;  k <= min(left + 10, right);  ++k){\n                string cur = word.substr(left, k-left + 1); \n                if (st.count(cur)){\n                    \n                    \n                }\n            }\n            res = max(res, right - left + 1); \n            \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word\": [\"2\"], \"forbidden\": [1], \"forbidden_element0\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors2. /*FC*/ {\n/*FM*/void sortColors2(int A[], int n){\r\n\t\r\n\tint redindex = 0, blueindex = n - 1; \r\n\t\r\n\tfor ( int i = 0;  i < blueindex + 1; ){\r\n\t\t\r\n\t\tif (A[i] == 0){\r\n\t\t\tswap(A[i], A[redindex]); \r\n\t\t\tredindex++; \r\n\t\t\ti++; \r\n\t\t\tcontinue; \r\n\t\t}\r\n\t\t\r\n\t\telse if ( A[i] == 2 ){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t\ti++; \r\n\t\t\r\n\t}\r\n\treturn; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"711\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findSmallestInteger. /*FC*/class Solution {\n/*FM*/int findSmallestInteger(vector<int>& nums, int value) \n    {\n        vector<int>count(value); \n        \n        for (int& x: nums)\n        {\n            x = ((x%value)+value) % value; \n            count[x] += 1; \n        }\n        \n        int min_count = INT_MAX; \n        int k; \n        \n        for (int i=0;  i<value;  i++)\n        {\n            if (count[i]<min_count)\n            {\n                min_count = count[i]; \n                k = i; \n            }            \n        }\n        \n        return min_count*value + k;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"2082765341\"], \"nums_element1\": [\"1874187401\"], \"nums_element2\": [\"1150221575\"], \"value\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long countInterestingSubarrays. /*FC*/class Solution {\n/*FM*/long long countInterestingSubarrays(vector<int>& nums, int modulo, int k) \n    {\n        int n = nums.size(); \n        int count = 0; \n        unordered_map<int,LL>Map; \n        Map[0]+=1; \n        LL ret = 0; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            count += ((nums[i]%modulo)==k); \n            int m = count % modulo; \n            int kk = (m-k+modulo)%modulo; \n            \n            ret += Map[kk]; \n            Map[m] += 1; \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1681965565\"], \"nums_element1\": [\"64553815\"], \"modulo\": [\"-180890956\"], \"k\": [\"-24886861\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestWordDistance. /*FC*/class Solution {\n/*FM*/int shortestWordDistance(vector<string>& words, string word1, string word2) {\n        int p1 = -1, p2 = -1; \n        int minDist = words.size(); \n        bool diff = (word1 != word2); \n        for (int i = 0;  i < words.size();  ++i) {\n            if (diff) {\n                if (words[i] == word1) {\n                    \n                    \n                }\n                else if (words[i] == word2) {\n                    \n                    \n                }\n            }\n            else if (words[i] == word1) {\n                \n                \n            }\n        }\n        \n        return minDist; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"1\"], \"word1\": [\"1\"], \"word2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMaximumGold. /*FC*/class Solution {\n/*FM*/int getMaximumGold(vector < vector < int >> & grid) {\r\n    int ans = 0;  \n    int m = grid.size();  \n    int n = grid[0].size();  \n    vector < vector < bool >> vis(m, vector < bool > (n, false)); \r\n    for (int i = 0;  i < m;  i++) {\r\n      for (int j = 0;  j < n;  j++) {\r\n        if (grid[i][j] != 0) {\r\n          int temp = dfs(grid, i, j, vis);  \n          ans = max(ans, temp);  \n        }\r\n      }\r\n    }\r\n    return ans; \n  };/*F*//*C*//*M*/int dfs(vector < vector < int >> & grid, int i, int j, vector < vector < bool >> & vis) {\r\n      \n      if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || vis[i][j] == true || grid[i][j] == 0)\r\n        return 0; \r\n      vis[i][j] = true;  \n      int curr = grid[i][j]; \r\n      \n      curr = max({\r\n        curr,\r\n        grid[i][j] + dfs(grid, i - 1, j, vis),\r\n        grid[i][j] + dfs(grid, i + 1, j, vis),\r\n        grid[i][j] + dfs(grid, i, j - 1, vis),\r\n        grid[i][j] + dfs(grid, i, j + 1, vis)\r\n      }); \r\n      vis[i][j] = false;  \n      return curr;  \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"679\"], \"grid_element0_element1\": [\"-153\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"-186\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findDuplicates. /*FC*/class Solution {\n/*FM*/vector<int> findDuplicates(vector<int>& nums) \n    {\n        int n = nums.size(); \n        nums.insert(nums.begin(),0); \n        for (int i=1;  i<=n;  i++)\n        {\n            while (nums[i]!=i && nums[i]<=n && nums[i]!=nums[nums[i]])\n                \n        }\n        vector<int>rets; \n        for (int i=1;  i<=n;  i++)\n        {\n            if (nums[i]!=i)\n                rets.push_back(nums[i]); \n        }\n        return rets; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"675789687\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findDisappearedNumbers. /*FC*/class Solution {\n/*FM*/vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size(); \n        nums.insert(nums.begin(),0); \n        for (int i=1;  i<=n;  i++)\n        {\n            while (nums[i]!=i && nums[i]<=n && nums[i]!=nums[nums[i]])\n                \n        }\n        vector<int>rets; \n        for (int i=1;  i<=n;  i++)\n        {\n            if (nums[i]!=i)\n                rets.push_back(i); \n        }\n        return rets; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"803073063\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minMeetingRooms. /*FC*/class Solution {\n/*FM*/int minMeetingRooms(vector<vector<int>>& intervals) {\n        vector<pair<int, int>> time; \n        for (auto i : intervals) {\n            time.emplace_back(i[0], 1); \n            time.emplace_back(i[1], 0); \n        }\n        \n        sort(time.begin(), time.end()); \n        int count = 0, maxCount = 0; \n        for (auto& t : time) {\n            if (t.second) {\n                ++count; \n                maxCount = max(maxCount, count); \n            }\n            else {\n                --count; \n            }            \n        }\n        return maxCount; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [1], \"intervals_element0\": [1], \"intervals_element0_element0\": [\"615497463\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long fixedRatio. /*FC*/class Solution {\n/*FM*/long long fixedRatio(string s, int num1, int num2) \n    {\n        Map[{0,0}] = 1; \n        LL a = 0, b = 0; \n        LL ret = 0; \n        for (auto ch: s)\n        {\n            if (ch=='0') \n            else b++; \n\n            LL k = min(a/num1, b/num2); \n            LL x = a-k*num1, y = b-k*num2; \n\n            if (Map.find({x,y})!=Map.end())            \n                            \n\n            Map[{x,y}] += 1;                 \n        }\n\n        return ret; \n    };/*F*/map<pair<LL,LL>, int> Map;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"num1\": [\"1650962261\"], \"num2\": [\"-699850079\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int tallestBillboard. /*FC*/class Solution {\n/*FM*/int tallestBillboard(vector<int>& rods) {\r\n        auto left = dp(rods.cbegin(), rods.cbegin() + rods.size() / 2); \r\n        auto right = dp(rods.cbegin() + rods.size() / 2, rods.cend()); \r\n        int result = 0; \r\n        for (const auto& kvp : left) {\r\n            if (right.count(kvp.first)) {\r\n                result = max(result,\r\n                             left[kvp.first] + right[kvp.first] + kvp.first); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/unordered_map<int, int> dp(vector<int>::const_iterator it,\r\n                               vector<int>::const_iterator end) {\r\n        unordered_map<int, int> lookup; \r\n        lookup[0] = 0; \r\n        for (;  it != end;  ++it) {\r\n            unordered_map<int, int> tmp(lookup); \r\n            for (const auto& kvp : tmp) {\r\n                lookup[kvp.first + *it] = max(lookup[kvp.first + *it], kvp.second); \r\n                lookup[abs(kvp.first - *it)] = max(lookup[abs(kvp.first - *it)],\r\n                                                   kvp.second + min(kvp.first, *it)); \r\n            }\r\n        }\r\n        return lookup; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"rods\": [4], \"rods_element0\": [\"1\"], \"rods_element1\": [\"2\"], \"rods_element2\": [\"3\"], \"rods_element3\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sumNumbers. /*FC*/class Solution {\n/*FM*/int sumNumbers(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        int sum = 0; \r\n        queue<NodeValue> que; \r\n        que.push(NodeValue(root, 0)); \r\n        while (!que.empty()) {\r\n            NodeValue node = que.front(); \r\n            que.pop(); \r\n            if (!node.node->left && !node.node->right) {\r\n                sum += node.value * 10 + node.node->val; \r\n            }\r\n            if (node.node->left)\r\n                \r\n            if (node.node->right)\r\n                \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/NodeValue(TreeNode *node, int value) : node(node), value(value) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> eventualSafeNodes. /*FC*/class Solution {\n/*FM*/vector<int> eventualSafeNodes(vector<vector<int>> &graph) {\r\n        vector<int> ret; \r\n        vector<int> res; \r\n        int n = graph.size(); \r\n        res = vector<int>(n, 0); \r\n        for (int i = 0;  i < n;  ++i) {\r\n            if (res[i] == 0)\r\n                DFS(i, graph, res); \r\n        }\r\n        for (int i = 0;  i < n;  ++i)\r\n            if (res[i] == 2)\r\n                ret.push_back(i); \r\n        return ret; \r\n    };/*F*//*C*//*M*/bool DFS(int root, vector<vector<int>> &graph, vector<int> &res) {\r\n        res[root] = 1; \r\n        for (auto &node:graph[root]) {\r\n            if (res[node] == 2)\r\n                continue; \r\n            if (res[node] == 1 || !DFS(node, graph, res))\r\n                return false; \r\n        }\r\n        res[root] = 2; \r\n        return true; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"graph\": [2], \"graph_element0\": [1], \"graph_element0_element0\": [\"318\"], \"graph_element1\": [2], \"graph_element1_element0\": [\"-919\"], \"graph_element1_element1\": [\"-535\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minInsertions. /*FC*/class Solution {\n/*FM*/int minInsertions(string s) \n    {\n        int count = 0; \n        int ret = 0; \n        for (int i=0;  i<s.size();  i++)\n        {\n            if (s[i]=='(')\n                \n            else\n            {\n                if (i+1<s.size() && s[i+1]==')')\n                {\n                    \n                    \n                }\n                else\n                {\n                    count--; \n                    ret++; \n                }\n            }\n            if (count<0)\n            {\n                ret++; \n                count=0; \n            }\n        }\n        return ret + count*2; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<string>> findDuplicate. /*FC*/class Solution {\n/*FM*/vector<vector<string>> findDuplicate(vector<string>& paths) {\n        unordered_map<string, vector<string>> table; \n        for (string path : paths) {\n            string dir; \n            int i = 0; \n            while (i < path.size() && path[i] != ' ') {\n                dir += path[i++]; \n            }\n            ++i; \n            \n            while (i < path.size()) {\n                \n                \n\n                \n                \n                \n                \n                \n            }\n        }\n        \n        vector<vector<string>> result; \n        for (auto t : table) {\n            \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"paths\": [1], \"paths_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNonDuplicate. /*FC*/class Solution {\n/*FM*/int singleNonDuplicate(vector<int>& nums) {\r\n        int left = 0, right = nums.size() - 1; \r\n        while (left <= right) {\r\n            auto mid = left + (right - left) / 2; \r\n            if (!(mid % 2 == 0 && mid + 1 < nums.size() &&\r\n                  nums[mid] == nums[mid + 1]) &&\r\n                !(mid % 2 == 1 && nums[mid] == nums[mid - 1])) {\r\n                right = mid - 1; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n        return nums[left]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [9], \"nums_element0\": [\"1\"], \"nums_element1\": [\"1\"], \"nums_element2\": [\"2\"], \"nums_element3\": [\"3\"], \"nums_element4\": [\"3\"], \"nums_element5\": [\"4\"], \"nums_element6\": [\"4\"], \"nums_element7\": [\"8\"], \"nums_element8\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int partitionDisjoint. /*FC*/class Solution {\n/*FM*/int partitionDisjoint(vector<int>& A) {\r\n        vector<int> B(A); \r\n        for (int i = A.size() - 2;  i > 0;  --i) {\r\n            B[i] = min(B[i], B[i + 1]); \r\n        }\r\n        int p_max = 0; \r\n        for (int i = 1;  i < A.size();  ++i) {\r\n            p_max = max(p_max, A[i - 1]); \r\n            if (p_max <= B[i]) {\r\n                return i; \r\n            }\r\n        }\r\n          \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [6], \"A_element0\": [\"1\"], \"A_element1\": [\"1\"], \"A_element2\": [\"1\"], \"A_element3\": [\"0\"], \"A_element4\": [\"6\"], \"A_element5\": [\"12\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> nextGreaterElements. /*FC*/class Solution {\n/*FM*/vector<int> nextGreaterElements(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        stack<int> s; \r\n        vector<int> ret(n, -1); \r\n        for (int i = 0;  i < n * 2;  ++i) {\r\n            while (!s.empty() && nums[s.top()] < nums[i % n]) {\r\n                ret[s.top()] = nums[i % n]; \r\n                s.pop(); \r\n            }\r\n            if (i < n)\r\n                s.push(i); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"268204512\"], \"nums_element1\": [\"2104340273\"], \"nums_element2\": [\"691790386\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestArithSeqLength. /*FC*/class Solution {\n/*FM*/int longestArithSeqLength(vector<int> &A) {\r\n        int n = A.size(), res = 0; \r\n        vector<unordered_map<int, int>> dp(n); \r\n        for (int i = 1;  i < n;  ++i) {\r\n            for (int j = 0;  j < i;  ++j) {\r\n                int diff = A[i] - A[j]; \r\n                dp[i][diff] = dp[j][diff] + 1; \r\n                res = max(res, dp[i][diff]); \r\n            }\r\n        }\r\n        return res + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-1708524231\"], \"A_element1\": [\"117413572\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestDupSubstring. /*FC*/class Solution {\n/*FM*/string longestDupSubstring(string s) {\r\n        s_size = s.size(); \r\n        \n        vector<ll> power(s_size, 1); \r\n        for (int i = 1;  i < s_size;  ) \r\n\r\n        \n        int l = 0, r = s_size - 1, mid = 0; \r\n        for (;  l <= r;  mid = l + (r - l) / 2) {\r\n            if (helper(mid + 1, s, power[mid]))\r\n                \r\n            else\r\n                r = mid - 1; \r\n        }\r\n\r\n        return ans; \r\n    };/*F*/int s_size = 0;/*C*//*M*/bool helper(int len, string& s, ll po) {\r\n        unordered_set<ll> memo; \r\n        int l = 0; \r\n        \n        ll current_hash = 0; \r\n        for (int i = 0;  i < len;  ++i) {\r\n            current_hash = (current_hash * p) + s[i]; \r\n        }\r\n        memo.insert(current_hash); \r\n\r\n        \n        for (int i = len;  i < s_size;  ++i) {\r\n            current_hash -= po * s[l]; \r\n            current_hash = current_hash * p + s[i]; \r\n            ++l; \r\n\r\n            if (memo.find(current_hash) != memo.end()) {\r\n                string pick_string = s.substr(l, len); \r\n                if (ans.size() < pick_string.size()) ans = pick_string; \r\n                return true; \r\n            }\r\n            memo.insert(current_hash); \r\n        }\r\n        return false; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindromeDP. /*FC*/class Solution {\n/*FM*/string longestPalindromeDP(string s) {\n        int n = s.length(), maxLength = 0; \n        string ans; \n        \n        bool dp[n][n]; \n        \n        for (int i = 0;  i < n;  i++) {\n            dp[i][i] = true; \n            if (1 > maxLength) {\n                maxLength = 1; \n                ans = s.substr(i, 1); \n            }\n            if (i < n - 1) {\n                \n                \n            }\n        }\n        \n        for (int diff = 2;  diff < n;  ) {\n            \n        }\n\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> canSeePersonsCount. /*FC*/class Solution {\n/*FM*/vector<int> canSeePersonsCount(vector<int>& heights) {\n        int n = heights.size(); \n        heights.push_back(1e6); \n        vector<int> ans(n, 0), right(n, 0); \n\n        stack<int> s({n}); \n        for (int i = n - 1;  i >= 0;  --i) {\n            while (heights[s.top()] < heights[i]) {\n                s.pop(); \n                ans[i]++; \n            }\n            \n            if (s.top() != n) \n            s.push(i); \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"heights\": [2], \"heights_element0\": [\"-134325474\"], \"heights_element1\": [\"-142845134\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> kClosest. /*FC*/class Solution {\n/*FM*/vector<vector<int>> kClosest(vector<vector<int>> &points, int K) {\r\n        vector<vector<int>> ret; \r\n        sort(points.begin(), points.end(), [](vector<int> &v1, vector<int> v2) {\r\n            return (pow(v1[0], 2) + pow(v1[1], 2)) < (pow(v2[0], 2) + pow(v2[1], 2)); \r\n        }); \r\n        for (int i = 0;  i < K;  ++i)\r\n            ret.push_back(points[i]); \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"points\": [2], \"points_element0\": [1], \"points_element0_element0\": [\"751\"], \"points_element1\": [1], \"points_element1_element0\": [\"622\"], \"K\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDupDigitsAtMostN. /*FC*/class Solution {\n/*FM*/int numDupDigitsAtMostN(int N) \n    {\n        \n        vector<int>num; \n        int n = N; \n        while (n>0)\n        {\n            num.push_back(n%10); \n            n=n/10; \n        }\n        reverse(num.begin(),num.end()); \n        \n        for (int k=1;  k<num.size();  )\n        {\n            \n        }\n        \n        cout<<count<<endl; \n        \n        vector<int>digits(10,0); \n        DFS(num,digits,0); \n        \n        return N-count; \n    };/*F*/int count = 0;/*C*//*M*/void DFS(vector<int>&num, vector<int>&digits, int k)\n    {\n        if (k==num.size())\n        {\n            count++; \n            return; \n        }\n        \n        for (int i=0;  i<=9;  i++)\n        {\n            if (k==0 && i==0) continue; \n            \n            if (i<num[k])\n            {\n                if (digits[i]==1) continue; \n                count+= permu(10-(k+1),num.size()-(k+1)); \n            }\n            else if (i==num[k])\n            {\n                if (digits[i]==1) continue; \n                digits[i] = 1; \n                DFS(num, digits, k+1); \n                digits[i] = 0;                 \n            }\n            \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string search. /*FC*/class Solution {\n/*FM*/string search(TrieNode* root, vector<string>& words) {\n        stack<TrieNode*> St; \n        St.push(root); \n        string result; \n        while (!St.empty()) {\n            TrieNode* node = St.top(); \n            St.pop(); \n            if (node->index != -1 || node == root) {\n                if (node != root) {\n                    \n                    \n                }\n                \n                for (int i = 0;  i < 26;  ++i) {\n                    if (node->next[i]) {\n                        \n                    }                    \n                }\n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TrieNode\", \"TrieNode()\"], \"root[0].next\": [26], \"root[1]\": [\"TrieNode\", \"TrieNode()\"], \"root[1].next\": [26], \"words\": [1], \"words_element0\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addTwonumber. /*FC*/class Solution {\n/*FM*/string addTwonumber(string a, string b){\n        \n        string res; \n        int i = a.size()-1, j = b.size() - 1, carry = 0; \n        while( i>=0 || j>=0 || carry > 0) {\n            if(i>=0) carry += a[i] - '0'; \n            if(j>=0) carry += b[j] - '0'; \n            res += to_string(carry%10); \n            carry /= 10; \n            i--;  j--; \n        }\n        reverse(res.begin(),res.end()); \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"2\"], \"b\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method pair<bool,bool> cal. /*FC*/class Solution {\n/*FM*/pair<bool,bool> cal(TreeNode* root,int &ans){\r\n        if(!root){\r\n            return {false,true}; \r\n        }\r\n        auto l = cal(root->left,ans); \r\n        auto r = cal(root->right,ans); \r\n        bool cam = false, mon = false; \r\n        if(l.first || r.first){\r\n           \r\n        }\r\n        if(l.second==false || r.second==false){\r\n            ans++; \r\n            cam = true; \r\n            mon = true; \r\n        }\r\n        return {cam,mon}; \r\n    };/*F*//*C*//*M*/pair<bool,bool> cal(TreeNode* root,int &ans){\r\n        if(!root){\r\n            return {false,true}; \r\n        }\r\n        auto l = cal(root->left,ans); \r\n        auto r = cal(root->right,ans); \r\n        bool cam = false, mon = false; \r\n        if(l.first || r.first){\r\n           mon = true; \r\n        }\r\n        if(l.second==false || r.second==false){\r\n            ans++; \r\n            cam = true; \r\n            mon = true; \r\n        }\r\n        return {cam,mon}; \r\n    } pair<bool,bool> cal(TreeNode* root,int &ans){\r\n        if(!root){\r\n            return {false,true}; \r\n        }\r\n        auto l = cal(root->left,ans); \r\n        auto r = cal(root->right,ans); \r\n        bool cam = false, mon = false; \r\n        if(l.first || r.first){\r\n           mon = true; \r\n        }\r\n        if(l.second==false || r.second==false){\r\n            ans++; \r\n            cam = true; \r\n            mon = true; \r\n        }\r\n        return {cam,mon}; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"470\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root0_right1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-493\"], \"ans\": [\"-1963732693\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLength2. /*FC*/class Solution {\n/*FM*/int findLength2(vector<int>& A, vector<int>& B) {\n        int m = A.size(); \n        int n = B.size(); \n        vector<int> dp(1 + n); \n        int maxLen = 0; \n        for (int i = 1;  i <= m;  ++i) {\n            for (int j = n;  j >= 1;  --j) {\n                if (A[i - 1] == B[j - 1]) {\n                    \n                    \n                }\n                else {\n                    dp[j] = 0; \n                }                \n            }\n        }\n        \n        return maxLen; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"1994816983\"], \"A_element1\": [\"-229842330\"], \"A_element2\": [\"1214587327\"], \"B\": [2], \"B_element0\": [\"-1105375330\"], \"B_element1\": [\"562976647\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string removeKdigits. /*FC*/class Solution {\n/*FM*/string removeKdigits(string num, int k) {\r\n        \n        string s; \r\n        for (const auto c : num) {\r\n            while (k > 0 && !s.empty() && s.back() > c) {\r\n                s.pop_back(); \r\n                --k; \r\n            }\r\n            s.push_back(c); \r\n        }\r\n\r\n        \n        s.resize(s.length() - k); \r\n\r\n        \n        return s.empty() || s == \"0\" ? \"0\" : s.substr(s.find_first_not_of('0')); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [\"1432219\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numOfSubarrays. /*FC*/class Solution {\n/*FM*/int numOfSubarrays(vector<int>& arr) \n    {\n        int presum = 0; \n        long odd = 0, even  = 1; \n        long ret = 0; \n        long M = 1e9+7; \n        for (int x : arr)\n        {\n            presum+=x; \n            if (presum%2==0)\n                ret = (ret+odd)%M; \n            else\n                ret = (ret+even)%M; \n            if (presum%2==0)\n                even+=1; \n            else\n                odd+=1; \n        }\n        return ret; \n\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"1543660227\"], \"arr_element1\": [\"1715053591\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string shortestPalindrome. /*FC*/class Solution {\n/*FM*/string shortestPalindrome(string s) {\n        string r(s); \n        reverse(r.begin(), r.end()); \n        string t = s + \"#\" + r; \n        vector<int> lps(t.size()); \n        int len = 0, i = 1; \n        while (i < t.size()) {\n            if (t[i] == t[len]) {\n                lps[i++] = ++len; \n            }\n            else if (len != 0) {\n                \n            }\n            else {\n                ++i; \n            }\n        }\n        \n        return r + s.substr(len); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void f. /*FC*/class Solution {\n/*FM*/void f(vector<vector<int>>&ans,vector<int>vec,int targetSum,TreeNode*root){\r\n if(root==NULL)\r\n              vec.push_back(root->val); \r\n       targetSum-=root->val; \r\n        if(root->left==NULL&&root->right==NULL&&targetSum==0){\r\n           \r\n                \r\n           \r\n                \r\n            }        \r\n            \r\n            \r\n            \r\n            \r\n      \r\n        f(ans,vec,targetSum,root->left); \r\n       \r\n        \r\n          \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ans\": [1], \"ans_element0\": [3], \"ans_element0_element0\": [\"-1721296700\"], \"ans_element0_element1\": [\"-1905676368\"], \"ans_element0_element2\": [\"88203311\"], \"vec\": [1], \"vec_element0\": [\"-1724271414\"], \"targetSum\": [\"-408395519\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestReduction. /*FC*/ {\n/*FM*/int shortestReduction(const string& x) {\r\n  int L = x.size(); \r\n  vector<vector<pair<int, char> > > N(L, vector<pair<int, char> >(L, make_pair(INT_MAX, 'd'))); \r\n  for (int i = 0;  i < L;  ++i) {\r\n    N[i][i] = make_pair(1, x[i]); \r\n  }\r\n  for (int diff = 1;  diff < L;  ) {\r\n    \r\n  }\r\n  return N[0][L - 1].first; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"x\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countMatchingSubarrays. /*FC*/class Solution {\n/*FM*/int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {\n        int k = pattern.size()+1; \n        int res = 0; \n        vector<int>prefix = kmp(pattern); \n        for(int i = 0, j = 0;  i<nums.size()-1; ++i){\n            while(j > 0 && !satisfy(nums, pattern, i, j)){\n                \n            } \n            j += satisfy(nums, pattern, i, j); \n            if ( j == pattern.size()){\n                \n\n                \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/vector<int>kmp(vector<int>&pattern){\n        int j = 0; \n        vector<int>res(pattern.size());  \n        for(int i = 1;  i<pattern.size();  ++i){\n            while (j && pattern[i]!=pattern[j]){\n                j = res[j-1]; \n            }\n            res[i] = (j += pattern[i] == pattern[j]); \n        }\n        return res; \n    } bool satisfy(vector<int>& nums, vector<int>& pattern, int i, int j){\n        return  pattern[j] == 0 && nums[i] == nums[i+1] || \n                pattern[j] == 1 && nums[i] < nums[i+1] ||\n                pattern[j] == -1 && nums[i] > nums[i+1]; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1280851004\"], \"nums_element1\": [\"1113867004\"], \"pattern\": [2], \"pattern_element0\": [\"-567938710\"], \"pattern_element1\": [\"1344176183\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string modifyString. /*FC*/class Solution {\n/*FM*/string modifyString(string s) {\r\n        for (int i = 0;  i < s.length();  ++i) {\r\n            if (s[i] != '?') {\r\n                continue; \r\n            }\r\n            for (s[i] = 'a';  s[i] <= 'c';  ) {\r\n                if ((i == 0 || s[i - 1] != s[i]) && (i == s.size() - 1 || s[i + 1] != s[i])) {\r\n                    break; \r\n                }\r\n            }\r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"ubv?w\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int leastBricks. /*FC*/class Solution {\n/*FM*/int leastBricks(vector<vector<int>>& wall) {\n        int m = wall.size(); \n        unordered_map<int, int> table; \n        int maxCount = 0; \n        for (int i = 0;  i < m;  ++i) {\n            int n = wall[i].size(); \n            int sum = 0; \n            for (int j = 0;  j < n - 1;  ++j) {\n                sum += wall[i][j]; \n                maxCount = max(maxCount, ++table[sum]); \n            }\n        }\n        \n        return m - maxCount; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"wall\": [2], \"wall_element0\": [2], \"wall_element0_element0\": [\"-1372983927\"], \"wall_element0_element1\": [\"-394483085\"], \"wall_element1\": [1], \"wall_element1_element0\": [\"747399012\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> preorder. /*FC*/class Solution {\n/*FM*/vector<int> preorder(Node* root) {\n        vector<int> result; \n        if (root == nullptr) {\n            \n        }\n        stack<Node*> St; \n        St.push(root); \n        while (!St.empty()) {\n            Node* node = St.top(); \n            St.pop(); \n            result.push_back(node->val); \n            int n = node->children.size(); \n            for (int i = n - 1;  i >= 0;  --i) {\n                St.push(node->children[i]); \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"Node\", \"Node(int,vector<Node*>)\"], \"root0__val\": [\"787960400\"], \"root0__children\": [1], \"root0__children_element0\": [1], \"root0__children_element0[0]\": [\"Node\", \"Node()\"], \"root[1]\": [\"Node\", \"Node(int,vector<Node*>)\"], \"root1__val\": [\"716782888\"], \"root1__children\": [1]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> postorderTraversal. /*FC*/class Solution {\n/*FM*/vector<int> postorderTraversal(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        vector<int> ret; \r\n        stack<TreeNode *> s; \r\n        s.push(root); \r\n        while (!s.empty()) {\r\n            TreeNode *curr = s.top(); \r\n            s.pop(); \r\n            ret.push_back(curr->val); \r\n            if (curr->left)\r\n                \r\n            if (curr->right)\r\n                \r\n        }\r\n        std::reverse(ret.begin(), ret.end()); \r\n        return ret; \r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(nullptr), right(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-879998854\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long maxSubArrSum. /*FC*/class Solution {\n/*FM*/long maxSubArrSum(vector<int>arr) \n    { \n        long max_so_far = 0;  \n        long max_ending_here = 0;  \n  \n        for (int i = 0;  i < arr.size();  i++) \n        { \n            max_ending_here = max_ending_here + arr[i];  \n            if (max_ending_here < 0) \n                max_ending_here = 0;  \n            if (max_so_far < max_ending_here) \n                max_so_far = max_ending_here; \n        } \n        return max_so_far;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"-371224046\"], \"arr_element1\": [\"643186963\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int splitArray. /*FC*/class Solution {\n/*FM*/int splitArray(vector<int>& nums, int m) {\r\n        int64_t left = *max_element(cbegin(nums), cend(nums)); \r\n        int64_t right = accumulate(cbegin(nums), cend(nums), 0LL); \r\n        while (left <= right) {\r\n            const auto mid = left + (right - left) / 2; \r\n            if (check(nums, m, mid)) {\r\n                right = mid - 1; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n        return left; \r\n    };/*F*//*C*//*M*/bool check(vector<int>& nums, int m, int64_t total) {\r\n        int cnt = 1; \r\n        int64_t curr_sum = 0; \r\n        for (const auto& num : nums) {\r\n            curr_sum += num; \r\n            if (curr_sum > total) {\r\n                curr_sum = num; \r\n                ++cnt; \r\n            }\r\n        }\r\n        return cnt <= m; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [5], \"nums_element0\": [\"7\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"5\"], \"nums_element3\": [\"10\"], \"nums_element4\": [\"8\"], \"m\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countNumbersWithUniqueDigits. /*FC*/class Solution {\n/*FM*/int countNumbersWithUniqueDigits(int n) {\r\n\t\tstd::vector<int> unique; \r\n\t\tunique.push_back(1); \r\n\t\tint sum = 1; \r\n\t\tfor (int i = 1;  i <= n;  ++i) {\r\n\t\t\tint uni = 9; \r\n\t\t\tfor (int j = 1;  j < i;  ++j)\r\n\t\t\t\tuni *= (10 - j); \r\n\t\t\tsum += uni; \r\n\t\t\tunique.push_back(sum); \r\n\t\t}\r\n\t\treturn unique[n]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int closestMeetingNode. /*FC*/class Solution {\n/*FM*/int closestMeetingNode(vector<int>& e, int node1, int node2) {\n        int res = -1, min_dist = INT_MAX; \n        vector<int> m1(e.size(), -1), m2(e.size(), -1); \n        for (int i = node1, dist = 0;  i != -1 && m1[i] == -1;  )\n            \n        for (int i = node2, dist = 0;  i != -1 && m2[i] == -1;  ) {\n            \n            \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"e\": [1], \"e_element0\": [\"1219172910\"], \"node1\": [\"1\"], \"node2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumKeypresses. /*FC*/class Solution2 {\n/*FM*/int minimumKeypresses(string s) {\n        vector<int> freq (26, 0); \n        for (char c: s) {\n            freq[c - 'a']++; \n        }\n        \n        sort(freq.begin(), freq.end(), greater<>()); \n        \n        int ans = 0; \n        int count = 0; \n        for (int i = 0;  i < 26;  i++) {\n            \n            \n            \n            \n            if (i%9 == 0)\n                count++; \n            ans += count * freq[i]; \n        }\n        \n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isInterleave. /*FC*/ {\n/*FM*/bool isInterleave(string s1, string s2, string s3){\r\n\t\r\n    int n1 = s1.size(); \r\n           int n2 = s2.size(); \r\n           vector<vector<bool> > A(n1+1,vector<bool>(n2+1,false)); \r\n           if (n1+n2!=s3.size()){return false; }\r\n           if (s1.empty()&&s2.empty()&&s3.empty()){}\r\n          \r\n               \r\n           \r\n           \r\n                  \r\n           \r\n           \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s1\": [\"1\"], \"s2\": [\"1\"], \"s3\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxNumOfMarkedIndices. /*FC*/class Solution {\n/*FM*/int maxNumOfMarkedIndices(vector<int>& nums) \n    {\n        sort(nums.begin(), nums.end()); \n        int n = nums.size(); \n        \n        int i = 0, j = n/2; \n        int count = 0; \n        for (int i=0;  i<n/2;  i++)\n        {\n            while (j<n && nums[i]*2>nums[j])\n                \n            if (j<n)\n            {\n                count+=2; \n                j++; \n            }                \n        }\n        return count; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"682615463\"], \"nums_element1\": [\"-919542613\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool find132pattern. /*FC*/class Solution {\n/*FM*/bool find132pattern(vector<int>& nums) {\r\n        int ak = numeric_limits<int>::min(); \r\n        stack<int> st; \r\n        for (int i = nums.size() - 1;  i >= 0;  --i) {\r\n            if (nums[i] < ak) {\r\n                \r\n            } else {\r\n                while (!st.empty() && nums[i] > st.top()) {\r\n                     \r\n                }\r\n            }\r\n            st.emplace(nums[i]); \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-519\"], \"nums_element1\": [\"862\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<TreeNode*> splitBST. /*FC*/class Solution {\n/*FM*/vector<TreeNode*> splitBST(TreeNode* root, int V) {\n        if (root == nullptr) return {nullptr, nullptr}; \n        vector<TreeNode*> result; \n        if (root->val <= V) {\n            result = splitBST(root->right, V); \n            root->right = result[0]; \n            result[0] = root;             \n        }\n        else {\n            result = splitBST(root->left, V); \n            root->left = result[1]; \n            result[1] = root; \n        }\n        return result; \n    };/*F*//*C*//*M*/vector<TreeNode*> splitBST(TreeNode* root, int V) {\n        if (root == nullptr) return {nullptr, nullptr}; \n        vector<TreeNode*> result; \n        if (root->val <= V) {\n            result = splitBST(root->right, V); \n            root->right = result[0]; \n            result[0] = root;             \n        }\n        else {\n            result = splitBST(root->left, V); \n            root->left = result[1]; \n            result[1] = root; \n        }\n        return result; \n    } vector<TreeNode*> splitBST(TreeNode* root, int V) {\n        if (root == nullptr) return {nullptr, nullptr}; \n        vector<TreeNode*> result; \n        if (root->val <= V) {\n            result = splitBST(root->right, V); \n            root->right = result[0]; \n            result[0] = root;             \n        }\n        else {\n            result = splitBST(root->left, V); \n            root->left = result[1]; \n            result[1] = root; \n        }\n        return result; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"927709622\"], \"root[0].val\": [\"1446882077\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-116307023\"], \"root[0].right[0].val\": [\"1806979790\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"-668880263\"], \"root[0].right[1].val\": [\"-1109667249\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"893323561\"], \"root[1].val\": [\"-1054174764\"], \"V\": [\"1570113970\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > generate. /*FC*/class Solution {\n/*FM*/vector<vector<int> > generate(int numRows) {\r\n    vector<vector<int> > ret; \r\n    for (int i = 0;  i < numRows;  i ++)\r\n    {\r\n      ret.push_back(vector<int>(i + 1, 1)); \r\n      for (int j = 1;  j < i;  j ++)\r\n      {\r\n\tret[i][j] = ret[i - 1][j - 1] + ret[i - 1][j]; \r\n      }\r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numRows\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void stripSpaces. /*FC*/class Solution {\n/*FM*/void stripSpaces(string &s)\r\n  {\r\n    \n    while(s.size() > 0 && s[0] == ' ')\r\n    {\r\n      \r\n    }\r\n    s += ' '; \r\n    \n    for (int i = 0;  i < s.size();  i ++)\r\n    {\r\n      while (s[i] == ' ' && s[i + 1] == ' ')\r\n      {\r\n\t\r\n      }\r\n    }\r\n    \n    s.erase(s.size() - 1, 1); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkLeft. /*FC*/class Solution {\n/*FM*/bool checkLeft(string s, string locked)\n    {\n        int unmatched = 0; \n        int count = 0; \n        \n        for (int i = s.size()-1;  i>=0;  )\n        {\n            if (s[i]==')')\n                \n            else\n                unmatched--; \n\n            if (locked[i]=='0' && s[i]=='(')            \n                \n            \n            if (unmatched < 0)\n            {\n                if (count==0) return false; \n                \n                \n            }\n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"], \"locked\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstringMap. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstringMap(string s) {\n        int n = s.length(); \n        int i = 0, j = 0, ans = 0; \n        map<char, int> chars2Index; \n        while (i < n && j < n) {\n            if (chars2Index.count(s[j]) && chars2Index[s[j]] >= i) {\n                \n                \n            } else {\n                chars2Index[s[j++]] = j; \n                ans = max(ans, j - i); \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* BuildBST. /*FC*/class Solution {\n/*FM*/TreeNode* BuildBST(ListNode*& list, int start, int end)\r\n\t{\r\n\t\tif (start > end) return NULL; \r\n\t\tint mid = (start + end) / 2; \r\n\t\tTreeNode *leftChild = BuildBST(list, start, mid - 1); \r\n\t\tTreeNode *parent = new TreeNode(list->val); \r\n\t\tparent->left = leftChild; \r\n\t\tlist = list->next; \r\n\t\tparent->right = BuildBST(list, mid + 1, end); \r\n\t\treturn parent; \r\n\t};/*F*//*C*//*M*/TreeNode* BuildBST(ListNode*& list, int start, int end)\r\n\t{\r\n\t\tif (start > end) return NULL; \r\n\t\tint mid = (start + end) / 2; \r\n\t\tTreeNode *leftChild = BuildBST(list, start, mid - 1); \r\n\t\tTreeNode *parent = new TreeNode(list->val); \r\n\t\tparent->left = leftChild; \r\n\t\tlist = list->next; \r\n\t\tparent->right = BuildBST(list, mid + 1, end); \r\n\t\treturn parent; \r\n\t} TreeNode* BuildBST(ListNode*& list, int start, int end)\r\n\t{\r\n\t\tif (start > end) return NULL; \r\n\t\tint mid = (start + end) / 2; \r\n\t\tTreeNode *leftChild = BuildBST(list, start, mid - 1); \r\n\t\tTreeNode *parent = new TreeNode(list->val); \r\n\t\tparent->left = leftChild; \r\n\t\tlist = list->next; \r\n\t\tparent->right = BuildBST(list, mid + 1, end); \r\n\t\treturn parent; \r\n\t} TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"list\": [2], \"list[0]\": [\"ListNode\", \"ListNode(int)\"], \"list0_x\": [\"720394690\"], \"list[0].val\": [\"1642740660\"], \"list[1]\": [\"ListNode\", \"ListNode(int)\"], \"list1_x\": [\"1083038176\"], \"list[1].val\": [\"704253561\"], \"list[1].next\": [3], \"list[1].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"list1_next0_x\": [\"-359797065\"], \"list[1].next[0].val\": [\"-610116129\"], \"list[1].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"list1_next1_x\": [\"-1000881388\"], \"list[1].next[1].val\": [\"-2054534775\"], \"list[1].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"list1_next2_x\": [\"1166772642\"], \"list[1].next[2].val\": [\"1271068258\"], \"start\": [\"931127190\"], \"end\": [\"972831173\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* oddEvenList. /*FC*/class Solution {\n/*FM*/ListNode* oddEvenList(ListNode* head) {\r\n    if (head == NULL)\r\n    {\r\n      \r\n    }\r\n\r\n    ListNode *odd = head; \r\n    ListNode *even = head -> next; \r\n    ListNode *evenHead = even; \r\n\r\n    while (even != NULL && even -> next != NULL)\r\n    {\r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n    }\r\n\r\n    odd -> next = evenHead; \r\n    \r\n    return head; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1197023004\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-1464042340\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int orderOfLargestPlusSign. /*FC*/class Solution {\n/*FM*/int orderOfLargestPlusSign(int N, vector<vector<int>> &mines) {\r\n        vector<vector<int>> dp(N, vector<int>(N, N)); \r\n        for(int i = 0 ;  i < mines.size();  )\r\n            \r\n        for (int i = 0;  i < N;  ) {\r\n            \r\n            \r\n        }\r\n        int maxSign = 0; \r\n        for (int i = 0;  i < N;  )\r\n            \r\n        return maxSign; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool divisorGame. /*FC*/class Solution {\n/*FM*/bool divisorGame(int N) \n    {\n        vector<int>dp(N+1,0); \n        \n        dp[1] = 0; \n        \n        for (int i=1;  i<=N;  i++)\n        {\n            for (int j=1;  j*2<=i;  j++)\n            {\n                if (i%j==0 && dp[i-j]==0)\n                {\n                    dp[i] = 1; \n                    break; \n                }\n            }\n        }\n        return dp[N]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkRight. /*FC*/class Solution {\n/*FM*/bool checkRight(string s, string locked)\n    {\n        int unmatched = 0; \n        int count = 0; \n        \n        for (int i = 0;  i<s.size();  )\n        {\n            if (s[i]=='(')\n                \n            else\n                unmatched--; \n\n            if (locked[i]=='0' && s[i]==')')            \n                \n            \n            if (unmatched < 0)\n            {\n                if (count==0) return false; \n                \n                \n            }\n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"], \"locked\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverse. /*FC*/ {\n/*FM*/ListNode* reverse(ListNode* start, ListNode* end){\r\n\tListNode* dnode = new ListNode(0); \r\n\tdnode->next = start; \r\n\tstart = start->next; \r\n\tdnode->next->next = end; \r\n\t\r\n\twhile ( start != end ){\r\n\t\tListNode *tmp = start; \r\n\t\tstart = start->next; \r\n\t\ttmp->next = dnode->next; \r\n\t\tdnode->next = tmp; \r\n\t}\r\n\treturn dnode->next; \r\n};/*F*//*C*//*M*/ListNode(int x): val(x), next(NULL) {};\n}",
        "target": "{\"start\": [3], \"start[0]\": [\"ListNode\", \"ListNode(int)\"], \"start0_x\": [\"-828279094\"], \"start[0].next\": [1], \"start[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"start0_next0_x\": [\"1033379974\"], \"start[1]\": [\"ListNode\", \"ListNode(int)\"], \"start1_x\": [\"-521879754\"], \"start[2]\": [\"ListNode\", \"ListNode(int)\"], \"start2_x\": [\"-1838375397\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxWidthOfVerticalArea. /*FC*/class Solution {\n/*FM*/int maxWidthOfVerticalArea(vector<vector<int>>& points) {\r\n        set<int> sorted_x; \r\n        for (const auto& point : points) {\r\n            sorted_x.emplace(point[0]); \r\n        }\r\n        int result = 0, prev = -1; \r\n        for (const auto x : sorted_x) {\r\n            if (prev != -1) {\r\n                result = max(result, x - prev); \r\n            }\r\n            prev = x; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"points\": [6], \"points_element0\": [2], \"points_element0_element0\": [\"3\"], \"points_element0_element1\": [\"1\"], \"points_element1\": [2], \"points_element1_element0\": [\"9\"], \"points_element1_element1\": [\"0\"], \"points_element2\": [2], \"points_element2_element0\": [\"1\"], \"points_element2_element1\": [\"0\"], \"points_element3\": [2], \"points_element3_element0\": [\"1\"], \"points_element3_element1\": [\"4\"], \"points_element4\": [2], \"points_element4_element0\": [\"5\"], \"points_element4_element1\": [\"3\"], \"points_element5\": [2], \"points_element5_element0\": [\"8\"], \"points_element5_element1\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestRangeII. /*FC*/class Solution {\n/*FM*/int smallestRangeII(vector<int>& A, int K) \n    {\n        sort(A.begin(), A.end()); \n        int diff = A.back()-A[0]; \n        for (int i=0;  i<A.size()-1;  i++)\n        {\n            int MAX = max(A[i]+K, A.back()-K); \n            int MIN = min(A[0]+K, A[i+1]-K); \n            diff = min(diff, MAX-MIN); \n        }\n        return diff; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"125937283\"], \"A_element1\": [\"1987775402\"], \"K\": [\"-1596420270\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> lexicalOrder. /*FC*/class Solution {\n/*FM*/vector<int> lexicalOrder(int n) \n    {\n        vector<int>rets = {1}; \n        int i=1; \n        \n        while (rets.size()<n)\n        {\n            if (i*10<=n)\n            {\n                \n            }\n            else \n            {\n                while (i+1>n || (i%10==9))                \n                                        \n                i+=1; \n            }         \n            \n            rets.push_back(i); \n         }\n        \n        return rets; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> anagramMappings. /*FC*/class Solution {\n/*FM*/vector<int> anagramMappings(vector<int>& A, vector<int>& B) {\n        int n = B.size(); \n        unordered_map<int, int> table; \n        for (int i = 0;  i < n;  ++i) {\n            table[B[i]] = i; \n        }\n        \n        vector<int> result(n); \n        for (int i = 0;  i < n;  ++i) {\n            result[i] = table[A[i]]; \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-1119303035\"], \"A_element1\": [\"-858994492\"], \"B\": [2], \"B_element0\": [\"1248314797\"], \"B_element1\": [\"-1921239014\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string baseNeg2. /*FC*/class Solution {\n/*FM*/string baseNeg2(int N) \n    {\n        string ret; \n        while (N!=-0)\n        {\n            int r = N%(-2); \n            int d = (N-r)/(-2); \n            \n            if (r<0)\n            {\n                d += 1; \n                r += 2; \n            }\n            \n            ret.push_back('0'+r); \n            N = d; \n        }\n        reverse(ret.begin(), ret.end()); \n        if (ret==\"\") \n        else return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> getFolderNames. /*FC*/class Solution {\n/*FM*/vector<string> getFolderNames(vector<string>& names) \n    {\n        unordered_map<string,int>Map; \n        vector<string>rets; \n        \n        for (auto name: names)\n        {\n            if (Map.find(name)!=Map.end())            \n            {                \n                \n                                \n                                \n                \n                \n            }\n            else            \n            {\n                rets.push_back(name);                 \n                Map[name] = 1; \n            }\n                \n        }\n        return rets; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"names\": [2], \"names_element0\": [\"1\"], \"names_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countCornerRectangles2. /*FC*/class Solution {\n/*FM*/int countCornerRectangles2(vector<vector<int>>& grid) {\n        int m = grid.size(); \n        int n = grid[0].size(); \n        unordered_map<int, int> table; \n        int count = 0; \n        for (int i = 0;  i < m;  ++i) {\n            for (int j = 0;  j < n - 1;  ++j) {\n                if (grid[i][j] == 1) {\n                    \n                }                \n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"1257856002\"], \"grid_element0_element1\": [\"-394358843\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"286236220\"], \"grid_element1_element1\": [\"2113243611\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumberNoE. /*FC*/class Solution {\n/*FM*/bool isNumberNoE(string s) {\r\n    if (s == \"\") \r\n    if (s[0] == '+' || s[0] == '-') \r\n    int p = s.find('.'); \r\n    string dec = \"\"; \r\n    if (p != string::npos) {\r\n      \r\n      \r\n    }\r\n    bool res = s.length() || dec.length(); \r\n    if (s.length()) res &= isIntNoSign(s); \r\n    if (dec.length()) \r\n    return res; \r\n  };/*F*//*C*//*M*/bool isIntNoSign(string s) {\r\n    if (s.length() == 0) return false; \r\n    for (int i = 0;  i < s.length();  ++i) {\r\n      if (s[i] > '9' || s[i] < '0') return false; \r\n    }\r\n    return true; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pickIndex. /*FC*/class Solution {\n/*FM*/int pickIndex() {\r\n        uniform_int_distribution<int> uid(0, sum.back() - 1); \r\n        int lo = 0, hi = sum.size() - 2, n = uid(dre); \r\n        while (lo <= hi) {\r\n            int mid = (lo + hi) / 2; \r\n            if (sum[mid] <= n) {\r\n                lo = mid + 1; \r\n            } else {\r\n                hi = mid - 1; \r\n            }\r\n        }\r\n        return hi; \r\n    };/*F*/default_random_engine dre;  vector<int> sum;/*C*/Solution(vector<int>& w) : dre(time(0)), sum(w.size() + 1) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution(vector<int>&)\"], \"AKA_INSTANCE___Solution_w\": [2], \"AKA_INSTANCE___Solution_w_element0\": [\"448\"], \"AKA_INSTANCE___Solution_w_element1\": [\"584\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<double> randPoint. /*FC*/class Solution {\n/*FM*/vector<double> randPoint() \n    {\n        double r1 = (double)rand()/RAND_MAX;   \n        double x = r1*2*R-R+x0; \n        double r2 = (double)rand()/RAND_MAX;  \n        double y = r2*2*R-R+y0; \n        \n        if ((x-x0)*(x-x0)+(y-y0)*(y-y0)<=R*R)\n            return {x,y}; \n        else\n            \n    };/*F*/double R;  double x0;  double y0;/*C*/Solution(double radius, double x_center, double y_center) { };/*M*/vector<double> randPoint() \n    {\n        double r1 = (double)rand()/RAND_MAX;   \n        double x = r1*2*R-R+x0; \n        double r2 = (double)rand()/RAND_MAX;  \n        double y = r2*2*R-R+y0; \n        \n        if ((x-x0)*(x-x0)+(y-y0)*(y-y0)<=R*R)\n            return {x,y}; \n        else\n            return randPoint(); \n    } vector<double> randPoint() \n    {\n        double r1 = (double)rand()/RAND_MAX;   \n        double x = r1*2*R-R+x0; \n        double r2 = (double)rand()/RAND_MAX;  \n        double y = r2*2*R-R+y0; \n        \n        if ((x-x0)*(x-x0)+(y-y0)*(y-y0)<=R*R)\n            return {x,y}; \n        else\n            return randPoint(); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution(double,double,double)\"], \"AKA_INSTANCE___Solution_radius\": [\"0.82\"], \"AKA_INSTANCE___Solution_x_center\": [\"0.97\"], \"AKA_INSTANCE___Solution_y_center\": [\"0.59\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPoisonedDuration. /*FC*/class Solution {\n/*FM*/int findPoisonedDuration(vector<int> &timeSeries, int duration) {\r\n        int n = timeSeries.size(), total = 0; \r\n        if (n == 0)\r\n            \r\n        for (int i = 1;  i < n;  ++i) {\r\n            int gap = timeSeries[i] - timeSeries[i - 1]; \r\n            if (gap > duration)\r\n                total += duration; \r\n            else\r\n                total += gap; \r\n        }\r\n        return total + duration; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"timeSeries\": [3], \"timeSeries_element0\": [\"911943973\"], \"timeSeries_element1\": [\"-142350999\"], \"timeSeries_element2\": [\"-81722783\"], \"duration\": [\"-777264163\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int diameter. /*FC*/class Solution {\n/*FM*/int diameter(TreeNode* root, int &h){\r\n        if(!root){\r\n            h = 0; \r\n            return 0; \r\n        }\r\n        \r\n        int h1 = 0, h2 = 0; \r\n        int d1 = diameter(root->left, h1); \r\n        int d2 = diameter(root->right, h2); \r\n        \r\n        h = max(h1, h2)+1; \r\n        \r\n        return max({d1, d2, h1+h2}); \r\n    };/*F*//*C*//*M*/int diameter(TreeNode* root, int &h){\r\n        if(!root){\r\n            h = 0; \r\n            return 0; \r\n        }\r\n        \r\n        int h1 = 0, h2 = 0; \r\n        int d1 = diameter(root->left, h1); \r\n        int d2 = diameter(root->right, h2); \r\n        \r\n        h = max(h1, h2)+1; \r\n        \r\n        return max({d1, d2, h1+h2}); \r\n    } int diameter(TreeNode* root, int &h){\r\n        if(!root){\r\n            h = 0; \r\n            return 0; \r\n        }\r\n        \r\n        int h1 = 0, h2 = 0; \r\n        int d1 = diameter(root->left, h1); \r\n        int d2 = diameter(root->right, h2); \r\n        \r\n        h = max(h1, h2)+1; \r\n        \r\n        return max({d1, d2, h1+h2}); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"707\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"636\"], \"h\": [\"1426644570\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int secondHighest. /*FC*/class Solution {\n/*FM*/int secondHighest(string s) {\r\n        int first = -1, second = -1; \r\n        for (const auto& c : s) {\r\n            if (!isdigit(c)) {\r\n                continue; \r\n            }\r\n            int d = c - '0'; \r\n            if (d > first) {\r\n                second = first; \r\n                first = d; \r\n            } else if (first > d && d > second) {\r\n                \r\n            }\r\n        }\r\n        return second; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"dfa12321afd\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findFrequentTreeSum. /*FC*/class Solution {\n/*FM*/vector<int> findFrequentTreeSum(TreeNode *root) {\r\n        CountSum(root); \r\n        vector<int> treeSum; \r\n        int time = 0; \r\n        for (auto sum : sums) {\r\n            if (time < sum.second) {\r\n                time = sum.second; \r\n                treeSum.clear(); \r\n                treeSum.push_back(sum.first); \r\n            } else if (time == sum.second)\r\n                \r\n        }\r\n        return treeSum; \r\n    };/*F*/unordered_map<int, int> sums;/*C*//*M*/int CountSum(TreeNode *node) {\r\n        if (!node)\r\n            return 0; \r\n        int &&leftSum = CountSum(node->left); \r\n        int &&rightSum = CountSum(node->right); \r\n        int &&currentSum = leftSum + rightSum + node->val; \r\n        ++sums[currentSum]; \r\n        return currentSum; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1386492332\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1424293414\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestPalindromeSubseq. /*FC*/class Solution {\n/*FM*/int longestPalindromeSubseq(string s) {\n        int n = s.size(); \n        if (n == 0) {\n            \n        }\n        \n        vector<vector<int>> dp(n, vector<int>(n)); \n        for (int i = 0;  i < n;  ++i) {\n            dp[i][i] = 1; \n        }\n        for (int l = 2;  l <= n;  ) {\n            \n        }\n        \n        return dp[0][n - 1]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> constructArray2. /*FC*/class Solution {\n/*FM*/vector<int> constructArray2(int n, int k) {\n        vector<int> result(n); \n        int i = 0; \n        while (i < n - k) {\n            result[i] = n - i; \n            ++i; \n        }\n        \n        int start = 1, end = k; \n        bool flag = true; \n        while (i < n) {\n            result[i++] = flag ? start++ : end--; \n            flag = !flag; \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"], \"k\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool possible. /*FC*/class Solution {\n/*FM*/bool possible(vector<int>& nums, vector<int>& changeIndices, int bound){\n        unordered_map<int, int>last_index; \n        for(int i = 0;  i < changeIndices.size() && i < bound;  ++i){\n            last_index[changeIndices[i]] = i; \n        }\n        cout<<\" last_index.size() \"<<last_index.size()<<endl; \n        if (last_index.size() != nums.size()) return false;  \n         \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1593833790\"], \"nums_element1\": [\"-2120853231\"], \"changeIndices\": [1], \"changeIndices_element0\": [\"-2099368868\"], \"bound\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> subsets. /*FC*/class Solution {\n/*FM*/vector<vector<int>> subsets(vector<int>& nums) {\n        int len = nums.size(); \n        int maxn = pow(2, len); \n        vector<vector<int>> result(maxn); \n        for (int i = 0;  i < len;  i++) {\n            for (int j = 0;  j < maxn;  j++) {\n                if ((j >> i) & 1)\n                    result[j].push_back(nums[i]); \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1117733033\"], \"nums_element1\": [\"1808087088\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int kIncreasing. /*FC*/class Solution {\n/*FM*/int kIncreasing(vector<int>& arr, int k) \n    {\n        int ret = 0; \n        int n = arr.size(); \n        \n        for (int t=0;  t<k;  t++)\n        {\n            vector<int>nums; \n            for (int i=t;  i<n;  i+=k)\n                nums.push_back(arr[i]); \n            ret += nums.size() - lengthOfLIS(nums);             \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/int lengthOfLIS(vector<int>& nums) \n    {\n        int n = nums.size();               \n        vector<int>q(n, INT_MAX); \n        for (int i=0;  i<n;  i++)\n        {\n            auto iter = upper_bound(q.begin(),q.end(),nums[i]); \n            *iter = nums[i]; \n        }\n        for (int i = n - 1;  i >= 0;  i--)\n        {\n            if (q[i] != INT_MAX)\n                return i + 1;   \n        }\n        return 0;     \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [3], \"arr_element0\": [\"-1515392462\"], \"arr_element1\": [\"567835944\"], \"arr_element2\": [\"-717177749\"], \"k\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void changeRating. /*FC*/class FoodRatings {\n/*FM*/void changeRating(string food, int newRating) {\n        string category = categories_[food].first;  \n        int oldrating =  categories_[food].second;  \n        ratings_[category][oldrating].erase(food); \n        if (ratings_[category][oldrating].empty()) {\n            ratings_[category].erase(oldrating); \n        }\n        ratings_[category][newRating].insert(food); \n        categories_[food] = {category, newRating}; \n    };/*F*/unordered_map<string,map<int, set<string>>> ratings_;  unordered_map<string,pair<string,int>> categories_;/*C*/FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___FoodRatings\": [\"FoodRatings\", \"FoodRatings(vector<string>&,vector<string>&,vector<int>&)\"], \"AKA_INSTANCE___FoodRatings_foods\": [1], \"AKA_INSTANCE___FoodRatings_foods_element0\": [\"1\"], \"AKA_INSTANCE___FoodRatings_cuisines\": [2], \"AKA_INSTANCE___FoodRatings_cuisines_element0\": [\"1\"], \"AKA_INSTANCE___FoodRatings_cuisines_element1\": [\"1\"], \"AKA_INSTANCE___FoodRatings_ratings\": [2], \"AKA_INSTANCE___FoodRatings_ratings_element0\": [\"-588561301\"], \"AKA_INSTANCE___FoodRatings_ratings_element1\": [\"402980431\"], \"food\": [\"1\"], \"newRating\": [\"1183815942\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxBoxesInWarehouse. /*FC*/class Solution {\n/*FM*/int maxBoxesInWarehouse(vector<int>& boxes, vector<int>& warehouse) \n    {\n        sort(boxes.begin(), boxes.end()); \n        reverse(boxes.begin(), boxes.end()); \n        \n        int count = 0; \n        int j = 0; \n        for (int box: boxes)\n        {\n            if (j==warehouse.size()) \n            if (box <= warehouse[j])\n            {\n                j++; \n                count++; \n            }                \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"boxes\": [3], \"boxes_element0\": [\"-545367873\"], \"boxes_element1\": [\"463635323\"], \"boxes_element2\": [\"-1614878469\"], \"warehouse\": [3], \"warehouse_element0\": [\"435840188\"], \"warehouse_element1\": [\"-1355363728\"], \"warehouse_element2\": [\"43465750\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *increasingBST. /*FC*/class Solution {\n/*FM*/TreeNode *increasingBST(TreeNode *root) {\r\n        if (!root)\r\n            return nullptr; \r\n        root->right = increasingBST(root->right); \r\n        if (root->left) {\r\n            TreeNode *temp = increasingBST(root->left), *left = temp; \r\n            while (left->right)\r\n                \r\n            left->right = root; \r\n            root->left = nullptr; \r\n            return temp; \r\n        }\r\n        return root; \r\n    };/*F*//*C*//*M*/TreeNode *increasingBST(TreeNode *root) {\r\n        if (!root)\r\n            return nullptr; \r\n        root->right = increasingBST(root->right); \r\n        if (root->left) {\r\n            TreeNode *temp = increasingBST(root->left), *left = temp; \r\n            while (left->right)\r\n                left = left->right; \r\n            left->right = root; \r\n            root->left = nullptr; \r\n            return temp; \r\n        }\r\n        return root; \r\n    } TreeNode *increasingBST(TreeNode *root) {\r\n        if (!root)\r\n            return nullptr; \r\n        root->right = increasingBST(root->right); \r\n        if (root->left) {\r\n            TreeNode *temp = increasingBST(root->left), *left = temp; \r\n            while (left->right)\r\n                left = left->right; \r\n            left->right = root; \r\n            root->left = nullptr; \r\n            return temp; \r\n        }\r\n        return root; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-172\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1000\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode()\"], \"root[1]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> flip. /*FC*/class Solution {\n/*FM*/vector<int> flip() \n    {\n        int k = rand()%(m*n-count); \n        int ret; \n        \n        count++; \n        \n        if (Map.find(k)!=Map.end())\n            \n        else\n            ret = k; \n        \n        if (Map.find(m*n-count)!=Map.end())\n            \n        else\n            Map[k] = m*n-count; \n        \n        return {ret/n,ret%n}; \n        \n    };/*F*/int m;  int n;  int count;  unordered_map<int,int> Map;/*C*/Solution(int n_rows, int n_cols) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution(int,int)\"], \"AKA_INSTANCE___Solution_n_rows\": [\"929982064\"], \"AKA_INSTANCE___Solution_n_cols\": [\"-602964880\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<pair<int, int>> reconstructQueue. /*FC*/class Solution {\n/*FM*/vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) \n    {\n        sort(people.begin(),people.end(),cmp); \n        vector<pair<int, int>>results; \n        for (int i=0;  i<people.size();  i++)\n        {\n            if (results.size()==0)\n            {\n                results.push_back(people[i]); \n                continue; \n            }\n            \n            \n            \n        }\n        return results; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"people\": [1], \"people_element0.first\": [\"-1374351405\"], \"people_element0.second\": [\"-1861302278\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countGoodTriplets. /*FC*/class Solution {\n/*FM*/int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\r\n        int count=0; \r\n        int n = arr.size(); \r\n        for(int i=0; i<n; i++){\r\n            for(int j=i+1; j<n; j++){\r\n                for(int k=j+1; k<n; ){\r\n                    \r\n                }\r\n            }\r\n        }\r\n        \r\n        return count; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"-503\"], \"arr_element1\": [\"-178\"], \"a\": [\"567625714\"], \"b\": [\"-1046450108\"], \"c\": [\"-1895641721\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string manacher. /*FC*/class Solution4 {\n/*FM*/string manacher(const string& s){\n        int mx = 0, maxlen = 0; \n        int id, maxid; \n        vector<int>p(snew.size()); \n        \n        for(int i = 1;  i<snew.size()-1; ){\n            \n            \n            if(mx < i + p[i]){\n                \n                \n            }\n            \n            \n        }\n        \n        \n        return s.substr((maxid-maxlen)/2, maxlen-1); \n    };/*F*/string snew;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"AKA_INSTANCE___Solution4->snew\": [\"2\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method array<int, 3> dfs. /*FC*/class Solution3 {\n/*FM*/array<int, 3> dfs(TreeNode* n) {\n        if (n == nullptr)\n            return {0, 0, 0}; \n        auto p1 = dfs(n->left), p2 = dfs(n->right); \n        int sum = p1[0] + p2[0] + n->val, count = 1 + p1[1] + p2[1]; \n        return {sum, count, p1[2] + p2[2] + (n->val == sum / count)}; \n    };/*F*//*C*//*M*/array<int, 3> dfs(TreeNode* n) {\n        if (n == nullptr)\n            return {0, 0, 0}; \n        auto p1 = dfs(n->left), p2 = dfs(n->right); \n        int sum = p1[0] + p2[0] + n->val, count = 1 + p1[1] + p2[1]; \n        return {sum, count, p1[2] + p2[2] + (n->val == sum / count)}; \n    } array<int, 3> dfs(TreeNode* n) {\n        if (n == nullptr)\n            return {0, 0, 0}; \n        auto p1 = dfs(n->left), p2 = dfs(n->right); \n        int sum = p1[0] + p2[0] + n->val, count = 1 + p1[1] + p2[1]; \n        return {sum, count, p1[2] + p2[2] + (n->val == sum / count)}; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"n\": [1], \"n[0]\": [\"TreeNode\", \"TreeNode()\"], \"AKA_EXPECTED_OUTPUT\": [3]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int count. /*FC*/class DetectSquares {\n/*FM*/int count(vector<int> point) {\n        int ans = 0; \n        for (auto &p : all) {\n                if (abs(point[0] - p[0]) != abs(point[1] - p[1])) \n            if (cnt.count(p[0]) && cnt[p[0]].count(point[1]) && cnt.count(point[0]) && cnt[point[0]].count(p[1])) {\n                \n            }\n        }\n        return ans; \n    };/*F*/vector<vector<int>> all;  unordered_map<int, unordered_map<int, int>> cnt;/*C*/DetectSquares() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___DetectSquares\": [\"DetectSquares\", \"DetectSquares()\"], \"point\": [2], \"point_element0\": [\"296676427\"], \"point_element1\": [\"-2112859156\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool makesquare. /*FC*/class Solution {\n/*FM*/bool makesquare(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        int len = 0, s = 4; \r\n        sort(nums.begin(), nums.end(), greater<int>());  \n        for (int i = 0;  i < n;  ++i)\r\n            len += nums[i]; \r\n        if (n < 4 || len % 4 != 0 || nums[0] > len)\r\n            return false; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"2019113824\"], \"nums_element1\": [\"-1213805319\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minStickers. /*FC*/class Solution {\n/*FM*/int minStickers(vector<string>& stickers, string target) {\n        int n = stickers.size(); \n        vector<vector<int>> table(n, vector<int>(26)); \n        for (int i = 0;  i < n;  ++i) {\n            for (char c : stickers[i]) {\n                ++table[i][c - 'a']; \n            }\n        }\n        \n        lens[\"\"] = 0; \n        return dfs(target, table); \n    };/*F*/unordered_map<string, int> lens;/*C*//*M*/int dfs(string target, vector<vector<int>>& table) {\n        if (lens.find(target) != lens.end()) {\n            return lens[target]; \n        }\n        \n        vector<int> count(26); \n        for (char c : target) {\n            ++count[c - 'a']; \n        }\n        \n        int minLen = -1; \n        for (int i = 0;  i < table.size();  ++i) {\n            if (table[i][target[0] - 'a'] != 0) {\n                string next; \n                for (int j = 0;  j < 26;  ++j) {\n                    if (count[j] - table[i][j] > 0) {\n                        next += string(count[j] - table[i][j], 'a' + j); \n                    }\n                }\n                int nextLen = dfs(next, table); \n                if (nextLen != -1 && (minLen == -1 || nextLen + 1 < minLen)) {\n                    minLen = nextLen + 1; \n                }\n            }\n        }\n        \n        return lens[target] = minLen; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"stickers\": [1], \"stickers_element0\": [\"2\"], \"target\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countNodes. /*FC*/class Solution {\n/*FM*/int countNodes(TreeNode* root) {\n        int h = height(root); \n        int count = 0; \n        while (root) {\n            int rh = height(root->right); \n            if (rh == h - 1) {\n                count += (1 << h); \n                root = root->right; \n            }\n            else {\n                count += (1 << (h - 1)); \n                root = root->left; \n            }\n            --h; \n        }\n        \n        return count;         \n    };/*F*//*C*//*M*/int height(TreeNode* root) {\n        int h = -1; \n        while (root) {\n            ++h; \n            root = root->left; \n        }\n        return h; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1260534978\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-910037361\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestDistance. /*FC*/class Solution {\n/*FM*/int shortestDistance(vector<string>& words, string word1, string word2) {\n        int p1 = -1, p2 = -1; \n        int minDist = words.size(); \n        for (int i = 0;  i < words.size();  ++i) {\n            if (words[i] == word1) {\n                \n                \n            }\n            else if (words[i] == word2) {\n                \n                \n            }\n        }\n        \n        return minDist; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"1\"], \"word1\": [\"1\"], \"word2\": [\"1\"]}"
    }
]