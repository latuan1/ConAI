[
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *buildTree. /*FC*/class Solution {\n/*FM*/TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\r\n        int size = inorder.size(); \r\n        if (size == 0)\r\n            \r\n        this->inorder = inorder; \r\n        this->postorder = postorder; \r\n        return FindSubtree(0, size - 1, 0, size - 1); \r\n    };/*F*/vector<int> inorder;  vector<int> postorder;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->inorder\": [2], \"AKA_INSTANCE___Solution_inorder_element0\": [\"-197002213\"], \"AKA_INSTANCE___Solution_inorder_element1\": [\"689981068\"], \"AKA_INSTANCE___Solution->postorder\": [2], \"AKA_INSTANCE___Solution_postorder_element0\": [\"-1135275852\"], \"AKA_INSTANCE___Solution_postorder_element1\": [\"-1849058503\"], \"inorder\": [3], \"inorder_element0\": [\"-2092403912\"], \"inorder_element1\": [\"656796479\"], \"inorder_element2\": [\"656039376\"], \"postorder\": [1], \"postorder_element0\": [\"-1021313183\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int fixedPoint. /*FC*/class Solution {\n/*FM*/int fixedPoint(vector<int>& A) {\r\n        for(int i = 0;  i<A.size();  ++i)\r\n            if(A[i] == i)\r\n                \r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"1596198018\"], \"A_element1\": [\"144353893\"], \"A_element2\": [\"2084473602\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> indexPairs. /*FC*/class Solution {\n/*FM*/vector<vector<int>> indexPairs(string &text, vector<string> &words) {\r\n        vector<vector<int>> res; \r\n        for (auto &word:words) {\r\n            int i = 0; \r\n            int pos = text.find(word); \r\n            while (pos != -1) {\r\n                \r\n                \r\n                \r\n            }\r\n        }\r\n        sort(res.begin(), res.end()); \r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"text\": [\"1\"], \"words\": [2], \"words_element0\": [\"1\"], \"words_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> levelOrderBottom. /*FC*/class Solution {\n/*FM*/vector<vector<int>> levelOrderBottom(TreeNode *root) {\r\n        vector<vector<int>> ret; \r\n        if (!root)\r\n            \r\n        vector<int> cur; \r\n        int len = 1; \r\n        queue<TreeNode *> que; \r\n        que.push(root); \r\n        while (!que.empty()) {\r\n            TreeNode *temp = que.front(); \r\n            que.pop(); \r\n            --len; \r\n            cur.push_back(temp->val); \r\n            if (temp->left) \r\n            if (temp->right) \r\n            if (!len) {\r\n                ret.push_back(cur); \r\n                cur.clear(); \r\n                len = que.size(); \r\n            }\r\n        }\r\n        reverse(ret.begin(), ret.end()); \r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1769339925\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1752827908\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDepth. /*FC*/class Solution {\n/*FM*/int minDepth(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        int &&dep = 1, &&size = 1; \r\n        queue<TreeNode *> node; \r\n        node.push(root); \r\n        while (!node.empty()) {\r\n            TreeNode *temp = node.front(); \r\n            node.pop(); \r\n            --size; \r\n            if (!temp->left && !temp->right)\r\n                return dep; \r\n            if (temp->left) \r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1665095787\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void flatten. /*FC*/class Solution {\n/*FM*/void flatten(TreeNode *root) {\r\n        while (root) {\r\n            TreeNode *temp = root->left; \r\n            while (temp && temp->right) {\r\n                \r\n            }\r\n            if (temp) {\r\n                temp->right = root->right; \r\n                root->right = root->left; \r\n                root->left = nullptr; \r\n            }\r\n            root = root->right; \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-2135553576\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1540893034\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-640721246\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"-843794075\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void connect. /*FC*/class Solution {\n/*FM*/void connect(TreeLinkNode *root) {\r\n        if (!root)\r\n            \r\n        TreeLinkNode *prev = nullptr, *head = root; \r\n        while (root) {\r\n            while (root) {\r\n                if (root->left) {\r\n                    if (prev)\r\n                        \r\n                    else\r\n                        head = root->left; \r\n                    prev = root->left; \r\n                }\r\n                if (root->right) {\r\n                    \r\n                    \r\n                }\r\n                root = root->next; \r\n            }\r\n            root = head; \r\n            head = nullptr; \r\n            prev = nullptr; \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_x\": [\"82473710\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_left0_x\": [\"-593135767\"], \"root[0].left[1]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[0].left[2]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_left2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void connect. /*FC*/class Solution {\n/*FM*/void connect(TreeLinkNode *root) {\r\n        if (!root)\r\n            \r\n        TreeLinkNode *prev = nullptr, *head = root; \r\n        while (root) {\r\n            while (root) {\r\n                if (root->left) {\r\n                    if (prev)\r\n                        \r\n                    else\r\n                        head = root->left; \r\n                    prev = root->left; \r\n                }\r\n                if (root->right) {\r\n                    if (prev)\r\n                        prev->next = root->right; \r\n                    else\r\n                        \r\n                    \r\n                }\r\n                \r\n            }\r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void connect. /*FC*/class Solution {\n/*FM*/void connect(TreeLinkNode *root) {\r\n        if (!root)\r\n            \r\n        TreeLinkNode *prev = nullptr, *head = root; \r\n        while (root) {\r\n            while (root) {\r\n                if (root->left) {\r\n                    \r\n                    \r\n                }\r\n                if (root->right) {\r\n                    if (prev)\r\n                        \r\n                    else\r\n                        head = root->right; \r\n                    prev = root->right; \r\n                }\r\n                root = root->next; \r\n            }\r\n            root = head; \r\n            head = nullptr; \r\n            prev = nullptr; \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_x\": [\"768333314\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_right0_x\": [\"-771798098\"], \"root[0].right[1]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_right1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> generate. /*FC*/class Solution {\n/*FM*/vector<vector<int>> generate(int numRows) {\r\n        int n = numRows; \r\n        vector<vector<int>> ret; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            vector<int> temp; \r\n            for (int j = 0;  j < i + 1;  ++j) {\r\n                if (j == 0 || j == i)\r\n                    temp.push_back(1); \r\n                else\r\n                    temp.push_back(ret[i - 1][j - 1] + ret[i - 1][j]); \r\n            }\r\n            ret.push_back(temp); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numRows\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> getRow. /*FC*/class Solution {\n/*FM*/vector<int> getRow(int rowIndex) {\r\n        int n = rowIndex; \r\n        vector<int> first; \r\n        vector<int> second; \r\n        first.push_back(1); \r\n        for (int i = 1;  i <= n;  ++i) {\r\n            for (int j = 0;  j < i + 1;  ++j) {\r\n                if (j == 0 || j == i)\r\n                    second.push_back(1); \r\n                else\r\n                    second.push_back(first[j - 1] + first[j]); \r\n            }\r\n            first = second; \r\n            second.clear(); \r\n        }\r\n        return first; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"rowIndex\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumTotal. /*FC*/class Solution {\n/*FM*/int minimumTotal(vector<vector<int>> &triangle) {\r\n        int n = triangle.size(); \r\n        vector<vector<int>> dp(n, vector<int>(n, 0)); \r\n        for (int j = 0;  j < n;  ++j)\r\n            dp[n - 1][j] = triangle[n - 1][j]; \r\n        for (int i = n - 2;  i >= 0;  --i)\r\n            for (int j = 0;  j < n;  ++j)\r\n                dp[i][j] = triangle[i][j] + min(dp[i + 1][j], dp[i + 1][j + 1]); \r\n        return dp[0][0]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"triangle\": [2], \"triangle_element0\": [3], \"triangle_element0_element0\": [\"-2016739353\"], \"triangle_element0_element1\": [\"1361657393\"], \"triangle_element0_element2\": [\"-791392737\"], \"triangle_element1\": [1], \"triangle_element1_element0\": [\"1257883652\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int>& prices) {\r\n        int profit = 0, min_val = INT_MAX; \r\n        for(int i = 0;  i < prices.size();  ++i) {\r\n            min_val = min(min_val, prices[i]); \r\n            profit = max(profit, prices[i] - min_val); \r\n        }\r\n        return profit; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [3], \"prices_element0\": [\"883967188\"], \"prices_element1\": [\"-349340514\"], \"prices_element2\": [\"-1204958932\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int> &prices) {\r\n        bool bought = false; \r\n        auto size = prices.size(); \r\n        int profit = 0, price = 0; \r\n        int i = 0; \r\n        while (i < size) {\r\n            if (!bought) {\r\n                if (prices[i] < prices[i + 1] && i + 1 < size) {\r\n                    \r\n                    \r\n                }\r\n            } else {\r\n                \r\n            }\r\n            ++i; \r\n        }\r\n        if (bought)\r\n            \r\n        return profit; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [3], \"prices_element0\": [\"-11842122\"], \"prices_element1\": [\"-235178375\"], \"prices_element2\": [\"-439252267\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int> &prices) {\r\n        bool bought = false; \r\n        auto size = prices.size(); \r\n        int profit = 0, price = 0; \r\n        int i = 0; \r\n        while (i < size) {\r\n            if (!bought) {\r\n                if (prices[i] < prices[i + 1] && i + 1 < size) {\r\n                    price = prices[i]; \r\n                    bought = true; \r\n                }\r\n            } else {\r\n                if (prices[i] > prices[i + 1] && i + 1 < size) {\r\n                    \r\n                    \r\n                    \r\n                }\r\n            }\r\n            ++i; \r\n        }\r\n        if (bought)\r\n            profit += prices[i - 1] - price; \r\n        return profit; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"-1709900598\"], \"prices_element1\": [\"636096887\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestConsecutive. /*FC*/class Solution {\n/*FM*/int longestConsecutive(vector<int> &nums) {\r\n        unordered_set<int> count(nums.begin(), nums.end()); \r\n        int val = INT_MAX, length = 0; \r\n        while (!count.empty()) {\r\n            int val1 = *count.begin() + 1, val2 = *count.begin() - 1; \r\n            count.erase(*count.begin()); \r\n            while (count.find(val1) != count.end()) {\r\n                \r\n                \r\n            }\r\n            while (count.find(val2) != count.end()) {\r\n                \r\n                \r\n            }\r\n            length = max(length, val1 - val2 - 1); \r\n        }\r\n        return length; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"498901262\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int romanToInt. /*FC*/class Solution {\n/*FM*/int romanToInt(string s) {\r\n        int sum = 0, n = s.size(), temp = 0; \r\n        unordered_map<char, int> symbol; \r\n        symbol.insert(pair<char, int>('I', 1)); \r\n        symbol.insert(pair<char, int>('V', 5)); \r\n        symbol.insert(pair<char, int>('X', 10)); \r\n        symbol.insert(pair<char, int>('L', 50)); \r\n        symbol.insert(pair<char, int>('C', 100)); \r\n        symbol.insert(pair<char, int>('D', 500)); \r\n        symbol.insert(pair<char, int>('M', 1000)); \r\n        for (int i = 0;  i < n;  ++i) {\r\n            while (i < n - 1 && symbol[s[i]] < symbol[s[i + 1]]) {\r\n                \r\n                \r\n            }\r\n            sum += symbol[s[i]] - temp; \r\n            temp = 0; \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void solve. /*FC*/class Solution {\n/*FM*/void solve(vector<vector<char>> &board) {\r\n        m = board.size(), n = m == 0 ? 0 : board[0].size(); \r\n        if (m == 0)\r\n            \r\n        for (int i = 0;  i < m;  ++i) {\r\n            if (board[i][0] == 'O')\r\n                \r\n            if (board[i][n - 1] == 'O')\r\n                \r\n        }\r\n        for (int j = 1;  j < n - 1;  ++j) {\r\n            if (board[0][j] == 'O')\r\n                \r\n            if (board[m - 1][j] == 'O')\r\n                \r\n        }\r\n        for (int i = 0;  i < m;  ++i) {\r\n            for (int j = 0;  j < n;  ++j) {\r\n                auto &c = board[i][j]; \r\n                if (c == 'O')\r\n                    \r\n                else if (c == 'Y')\r\n                    \r\n            }\r\n        }\r\n    };/*F*/vector<int> dir_x = {-1, 0, 1, 0};  vector<int> dir_y = {0, -1, 0, 1};  int m;  int n;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"board\": [3], \"board_element0\": [3], \"board_element0_element0\": [\"22\"], \"board_element0_element1\": [\"109\"], \"board_element0_element2\": [\"-67\"], \"board_element1\": [2], \"board_element1_element0\": [\"-35\"], \"board_element1_element1\": [\"-60\"], \"board_element2\": [2], \"board_element2_element0\": [\"39\"], \"board_element2_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<string>> partition. /*FC*/class Solution {\n/*FM*/vector<vector<string>> partition(string s) {\r\n        int n = s.size(); \r\n        if (n == 0)\r\n            \r\n        vector<string> temp; \r\n        BackTracking(s,n,0,temp); \r\n        return ret; \r\n    };/*F*/vector<vector<string>> ret;/*C*//*M*/void BackTracking(string s,int &n,int i,vector<string> &temp){\r\n        if(i == n) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for(int j =i ;  j < n;  ++j) {\r\n            if(isPalindrome(i,j,s)) {\r\n                temp.push_back(s.substr(i,j-i + 1)); \r\n                BackTracking(s,n,j+1,temp); \r\n                temp.pop_back(); \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void BackTracking. /*FC*/class Solution {\n/*FM*/void BackTracking(string s,int &n,int i,vector<string> &temp){\r\n        if(i == n) {\r\n            \r\n            \r\n        }\r\n        for(int j =i ;  j < n;  ) {\r\n            \r\n        }\r\n    };/*F*//*C*//*M*/void BackTracking(string s,int &n,int i,vector<string> &temp){\r\n        if(i == n) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for(int j =i ;  j < n;  ++j) {\r\n            if(isPalindrome(i,j,s)) {\r\n                temp.push_back(s.substr(i,j-i + 1)); \r\n                BackTracking(s,n,j+1,temp); \r\n                temp.pop_back(); \r\n            }\r\n        }\r\n    } void BackTracking(string s,int &n,int i,vector<string> &temp){\r\n        if(i == n) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for(int j =i ;  j < n;  ++j) {\r\n            if(isPalindrome(i,j,s)) {\r\n                temp.push_back(s.substr(i,j-i + 1)); \r\n                BackTracking(s,n,j+1,temp); \r\n                temp.pop_back(); \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"n\": [\"1\"], \"i\": [\"5\"], \"temp\": [3], \"temp_element0\": [\"1\"], \"temp_element1\": [\"2\"], \"temp_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int i, int j,string &s) {\r\n        while(i <= j &&s[i] == s[j]) {\r\n            \r\n            \r\n        }\r\n        if(i > j)\r\n            \r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"i\": [\"2\"], \"j\": [\"6\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int i, int j,string &s) {\r\n        while(i <= j &&s[i] == s[j]) {\r\n            ++i; \r\n            --j; \r\n        }\r\n        if(i > j)\r\n            return true; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"i\": [\"4\"], \"j\": [\"4\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reorderList. /*FC*/class Solution {\n/*FM*/void reorderList(ListNode *head) {\r\n        if (!head || !head->next || !head->next->next)\r\n            return; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-306153554\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head0_next2_x\": [\"0\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1486268839\"], \"head[2]\": [\"ListNode\", \"ListNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseListNode. /*FC*/class Solution {\n/*FM*/ListNode *reverseListNode(ListNode *head) {\r\n        if (!head->next)\r\n            \r\n        ListNode *prev = head->next, *temp = nullptr; \r\n        head->next = nullptr; \r\n        while (prev) {\r\n            temp = prev->next; \r\n            prev->next = head; \r\n            head = prev; \r\n            prev = temp; \r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"302740885\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode()\"], \"head[1]\": [\"ListNode\", \"ListNode()\"], \"head[2]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head2_x\": [\"14973634\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> preorderTraversal. /*FC*/class Solution {\n/*FM*/vector<int> preorderTraversal(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        vector<int> vec; \r\n        stack<TreeNode *> que; \r\n        que.push(root); \r\n        while (!que.empty()) {\r\n            TreeNode *temp = que.top(); \r\n            vec.push_back(temp->val); \r\n            que.pop(); \r\n            if (temp->right) \r\n            if (temp->left) \r\n        }\r\n        return vec; \r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(nullptr), right(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_x\": [\"1976006587\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int>> threeSum(vector<int> &nums) {\r\n        vector<vector<int>> ret; \r\n        auto size = nums.size(); \r\n        std::sort(nums.begin(), nums.end()); \r\n        for (int j = 0;  j < size;  ++j) {\r\n            int &&target = -nums[j]; \r\n            int x = j + 1, y = size - 1; \r\n            while (x < y) {\r\n                if (nums[x] + nums[y] < target)\r\n                    ++x; \r\n                else if (nums[x] + nums[y] > target)\r\n                    \r\n                else {\r\n                    \r\n                    do\r\n                        \r\n                    while (x < y && nums[x] == nums[x - 1]); \r\n                    do\r\n                        \r\n                    while (x < y && nums[y] == nums[y + 1]); \r\n                }\r\n            }\r\n            while (j + 1 < size && nums[j + 1] == nums[j])\r\n                \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1526206061\"], \"nums_element1\": [\"-205848407\"], \"nums_element2\": [\"-1492380789\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMin. /*FC*/class Solution {\n/*FM*/int findMin(vector<int> nums) {\r\n        int i = 0, j = nums.size() - 1, mid = 0; \r\n        if (j == -1)\r\n            \r\n        while (i < j - 1) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] > nums[i] && nums[mid] > nums[j])\r\n                i = mid; \r\n            else if (nums[mid] < nums[i] && nums[mid] < nums[j])\r\n                \r\n            else\r\n                \r\n        }\r\n        return min(nums[i], nums[j]); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-369222923\"], \"nums_element1\": [\"1585717659\"], \"nums_element2\": [\"-1887563311\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMin. /*FC*/class Solution {\n/*FM*/int findMin(vector<int> nums) {\r\n        int i = 0, j = nums.size() - 1, mid = 0; \r\n        if (j == -1)\r\n            \r\n        while (i < j - 1) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] > nums[i] && nums[mid] > nums[j])\r\n                \r\n            else if (nums[mid] < nums[i] && nums[mid] < nums[j])\r\n                j = mid; \r\n            else\r\n                \r\n        }\r\n        return min(nums[i], nums[j]); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1025263655\"], \"nums_element1\": [\"-82398385\"], \"nums_element2\": [\"1785887959\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void push. /*FC*/class MinStack {\n/*FM*/void push(int x) {\r\n        normalStack.push(x); \r\n        if (minStack.empty() || minStack.top() >= x)\r\n            minStack.push(x); \r\n    };/*F*/stack<int> normalStack;  stack<int> minStack;/*C*/MinStack() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MinStack\": [\"MinStack\", \"MinStack()\"], \"x\": [\"-1380718772\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void pop. /*FC*/class MinStack {\n/*FM*/void pop() {\r\n        if (normalStack.top() == minStack.top())\r\n            \r\n        \r\n    };/*F*/stack<int> normalStack;  stack<int> minStack;/*C*/MinStack() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MinStack\": [\"MinStack\", \"MinStack()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> twoSum. /*FC*/class Solution {\n/*FM*/vector<int> twoSum(vector<int> &numbers, int target) {\r\n        vector<int> ret; \r\n        int i = 0, j = numbers.size() - 1; \r\n        while (i < j) {\r\n            if (numbers[i] + numbers[j] == target)\r\n                \r\n            else if (numbers[i] + numbers[j] > target)\r\n                \r\n            else\r\n                ++i; \r\n        }\r\n        ret.push_back(i + 1); \r\n        ret.push_back(j + 1); \r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numbers\": [3], \"numbers_element0\": [\"-2073277305\"], \"numbers_element1\": [\"449489755\"], \"numbers_element2\": [\"-1814669307\"], \"target\": [\"432799517\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> twoSum. /*FC*/class Solution {\n/*FM*/vector<int> twoSum(vector<int> &numbers, int target) {\r\n        vector<int> ret; \r\n        int i = 0, j = numbers.size() - 1; \r\n        while (i < j) {\r\n            if (numbers[i] + numbers[j] == target)\r\n                \r\n            else if (numbers[i] + numbers[j] > target)\r\n                --j; \r\n            else\r\n                \r\n        }\r\n        ret.push_back(i + 1); \r\n        ret.push_back(j + 1); \r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numbers\": [3], \"numbers_element0\": [\"1686277361\"], \"numbers_element1\": [\"1937976771\"], \"numbers_element2\": [\"1510576135\"], \"target\": [\"-1451237156\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int majorityElement. /*FC*/class Solution {\n/*FM*/int majorityElement(vector<int> &nums) {\r\n        int maj = 0, max_n = 0; \r\n        unordered_map<int, int> m; \r\n        for (auto n : nums) {\r\n            if (m.find(n) == m.end())\r\n                m[n] = 0; \r\n            ++m[n]; \r\n            if (max_n < m[n]) {\r\n                max_n = m[n]; \r\n                maj = n; \r\n            }\r\n        }\r\n        return maj; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1831076690\"], \"nums_element1\": [\"845902923\"], \"nums_element2\": [\"1648479885\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> letterCombinations. /*FC*/class Solution {\n/*FM*/vector<string> letterCombinations(string digits) {\r\n        int n = digits.size(); \r\n        if(n == 0) \r\n        char a = 'a'; \r\n        for (int i = 0;  i < 8;  ++i) {\r\n            tran.push_back(vector<char>()); \r\n            for (int j = 0;  j < 3;  ++j)\r\n                tran[i].push_back(a++); \r\n            if(i == 5)\r\n                tran[i].push_back(a++); \r\n        }\r\n        tran[7].push_back(a); \r\n        string temp; \r\n        vector<string> ret; \r\n        BackTracking(digits, n, 0, temp, ret); \r\n        return ret; \r\n    };/*F*/vector<vector<char>> tran;/*C*//*M*/void BackTracking(string digits, int &n, int i, string &temp, vector<string> &ret) {\r\n        if (i == n) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for (int j = 0;  j < (tran[digits[i] - '0' - 2]).size();  ++j) {\r\n            temp.push_back(tran[digits[i] - '0' - 2][j]); \r\n            BackTracking(digits, n, i + 1, temp, ret); \r\n            temp.pop_back(); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void BackTracking. /*FC*/class Solution {\n/*FM*/void BackTracking(string digits, int &n, int i, string &temp, vector<string> &ret) {\r\n        if (i == n) {\r\n            \r\n            \r\n        }\r\n        for (int j = 0;  j < (tran[digits[i] - '0' - 2]).size();  ) {\r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*/vector<vector<char>> tran;/*C*//*M*/void BackTracking(string digits, int &n, int i, string &temp, vector<string> &ret) {\r\n        if (i == n) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for (int j = 0;  j < (tran[digits[i] - '0' - 2]).size();  ++j) {\r\n            temp.push_back(tran[digits[i] - '0' - 2][j]); \r\n            BackTracking(digits, n, i + 1, temp, ret); \r\n            temp.pop_back(); \r\n        }\r\n    } void BackTracking(string digits, int &n, int i, string &temp, vector<string> &ret) {\r\n        if (i == n) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for (int j = 0;  j < (tran[digits[i] - '0' - 2]).size();  ++j) {\r\n            temp.push_back(tran[digits[i] - '0' - 2][j]); \r\n            BackTracking(digits, n, i + 1, temp, ret); \r\n            temp.pop_back(); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [\"1\"], \"n\": [\"-2036815443\"], \"i\": [\"93098906\"], \"temp\": [\"2\"], \"ret\": [3], \"ret_element0\": [\"2\"], \"ret_element1\": [\"3\"], \"ret_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int next. /*FC*/class BSTIterator {\n/*FM*/int next() {\r\n        if (size <= 0)\r\n            return 0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*/int size;/*C*/BSTIterator(TreeNode *root) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___BSTIterator\": [\"BSTIterator\", \"BSTIterator(TreeNode*)\"], \"AKA_INSTANCE___BSTIterator_root\": [2], \"AKA_INSTANCE___BSTIterator_root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"AKA_INSTANCE___BSTIterator_root0_x\": [\"701645846\"], \"AKA_INSTANCE___BSTIterator_root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"AKA_INSTANCE___BSTIterator_root1_x\": [\"0\"], \"AKA_INSTANCE___BSTIterator->s\": [3], \"AKA_INSTANCE___BSTIterator->size\": [\"-871139893\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void PushAllLeft. /*FC*/class BSTIterator {\n/*FM*/void PushAllLeft(TreeNode *node) {\r\n        while (node) {\r\n            s.push(node); \r\n            node = node->left; \r\n            ++size; \r\n        }\r\n    };/*F*/stack<TreeNode *> s;  int size;/*C*/BSTIterator(TreeNode *root) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___BSTIterator\": [\"BSTIterator\", \"BSTIterator(TreeNode*)\"], \"AKA_INSTANCE___BSTIterator_root\": [1], \"AKA_INSTANCE___BSTIterator_root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"AKA_INSTANCE___BSTIterator_root0_x\": [\"1846491364\"], \"AKA_INSTANCE___BSTIterator->s\": [2], \"AKA_INSTANCE___BSTIterator->size\": [\"-177480206\"], \"node\": [1], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"-946284991\"], \"node[0].left\": [2], \"node[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_left0_x\": [\"-1672728836\"], \"node[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_left1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution {\n/*FM*/void rotate(vector<int> &nums, int k) {\r\n        k %= nums.size(); \r\n        while (k > 0) {\r\n            int &temp = nums.back(); \r\n            nums.pop_back(); \r\n            nums.insert(nums.begin(), temp); \r\n            --k; \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-294796131\"], \"nums_element1\": [\"-588732218\"], \"k\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *removeNthFromEnd. /*FC*/class Solution {\n/*FM*/ListNode *removeNthFromEnd(ListNode *head, int n) {\r\n        ListNode *l = new ListNode(0); \r\n        l->next = head; \r\n        ListNode *fast = head, *slow = head; \r\n        ListNode *prev = l; \r\n        while (n > 0) {\r\n            fast = fast->next; \r\n            --n; \r\n        }\r\n        while (fast) {\r\n            \r\n            \r\n            \r\n        }\r\n        prev->next = slow->next; \r\n        return l->next; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-542041187\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-269174359\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-443910147\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hammingWeight. /*FC*/class Solution {\n/*FM*/int hammingWeight(uint32_t n) {\r\n        int m = 8 * sizeof(uint32_t); \r\n        int count = 0; \r\n        while (m > 0) {\r\n            count += 1 & n; \r\n            n = n >> 1; \r\n            --m; \r\n        }\r\n        return count; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1798503441\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int> &nums) {\r\n        int size = nums.size(); \r\n        if (size == 0) \r\n        int first = -1, second = -1; \r\n        for (int i = 0;  i < size;  ++i) {\r\n            if (i % 2 == 0) {\r\n                if (first == -1) first = nums[i]; \r\n                else first = max(first + nums[i], second); \r\n            } else {\r\n                if (second == -1) second = max(first, nums[i]); \r\n                else \r\n            }\r\n        }\r\n        return size % 2 == 0 ? second : first; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1494966292\"], \"nums_element1\": [\"1475265228\"], \"nums_element2\": [\"-1082959339\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> rightSideView. /*FC*/class Solution {\n/*FM*/vector<int> rightSideView(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        view.clear(); \r\n        queue<TreeNode *> que; \r\n        que.push(root); \r\n        int size = 1, index = 1; \r\n        while (!que.empty()) {\r\n            TreeNode *temp = que.front(); \r\n            if (view.size() < index)\r\n                view.push_back(temp->val); \r\n            que.pop(); \r\n            if (temp->right) \r\n            if (temp->left) \r\n            --size; \r\n            if (size == 0) {\r\n                size = que.size(); \r\n                ++index; \r\n            }\r\n        }\r\n        return view; \r\n    };/*F*/vector<int> view;/*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->view\": [1], \"AKA_INSTANCE___Solution_view_element0\": [\"-1596616896\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"834268111\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *addTwoNumbers. /*FC*/class Solution {\n/*FM*/ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\r\n        int lenL1 = 0, lenL2 = 0; \r\n        ListNode *tempL1 = l1, *tempL2 = l2, *ret = l1, *tempRet = nullptr; \r\n        while (tempL1) {\r\n            ++lenL1; \r\n            tempL1 = tempL1->next; \r\n        }\r\n        while (tempL2) {\r\n            ++lenL2; \r\n            tempL2 = tempL2->next; \r\n        }\r\n        if (lenL1 < lenL2) {\r\n            ListNode *temp = l1; \r\n            l1 = l2; \r\n            ret = l2; \r\n            l2 = temp; \r\n        }\r\n        int sur = 0; \r\n        while (l1 && l2) {\r\n            if (lenL1 == lenL2 && !l1->next)\r\n                \r\n            int temp = l1->val + l2->val + sur; \r\n            l1->val = temp % 10; \r\n            sur = temp / 10; \r\n            l1 = l1->next; \r\n            l2 = l2->next; \r\n        }\r\n        while (l1) {\r\n            if (!l1->next)\r\n                tempRet = l1; \r\n            int temp = l1->val + sur; \r\n            l1->val = temp % 10; \r\n            sur = temp / 10; \r\n            l1 = l1->next; \r\n        }\r\n        if (sur == 1) {\r\n            \r\n            \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"236139575\"], \"l1[0].val\": [\"1310134687\"], \"l2\": [1], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"822716436\"], \"l2[0].val\": [\"1419480063\"], \"l2[0].next\": [3], \"l2[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_next0_x\": [\"64692128\"], \"l2[0].next[0].val\": [\"1383212867\"], \"l2[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"l20_next1_x\": [\"-583027220\"], \"l2[0].next[1].val\": [\"518472286\"], \"l2[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"l20_next2_x\": [\"-1949068233\"], \"l2[0].next[2].val\": [\"-999727381\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *addTwoNumbers. /*FC*/class Solution {\n/*FM*/ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\r\n        int lenL1 = 0, lenL2 = 0; \r\n        ListNode *tempL1 = l1, *tempL2 = l2, *ret = l1, *tempRet = nullptr; \r\n        while (tempL1) {\r\n            ++lenL1; \r\n            tempL1 = tempL1->next; \r\n        }\r\n        while (tempL2) {\r\n            ++lenL2; \r\n            tempL2 = tempL2->next; \r\n        }\r\n        if (lenL1 < lenL2) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        int sur = 0; \r\n        while (l1 && l2) {\r\n            if (lenL1 == lenL2 && !l1->next)\r\n                tempRet = l1; \r\n            int temp = l1->val + l2->val + sur; \r\n            l1->val = temp % 10; \r\n            sur = temp / 10; \r\n            l1 = l1->next; \r\n            l2 = l2->next; \r\n        }\r\n        while (l1) {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        if (sur == 1) {\r\n            \r\n            \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"-1161536339\"], \"l1[0].val\": [\"94180007\"], \"l1[0].next\": [3], \"l1[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_next0_x\": [\"346353182\"], \"l1[0].next[0].val\": [\"21363469\"], \"l1[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"l10_next1_x\": [\"-2012289711\"], \"l1[0].next[1].val\": [\"731782289\"], \"l1[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"l10_next2_x\": [\"307088843\"], \"l1[0].next[2].val\": [\"-1648114036\"], \"l2\": [1], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"-1761243202\"], \"l2[0].val\": [\"466816607\"], \"l2[0].next\": [3], \"l2[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_next0_x\": [\"-345183689\"], \"l2[0].next[0].val\": [\"-447750208\"], \"l2[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"l20_next1_x\": [\"930910491\"], \"l2[0].next[1].val\": [\"1018783215\"], \"l2[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"l20_next2_x\": [\"-1139425104\"], \"l2[0].next[2].val\": [\"644387493\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        stack<char> parentheses; \r\n        for (char c:s) {\r\n            if (!parentheses.empty()) {\r\n                \r\n                \r\n            } else\r\n                parentheses.push(c); \r\n        }\r\n        if(!parentheses.empty())\r\n            return false; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSubArrayLen. /*FC*/class Solution {\n/*FM*/int minSubArrayLen(int s, vector<int> &nums) {\r\n        int sum = 0, i = 0, j = 0, size = nums.size(), min_len = INT_MAX; \r\n        if (size == 0)\r\n            \r\n        while (j < size) {\r\n            sum += nums[j]; \r\n            while (sum >= s) {\r\n                sum -= nums[i]; \r\n                ++i; \r\n                min_len = min(min_len, j - i + 2); \r\n            }\r\n            ++j; \r\n        }\r\n        return i == 0 ? 0 : min_len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"4\"], \"nums\": [1], \"nums_element0\": [\"274910857\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0) \r\n        else if (n == 1) \r\n        else if (n == 2) \r\n        return (max(helper(nums, 0, n - 1), helper(nums, 1, n))); \r\n    };/*F*//*C*//*M*/int helper(vector<int> &nums, int i, int j) {\r\n        if (j - i == 2) return max(nums[i], nums[i + 1]); \r\n        int prev = nums[i], last = max(nums[i + 1], nums[i]), curr; \r\n        for (int k = i + 2;  k < j;  ++k) {\r\n            curr = max(prev + nums[k], last); \r\n            prev = last; \r\n            last = curr; \r\n        }\r\n        return curr; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"692267259\"], \"nums_element1\": [\"-595431298\"], \"nums_element2\": [\"1678486698\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0) \r\n        else if (n == 1) return nums[0]; \r\n        else if (n == 2) \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"105764488\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0) \r\n        else if (n == 1) \r\n        else if (n == 2) return max(nums[0], nums[1]); \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1411961822\"], \"nums_element1\": [\"-1606019878\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int helper. /*FC*/class Solution {\n/*FM*/int helper(vector<int> &nums, int i, int j) {\r\n        if (j - i == 2) \r\n        int prev = nums[i], last = max(nums[i + 1], nums[i]), curr; \r\n        for (int k = i + 2;  k < j;  ++k) {\r\n            curr = max(prev + nums[k], last); \r\n            prev = last; \r\n            last = curr; \r\n        }\r\n        return curr; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1254703322\"], \"nums_element1\": [\"-653802341\"], \"nums_element2\": [\"901476615\"], \"i\": [\"5\"], \"j\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findKthLargest. /*FC*/class Solution {\n/*FM*/int findKthLargest(vector<int> &nums, int k) {\r\n        priority_queue<int, vector<int>, greater<>> min_heap; \r\n        for (auto &m : nums) {\r\n            if (min_heap.size() < k || min_heap.top() < m)\r\n                min_heap.push(m); \r\n            if (min_heap.size() > k)\r\n                \r\n        }\r\n        return min_heap.top(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1184188713\"], \"nums_element1\": [\"-470487008\"], \"k\": [\"2136356240\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void helper. /*FC*/class Solution {\n/*FM*/void helper(int n, int sum, vector<vector<int>> &ret, vector<int> &temp, int index) {\r\n        if (sum == 0 && n == 0) {\r\n            \r\n            \r\n        }\r\n        for (int i = index;  i <= 9;  ) {\r\n            if (sum - i < 0)\r\n                break; \r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*//*C*//*M*/void helper(int n, int sum, vector<vector<int>> &ret, vector<int> &temp, int index) {\r\n        if (sum == 0 && n == 0) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for (int i = index;  i <= 9;  ++i) {\r\n            if (sum - i < 0)\r\n                break; \r\n            temp.push_back(i); \r\n            helper(n - 1, sum - i, ret, temp, i + 1); \r\n            temp.pop_back(); \r\n        }\r\n    } void helper(int n, int sum, vector<vector<int>> &ret, vector<int> &temp, int index) {\r\n        if (sum == 0 && n == 0) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for (int i = index;  i <= 9;  ++i) {\r\n            if (sum - i < 0)\r\n                break; \r\n            temp.push_back(i); \r\n            helper(n - 1, sum - i, ret, temp, i + 1); \r\n            temp.pop_back(); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-1803216247\"], \"sum\": [\"-49019699\"], \"ret\": [3], \"ret_element0\": [1], \"ret_element0_element0\": [\"-860212789\"], \"ret_element1\": [3], \"ret_element1_element0\": [\"-173648691\"], \"ret_element1_element1\": [\"1174359622\"], \"ret_element1_element2\": [\"1386488286\"], \"ret_element2\": [3], \"ret_element2_element0\": [\"1351867539\"], \"ret_element2_element1\": [\"1742219384\"], \"ret_element2_element2\": [\"-1153908872\"], \"temp\": [1], \"temp_element0\": [\"1683226634\"], \"index\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void helper. /*FC*/class Solution {\n/*FM*/void helper(int n, int sum, vector<vector<int>> &ret, vector<int> &temp, int index) {\r\n        if (sum == 0 && n == 0) {\r\n            \r\n            \r\n        }\r\n        for (int i = index;  i <= 9;  ++i) {\r\n            if (sum - i < 0)\r\n                \r\n            temp.push_back(i); \r\n            helper(n - 1, sum - i, ret, temp, i + 1); \r\n            temp.pop_back(); \r\n        }\r\n    };/*F*//*C*//*M*/void helper(int n, int sum, vector<vector<int>> &ret, vector<int> &temp, int index) {\r\n        if (sum == 0 && n == 0) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for (int i = index;  i <= 9;  ++i) {\r\n            if (sum - i < 0)\r\n                break; \r\n            temp.push_back(i); \r\n            helper(n - 1, sum - i, ret, temp, i + 1); \r\n            temp.pop_back(); \r\n        }\r\n    } void helper(int n, int sum, vector<vector<int>> &ret, vector<int> &temp, int index) {\r\n        if (sum == 0 && n == 0) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for (int i = index;  i <= 9;  ++i) {\r\n            if (sum - i < 0)\r\n                break; \r\n            temp.push_back(i); \r\n            helper(n - 1, sum - i, ret, temp, i + 1); \r\n            temp.pop_back(); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-1624378528\"], \"sum\": [\"1805732548\"], \"ret\": [3], \"ret_element0\": [3], \"ret_element0_element0\": [\"-378800266\"], \"ret_element0_element1\": [\"1293485308\"], \"ret_element0_element2\": [\"415708662\"], \"ret_element1\": [2], \"ret_element1_element0\": [\"-425451302\"], \"ret_element1_element1\": [\"-2121582135\"], \"ret_element2\": [1], \"ret_element2_element0\": [\"2134928454\"], \"temp\": [3], \"temp_element0\": [\"-1384392951\"], \"temp_element1\": [\"769259947\"], \"temp_element2\": [\"-1438690816\"], \"index\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsDuplicate. /*FC*/class Solution {\n/*FM*/bool containsDuplicate(vector<int> &nums) {\r\n        unordered_set<int> table; \r\n        for (auto n: nums) {\r\n            if (table.find(n) == table.end())\r\n                table.insert(n); \r\n            else\r\n                \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"374462709\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyDuplicate(vector<int> &nums, int k) {\r\n        int n = nums.size(); \r\n        if (n <= 1)\r\n            return false; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1025007075\"], \"k\": [\"-615067605\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyDuplicate(vector<int> &nums, int k) {\r\n        int n = nums.size(); \r\n        if (n <= 1)\r\n            \r\n        map<int, int> dup; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            if ((dup.find(nums[i]) != dup.end()) && (abs(i - dup[nums[i]]) <= k))\r\n                \r\n            dup[nums[i]] = i; \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"748464658\"], \"nums_element1\": [\"-930128244\"], \"k\": [\"326279553\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalSquare. /*FC*/class Solution {\n/*FM*/int maximalSquare(vector<vector<char>> &matrix) {\r\n        int n = matrix.size(); \r\n        if (n == 0)\r\n            \r\n        int m = matrix[0].size(); \r\n        vector<vector<int>> dp(n, vector<int>(m, 0)); \r\n        int temp0 = 0; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            dp[i][0] = (matrix[i][0] == '1' ? 1 : 0); \r\n            temp0 = max(temp0, dp[i][0]); \r\n        }\r\n        if (m == 1)\r\n            \r\n        int temp1 = 0; \r\n        for (int j = 0;  j < m;  ++j) {\r\n            dp[0][j] = (matrix[0][j] == '1' ? 1 : 0); \r\n            temp1 = max(temp1, dp[0][j]); \r\n        }\r\n        if (n == 1)\r\n            return temp1; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"108\"], \"matrix_element0_element1\": [\"40\"], \"matrix_element0_element2\": [\"-55\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalSquare. /*FC*/class Solution {\n/*FM*/int maximalSquare(vector<vector<char>> &matrix) {\r\n        int n = matrix.size(); \r\n        if (n == 0)\r\n            \r\n        int m = matrix[0].size(); \r\n        vector<vector<int>> dp(n, vector<int>(m, 0)); \r\n        int temp0 = 0; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            dp[i][0] = (matrix[i][0] == '1' ? 1 : 0); \r\n            temp0 = max(temp0, dp[i][0]); \r\n        }\r\n        if (m == 1)\r\n            \r\n        int temp1 = 0; \r\n        for (int j = 0;  j < m;  ++j) {\r\n            dp[0][j] = (matrix[0][j] == '1' ? 1 : 0); \r\n            temp1 = max(temp1, dp[0][j]); \r\n        }\r\n        if (n == 1)\r\n            \r\n        int maxLen = max(temp0, temp1); \r\n        for (int i = 1;  i < n;  ++i)\r\n            for (int j = 1;  j < m;  ++j) {\r\n                dp[i][j] = (matrix[i][j] == '0' ? 0 : min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1); \r\n                maxLen = max(maxLen, dp[i][j]); \r\n            }\r\n        return maxLen * maxLen; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"-91\"], \"matrix_element0_element1\": [\"68\"], \"matrix_element0_element2\": [\"-63\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"63\"], \"matrix_element1_element1\": [\"-123\"], \"matrix_element1_element2\": [\"94\"], \"matrix_element2\": [2], \"matrix_element2_element0\": [\"-105\"], \"matrix_element2_element1\": [\"-32\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalSquare. /*FC*/class Solution {\n/*FM*/int maximalSquare(vector<vector<char>> &matrix) {\r\n        int n = matrix.size(); \r\n        if (n == 0)\r\n            \r\n        int m = matrix[0].size(); \r\n        vector<vector<int>> dp(n, vector<int>(m, 0)); \r\n        int temp0 = 0; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            dp[i][0] = (matrix[i][0] == '1' ? 1 : 0); \r\n            temp0 = max(temp0, dp[i][0]); \r\n        }\r\n        if (m == 1)\r\n            return temp0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"86\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void push. /*FC*/class MyStack {\n/*FM*/void push(int x) {\r\n        reserve.push(x); \r\n        while (!utility.empty()) {\r\n            \r\n            \r\n            \r\n        }\r\n        queue<int> tempQueue = reserve; \r\n        reserve = utility; \r\n        utility = tempQueue; \r\n    };/*F*/queue<int> utility;  queue<int> reserve;/*C*/MyStack() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyStack\": [\"MyStack\", \"MyStack()\"], \"x\": [\"226604806\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *invertTree. /*FC*/class Solution {\n/*FM*/TreeNode *invertTree(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        queue<TreeNode *> que; \r\n        que.push(root); \r\n        while (!que.empty()) {\r\n            TreeNode *temp = que.front(); \r\n            swap(temp->left, temp->right); \r\n            que.pop(); \r\n            if (temp->left) \r\n            if (temp->right) \r\n        }\r\n        return root; \r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(nullptr), right(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"904839987\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"2008146986\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> summaryRanges. /*FC*/class Solution {\n/*FM*/vector<string> summaryRanges(vector<int> &nums) {\r\n        int size = nums.size(); \r\n        if (size == 0)\r\n            \r\n        vector<string> ret; \r\n        int start = nums[0]; \r\n        for (int i = 1;  i < nums.size();  ++i) {\r\n            if (nums[i] != nums[i - 1] + 1) {\r\n                if (start == nums[i - 1])\r\n                    ret.push_back(to_string(start)); \r\n                else\r\n                    \r\n                start = nums[i]; \r\n            }\r\n        }\r\n        if (start == nums[size - 1])\r\n            ret.push_back(to_string(start)); \r\n        else\r\n            \r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-2054643672\"], \"nums_element1\": [\"-1826950231\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfTwo. /*FC*/class Solution {\n/*FM*/bool isPowerOfTwo(int n) {\r\n        if (n <= 0)\r\n            return false; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfTwo. /*FC*/class Solution {\n/*FM*/bool isPowerOfTwo(int n) {\r\n        if (n <= 0)\r\n            \r\n        while ((n & 1) == 0)\r\n            n >>= 1; \r\n        return n == 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfTwo. /*FC*/class Solution {\n/*FM*/bool isPowerOfTwo(int n) {\r\n        if (n <= 0)\r\n            \r\n        while ((n & 1) == 0)\r\n            \r\n        return n == 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void push. /*FC*/class MyQueue {\n/*FM*/void push(int x) {\r\n        while (!utility.empty()) {\r\n            \r\n            \r\n            \r\n        }\r\n        utility.push(x); \r\n        while (!reserve.empty()) {\r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*/stack<int> utility;  stack<int> reserve;/*C*/MyQueue() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyQueue\": [\"MyQueue\", \"MyQueue()\"], \"x\": [\"-1061305032\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(ListNode *head) {\r\n        ListNode *first = head, *second = head; \r\n        while (first && first->next) {\r\n            first = first->next->next; \r\n            second = second->next; \r\n        }\r\n        if (first)\r\n            \r\n        second = ReverseList(second); \r\n        while (head && second) {\r\n            if (head->val != second->val)\r\n                return false; \r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/ListNode *ReverseList(ListNode *head) {\r\n        ListNode *prev = nullptr, *curr = head, *next = head; \r\n        while (curr) {\r\n            next = curr->next; \r\n            curr->next = prev; \r\n            prev = curr; \r\n            curr = next; \r\n        }\r\n        return prev; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-304620091\"], \"head[0].val\": [\"-1804203764\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-1130888034\"], \"head[0].next[0].val\": [\"250541168\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"1397099351\"], \"head[0].next[1].val\": [\"-740516719\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"-1307788861\"], \"head[0].next[2].val\": [\"866201835\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(ListNode *head) {\r\n        ListNode *first = head, *second = head; \r\n        while (first && first->next) {\r\n            \r\n            \r\n        }\r\n        if (first)\r\n            second = second->next; \r\n        second = ReverseList(second); \r\n        while (head && second) {\r\n            \r\n            \r\n            \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/ListNode *ReverseList(ListNode *head) {\r\n        ListNode *prev = nullptr, *curr = head, *next = head; \r\n        while (curr) {\r\n            next = curr->next; \r\n            curr->next = prev; \r\n            prev = curr; \r\n            curr = next; \r\n        }\r\n        return prev; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1532299193\"], \"head[0].val\": [\"1155482597\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1526825239\"], \"head[1].val\": [\"640212287\"], \"head[1].next\": [1], \"head[1].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head1_next0_x\": [\"605725874\"], \"head[1].next[0].val\": [\"-1577239525\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"828831167\"], \"head[2].val\": [\"-419769502\"], \"head[2].next\": [1], \"head[2].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head2_next0_x\": [\"-370444427\"], \"head[2].next[0].val\": [\"1841783040\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *ReverseList. /*FC*/class Solution {\n/*FM*/ListNode *ReverseList(ListNode *head) {\r\n        ListNode *prev = nullptr, *curr = head, *next = head; \r\n        while (curr) {\r\n            next = curr->next; \r\n            curr->next = prev; \r\n            prev = curr; \r\n            curr = next; \r\n        }\r\n        return prev; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"2022049402\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1905412631\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseKGroup. /*FC*/class Solution {\n/*FM*/ListNode *reverseKGroup(ListNode *head, int k) {\r\n        if (!head || !head->next)\r\n            \r\n        ListNode *temp = head, *start = new ListNode(0), *ret = start; \r\n        start->next = head; \r\n        int n = 0, left = 0; \r\n        while (temp) {\r\n            temp = temp->next; \r\n            ++n; \r\n        }\r\n        left = n % k; \r\n        n /= k; \r\n        while (n > 0) {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        start->next = head; \r\n        return ret->next; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> binaryTreePaths. /*FC*/class Solution {\n/*FM*/vector<string> binaryTreePaths(TreeNode *root) {\r\n        ret.clear(); \r\n        if (!root)\r\n            \r\n        string path; \r\n        path += to_string(root->val); \r\n        helper(root->left, path); \r\n        helper(root->right, path); \r\n        if (ret.empty())\r\n            \r\n        return ret; \r\n    };/*F*/vector<string> ret;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->ret\": [1], \"AKA_INSTANCE___Solution_ret_element0\": [\"1\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"1911838605\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[0].val\": [\"1211773760\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root0_left1_x\": [\"973853712\"], \"root[0].left[1].val\": [\"-1869778231\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].right[0].val\": [\"1164846778\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-319262713\"], \"root[1].val\": [\"-1610599580\"], \"root[1].left\": [1], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1].left[0].val\": [\"-386491794\"], \"root[1].right\": [2], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1].right[0].val\": [\"-895941108\"], \"root[1].right[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_right1_x\": [\"-1955319979\"], \"root[1].right[1].val\": [\"1096917083\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void helper. /*FC*/class Solution {\n/*FM*/void helper(TreeNode *root, string &path) {\r\n        if (!root)\r\n            \r\n        if (!root->left && !root->right) {\r\n            string &&temp = path + \"->\" + to_string(root->val); \r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        int &&size = path.size(); \r\n        path += \"->\" + to_string(root->val); \r\n        helper(root->left, path); \r\n        helper(root->right, path); \r\n        path = path.substr(0, size); \r\n    };/*F*/vector<string> ret;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->ret\": [3], \"AKA_INSTANCE___Solution_ret_element0\": [\"3\"], \"AKA_INSTANCE___Solution_ret_element1\": [\"3\"], \"AKA_INSTANCE___Solution_ret_element2\": [\"1\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"-1410250921\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[0].val\": [\"913247364\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-1695987417\"], \"root[0].right[0].val\": [\"-1294167968\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root0_right1_x\": [\"800116360\"], \"root[0].right[1].val\": [\"-966055313\"], \"path\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int addDigits. /*FC*/class Solution {\n/*FM*/int addDigits(int num) {\r\n        while (num > 9) {\r\n            \r\n            \r\n            \r\n        }\r\n        return num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int> &nums) {\r\n        auto size = nums.size(); \r\n        if (!size)\r\n            \r\n        int i = 0, j = 1; \r\n        while (j < size) {\r\n            if (nums[j] != nums[i])\r\n                nums[++i] = nums[j]; \r\n            ++j; \r\n        }\r\n        return i + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1014813708\"], \"nums_element1\": [\"-695125181\"], \"nums_element2\": [\"-27006570\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUgly. /*FC*/class Solution {\n/*FM*/bool isUgly(int num) {\r\n        if (num < 1)\r\n            \r\n        while (num % 2 == 0)\r\n            \r\n        while (num % 3 == 0)\r\n            num /= 3; \r\n        while (num % 5 == 0)\r\n            \r\n        if (num == 1)\r\n            return true; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUgly. /*FC*/class Solution {\n/*FM*/bool isUgly(int num) {\r\n        if (num < 1)\r\n            \r\n        while (num % 2 == 0)\r\n            num /= 2; \r\n        while (num % 3 == 0)\r\n            \r\n        while (num % 5 == 0)\r\n            num /= 5; \r\n        if (num == 1)\r\n            return true; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthUglyNumber. /*FC*/class Solution {\n/*FM*/int nthUglyNumber(int n) {\r\n        vector<int> primes{2, 3, 5}; \r\n        int m = primes.size(); \r\n        vector<int> factor(primes.size(), 0), res(n, 1); \r\n        for (int i = 1;  i < n;  ++i) {\r\n            res[i] = INT_MAX; \r\n            for (int j = 0;  j < m;  ++j)\r\n                res[i] = min(res[i], primes[j] * res[factor[j]]); \r\n            for (int j = 0;  j < m;  ++j)\r\n                if (primes[j] * res[factor[j]] == res[i])\r\n                    ++factor[j]; \r\n        }\r\n        return res.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int missingNumber. /*FC*/class Solution {\n/*FM*/int missingNumber(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        int res = n; \r\n        for (int i = 0;  i < n;  ++i)\r\n            res ^= nums[i] ^ i; \r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1280185976\"], \"nums_element1\": [\"1968759550\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeElement. /*FC*/class Solution {\n/*FM*/int removeElement(vector<int>& nums, int val) {\r\n        int n = 0; \r\n        for (int i = 0;  i < nums.size();  ++i) {\r\n            if (nums[i] != val)\r\n                ++n; \r\n            else {\r\n                \r\n                \r\n            }\r\n        }\r\n        return n; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1002509134\"], \"nums_element1\": [\"719467555\"], \"nums_element2\": [\"91074093\"], \"val\": [\"-1944310627\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSquares. /*FC*/class Solution {\n/*FM*/int numSquares(int n) {\r\n        vector<int> dp(n + 1, INT_MAX); \r\n        dp[0] = 0, dp[1] = 1; \r\n        for (int i = 2;  i <= n;  ++i) {\r\n            for (int j = 1;  j * j <= i;  ++j)\r\n                dp[i] = min(dp[i], dp[i - j * j] + 1); \r\n        }\r\n        return dp[n]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strStr. /*FC*/class Solution {\n/*FM*/int strStr(string &haystack, string &needle) {\r\n        int n = haystack.size(), m = needle.size(); \r\n        if (m == 0)\r\n            \r\n        for (int i = 0;  i < n;  ++i) {\r\n            if (i + m > n)\r\n                \r\n            int j = 0; \r\n            while (j < m && haystack[i + j] == needle[j])\r\n                \r\n            if (j == m)\r\n                \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [\"3\"], \"needle\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void moveZeroes. /*FC*/class Solution {\n/*FM*/void moveZeroes(vector<int> &nums) {\r\n        int index = 0; \r\n        for (int i = 0;  i < nums.size();  ++i)\r\n            if (nums[i] != 0)\r\n                swap(nums[index++], nums[i]); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"809680542\"], \"nums_element1\": [\"-801809393\"], \"nums_element2\": [\"-1398725733\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool wordPattern. /*FC*/class Solution {\n/*FM*/bool wordPattern(string pattern, string str) {\r\n        unordered_map<char, string> seq; \r\n        unordered_map<string, char> rev; \r\n        vector<string> s; \r\n        int b = 0; \r\n        for (int i = 0;  i < str.size();  ++i) {\r\n            if (str[i] == ' ') {\r\n                \r\n                \r\n            }\r\n        }\r\n        s.push_back(str.substr(b, str.size() - b)); \r\n        if (s.size() != pattern.size())\r\n            \r\n        for (int i = 0;  i < pattern.size();  ++i) {\r\n            if ((seq.find(pattern[i]) != seq.end() && seq[pattern[i]] != s[i]) ||\r\n                (rev.find(s[i]) != rev.end() && rev[s[i]] != pattern[i]))\r\n                \r\n            cout << 1; \r\n            seq[pattern[i]] = s[i]; \r\n            cout << 2; \r\n            rev[s[i]] = pattern[i]; \r\n            cout << 3; \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pattern\": [\"1\"], \"str\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n        vector<int> pos(200, -1); \r\n        int start = 0, res = 0; \r\n        for (int i = 0;  i < s.size();  ++i) {\r\n            if (pos[s[i]] != -1) {\r\n                res = max(res, i - start); \r\n                start = max(start, pos[s[i]] + 1); \r\n            }\r\n            pos[s[i]] = i; \r\n        }\r\n        res = max(res, static_cast<int>(s.size()) - start); \r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n        vector<int> pos(200, -1); \r\n        int start = 0, res = 0; \r\n        for (int i = 0;  i < s.size();  ++i) {\r\n            if (pos[s[i]] != -1) {\r\n                \r\n                \r\n            }\r\n            pos[s[i]] = i; \r\n        }\r\n        res = max(res, static_cast<int>(s.size()) - start); \r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLIS. /*FC*/class Solution {\n/*FM*/int lengthOfLIS(vector<int> &nums) {\r\n        auto size = nums.size(); \r\n        if (size == 0)\r\n            \r\n        vector<int> seq(1, nums[0]); \r\n        for (int i = 1;  i < size;  ++i) {\r\n            int mid = 0, x = 0, y = seq.size(); \r\n            while (x < y) {\r\n                mid = x + (y - x) / 2; \r\n                if (seq[mid] < nums[i])\r\n                    x = mid + 1; \r\n                else\r\n                    \r\n            }\r\n            if (y == seq.size())\r\n                seq.push_back(nums[i]); \r\n            else\r\n                \r\n        }\r\n        return seq.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1483814552\"], \"nums_element1\": [\"1791400535\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLIS. /*FC*/class Solution {\n/*FM*/int lengthOfLIS(vector<int> &nums) {\r\n        auto size = nums.size(); \r\n        if (size == 0)\r\n            \r\n        vector<int> seq(1, nums[0]); \r\n        for (int i = 1;  i < size;  ++i) {\r\n            int mid = 0, x = 0, y = seq.size(); \r\n            while (x < y) {\r\n                mid = x + (y - x) / 2; \r\n                if (seq[mid] < nums[i])\r\n                    \r\n                else\r\n                    y = mid; \r\n            }\r\n            if (y == seq.size())\r\n                \r\n            else\r\n                seq[y] = nums[i]; \r\n        }\r\n        return seq.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"968883869\"], \"nums_element1\": [\"-693339169\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sumRegion. /*FC*/class NumMatrix {\n/*FM*/int sumRegion(int row1, int col1, int row2, int col2) {\r\n        if (row1 == 0 && col1 == 0)\r\n            \r\n        else if (row1 == 0)\r\n            \r\n        else if (col1 == 0)\r\n            \r\n        return sum[row2][col2] - sum[row1 - 1][col2] - sum[row2][col1 - 1] + sum[row1 - 1][col1 - 1]; \r\n    };/*F*/vector<vector<int>> sum;/*C*/NumMatrix(vector<vector<int>> matrix) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___NumMatrix\": [\"NumMatrix\", \"NumMatrix(vector<vector<int>>)\"], \"AKA_INSTANCE___NumMatrix_matrix\": [1], \"AKA_INSTANCE___NumMatrix_matrix_element0\": [1], \"AKA_INSTANCE___NumMatrix_matrix_element0_element0\": [\"-757137166\"], \"AKA_INSTANCE___NumMatrix->sum\": [3], \"AKA_INSTANCE___NumMatrix_sum_element0\": [3], \"AKA_INSTANCE___NumMatrix_sum_element0_element0\": [\"-1827707725\"], \"AKA_INSTANCE___NumMatrix_sum_element0_element1\": [\"266164027\"], \"AKA_INSTANCE___NumMatrix_sum_element0_element2\": [\"536947227\"], \"AKA_INSTANCE___NumMatrix_sum_element1\": [3], \"AKA_INSTANCE___NumMatrix_sum_element1_element0\": [\"-1424627366\"], \"AKA_INSTANCE___NumMatrix_sum_element1_element1\": [\"-1653785878\"], \"AKA_INSTANCE___NumMatrix_sum_element1_element2\": [\"-1830682553\"], \"AKA_INSTANCE___NumMatrix_sum_element2\": [3], \"AKA_INSTANCE___NumMatrix_sum_element2_element0\": [\"1242514561\"], \"AKA_INSTANCE___NumMatrix_sum_element2_element1\": [\"-1382291899\"], \"AKA_INSTANCE___NumMatrix_sum_element2_element2\": [\"-1440083386\"], \"row1\": [\"-2042029809\"], \"col1\": [\"2510765\"], \"row2\": [\"983780917\"], \"col2\": [\"1483994572\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAdditiveNumber. /*FC*/class Solution {\n/*FM*/bool isAdditiveNumber(string num) {\r\n        int n = num.size(); \r\n        if (n < 3)\r\n            return false; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sumRange. /*FC*/class NumArray {\n/*FM*/int sumRange(int i, int j) {\r\n        int sum = 0; \r\n        i += array.size() / 2; \r\n        j += array.size() / 2; \r\n        while (i <= j) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return sum; \r\n    };/*F*/vector<int> array;/*C*/NumArray(vector<int> nums) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___NumArray\": [\"NumArray\", \"NumArray(vector<int>)\"], \"AKA_INSTANCE___NumArray_nums\": [2], \"AKA_INSTANCE___NumArray_nums_element0\": [\"-963600395\"], \"AKA_INSTANCE___NumArray_nums_element1\": [\"-771065708\"], \"i\": [\"9\"], \"j\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sumRange. /*FC*/class NumArray {\n/*FM*/int sumRange(int i, int j) {\r\n        int sum = 0; \r\n        i += array.size() / 2; \r\n        j += array.size() / 2; \r\n        while (i <= j) {\r\n            if (i % 2 == 1) {\r\n                sum += array[i]; \r\n                ++i; \r\n            }\r\n            if (j % 2 == 0) {\r\n                sum += array[j]; \r\n                --j; \r\n            }\r\n            i /= 2; \r\n            j /= 2; \r\n        }\r\n        return sum; \r\n    };/*F*/vector<int> array;/*C*/NumArray(vector<int> nums) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___NumArray\": [\"NumArray\", \"NumArray(vector<int>)\"], \"AKA_INSTANCE___NumArray_nums\": [1], \"AKA_INSTANCE___NumArray_nums_element0\": [\"1598959599\"], \"i\": [\"2\"], \"j\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int> &prices) {\r\n        int n = prices.size(); \r\n        if (n == 0)\r\n            \r\n        else if (n == 1)\r\n            \r\n        vector<int> purchase(n, 0); \r\n        vector<int> sell(n, 0); \r\n        purchase[0] = -prices[0]; \r\n        purchase[1] = -prices[1]; \r\n        sell[1] = prices[1] - prices[0]; \r\n        for (int i = 2;  i < n;  ++i) {\r\n            int transact = prices[i] - prices[i - 1]; \r\n            purchase[i] = max(purchase[i - 1] - transact, sell[i - 2] - prices[i]); \r\n            sell[i] = max(purchase[i - 1] + prices[i], sell[i - 1] + transact); \r\n        }\r\n        return *max_element(sell.begin(), sell.end()); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [3], \"prices_element0\": [\"-579676250\"], \"prices_element1\": [\"-602647142\"], \"prices_element2\": [\"686250240\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int> &prices) {\r\n        int n = prices.size(); \r\n        if (n == 0)\r\n            \r\n        else if (n == 1)\r\n            return prices[1] > prices[0] ? prices[1] - prices[0] : 0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [1], \"prices_element0\": [\"-1188893187\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector<int> &nums) {\r\n        int size = nums.size(), n = nums.size() - 2; \r\n        while (n >= 0) {\r\n            if (nums[n] < nums[n + 1])\r\n                break; \r\n            \r\n        }\r\n        if (n >= 0) {\r\n            int sub = 0, upper = INT_MAX; \r\n            for (int i = n + 1;  i < size;  ++i) {\r\n                if (nums[i] > nums[n] && upper > nums[i]) {\r\n                    sub = i; \r\n                    upper = nums[i]; \r\n                }\r\n            }\r\n            swap(nums[sub], nums[n]); \r\n        }\r\n        std::sort(nums.begin() + n + 1, nums.end()); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1418061399\"], \"nums_element1\": [\"-1992700586\"], \"nums_element2\": [\"603141065\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector<int> &nums) {\r\n        int size = nums.size(), n = nums.size() - 2; \r\n        while (n >= 0) {\r\n            if (nums[n] < nums[n + 1])\r\n                \r\n            --n; \r\n        }\r\n        if (n >= 0) {\r\n            \r\n            \r\n            \r\n        }\r\n        std::sort(nums.begin() + n + 1, nums.end()); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1659202618\"], \"nums_element1\": [\"-247976974\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthSuperUglyNumber. /*FC*/class Solution {\n/*FM*/int nthSuperUglyNumber(int n, vector<int> &primes) {\r\n        int m = primes.size(); \r\n        vector<int> factor(primes.size(), 0), res(n, 1); \r\n        for (int i = 1;  i < n;  ++i) {\r\n            res[i] = INT_MAX; \r\n            for (int j = 0;  j < m;  ++j)\r\n                res[i] = min(res[i], primes[j] * res[factor[j]]); \r\n            for (int j = 0;  j < m;  ++j)\r\n                if (primes[j] * res[factor[j]] == res[i])\r\n                    ++factor[j]; \r\n        }\r\n        return res.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"], \"primes\": [2], \"primes_element0\": [\"1625330069\"], \"primes_element1\": [\"-1972549675\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int coinChange. /*FC*/class Solution {\n/*FM*/int coinChange(vector<int> &coins, int amount) {\r\n        int n = coins.size(); \r\n        if (amount == 0)\r\n            \r\n        if (n == 0)\r\n            \r\n        vector<int> dp(amount + 1, amount + 1); \r\n        dp[0] = 0; \r\n        for (int i = 1;  i <= amount;  ++i) {\r\n            for (int j = 0;  j < n;  ++j)\r\n                if (i - coins[j] >= 0)\r\n                    \r\n        }\r\n        return dp[amount] == amount + 1 ? -1 : dp[amount]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"coins\": [2], \"coins_element0\": [\"1460654756\"], \"coins_element1\": [\"1172179319\"], \"amount\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int coinChange. /*FC*/class Solution {\n/*FM*/int coinChange(vector<int> &coins, int amount) {\r\n        int n = coins.size(); \r\n        if (amount == 0)\r\n            return 0; \r\n        if (n == 0)\r\n            \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"coins\": [2], \"coins_element0\": [\"-2069332678\"], \"coins_element1\": [\"2100765874\"], \"amount\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfThree. /*FC*/class Solution {\n/*FM*/bool isPowerOfThree(int n) {\r\n        if (n <= 0)\r\n            \r\n        while (n % 3 == 0)\r\n            n /= 3; \r\n        return n == 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *oddEvenList. /*FC*/class Solution {\n/*FM*/ListNode *oddEvenList(ListNode *head) {\r\n        if (!head)\r\n            \r\n        ListNode *odd = head, *even = head->next, *evenHead = head->next; \r\n        while (odd && even) {\r\n            odd->next = even->next; \r\n            if (odd->next) {\r\n                \r\n                \r\n            }\r\n            even = even->next; \r\n        }\r\n        odd->next = evenHead; \r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"200961380\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"1444062024\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, mid = 0, n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] > nums[i] && nums[mid] > nums[j])\r\n                \r\n            else if (nums[mid] < nums[i] && nums[mid] < nums[j])\r\n                \r\n            else\r\n                break; \r\n        }\r\n        i = nums[i] < nums[j] ? i : j; \r\n        int start = 0, end = i - 1; \r\n        if (target < nums[0] || i == 0) {\r\n            \r\n            \r\n        }\r\n        while (start <= end) {\r\n            mid = start + (end - start) / 2; \r\n            if (nums[mid] > target)\r\n                \r\n            else if (nums[mid] < target)\r\n                start = mid + 1; \r\n            else\r\n                \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"891794866\"], \"nums_element1\": [\"-1014277683\"], \"target\": [\"1611000431\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, mid = 0, n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] > nums[i] && nums[mid] > nums[j])\r\n                \r\n            else if (nums[mid] < nums[i] && nums[mid] < nums[j])\r\n                \r\n            else\r\n                break; \r\n        }\r\n        i = nums[i] < nums[j] ? i : j; \r\n        int start = 0, end = i - 1; \r\n        if (target < nums[0] || i == 0) {\r\n            start = i; \r\n            end = n - 1; \r\n        }\r\n        while (start <= end) {\r\n            mid = start + (end - start) / 2; \r\n            if (nums[mid] > target)\r\n                \r\n            else if (nums[mid] < target)\r\n                start = mid + 1; \r\n            else\r\n                \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1701296426\"], \"nums_element1\": [\"-649793309\"], \"nums_element2\": [\"1607472286\"], \"target\": [\"2085997175\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, mid = 0, n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] > nums[i] && nums[mid] > nums[j])\r\n                i = mid + 1; \r\n            else if (nums[mid] < nums[i] && nums[mid] < nums[j])\r\n                \r\n            else\r\n                \r\n        }\r\n        i = nums[i] < nums[j] ? i : j; \r\n        int start = 0, end = i - 1; \r\n        if (target < nums[0] || i == 0) {\r\n            start = i; \r\n            end = n - 1; \r\n        }\r\n        while (start <= end) {\r\n            mid = start + (end - start) / 2; \r\n            if (nums[mid] > target)\r\n                end = mid - 1; \r\n            else if (nums[mid] < target)\r\n                \r\n            else\r\n                \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1328059162\"], \"nums_element1\": [\"1975806061\"], \"nums_element2\": [\"1546905281\"], \"target\": [\"-1473833993\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, mid = 0, n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] > nums[i] && nums[mid] > nums[j])\r\n                \r\n            else if (nums[mid] < nums[i] && nums[mid] < nums[j])\r\n                j = mid; \r\n            else\r\n                break; \r\n        }\r\n        i = nums[i] < nums[j] ? i : j; \r\n        int start = 0, end = i - 1; \r\n        if (target < nums[0] || i == 0) {\r\n            start = i; \r\n            end = n - 1; \r\n        }\r\n        while (start <= end) {\r\n            mid = start + (end - start) / 2; \r\n            if (nums[mid] > target)\r\n                end = mid - 1; \r\n            else if (nums[mid] < target)\r\n                \r\n            else\r\n                \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1353996570\"], \"nums_element1\": [\"-210591722\"], \"nums_element2\": [\"1239714966\"], \"target\": [\"-1243211432\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> countBits. /*FC*/class Solution {\n/*FM*/vector<int> countBits(int num) {\r\n        vector<int> count(num + 1, 0); \r\n        for (int i = 1;  i <= num;  ++i)\r\n            count[i] = count[i / 2] + (i % 2); \r\n        return count; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> searchRange. /*FC*/class Solution {\n/*FM*/vector<int> searchRange(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, mid = 0, x = i, y = j; \r\n        if (j < 0)\r\n            \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] < target)\r\n                i = mid + 1; \r\n            else if (nums[mid] >= target)\r\n                \r\n        }\r\n        if (j < 0 || nums[j] < target)\r\n            ++j; \r\n        while (x < y) {\r\n            mid = x + (y - x) / 2; \r\n            if (nums[mid] <= target)\r\n                x = mid + 1; \r\n            else if (nums[mid] > target)\r\n                \r\n        }\r\n        if (x < 0 || nums[x] > target)\r\n            \r\n        return (x >= j ? vector<int>{j, x} : vector<int>{-1, -1}); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1130151394\"], \"nums_element1\": [\"-32696106\"], \"nums_element2\": [\"-3455033\"], \"target\": [\"478615778\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> searchRange. /*FC*/class Solution {\n/*FM*/vector<int> searchRange(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, mid = 0, x = i, y = j; \r\n        if (j < 0)\r\n            \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] < target)\r\n                \r\n            else if (nums[mid] >= target)\r\n                j = mid - 1; \r\n        }\r\n        if (j < 0 || nums[j] < target)\r\n            \r\n        while (x < y) {\r\n            mid = x + (y - x) / 2; \r\n            if (nums[mid] <= target)\r\n                \r\n            else if (nums[mid] > target)\r\n                y = mid - 1; \r\n        }\r\n        if (x < 0 || nums[x] > target)\r\n            --x; \r\n        return (x >= j ? vector<int>{j, x} : vector<int>{-1, -1}); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"377130904\"], \"nums_element1\": [\"-326476780\"], \"nums_element2\": [\"2135143470\"], \"target\": [\"-1291334221\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfFour. /*FC*/class Solution {\n/*FM*/bool isPowerOfFour(int num) {\r\n        if (num <= 0)\r\n            \r\n        while (num > 1) {\r\n             \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfFour. /*FC*/class Solution {\n/*FM*/bool isPowerOfFour(int num) {\r\n        if (num <= 0)\r\n            \r\n        while (num > 1) {\r\n            if ((num & 1) || (num & 2))\r\n                return false; \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int integerBreak. /*FC*/class Solution {\n/*FM*/int integerBreak(int n) {\r\n\t\tif (n == 2) \r\n\t\telse if (n == 3) \r\n\t\tstd::vector<int> maxProduct; \r\n\t\tmaxProduct.push_back(0); \t\n\t\tmaxProduct.push_back(1); \t\n\t\tmaxProduct.push_back(2); \t\n\t\tmaxProduct.push_back(3); \t\n\t\tmaxProduct.push_back(4); \t\n\t\tfor (int i = 5;  i <= n;  ++i) {\r\n\t\t\tint max = 0; \r\n\t\t\tfor (int j = 1;  j < i / 2 + 1;  ++j) {\r\n\t\t\t\tint sub = i - j; \r\n\t\t\t\tint temp = maxProduct[j] * maxProduct[sub]; \r\n\t\t\t\tmax = max < temp ? temp : max; \r\n\t\t\t}\r\n\t\t\tmaxProduct.push_back(max); \r\n\t\t}\r\n\t\treturn maxProduct[n]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int integerBreak. /*FC*/class Solution {\n/*FM*/int integerBreak(int n) {\r\n\t\tif (n == 2) \r\n\t\telse if (n == 3) return 2; \r\n\t\t\r\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseString. /*FC*/class Solution {\n/*FM*/string reverseString(string s) {\r\n        int n = s.size(); \r\n        for (int i = 0;  i < n / 2;  )\r\n            \r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> searchRange. /*FC*/class Solution {\n/*FM*/vector<int> searchRange(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, mid = 0, x = i, y = j; \r\n        if (j < 0)\r\n            \r\n        while (i < j) {\r\n            \r\n            \r\n        }\r\n        if (j < 0 || nums[j] < target)\r\n            \r\n        while (x < y) {\r\n            \r\n            \r\n        }\r\n        if (x < 0 || nums[x] > target)\r\n            --x; \r\n        return (x >= j ? vector<int>{j, x} : vector<int>{-1, -1}); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1868159373\"], \"target\": [\"-1778146994\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> searchRange. /*FC*/class Solution {\n/*FM*/vector<int> searchRange(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, mid = 0, x = i, y = j; \r\n        if (j < 0)\r\n            \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] < target)\r\n                \r\n            else if (nums[mid] >= target)\r\n                j = mid - 1; \r\n        }\r\n        if (j < 0 || nums[j] < target)\r\n            ++j; \r\n        while (x < y) {\r\n            mid = x + (y - x) / 2; \r\n            if (nums[mid] <= target)\r\n                \r\n            else if (nums[mid] > target)\r\n                y = mid - 1; \r\n        }\r\n        if (x < 0 || nums[x] > target)\r\n            --x; \r\n        return (x >= j ? vector<int>{j, x} : vector<int>{-1, -1}); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1151802727\"], \"nums_element1\": [\"-1998238839\"], \"target\": [\"-1650743394\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> searchRange. /*FC*/class Solution {\n/*FM*/vector<int> searchRange(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, mid = 0, x = i, y = j; \r\n        if (j < 0)\r\n            \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (nums[mid] < target)\r\n                \r\n            else if (nums[mid] >= target)\r\n                j = mid - 1; \r\n        }\r\n        if (j < 0 || nums[j] < target)\r\n            ++j; \r\n        while (x < y) {\r\n            mid = x + (y - x) / 2; \r\n            if (nums[mid] <= target)\r\n                \r\n            else if (nums[mid] > target)\r\n                y = mid - 1; \r\n        }\r\n        if (x < 0 || nums[x] > target)\r\n            \r\n        return (x >= j ? vector<int>{j, x} : vector<int>{-1, -1}); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1648434532\"], \"nums_element1\": [\"-1082246272\"], \"nums_element2\": [\"-157980836\"], \"target\": [\"-1114505737\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/class Solution {\n/*FM*/int searchInsert(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, index = 0; \r\n        while (i <= j) {\r\n            index = (i + j) / 2; \r\n            if (nums[index] < target)\r\n                i = index + 1; \r\n            else if (nums[index] > target)\r\n                j = index - 1; \r\n            else\r\n                \r\n        }\r\n        return i; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-310814848\"], \"nums_element1\": [\"-1595863875\"], \"nums_element2\": [\"49767572\"], \"target\": [\"-755393716\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> intersect. /*FC*/class Solution {\n/*FM*/vector<int> intersect(vector<int> &nums1, vector<int> &nums2) {\r\n        unordered_map<int, int> map1; \r\n        for (int i = 0;  i < nums1.size();  ++i)\r\n            ++map1[nums1[i]]; \r\n        for (int i = 0;  i < nums2.size();  ++i) {\r\n            if (map1[nums2[i]] > 0)\r\n                \r\n            else {\r\n                nums2.erase(nums2.begin() + i); \r\n                --i; \r\n            }\r\n        }\r\n        return nums2; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"1687307651\"], \"nums1_element1\": [\"597566849\"], \"nums2\": [2], \"nums2_element0\": [\"1802067465\"], \"nums2_element1\": [\"103116645\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int wiggleMaxLength. /*FC*/class Solution {\n/*FM*/int wiggleMaxLength(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0) \r\n        int i = 1, max = 1; \r\n        int pre; \r\n        while (nums[i] - nums[i - 1] == 0 && i < n)\r\n            \r\n        if (i == n)\r\n            \r\n        pre = (nums[i] - nums[i - 1] > 0 ? 1 : -1); \r\n        ++max; \r\n        for (i = i + 1;  i < n;  ) {\r\n            \r\n            \r\n            \r\n        }\r\n        return max; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1330184830\"], \"nums_element1\": [\"-1553076628\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int kthSmallest. /*FC*/class Solution {\n/*FM*/int kthSmallest(vector<vector<int>> &matrix, int k) {\r\n        int n = matrix.size(); \r\n        if (n == 0)\r\n            \r\n        priority_queue<int> heap; \r\n        for (auto &m: matrix) {\r\n            for (auto &num: m) {\r\n                if (heap.size() > k)\r\n                    \r\n                if (heap.size() < k || num < heap.top())\r\n                    heap.push(num); \r\n                else\r\n                    \r\n            }\r\n        }\r\n        return heap.top(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"-204528368\"], \"matrix_element0_element1\": [\"1371231117\"], \"matrix_element0_element2\": [\"-1989574137\"], \"k\": [\"-485183634\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool insert. /*FC*/class RandomizedSet {\n/*FM*/bool insert(int val) {\r\n        if (M.find(val) != M.end())\r\n            \r\n        V.push_back(val); \r\n        M.insert(std::pair<int, int>(val, V.size() - 1)); \r\n        return true; \r\n    };/*F*/unordered_map<int, int> M;  vector<int> V;/*C*/RandomizedSet() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RandomizedSet\": [\"RandomizedSet\", \"RandomizedSet()\"], \"AKA_INSTANCE___RandomizedSet->V\": [3], \"AKA_INSTANCE___RandomizedSet_V_element0\": [\"-360364804\"], \"AKA_INSTANCE___RandomizedSet_V_element1\": [\"1287687883\"], \"AKA_INSTANCE___RandomizedSet_V_element2\": [\"353351768\"], \"val\": [\"-539406586\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool remove. /*FC*/class RandomizedSet {\n/*FM*/bool remove(int val) {\r\n        if (M.find(val) == M.end())\r\n            return false; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*/unordered_map<int, int> M;/*C*/RandomizedSet() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RandomizedSet\": [\"RandomizedSet\", \"RandomizedSet()\"], \"AKA_INSTANCE___RandomizedSet->V\": [1], \"AKA_INSTANCE___RandomizedSet_V_element0\": [\"820759069\"], \"val\": [\"-2002688362\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char findTheDifference. /*FC*/class Solution {\n/*FM*/char findTheDifference(string s, string t) {\r\n        char sumS = 0, sumT = 0; \r\n        for(int i = 0;  i < s.size();  ++i) {\r\n            sumS += s[i]; \r\n            sumT += t[i]; \r\n        }\r\n        return sumT + t[s.size()] -sumS; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> combinationSum. /*FC*/class Solution {\n/*FM*/vector<vector<int>> combinationSum(vector<int> &candidates, int target) {\r\n        for (int i = 0;  i < candidates.size();  ++i) {\r\n            vector<int> temp; \r\n            temp.push_back(candidates[i]); \r\n            int index = 0; \r\n            helper(candidates, target, candidates[i], temp, i); \r\n        }\r\n        return ret; \r\n    };/*F*/vector<vector<int>> ret;/*C*//*M*/void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            ret.push_back(temp); \r\n        if (sum >= target)\r\n            return; \r\n        for (int i = index;  i < candidates.size();  ++i) {\r\n            if (sum + candidates[i] > target)\r\n                continue; \r\n            temp.push_back(candidates[i]); \r\n            helper(candidates, target, sum + candidates[i], temp, i); \r\n            temp.erase(temp.end() - 1); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"candidates\": [2], \"candidates_element0\": [\"1824694092\"], \"candidates_element1\": [\"25476158\"], \"target\": [\"1231324359\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void helper. /*FC*/class Solution {\n/*FM*/void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            \r\n        if (sum >= target)\r\n            \r\n        for (int i = index;  i < candidates.size();  ++i) {\r\n            if (sum + candidates[i] > target)\r\n                continue; \r\n            temp.push_back(candidates[i]); \r\n            helper(candidates, target, sum + candidates[i], temp, i); \r\n            temp.erase(temp.end() - 1); \r\n        }\r\n    };/*F*//*C*//*M*/void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            ret.push_back(temp); \r\n        if (sum >= target)\r\n            return; \r\n        for (int i = index;  i < candidates.size();  ++i) {\r\n            if (sum + candidates[i] > target)\r\n                continue; \r\n            temp.push_back(candidates[i]); \r\n            helper(candidates, target, sum + candidates[i], temp, i); \r\n            temp.erase(temp.end() - 1); \r\n        }\r\n    } void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            ret.push_back(temp); \r\n        if (sum >= target)\r\n            return; \r\n        for (int i = index;  i < candidates.size();  ++i) {\r\n            if (sum + candidates[i] > target)\r\n                continue; \r\n            temp.push_back(candidates[i]); \r\n            helper(candidates, target, sum + candidates[i], temp, i); \r\n            temp.erase(temp.end() - 1); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"candidates\": [3], \"candidates_element0\": [\"1923700046\"], \"candidates_element1\": [\"979744658\"], \"candidates_element2\": [\"625123226\"], \"target\": [\"1771250978\"], \"sum\": [\"722321988\"], \"temp\": [2], \"temp_element0\": [\"-1541085884\"], \"temp_element1\": [\"-1119656005\"], \"index\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void helper. /*FC*/class Solution {\n/*FM*/void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            \r\n        if (sum >= target)\r\n            return; \r\n        \r\n    };/*F*//*C*//*M*/void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            ret.push_back(temp); \r\n        if (sum >= target)\r\n            return; \r\n        for (int i = index;  i < candidates.size();  ++i) {\r\n            if (sum + candidates[i] > target)\r\n                continue; \r\n            temp.push_back(candidates[i]); \r\n            helper(candidates, target, sum + candidates[i], temp, i); \r\n            temp.erase(temp.end() - 1); \r\n        }\r\n    } void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            ret.push_back(temp); \r\n        if (sum >= target)\r\n            return; \r\n        for (int i = index;  i < candidates.size();  ++i) {\r\n            if (sum + candidates[i] > target)\r\n                continue; \r\n            temp.push_back(candidates[i]); \r\n            helper(candidates, target, sum + candidates[i], temp, i); \r\n            temp.erase(temp.end() - 1); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"candidates\": [3], \"candidates_element0\": [\"-666691631\"], \"candidates_element1\": [\"-1476122749\"], \"candidates_element2\": [\"-1335902519\"], \"target\": [\"-1856825677\"], \"sum\": [\"-847284414\"], \"temp\": [1], \"temp_element0\": [\"-431362561\"], \"index\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubsequence. /*FC*/class Solution {\n/*FM*/bool isSubsequence(string s, string t) {\r\n        int i = 0, j = 0; \r\n        while (i < s.size() && j < t.size()) {\r\n            if (s[i] == t[j])\r\n                \r\n            ++j; \r\n        }\r\n        if (i != s.size())\r\n            return false; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"t\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMedianSortedArrays. /*FC*/class Solution {\n/*FM*/double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\r\n        int m = nums1.size(), n = nums2.size(); \r\n        if (m > n) {\r\n            swap(nums1, nums2); \r\n            swap(m, n); \r\n        }\r\n        if (m == 0)\r\n            \r\n        int i = 0, j = m, half = (m + n + 1) / 2; \r\n        while (i < j) {\r\n            int k = i + (j - i) / 2, l = half - k; \r\n            if (nums1[k] < nums2[l - 1])\r\n                i = k + 1; \r\n            else\r\n                \r\n        }\r\n        int r1 = i, r2 = half - i; \r\n        int res1 = max(r1 - 1 >= 0 ? nums1[r1 - 1] : INT_MIN, r2 - 1 >= 0 ? nums2[r2 - 1] : INT_MIN); \r\n        if ((m + n) % 2)\r\n            return res1; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"505879414\"], \"nums1_element1\": [\"1897114552\"], \"nums2\": [1], \"nums2_element0\": [\"-546908853\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMedianSortedArrays. /*FC*/class Solution {\n/*FM*/double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\r\n        int m = nums1.size(), n = nums2.size(); \r\n        if (m > n) {\r\n            \r\n            \r\n        }\r\n        if (m == 0)\r\n            \r\n        int i = 0, j = m, half = (m + n + 1) / 2; \r\n        while (i < j) {\r\n            int k = i + (j - i) / 2, l = half - k; \r\n            if (nums1[k] < nums2[l - 1])\r\n                \r\n            else\r\n                j = k; \r\n        }\r\n        int r1 = i, r2 = half - i; \r\n        int res1 = max(r1 - 1 >= 0 ? nums1[r1 - 1] : INT_MIN, r2 - 1 >= 0 ? nums2[r2 - 1] : INT_MIN); \r\n        if ((m + n) % 2)\r\n            return res1; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [1], \"nums1_element0\": [\"1209104220\"], \"nums2\": [2], \"nums2_element0\": [\"-1672737376\"], \"nums2_element1\": [\"-110687471\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void helper. /*FC*/class Solution {\n/*FM*/void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            \r\n        if (sum >= target)\r\n            return; \r\n        \r\n    };/*F*//*C*//*M*/void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            ret.push_back(temp); \r\n        if (sum >= target)\r\n            return; \r\n        for (int i = index;  i < candidates.size();  ++i) {\r\n            if (sum + candidates[i] > target)\r\n                continue; \r\n            if (i == index || candidates[i] != candidates[i - 1]) {\r\n                temp.push_back(candidates[i]); \r\n                helper(candidates, target, sum + candidates[i], temp, i + 1); \r\n                temp.pop_back(); \r\n            }\r\n        }\r\n    } void helper(vector<int> &candidates, int &target, int sum, vector<int> &temp, int index) {\r\n        if (sum == target)\r\n            ret.push_back(temp); \r\n        if (sum >= target)\r\n            return; \r\n        for (int i = index;  i < candidates.size();  ++i) {\r\n            if (sum + candidates[i] > target)\r\n                continue; \r\n            if (i == index || candidates[i] != candidates[i - 1]) {\r\n                temp.push_back(candidates[i]); \r\n                helper(candidates, target, sum + candidates[i], temp, i + 1); \r\n                temp.pop_back(); \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"candidates\": [2], \"candidates_element0\": [\"-1131501353\"], \"candidates_element1\": [\"434522717\"], \"target\": [\"-1601381093\"], \"sum\": [\"-1276727503\"], \"temp\": [1], \"temp_element0\": [\"-335199604\"], \"index\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void calcHour. /*FC*/class Solution {\n/*FM*/void calcHour(int hour, vector<int> &h) {\r\n        if (hour == 3) {\r\n            \r\n            \r\n        } else if (hour == 2) {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        } else if (hour == 1) {\r\n            \r\n            \r\n            \r\n            \r\n        } else if (hour == 0)\r\n            \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"hour\": [\"645809409\"], \"h\": [3], \"h_element0\": [\"-596706795\"], \"h_element1\": [\"-1567137620\"], \"h_element2\": [\"327574564\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void calcMin. /*FC*/class Solution {\n/*FM*/void calcMin(int min, vector<int> &m, vector<int> &occ, int minute,int pre) {\r\n        if (min == 0) {\r\n            \r\n            \r\n        }\r\n        for (int i = pre + 1;  i < 6;  ++i) {\r\n            if (occ[i] == 0) {\r\n                \r\n                \r\n                \r\n                \r\n                \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/void calcMin(int min, vector<int> &m, vector<int> &occ, int minute,int pre) {\r\n        if (min == 0) {\r\n            m.push_back(minute); \r\n            return; \r\n        }\r\n        for (int i = pre + 1;  i < 6;  ++i) {\r\n            if (occ[i] == 0) {\r\n                occ[i] = 1; \r\n                minute += pow(2, i); \r\n                calcMin(min - 1, m, occ, minute,i); \r\n                minute -= pow(2, i); \r\n                occ[i] = 0; \r\n            }\r\n        }\r\n    } void calcMin(int min, vector<int> &m, vector<int> &occ, int minute,int pre) {\r\n        if (min == 0) {\r\n            m.push_back(minute); \r\n            return; \r\n        }\r\n        for (int i = pre + 1;  i < 6;  ++i) {\r\n            if (occ[i] == 0) {\r\n                occ[i] = 1; \r\n                minute += pow(2, i); \r\n                calcMin(min - 1, m, occ, minute,i); \r\n                minute -= pow(2, i); \r\n                occ[i] = 0; \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"min\": [\"-36680907\"], \"m\": [2], \"m_element0\": [\"-1827206276\"], \"m_element1\": [\"502484765\"], \"occ\": [3], \"occ_element0\": [\"499150407\"], \"occ_element1\": [\"1042190390\"], \"occ_element2\": [\"-135770917\"], \"minute\": [\"1508255371\"], \"pre\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sumOfLeftLeaves. /*FC*/class Solution {\n/*FM*/int sumOfLeftLeaves(TreeNode *root) {\r\n        if (!root)\r\n            return 0; \r\n        int sum = 0; \r\n        if (root->left && !root->left->left && !root->left->right)\r\n            sum += root->left->val; \r\n        sum += sumOfLeftLeaves(root->left); \r\n        sum += sumOfLeftLeaves(root->right); \r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1556787547\"], \"root[0].val\": [\"-296797672\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-614161769\"], \"root[0].left[0].val\": [\"695368931\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-414357857\"], \"root[0].right[0].val\": [\"-595843538\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfArithmeticSlices. /*FC*/class Solution {\n/*FM*/int numberOfArithmeticSlices(vector<int> &A) {\r\n        int size = A.size(); \r\n        if (size <= 2) \r\n        int len = 0, num = 0; \r\n        for (int i = 1;  i < size - 1;  ++i) {\r\n            if (A[i] - A[i - 1] == A[i + 1] - A[i])\r\n                \r\n            else {\r\n                num += len * (len + 1) / 2; \r\n                len = 0; \r\n            }\r\n        }\r\n        if (len)\r\n            \r\n        return num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"759821087\"], \"A_element1\": [\"614898815\"], \"A_element2\": [\"-987944391\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfArithmeticSlices. /*FC*/class Solution {\n/*FM*/int numberOfArithmeticSlices(vector<int> &A) {\r\n        int size = A.size(); \r\n        if (size <= 2) return 0; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"-1762184728\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addStrings. /*FC*/class Solution {\n/*FM*/string addStrings(string num1, string num2) {\r\n        int m = num1.size(), n = num2.size(); \r\n        string longer, shorter; \r\n        if (m >= n) {\r\n            longer = num1; \r\n            shorter = num2; \r\n        } else {\r\n            \r\n            \r\n            \r\n        }\r\n        int carry = 0, i = 1; \r\n        while (i <= n) {\r\n            int sum = longer[m - i] - '0' + shorter[n - i] - '0' + carry; \r\n            carry = sum / 10; \r\n            sum %= 10; \r\n            longer[m - i] = sum + '0'; \r\n            ++i; \r\n        }\r\n        while (carry) {\r\n            if (m - i < 0) {\r\n                longer.insert(longer.begin(), '1'); \r\n                break; \r\n            }\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return longer; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"3\"], \"num2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPartition. /*FC*/class Solution {\n/*FM*/bool canPartition(vector<int> &nums) {\r\n        int n = nums.size(), sum = 0; \r\n        for (int i = 0;  i < n;  ++i)\r\n            sum += nums[i]; \r\n        if (sum % 2)\r\n            \r\n        sort(nums.rbegin(),nums.rend()); \r\n        return helper(nums, sum / 2, 0); \r\n    };/*F*//*C*//*M*/bool helper(vector<int> &nums, int sum, int i) {\r\n        if (sum == nums[i])\r\n            return true; \r\n        else if (sum < nums[i])\r\n            return false; \r\n        return helper(nums, sum - nums[i], i + 1) || helper(nums, sum, i + 1); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-810657836\"], \"nums_element1\": [\"-59802178\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPartition. /*FC*/class Solution {\n/*FM*/bool canPartition(vector<int> &nums) {\r\n        int n = nums.size(), sum = 0; \r\n        for (int i = 0;  i < n;  ++i)\r\n            sum += nums[i]; \r\n        if (sum % 2)\r\n            return false; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1442867771\"], \"nums_element1\": [\"491918968\"], \"nums_element2\": [\"-87406982\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countBattleships. /*FC*/class Solution {\n/*FM*/int countBattleships(vector<vector<char>>& board) {\r\n        int m = board.size(), n = m == 0 ? 0 : board[0].size(), res = 0; \r\n        for (int i = 0;  i < m;  ++i)\r\n            for (int j = 0;  j < n;  ++j)\r\n                if (board[i][j] == 'X' && (i + 1 == m ||  board[i + 1][j] == '.') && (j + 1 == n ||  board[i][j + 1] == '.'))\r\n                    \r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"board\": [2], \"board_element0\": [3], \"board_element0_element0\": [\"-16\"], \"board_element0_element1\": [\"93\"], \"board_element0_element2\": [\"61\"], \"board_element1\": [2], \"board_element1_element0\": [\"-26\"], \"board_element1_element1\": [\"92\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method Node *flatten. /*FC*/class Solution {\n/*FM*/Node *flatten(Node *head) {\r\n        if (!head)\r\n            \r\n        stack<Node *> s; \r\n        Node *root = head; \r\n        s.push(head); \r\n        while (!s.empty()) {\r\n            head = s.top(); \r\n            s.pop(); \r\n            if (head->next) \r\n            if (head->child) \r\n            head->child = nullptr; \r\n            if (!s.empty()) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return root; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"Node\", \"Node(int)\"], \"head0__val\": [\"-240925804\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMinArrowShots. /*FC*/class Solution {\n/*FM*/int findMinArrowShots(vector<pair<int, int>>& points) {\r\n        sort(points.begin(), points.end(), [](pair<int, int>& p1, pair<int, int>& p2){\r\n            return p1.first < p2.first; \r\n        }); \r\n        if (points.size() == 0)\r\n            \r\n        int start = points[0].first, end = points[0].second, count = 0; \r\n        for (int i = 1;  i < points.size();  ++i) {\r\n            if (max(points[i].first, start) <= min(points[i].second, end)) {\r\n                start = max(points[i].first, start); \r\n                end = min(points[i].second, end); \r\n            }\r\n            else {\r\n                ++count; \r\n                start = points[i].first; \r\n                end = points[i].second; \r\n            }\r\n        }\r\n        return count + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"points\": [3], \"points_element0.first\": [\"-1309101893\"], \"points_element0.second\": [\"1580072994\"], \"points_element1.first\": [\"389355379\"], \"points_element1.second\": [\"-703609146\"], \"points_element2.first\": [\"-1832875236\"], \"points_element2.second\": [\"-1015684262\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findContentChildren. /*FC*/class Solution {\n/*FM*/int findContentChildren(vector<int>& g, vector<int>& s) {\r\n        sort(g.begin(), g.end()); \r\n        sort(s.begin(), s.end()); \r\n        int i = s.size() - 1, j = g.size() - 1; \r\n        while (i >= 0 && j >= 0) {\r\n            if(s[i] >= g[j])\r\n                --i; \r\n            --j; \r\n        }\r\n        return s.size() - i - 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"g\": [3], \"g_element0\": [\"325132601\"], \"g_element1\": [\"1945239015\"], \"g_element2\": [\"-647736450\"], \"s\": [1], \"s_element0\": [\"2011187070\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hammingDistance. /*FC*/class Solution {\n/*FM*/int hammingDistance(int x, int y) {\r\n        int sum = 0; \r\n        while(x != 0 || y != 0) {\r\n            int i = x % 2, j = y  % 2; \r\n            cout << i << ' ' << j << endl; \r\n            sum += (i ^ j == 1 ? 1 : 0); \r\n            cout << sum << endl; \r\n            x /= 2; \r\n            y /= 2; \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"1\"], \"y\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int islandPerimeter. /*FC*/class Solution {\n/*FM*/int islandPerimeter(vector<vector<int>> &grid) {\r\n        auto size = grid.size(); \r\n        vector<vector<int>> visited; \r\n        for (int i = 0;  i < size;  ++i)\r\n            visited.push_back(vector<int>(grid[i].size(), 0)); \r\n        for (int i = 0;  i < size;  ++i)\r\n            for (int j = 0;  j < grid[i].size();  )\r\n                if (grid[i][j]) {\r\n                    helper(i, j, visited, grid); \r\n                    break; \r\n                }\r\n        return num; \r\n    };/*F*/int num = 0;  int diry[4] = {0, 1, -1, 0};/*C*//*M*/void helper(int &i, int &j, vector<vector<int>> &visited, vector<vector<int>> &grid) {\r\n        if (visited[i][j] == 1)\r\n            return; \r\n        visited[i][j] = 1; \r\n        int surrounded = 0; \r\n        for (int a = 0;  a < 4;  ++a) {\r\n            int tempX = i + dirx[a]; \r\n            int tempY = j + diry[a]; \r\n            if (tempX >= 0 && tempX < grid.size() && tempY >= 0 && tempY < grid[i].size() && grid[tempX][tempY] == 1) {\r\n                ++surrounded; \r\n                helper(tempX, tempY, visited, grid); \r\n            }\r\n        }\r\n        num += (4 - surrounded); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->dirx\": [4], \"AKA_INSTANCE___Solution->diry\": [4], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"910655586\"], \"grid_element0_element1\": [\"350673451\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"1941329620\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findSubstringInWraproundString. /*FC*/class Solution {\n/*FM*/int findSubstringInWraproundString(string p) {\r\n        int n = p.size(); \r\n        if (n == 0)\r\n            \r\n        vector<int> con(26, 0); \r\n        con[p[0] - 'a'] = 1; \r\n        int sum = 0, len = 1; \r\n        for (int i = 1;  i < n;  ) {\r\n            \r\n        }\r\n        for (int i = 0;  i < 26;  ++i)\r\n            sum += con[i]; \r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"p\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> permuteUnique. /*FC*/class Solution {\n/*FM*/vector<vector<int>> permuteUnique(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        vector<vector<int>> ret; \r\n        if (n == 0)\r\n            \r\n        sort(nums.begin(), nums.end()); \r\n        visited = vector<int>(n, 0); \r\n        vector<int> temp; \r\n        BackTracking(nums, 0, n, ret, temp); \r\n        return ret; \r\n    };/*F*/vector<int> visited;/*C*//*M*/void BackTracking(vector<int> &nums, int i, int &n, vector<vector<int>> &ret, vector<int> temp) {\r\n        if (temp.size() == n) {\r\n            ret.push_back(temp); \r\n            return; \r\n        }\r\n        for (int j = 0;  j < n;  ++j) {\r\n            if (j > 0 && nums[j] == nums[j - 1] && visited[j - 1] == 0)\r\n                continue; \r\n            if (visited[j] == 0) {\r\n                temp.push_back(nums[j]); \r\n                visited[j] = 1; \r\n                BackTracking(nums, j + 1, n, ret, temp); \r\n                visited[j] = 0; \r\n                temp.pop_back(); \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"100177098\"], \"nums_element1\": [\"558970815\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findRadius. /*FC*/class Solution {\n/*FM*/int findRadius(vector<int> &H, vector<int> &T) {\r\n        int size = H.size(), size_heaters = T.size(); \r\n        if (size == 0 || size_heaters == 0)\r\n            \r\n        sort(H.begin(), H.end()); \r\n        sort(T.begin(), T.end()); \r\n        vector<int> radius(size, -1); \r\n        for (int h = 0, t = 0;  h < size && t < size_heaters; ) {\r\n            if (T[t] < H[h])\r\n                ++t; \r\n            else {\r\n                radius[h] = T[t] - H[h]; \r\n                ++h; \r\n            }\r\n        }\r\n        for (int h = size - 1, t = size_heaters - 1;  h >= 0 && t >= 0; ) {\r\n            if (T[t] > H[h])\r\n                --t; \r\n            else {\r\n                radius[h] = radius[h] == -1 ? H[h] - T[t] : min(radius[h], H[h] - T[t]); \r\n                --h; \r\n            }\r\n        }\r\n        return *max_element(radius.begin(), radius.end()); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"H\": [3], \"H_element0\": [\"-1005072724\"], \"H_element1\": [\"1117990842\"], \"H_element2\": [\"-1481913985\"], \"T\": [3], \"T_element0\": [\"143106613\"], \"T_element1\": [\"1668750107\"], \"T_element2\": [\"1585031212\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTargetSumWays. /*FC*/class Solution {\n/*FM*/int findTargetSumWays(vector<int> &nums, int S) {\r\n        if (nums.size() == 0)\r\n            \r\n        int index = 0; \r\n        return calcS(nums, S, 1, nums[0]) + calcS(nums, S, 1, -nums[0]); \r\n    };/*F*//*C*//*M*/int calcS(const vector<int> &nums, const int &S, const int &index, const int &sum) {\r\n        if (index == nums.size()) {\r\n            if (sum == S)\r\n                return 1; \r\n            return 0; \r\n        }\r\n        return calcS(nums, S, index + 1, sum + nums[index]) + calcS(nums, S, index + 1, sum - nums[index]); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-378677961\"], \"nums_element1\": [\"-255889769\"], \"S\": [\"1451420010\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int calcS. /*FC*/class Solution {\n/*FM*/int calcS(const vector<int> &nums, const int &S, const int &index, const int &sum) {\r\n        if (index == nums.size()) {\r\n            \r\n            \r\n        }\r\n        return calcS(nums, S, index + 1, sum + nums[index]) + calcS(nums, S, index + 1, sum - nums[index]); \r\n    };/*F*//*C*//*M*/int calcS(const vector<int> &nums, const int &S, const int &index, const int &sum) {\r\n        if (index == nums.size()) {\r\n            if (sum == S)\r\n                return 1; \r\n            return 0; \r\n        }\r\n        return calcS(nums, S, index + 1, sum + nums[index]) + calcS(nums, S, index + 1, sum - nums[index]); \r\n    } int calcS(const vector<int> &nums, const int &S, const int &index, const int &sum) {\r\n        if (index == nums.size()) {\r\n            if (sum == S)\r\n                return 1; \r\n            return 0; \r\n        }\r\n        return calcS(nums, S, index + 1, sum + nums[index]) + calcS(nums, S, index + 1, sum - nums[index]); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-2049105166\"], \"nums_element1\": [\"-1565348805\"], \"nums_element2\": [\"1007338473\"], \"S\": [\"208739328\"], \"index\": [\"-910411820\"], \"sum\": [\"-618736425\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\r\n        int size = s.size(); \r\n        if (size <= 1)\r\n            return s; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> findWords. /*FC*/class Solution {\n/*FM*/vector<string> findWords(vector<string> &words) {\r\n        string tempRow0 = \"qwertyuiop\", tempRow1 = \"asdfghjkl\", tempRow2 = \"zxcvbnm\"; \r\n        unordered_set<char> first(tempRow0.begin(), tempRow0.end()),\r\n                second(tempRow1.begin(), tempRow1.end()),\r\n                third(tempRow2.begin(), tempRow2.end()); \r\n        vector<string> ret; \r\n        for (auto word : words) {\r\n            bool row = true; \r\n            unordered_set<char> temp; \r\n            temp = (first.find(tolower(word[0])) == first.end() ?\r\n                    (second.find(tolower(word[0])) == second.end() ? third : second) : first); \r\n            for (int i = 1;  i < word.size();  ) {\r\n                \r\n            }\r\n            if (row)\r\n                ret.push_back(word); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findMode. /*FC*/class Solution {\n/*FM*/vector<int> findMode(TreeNode *root) {\r\n        ret.clear(); \r\n        if (!root)\r\n            \r\n        prev = nullptr; \r\n        k = 0; \r\n        maxNum = 0; \r\n        inOrder(root); \r\n        return ret; \r\n    };/*F*/TreeNode *prev;  int k;  int maxNum;  vector<int> ret;/*C*//*M*/void inOrder(TreeNode *root) {\r\n        if (!root)\r\n            return; \r\n        inOrder(root->left); \r\n\r\n        if (prev) {\r\n            if (root->val == prev->val) {\r\n                ++k; \r\n                if (k > maxNum) {\r\n                    maxNum = k; \r\n                    ret.clear(); \r\n                    ret.push_back(root->val); \r\n                } else if (k == maxNum)\r\n                    ret.push_back(root->val); \r\n            } else {\r\n                k = 1; \r\n                if (k == maxNum)\r\n                    ret.push_back(root->val); \r\n            }\r\n        } else {\r\n            ret.push_back(root->val); \r\n            k = 1; \r\n            maxNum = 1; \r\n        }\r\n        prev = root; \r\n\r\n        inOrder(root->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->prev\": [1], \"AKA_INSTANCE___Solution->prev[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"AKA_INSTANCE___Solution_prev0_x\": [\"-1605732282\"], \"AKA_INSTANCE___Solution->k\": [\"-1062794000\"], \"AKA_INSTANCE___Solution->maxNum\": [\"-1474751031\"], \"AKA_INSTANCE___Solution->ret\": [2], \"AKA_INSTANCE___Solution_ret_element0\": [\"-1117287591\"], \"AKA_INSTANCE___Solution_ret_element1\": [\"35024656\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1811514644\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1060229846\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int CountSum. /*FC*/class Solution {\n/*FM*/int CountSum(TreeNode *node) {\r\n        if (!node)\r\n            return 0; \r\n        int &&leftSum = CountSum(node->left); \r\n        int &&rightSum = CountSum(node->right); \r\n        int &&currentSum = leftSum + rightSum + node->val; \r\n        ++sums[currentSum]; \r\n        return currentSum; \r\n    };/*F*/unordered_map<int, int> sums;/*C*//*M*/int CountSum(TreeNode *node) {\r\n        if (!node)\r\n            return 0; \r\n        int &&leftSum = CountSum(node->left); \r\n        int &&rightSum = CountSum(node->right); \r\n        int &&currentSum = leftSum + rightSum + node->val; \r\n        ++sums[currentSum]; \r\n        return currentSum; \r\n    } int CountSum(TreeNode *node) {\r\n        if (!node)\r\n            return 0; \r\n        int &&leftSum = CountSum(node->left); \r\n        int &&rightSum = CountSum(node->right); \r\n        int &&currentSum = leftSum + rightSum + node->val; \r\n        ++sums[currentSum]; \r\n        return currentSum; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"node\": [1], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"845752949\"], \"node[0].val\": [\"661263338\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int fib. /*FC*/class Solution {\n/*FM*/int fib(int N) {\r\n        if(N == 0)\r\n            \r\n        int i = 0, j = 1; \r\n        while (N > 1) {\r\n            int temp = i + j; \r\n            i = j; \r\n            j = temp; \r\n            --N; \r\n        }\r\n        return j; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int fib. /*FC*/class Solution {\n/*FM*/int fib(int N) {\r\n        if(N == 0)\r\n            return 0; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxSubArray. /*FC*/class Solution {\n/*FM*/int maxSubArray(vector<int> &nums) {\r\n        int size = nums.size(), prev = 0, curr = 0, ret = INT_MIN; \r\n        if (size == 0)\r\n            \r\n        for (int i = 0;  i < nums.size();  ++i) {\r\n            int val = prev + nums[i]; \r\n            ret = max(ret, val); \r\n            if (val > 0)\r\n                \r\n            else {\r\n                if (nums[i] > 0)\r\n                    \r\n                else\r\n                    curr = 0; \r\n            }\r\n            prev = curr; \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-831492784\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxSubArray. /*FC*/class Solution {\n/*FM*/int maxSubArray(vector<int> &nums) {\r\n        int size = nums.size(), prev = 0, curr = 0, ret = INT_MIN; \r\n        if (size == 0)\r\n            \r\n        for (int i = 0;  i < nums.size();  ++i) {\r\n            int val = prev + nums[i]; \r\n            ret = max(ret, val); \r\n            if (val > 0)\r\n                curr = val; \r\n            else {\r\n                \r\n            }\r\n            prev = curr; \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1091012807\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *convertBST. /*FC*/class Solution {\n/*FM*/TreeNode *convertBST(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        int m = 0; \r\n        Count(root, m); \r\n        return root; \r\n    };/*F*//*C*//*M*/void Count(TreeNode *root, int &m) {\r\n        if (!root)\r\n            return; \r\n        Count(root->right, m); \r\n        m += root->val; \r\n        root->val = m; \r\n        Count(root->left, m); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1383281344\"], \"root[2]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> spiralOrder. /*FC*/class Solution {\n/*FM*/vector<int> spiralOrder(vector<vector<int>> &matrix) {\r\n        int m = matrix.size(), n = m == 0 ? 0 : matrix[0].size(), x = 0, y = 0; \r\n        if (m == 0)\r\n            \r\n        vector<int> dir_x = {0, 1, 0, -1}, dir_y = {1, 0, -1, 0}, ret; \r\n        int dir = 0, i = 0, j = 0, k = m * n; \r\n        while (k > 0) {\r\n            ret.push_back(matrix[i][j]); \r\n            if (j + dir_y[dir] >= n) {\r\n                ++dir; \r\n                ++x; \r\n            } else if (j + dir_y[dir] < y) {\r\n                ++dir; \r\n                --m; \r\n            } else if (i + dir_x[dir] >= m) {\r\n                ++dir; \r\n                --n; \r\n            } else if (i + dir_x[dir] < x) {\r\n                dir = 0; \r\n                ++y; \r\n            }\r\n            i += dir_x[dir]; \r\n            j += dir_y[dir]; \r\n            --k; \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"2081041404\"], \"matrix_element0_element1\": [\"1725482171\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"-1586844664\"], \"matrix_element1_element1\": [\"1859762105\"], \"matrix_element1_element2\": [\"1085179683\"], \"matrix_element2\": [2], \"matrix_element2_element0\": [\"-742127775\"], \"matrix_element2_element1\": [\"1467364062\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int helper. /*FC*/class Solution {\n/*FM*/int helper(TreeNode *root) {\r\n        if (!root)\r\n            return 0; \r\n        else if (!root->left && !root->right)\r\n            \r\n        int leftLen = helper(root->left); \r\n        int rightLen = helper(root->right); \r\n        \r\n        \r\n        \r\n    };/*F*/int maxLen = 0;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->maxLen\": [\"1470917876\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1920656761\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root0_right0_x\": [\"479660315\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_x\": [\"-1813023387\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int helper. /*FC*/class Solution {\n/*FM*/int helper(TreeNode *root) {\r\n        if (!root)\r\n            return 0; \r\n        else if (!root->left && !root->right)\r\n            return 1; \r\n        int leftLen = helper(root->left); \r\n        int rightLen = helper(root->right); \r\n        int &&len = leftLen + rightLen; \r\n        if (maxLen < len) maxLen = len; \r\n        return 1 + (leftLen > rightLen ? leftLen : rightLen); \r\n    };/*F*/int maxLen = 0;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->maxLen\": [\"-903754305\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-880829162\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1222628180\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode()\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"142727785\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findCircleNum. /*FC*/class Solution {\n/*FM*/int findCircleNum(vector<vector<int>> &M) {\r\n        int n = M.size(); \r\n        if (n == 0)\r\n            \r\n        circle = vector<int>(n, 0); \r\n        vector<int> rank(n, 0); \r\n        for (int i = 0;  i < n;  ++i)\r\n            circle[i] = i; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            for (int j = i + 1;  j < n;  ++j) {\r\n                if (M[i][j] == 1) {\r\n                    \r\n                    \r\n                    \r\n                    if (rank[x] > rank[y])\r\n                        \r\n                    else {\r\n                        \r\n                        \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        unordered_set<int> s; \r\n        for (int i = 0;  i < n;  ++i)\r\n            s.insert(UnionFind(circle[i])); \r\n        return s.size(); \r\n    };/*F*/vector<int> circle;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"M\": [2], \"M_element0\": [1], \"M_element0_element0\": [\"734924914\"], \"M_element1\": [2], \"M_element1_element0\": [\"1635174930\"], \"M_element1_element1\": [\"2025841311\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int> &nums) {\r\n        int step = 0; \r\n        for (int i = 0;  i < nums.size() - 1;  ++i) {\r\n            int curr = i + nums[i]; \r\n            step = max(step, curr); \r\n            if (step <= i)\r\n                \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"146315159\"], \"nums_element1\": [\"-235415000\"], \"nums_element2\": [\"-1433178016\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkRecord. /*FC*/class Solution {\n/*FM*/bool checkRecord(string s) {\r\n        int a = 0, l = 0; \r\n        for (int i = 0;  i < s.size();  ++i) {\r\n            if (s[i] == 'L')\r\n                \r\n            else\r\n                l = 0; \r\n            if (s[i] == 'A')\r\n                \r\n            if (a >= 2 || l >= 3)\r\n                \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseWords. /*FC*/class Solution {\n/*FM*/string reverseWords(string s) {\r\n        int n = s.size(); \r\n        for (int i = 0;  i < n;  ++i) {\r\n            int j = i + 1; \r\n            while (j < n && s[j] != ' ')\r\n                \r\n            for (int k = i;  k < (j + i) / 2;  )\r\n                \r\n            i = j; \r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> merge. /*FC*/class Solution {\n/*FM*/vector<Interval> merge(vector<Interval> &intervals) {\r\n        vector<Interval> ret; \r\n        sort(intervals.begin(), intervals.end()); \r\n        for (int i = 0;  i < intervals.size();  ++i) {\r\n            if (ret.empty() || ret.back().end < intervals[i].start)\r\n                ret.push_back(intervals[i]); \r\n            else\r\n                \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [3], \"intervals_element0\": [\"Interval\", \"Interval()\"], \"intervals_element0.start\": [\"237341182\"], \"intervals_element0.end\": [\"586777144\"], \"intervals_element1\": [\"Interval\", \"Interval()\"], \"intervals_element1.start\": [\"1209830261\"], \"intervals_element1.end\": [\"429406360\"], \"intervals_element2\": [\"Interval\", \"Interval()\"], \"intervals_element2.start\": [\"61936023\"], \"intervals_element2.end\": [\"-856885544\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> merge. /*FC*/class Solution {\n/*FM*/vector<Interval> merge(vector<Interval> &intervals) {\r\n        vector<Interval> ret; \r\n        sort(intervals.begin(), intervals.end()); \r\n        for (int i = 0;  i < intervals.size();  ++i) {\r\n            if (ret.empty() || ret.back().end < intervals[i].start)\r\n                ret.push_back(intervals[i]); \r\n            else\r\n                ret.back().end = max(ret.back().end, intervals[i].end); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [3], \"intervals_element0\": [\"Interval\", \"Interval()\"], \"intervals_element0.start\": [\"-483688119\"], \"intervals_element0.end\": [\"-821684729\"], \"intervals_element1\": [\"Interval\", \"Interval()\"], \"intervals_element1.start\": [\"-1752728676\"], \"intervals_element1.end\": [\"1272132452\"], \"intervals_element2\": [\"Interval\", \"Interval()\"], \"intervals_element2.start\": [\"-1288814185\"], \"intervals_element2.end\": [\"835109355\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int subarraySum. /*FC*/class Solution {\n/*FM*/int subarraySum(vector<int> &nums, int k) {\r\n        int size = nums.size(), res = 0; \r\n        for (int i = 0;  i < size;  ++i) {\r\n            int sum = 0; \r\n            for (int j = i;  j < size;  ++j) {\r\n                sum += nums[j]; \r\n                res += sum == k; \r\n            }\r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-999954777\"], \"k\": [\"575444342\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int arrayPairSum. /*FC*/class Solution {\n/*FM*/int arrayPairSum(vector<int> &nums) {\r\n        sort(nums.begin(), nums.end()); \r\n        int sum = 0; \r\n        for (int i = 0;  i < nums.size();  i += 2)\r\n            sum += nums[i]; \r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"624768386\"], \"nums_element1\": [\"-601737662\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTilt. /*FC*/class Solution {\n/*FM*/int findTilt(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        tilt = 0; \r\n        helper(root, tilt); \r\n        return tilt; \r\n    };/*F*/int tilt = 0;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->tilt\": [\"-1092651899\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-61559992\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1556338251\"], \"root[2]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int helper. /*FC*/class Solution {\n/*FM*/int helper(TreeNode *root, int &tilt) {\r\n        if (!root)\r\n            return 0; \r\n        if (!root->left && !root->right)\r\n            return root->val; \r\n        int leftSum = helper(root->left, tilt); \r\n        int rightSum = helper(root->right, tilt); \r\n        tilt += abs(leftSum - rightSum); \r\n        return leftSum + rightSum + root->val; \r\n    };/*F*/int tilt = 0;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->tilt\": [\"659548825\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"215525092\"], \"root[0].val\": [\"2119004451\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"352060311\"], \"root[0].right[0].val\": [\"-1624899365\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"772866729\"], \"root[0].right[1].val\": [\"-587207389\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-348687013\"], \"root[1].val\": [\"477285371\"], \"root[1].left\": [1], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"1578406698\"], \"root[1].left[0].val\": [\"1390220169\"], \"root[1].right\": [1], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1].right[0].val\": [\"-555356902\"], \"tilt\": [\"-1775852999\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> matrixReshape. /*FC*/class Solution {\n/*FM*/vector<vector<int>> matrixReshape(vector<vector<int>> &nums, int r, int c) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        int m = nums[0].size(); \r\n        if (n * m != r * c)\r\n            return nums; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [2], \"nums_element0_element0\": [\"1707285883\"], \"nums_element0_element1\": [\"962263661\"], \"r\": [\"-317085935\"], \"c\": [\"-2019981487\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubtree. /*FC*/class Solution {\n/*FM*/bool isSubtree(TreeNode *s, TreeNode *t) {\r\n        if (!s)\r\n            return false; \r\n        return compareNode(s, t) || isSubtree(s->left, t) || isSubtree(s->right, t); \r\n    };/*F*//*C*//*M*/bool compareNode(TreeNode *s, TreeNode *t) {\r\n        if (!s && !t)\r\n            return true; \r\n        else if (!s || !t || s->val != t->val)\r\n            return false; \r\n        return compareNode(s->left, t->left) && compareNode(s->right, t->right); \r\n    } bool isSubtree(TreeNode *s, TreeNode *t) {\r\n        if (!s)\r\n            return false; \r\n        return compareNode(s, t) || isSubtree(s->left, t) || isSubtree(s->right, t); \r\n    } bool isSubtree(TreeNode *s, TreeNode *t) {\r\n        if (!s)\r\n            return false; \r\n        return compareNode(s, t) || isSubtree(s->left, t) || isSubtree(s->right, t); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [2], \"s[0]\": [\"TreeNode\", \"TreeNode()\"], \"s[0].left\": [3], \"s[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"s0_left0_x\": [\"1279927666\"], \"s[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"s0_left1_x\": [\"0\"], \"s[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"s0_left2_x\": [\"0\"], \"s[1]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool compareNode. /*FC*/class Solution {\n/*FM*/bool compareNode(TreeNode *s, TreeNode *t) {\r\n        if (!s && !t)\r\n            \r\n        else if (!s || !t || s->val != t->val)\r\n            return false; \r\n        \r\n    };/*F*//*C*//*M*/bool compareNode(TreeNode *s, TreeNode *t) {\r\n        if (!s && !t)\r\n            return true; \r\n        else if (!s || !t || s->val != t->val)\r\n            return false; \r\n        return compareNode(s->left, t->left) && compareNode(s->right, t->right); \r\n    } bool compareNode(TreeNode *s, TreeNode *t) {\r\n        if (!s && !t)\r\n            return true; \r\n        else if (!s || !t || s->val != t->val)\r\n            return false; \r\n        return compareNode(s->left, t->left) && compareNode(s->right, t->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(string s) {\r\n        int len = 0, i = s.size() - 1; \r\n        while (s[i] == ' ')\r\n            \r\n        while (i >= 0) {\r\n            if (s[i] == ' ')\r\n                \r\n            ++len; \r\n            --i; \r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int> &nums) {\r\n        int max_val = INT_MIN, min_val = INT_MAX, start = -1, end = -1, n = nums.size(); \r\n        for (int i = 0;  i < n - 1;  ++i) {\r\n            if (nums[i] > nums[i + 1]) {\r\n                \r\n                \r\n            }\r\n        }\r\n        for (start = 0;  start < n;  ++start) {\r\n            if (nums[start] > min_val)\r\n                \r\n        }\r\n        for (end = n - 1;  end >= 0;  --end) {\r\n            if (nums[end] < max_val)\r\n                \r\n        }\r\n        return start > end ? 0 : end - start + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1615412919\"], \"nums_element1\": [\"-377920843\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int> &nums) {\r\n        int max_val = INT_MIN, min_val = INT_MAX, start = -1, end = -1, n = nums.size(); \r\n        for (int i = 0;  i < n - 1;  ++i) {\r\n            if (nums[i] > nums[i + 1]) {\r\n                max_val = max(max_val, nums[i]); \r\n                min_val = min(min_val, nums[i + 1]); \r\n            }\r\n        }\r\n        for (start = 0;  start < n;  ) {\r\n            if (nums[start] > min_val)\r\n                break; \r\n        }\r\n        for (end = n - 1;  end >= 0;  ) {\r\n            if (nums[end] < max_val)\r\n                break; \r\n        }\r\n        return start > end ? 0 : end - start + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1193011367\"], \"nums_element1\": [\"-1438334283\"], \"nums_element2\": [\"-1590933402\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> generateMatrix. /*FC*/class Solution {\n/*FM*/vector<vector<int>> generateMatrix(int n) {\r\n        vector<vector<int>> ret(n, vector<int>(n, 0)); \r\n        int N = pow(n, 2), m = 1; \r\n        int left = 0, right = n - 1, top = 0, down = n - 1; \r\n        while (top <= down && left <= right) {\r\n            for (int y = left;  y <= right;  ++y)\r\n                ret[top][y] = m++; \r\n            ++top; \r\n            for (int x = top;  x <= down;  ++x)\r\n                ret[x][right] = m++; \r\n            --right; \r\n            for (int y = right;  y >= left;  --y)\r\n                ret[down][y] = m++; \r\n            --down; \r\n            for (int x = down;  x >= top;  --x)\r\n                ret[x][left] = m++; \r\n            ++left; \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *rotateRight. /*FC*/class Solution {\n/*FM*/ListNode *rotateRight(ListNode *head, int k) {\r\n        if (!head || !head->next || k == 0)\r\n            \r\n        int n = 0; \r\n        ListNode *temp = head, *tail = nullptr, *start = head, *end = nullptr; \r\n        while (temp) {\r\n            if (!temp->next)\r\n                tail = temp; \r\n            temp = temp->next; \r\n            ++n; \r\n        }\r\n        k %= n; \r\n        if(k == 0)\r\n            return head; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1661009820\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-280035022\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head0_next1_x\": [\"0\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head0_next2_x\": [\"0\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"464435338\"], \"head[2]\": [\"ListNode\", \"ListNode()\"], \"k\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *rotateRight. /*FC*/class Solution {\n/*FM*/ListNode *rotateRight(ListNode *head, int k) {\r\n        if (!head || !head->next || k == 0)\r\n            return head; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1792449005\"], \"head[1]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head1_x\": [\"948674218\"], \"head[2]\": [\"ListNode\", \"ListNode()\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *rotateRight. /*FC*/class Solution {\n/*FM*/ListNode *rotateRight(ListNode *head, int k) {\r\n        if (!head || !head->next || k == 0)\r\n            \r\n        int n = 0; \r\n        ListNode *temp = head, *tail = nullptr, *start = head, *end = nullptr; \r\n        while (temp) {\r\n            if (!temp->next)\r\n                tail = temp; \r\n            temp = temp->next; \r\n            ++n; \r\n        }\r\n        k %= n; \r\n        if(k == 0)\r\n            \r\n        n -= k; \r\n        while (n > 0) {\r\n            if (n == 1)\r\n                end = start; \r\n            start = start->next; \r\n            --n; \r\n        }\r\n        tail->next = head; \r\n        end->next = nullptr; \r\n        return start; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-2140789369\"], \"head[1]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head1_x\": [\"-1372400302\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"-245500758\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int triangleNumber. /*FC*/class Solution {\n/*FM*/int triangleNumber(vector<int> &nums) {\r\n        int num = 0, size = nums.size(); \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 2;  i < size;  ++i) {\r\n            if (nums[i] == 0)\r\n                \r\n            int j = 0, k = i - 1; \r\n            while (j < k) {\r\n                if (nums[j] + nums[k] > nums[i] && nums[j] - nums[k] < nums[i]) {\r\n                    \r\n                    \r\n                } else\r\n                    ++j; \r\n            }\r\n        }\r\n        return num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-285930202\"], \"nums_element1\": [\"228957183\"], \"nums_element2\": [\"1232007523\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int triangleNumber. /*FC*/class Solution {\n/*FM*/int triangleNumber(vector<int> &nums) {\r\n        int num = 0, size = nums.size(); \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 2;  i < size;  ++i) {\r\n            if (nums[i] == 0)\r\n                \r\n            int j = 0, k = i - 1; \r\n            while (j < k) {\r\n                if (nums[j] + nums[k] > nums[i] && nums[j] - nums[k] < nums[i]) {\r\n                    num += k - j; \r\n                    --k; \r\n                } else\r\n                    \r\n            }\r\n        }\r\n        return num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-777712272\"], \"nums_element1\": [\"-227798543\"], \"nums_element2\": [\"-2139835009\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int triangleNumber. /*FC*/class Solution {\n/*FM*/int triangleNumber(vector<int> &nums) {\r\n        int num = 0, size = nums.size(); \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 2;  i < size;  ) {\r\n            \r\n            \r\n            \r\n        }\r\n        return num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1682920864\"], \"nums_element1\": [\"1409807793\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniquePaths. /*FC*/class Solution {\n/*FM*/int uniquePaths(int m, int n) {\r\n        vector<int> grid(n, 0); \r\n        grid[0] = 1; \r\n        for (int i = 0;  i < m;  ++i)\r\n            for (int j = 1;  j < n;  ++j)\r\n                grid[j] += grid[j - 1]; \r\n        return grid[n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"6\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> levelOrder(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        vector<vector<int>> traversal; \r\n        vector<int> currentLevel = vector<int>(); \r\n        queue<TreeNode *> que; \r\n        que.push(root); \r\n        int size = 1; \r\n        while (!que.empty()) {\r\n            TreeNode *temp = que.front(); \r\n            que.pop(); \r\n            if (temp->left) \r\n            if (temp->right) \r\n            currentLevel.push_back(temp->val); \r\n            --size; \r\n            if (size == 0) {\r\n                size = que.size(); \r\n                traversal.push_back(currentLevel); \r\n                currentLevel = vector<int>(); \r\n            }\r\n        }\r\n        return traversal; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1449200532\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-789754791\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string removeOuterParentheses. /*FC*/class Solution {\n/*FM*/string removeOuterParentheses(string S) {\r\n        string ret; \r\n        int empty = 0, start = 0; \r\n        for (int i = 0;  i < S.size();  ++i) {\r\n            char c = S[i]; \r\n            if (c == '(')\r\n                \r\n            else if (c == ')')\r\n                \r\n            if (empty == 0) {\r\n                ret += S.substr(start + 1, i - start - 1); \r\n                start = i + 1; \r\n            }\r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution {\n/*FM*/int videoStitching(vector<vector<int>> &clips, int T) {\r\n        int n = clips.size(); \r\n        sort(begin(clips), end(clips)); \r\n        vector<int> DP(T); \r\n        int res = 0, start = 0, end = 0, i = 0; \r\n        while (end < T) {\r\n            while (i < n && clips[i][0] <= start) {\r\n                end = max(end, clips[i][1]); \r\n                ++i; \r\n            }\r\n            if (start == end)\r\n                \r\n            ++res; \r\n            start = end; \r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"clips\": [2], \"clips_element0\": [1], \"clips_element0_element0\": [\"1507183467\"], \"clips_element1\": [1], \"clips_element1_element0\": [\"-1012732265\"], \"T\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution {\n/*FM*/int videoStitching(vector<vector<int>> &clips, int T) {\r\n        int n = clips.size(); \r\n        sort(begin(clips), end(clips)); \r\n        vector<int> DP(T); \r\n        int res = 0, start = 0, end = 0, i = 0; \r\n        while (end < T) {\r\n            while (i < n && clips[i][0] <= start) {\r\n                \r\n                \r\n            }\r\n            if (start == end)\r\n                return -1; \r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"clips\": [3], \"clips_element0\": [2], \"clips_element0_element0\": [\"57648908\"], \"clips_element0_element1\": [\"1696100479\"], \"clips_element1\": [1], \"clips_element1_element0\": [\"1025713737\"], \"clips_element2\": [3], \"clips_element2_element0\": [\"1582889733\"], \"clips_element2_element1\": [\"270142049\"], \"clips_element2_element2\": [\"1181577970\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *Construct. /*FC*/class Solution {\n/*FM*/TreeNode *Construct(int level, string &S, int &pos, int &back) {\r\n        if (pos >= S.size())\r\n            return nullptr; \r\n        \r\n        \r\n            \r\n        \r\n        (len != level + 1) {\r\n            \r\n            \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"level\": [\"-1387516558\"], \"S\": [\"1\"], \"pos\": [\"3\"], \"back\": [\"-680363846\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int helper. /*FC*/class Solution \r {\n/*FM*/int helper(int i, int n, int k, int target,int curr_sum, vector<vector<int>> &dp)\r\n    {\r\n        if(i == n+1 and curr_sum == target) \r\n            \r\n        if(i>n || curr_sum>target) return 0; \r\n        \r\n        if(dp[i][curr_sum] != -1) \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->MOD\": [\"6062612550686275624\"], \"i\": [\"-714166961\"], \"n\": [\"-761281314\"], \"k\": [\"9\"], \"target\": [\"1422452453\"], \"curr_sum\": [\"-1002874241\"], \"dp\": [3], \"dp_element0\": [2], \"dp_element0_element0\": [\"-363635292\"], \"dp_element0_element1\": [\"1299141335\"], \"dp_element1\": [1], \"dp_element1_element0\": [\"130660887\"], \"dp_element2\": [1], \"dp_element2_element0\": [\"65446438\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(int x,int y,vector<vector<char>>& grid){\r\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size())\r\n            return; \r\n        if(grid[x][y]!='1' || grid[x][y]=='2')\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->mem\": [\"-113501579\"], \"x\": [\"137084634\"], \"y\": [\"1987171039\"], \"grid\": [1], \"grid_element0\": [1], \"grid_element0_element0\": [\"-86\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numIslands. /*FC*/class Solution {\n/*FM*/int numIslands(vector<vector<char>>& grid) {\r\n        int n=grid.size(),m=grid[0].size(); \r\n        int ans=0; \r\n        for(int i=0; i<n; i++){\r\n            for(int j=0; j<m; j++){\r\n                if(grid[i][j]=='1'){\r\n                    \r\n                    \r\n                    \n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->mem\": [\"-1994128066\"], \"grid\": [3], \"grid_element0\": [1], \"grid_element0_element0\": [\"9\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"-2\"], \"grid_element1_element1\": [\"24\"], \"grid_element2\": [1], \"grid_element2_element0\": [\"-128\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *oddEvenList. /*FC*/class Solution\r {\n/*FM*/ListNode *oddEvenList(ListNode *head)\r\n    {\r\n        if (head == NULL)\r\n            \r\n        ListNode *odd = head; \r\n        ListNode *curr = head->next; \r\n        while (curr && curr->next)\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[1]\": [\"ListNode\", \"ListNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(vector<vector<int>>& heights, vector<vector<int>>& vis, int x, int y, int curr) {\r\n        if (x >= heights.size() || y >= heights[0].size() || x < 0 || y < 0) {\r\n            return false; \r\n        }\r\n        if (vis[x][y])\r\n        if (heights[x][y] < curr)\r\n        \r\n    };/*F*/vector <int> dx = {1, -1, 0, 0};/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"heights\": [1], \"heights_element0\": [2], \"heights_element0_element0\": [\"144183174\"], \"heights_element0_element1\": [\"-506144300\"], \"vis\": [2], \"vis_element0\": [2], \"vis_element0_element0\": [\"-1304803658\"], \"vis_element0_element1\": [\"913034278\"], \"vis_element1\": [1], \"vis_element1_element0\": [\"1210554852\"], \"x\": [\"-701921078\"], \"y\": [\"767521575\"], \"curr\": [\"-810818728\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool ispal. /*FC*/class Solution {\n/*FM*/bool ispal(string s){\r\n        if(s.size() == 1)   return true; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void func. /*FC*/class Solution {\n/*FM*/void func(string s,int i,int j, vector<string> &temp){\r\n        if(j==s.size() && i==s.size()){\r\n            \r\n            \r\n        }\r\n        if(j==s.size()){\r\n            \r\n        }\r\n        string sub = s.substr(i,j-i+1); \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->ans\": [2], \"AKA_INSTANCE___Solution_ans_element0\": [2], \"AKA_INSTANCE___Solution_ans_element0_element0\": [\"1\"], \"AKA_INSTANCE___Solution_ans_element0_element1\": [\"2\"], \"AKA_INSTANCE___Solution_ans_element1\": [1], \"AKA_INSTANCE___Solution_ans_element1_element0\": [\"1\"], \"s\": [\"3\"], \"i\": [\"292889983\"], \"j\": [\"1000683021\"], \"temp\": [1], \"temp_element0\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *partition. /*FC*/class Solution\r {\n/*FM*/ListNode *partition(ListNode *head, int x)\r\n    {\r\n        if (head != nullptr && head->next != nullptr)\r\n        {\r\n            ListNode *curr = head; \r\n            ListNode *prev = nullptr; \r\n            ListNode *flag = nullptr; \r\n            ListNode *temp; \r\n            while (curr != nullptr)\r\n            {\r\n                temp = curr->next; \r\n                if (curr->val >= x)\r\n                    \r\n                else\r\n                {\r\n                    if (flag == prev)\r\n                    {\r\n                        flag = curr; \r\n                        prev = curr; \r\n                    }\r\n                    else\r\n                    {\r\n                        \r\n                        \r\n                    }\r\n                }\r\n                curr = temp; \r\n            }\r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"1057139125\"], \"x\": [\"1564954448\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *partition. /*FC*/class Solution\r {\n/*FM*/ListNode *partition(ListNode *head, int x)\r\n    {\r\n        if (head != nullptr && head->next != nullptr)\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1983913976\"], \"x\": [\"-1065484620\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasPathSum. /*FC*/class Solution {\n/*FM*/bool hasPathSum(TreeNode* root, int targetSum) {\r\n        if(root==NULL){\r\n           \r\n            return false; \r\n        }\r\n        if(root->left==NULL&&root->right==NULL){\r\n            if(targetSum-root->val==0){\r\n                \r\n            }\r\n        }\r\n        return hasPathSum(root->left,targetSum-root->val)||hasPathSum(root->right,targetSum-root->val); \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"592656792\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[0].val\": [\"1199236106\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[1].val\": [\"1570558460\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"386484429\"], \"root[0].right[0].val\": [\"1356910815\"], \"targetSum\": [\"-77992646\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int romanToInt. /*FC*/class Solution {\n/*FM*/int romanToInt(string s) {\r\n        if(s.empty()) \r\n        int returnValue = 0; \r\n        for(unsigned int i=0;  i<s.size()-1;  ) {\r\n            \r\n        }\r\n        returnValue += getTranslateNum(s[s.size()-1]); \r\n        return returnValue; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution {\n/*FM*/void rotate(vector<int>& nums, int k) {\r\n        int n=nums.size(); \r\n        vector<int> temp(n); \r\n        for(int i=0; i<n; i++){\r\n            temp[(i+k)%n]=nums[i]; \r\n        }\r\n        nums=temp; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"132\"], \"k\": [\"-1586083458\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution {\n/*FM*/void rotate(vector<int>& nums, int k) {\r\n        vector<int> temp(nums.size()); \r\n        \r\n        for(int i=0; i<nums.size(); i++){\r\n            temp[(k+i)%nums.size()]=nums[i]; \r\n        }\r\n        \r\n        nums=temp; \r\n        \r\n        return; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-458\"], \"k\": [\"606294897\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> runningSum. /*FC*/class Solution {\n/*FM*/vector<int> runningSum(vector<int>& nums) {\r\n        vector<int> ans; \r\n        int n = nums.size(); \r\n        int sum=0; \r\n        for(int i=0; i<n; i++){\r\n            sum = sum + nums[i]; \r\n            ans.push_back(sum); \r\n        }\r\n        \r\n        return ans; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"901\"], \"nums_element1\": [\"-651\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void unionn. /*FC*/class Solution {\n/*FM*/void unionn(int a,int b,vector<int> &p,vector<int> &rank){\r\n        if(p[a] == p[b])    \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if(rank[pa] == rank[pb]){\r\n            \r\n            \r\n        }\r\n        else if(rank[pa] < rank[pb]){\r\n            \r\n        }\r\n        else{\r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"-1996938824\"], \"b\": [\"77391595\"], \"p\": [1], \"p_element0\": [\"-658\"], \"rank\": [2], \"rank_element0\": [\"-293\"], \"rank_element1\": [\"-485\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool equationsPossible. /*FC*/class Solution {\n/*FM*/bool equationsPossible(vector<string>& equations) {\r\n        vector<int> p(26), rank(26,0); \r\n        for(int i=0;  i<26;  i++) p[i]=i; \r\n        \r\n        for(auto x: equations){\r\n            if(x[1] == '='){\r\n                \r\n            }\r\n        }\r\n        for(auto x: equations){\r\n            if(x[1] == '!'){\r\n                \r\n                \r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"equations\": [2], \"equations_element0\": [\"2\"], \"equations_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int bin_search. /*FC*/class Solution {\n/*FM*/int bin_search(vector<int>& nums, int target, int s, int e){\r\n        while(s<=e){\r\n            int mid = s + (e-s)/2; \r\n            if(nums[mid] == target)\r\n                \r\n            if(nums[mid]>target)\r\n                \r\n            else\r\n                s = mid + 1; \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-398\"], \"nums_element1\": [\"-388\"], \"target\": [\"1468328636\"], \"s\": [\"5\"], \"e\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int bin_search. /*FC*/class Solution {\n/*FM*/int bin_search(vector<int>& nums, int target, int s, int e){\r\n        while(s<=e){\r\n            int mid = s + (e-s)/2; \r\n            if(nums[mid] == target)\r\n                \r\n            if(nums[mid]>target)\r\n                e = mid - 1; \r\n            else\r\n                \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"811\"], \"nums_element1\": [\"248\"], \"target\": [\"-343880313\"], \"s\": [\"1\"], \"e\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& nums, int target) {\r\n        int n = nums.size(); \r\n        int l = 0, r = n-1; \r\n        \r\n        while(l<r){\r\n            int mid = l + (r-l)/2; \r\n            if(nums[mid]>nums[r])\r\n                l = mid+1; \r\n            else\r\n                \r\n        }\r\n        \r\n        if(target<=nums[n-1])\r\n            \r\n        else\r\n            return bin_search(nums, target, 0, l-1); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"71\"], \"nums_element1\": [\"-133\"], \"target\": [\"826506323\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& nums, int target) {\r\n        int n = nums.size(); \r\n        int l = 0, r = n-1; \r\n        \r\n        while(l<r){\r\n            int mid = l + (r-l)/2; \r\n            if(nums[mid]>nums[r])\r\n                l = mid+1; \r\n            else\r\n                \r\n        }\r\n        \r\n        if(target<=nums[n-1])\r\n            return bin_search(nums, target, l, n-1); \r\n        else\r\n            \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"393\"], \"nums_element1\": [\"-905\"], \"target\": [\"-278675989\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string restoreString. /*FC*/class Solution {\n/*FM*/string restoreString(string s, vector<int>& indices) {    \r\n    string res=s; \r\n\r\n    for(int i=0;  i<s.size(); i++){\r\n        res[indices[i]] = s[i]; \r\n    }\r\n    \r\n    return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"indices\": [1], \"indices_element0\": [\"470\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        \r\n        stack<string> st; \r\n        string res; \r\n        \r\n        for(int i = 0;   i<path.size();  ++i)\r\n        {\r\n            if(path[i] == '/')    \r\n                \r\n            string temp; \r\n\t\t\t\n            while(i < path.size() && path[i] != '/')\r\n            {\r\n\t\t\t\t\n                temp += path[i]; \r\n                ++i; \r\n            }\r\n\r\n            if(temp == \".\")\r\n                \r\n\t\t\t\n            else if(temp == \"..\")\r\n            {\r\n                \r\n            }\r\n            else\r\n\t\t\t\n                st.push(temp); \r\n        }\r\n        \r\n\t\t\n        while(!st.empty())\r\n        {\r\n            res = \"/\" + st.top() + res; \r\n            st.pop(); \r\n        }\r\n        \r\n\t\t\n        if(res.size() == 0)\r\n            \r\n        \r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"path\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors. /*FC*/class Solution {\n/*FM*/void sortColors(vector<int>& nums) {\r\n        int low = 0; \r\n        int mid = 0; \r\n        int high = nums.size()-1; \r\n        \r\n        while(mid <= high){\r\n            if(nums[mid] == 0){\r\n                \r\n                \r\n                \r\n            }\r\n            else if(nums[mid] == 1){\r\n                \r\n            }\r\n            else{\r\n                swap(nums[mid],nums[high]); \r\n                high--; \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"406\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool findTarget. /*FC*/class Solution {\n/*FM*/bool findTarget(TreeNode* root, int k) {\r\n        int i, j; \r\n        vector<int>v; \r\n        func(root, v); \r\n        i=0; \r\n        j=v.size()-1; \r\n        while(i<j)\r\n        {\r\n            \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/void func(TreeNode *n, vector<int>&v)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, v); \r\n        v.push_back(n->val); \r\n        func(n->right, v); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_x\": [\"-236\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"], \"k\": [\"-148462693\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void inorder. /*FC*/class Solution {\n/*FM*/void inorder(TreeNode* root){\r\n        if(root==NULL) return; \r\n        inorder(root->left); \r\n        v.push_back(root->val); \r\n        inorder(root->right); \r\n    };/*F*/vector<int> v;/*C*//*M*/void inorder(TreeNode* root){\r\n        if(root==NULL) return; \r\n        inorder(root->left); \r\n        v.push_back(root->val); \r\n        inorder(root->right); \r\n    } void inorder(TreeNode* root){\r\n        if(root==NULL) return; \r\n        inorder(root->left); \r\n        v.push_back(root->val); \r\n        inorder(root->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->v\": [1], \"AKA_INSTANCE___Solution_v_element0\": [\"385\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-251\"], \"root[0].val\": [\"283\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[0].val\": [\"233\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[1].val\": [\"642\"], \"root[0].right\": [3], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root0_right0_x\": [\"281\"], \"root[0].right[0].val\": [\"-155\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root0_right1_x\": [\"74\"], \"root[0].right[1].val\": [\"108\"], \"root[0].right[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right2_x\": [\"-653\"], \"root[0].right[2].val\": [\"-136\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidBST. /*FC*/class Solution {\n/*FM*/bool isValidBST(TreeNode* root) {\r\n        inorder(root); \r\n        for(int i=0; i<v.size()-1; i++){\r\n            if(v[i]>=v[i+1]){\r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*/vector<int> v;/*C*//*M*/void inorder(TreeNode* root){\r\n        if(root==NULL) return; \r\n        inorder(root->left); \r\n        v.push_back(root->val); \r\n        inorder(root->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->v\": [1], \"AKA_INSTANCE___Solution_v_element0\": [\"557\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"577\"], \"root[0].val\": [\"717\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidBST. /*FC*/class Solution {\n/*FM*/bool isValidBST(TreeNode* root) {\r\n        inorder(root); \r\n        for(int i=0; i<v.size()-1; ){\r\n            if(v[i]>=v[i+1]){\r\n                return false; \r\n            }\r\n        }\r\n        \r\n    };/*F*/vector<int> v;/*C*//*M*/void inorder(TreeNode* root){\r\n        if(root==NULL) return; \r\n        inorder(root->left); \r\n        v.push_back(root->val); \r\n        inorder(root->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->v\": [2], \"AKA_INSTANCE___Solution_v_element0\": [\"955\"], \"AKA_INSTANCE___Solution_v_element1\": [\"204\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-842\"], \"root[0].val\": [\"-475\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> threeSum. /*FC*/class Solution \r {\n/*FM*/vector<vector<int>> threeSum(vector<int>& nums) {\r\n        if(nums.size()<=2) return {}; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-438\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> fourSum. /*FC*/class Solution \r {\n/*FM*/vector<vector<int>> fourSum(vector<int>& nums, int target) {\r\n        if(nums.size()<=3) return {}; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"25\"], \"nums_element1\": [\"-496\"], \"target\": [\"606782357\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\r\n        string result; \r\n        int carry = 0; \r\n        for(int idxA = a.size()-1, idxB = b.size()-1;  idxA>=0 || idxB>=0;  idxA--, idxB--) {\r\n            int aNum = idxA >=0 ? a[idxA]-'0' : 0; \r\n            int bNum = idxB >=0 ? b[idxB]-'0' : 0; \r\n            int curPosNum = aNum + bNum + carry; \r\n            int tempRe = curPosNum%2; \r\n            carry = curPosNum/2; \r\n            result.insert(result.begin(), tempRe+'0'); \r\n        }\r\n        if(carry > 0) \r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"1\"], \"b\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\r\n        string result; \r\n        int carry = 0; \r\n        for(int idxA = a.size()-1, idxB = b.size()-1;  idxA>=0 || idxB>=0;  idxA--, idxB--) {\r\n            int aNum = idxA >=0 ? a[idxA]-'0' : 0; \r\n            int bNum = idxB >=0 ? b[idxB]-'0' : 0; \r\n            int curPosNum = aNum + bNum + carry; \r\n            int tempRe = curPosNum%2; \r\n            carry = curPosNum/2; \r\n            result.insert(result.begin(), tempRe+'0'); \r\n        }\r\n        if(carry > 0) result.insert(result.begin(), carry+'0'); \r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"1\"], \"b\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> asteroidCollision. /*FC*/class Solution {\n/*FM*/vector<int> asteroidCollision(vector<int>& a) {\r\n        stack<int>s; \r\n        vector<int>v; \r\n        s.push(a[0]); \r\n        \r\n        for(int i=1; i<a.size(); i++){\r\n            if(a[i]>0) \r\n            else{\r\n                int f=0; \r\n                while(s.empty()==false && s.top()>0 ){\r\n                   if(s.top()==abs(a[i])){\r\n                       \r\n                       \r\n                       \r\n                   }\r\n                else if(s.top()<abs(a[i])){\r\n                    s.pop(); \r\n                    \r\n                }\r\n               else{\r\n                   \r\n                   \r\n               }    \r\n            }\r\n            if(f==0) s.push(a[i]); \r\n           \r\n        }\r\n    }\r\n         while(s.empty()==false){\r\n            v.push_back(s.top()); \r\n             s.pop(); \r\n        }\r\n        reverse(v.begin(),v.end()); \r\n        return v; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [2], \"a_element0\": [\"65\"], \"a_element1\": [\"-662\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> asteroidCollision. /*FC*/class Solution {\n/*FM*/vector<int> asteroidCollision(vector<int>& a) {\r\n        stack<int>s; \r\n        vector<int>v; \r\n        s.push(a[0]); \r\n        \r\n        for(int i=1; i<a.size(); i++){\r\n            if(a[i]>0) s.push(a[i]); \r\n            else{\r\n                \r\n                \r\n            \r\n           \r\n        }\r\n    }\r\n         while(s.empty()==false){\r\n            v.push_back(s.top()); \r\n             s.pop(); \r\n        }\r\n        reverse(v.begin(),v.end()); \r\n        return v; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [2], \"a_element0\": [\"226\"], \"a_element1\": [\"311\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool backspaceCompare. /*FC*/class Solution {\n/*FM*/bool backspaceCompare(string s, string t) {\r\n        string temp1 = \"\"; \r\n        string temp2 = \"\"; \r\n        \r\n        for(int i = 0;  i<s.length();  i++){\r\n            if(s[i] == '#' && temp1.length()>0)\r\n                \r\n            else if(s[i] != '#'){\r\n                temp1.push_back(s[i]); \r\n            }\r\n        }\r\n        \r\n        for(int i = 0;  i<t.length();  i++){\r\n            if(t[i] == '#' && temp2.length()>0)\r\n                \r\n            else if(t[i] != '#'){\r\n                temp2.push_back(t[i]); \r\n            }\r\n        }\r\n        \r\n        return temp1 == temp2; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution \r {\n/*FM*/int maxProfit(vector<int>& prices) {\r\n        int m=prices[0],ans=0; \r\n        for(int i=1; i<prices.size(); i++){\r\n            if(prices[i]>m){\r\n                \r\n            }\r\n            m=prices[i]; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"109\"], \"prices_element1\": [\"-752\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution \r {\n/*FM*/int maxProfit(vector<int>& prices) {\r\n        int m=prices[0],ans=0; \r\n        for(int i=1; i<prices.size(); i++){\r\n            if(prices[i]>m){\r\n                ans+=(prices[i]-m); \r\n            }\r\n            m=prices[i]; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"-78\"], \"prices_element1\": [\"901\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution \r {\n/*FM*/int maxProfit(vector<int>& prices) {\r\n        int m=prices[0],ans=0; \r\n        for(int i=1; i<prices.size(); i++){\r\n            if(prices[i]>m) \r\n            else m=prices[i]; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"-8\"], \"prices_element1\": [\"-880\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution \r {\n/*FM*/int maxProfit(vector<int>& prices) {\r\n        int m=prices[0],ans=0; \r\n        for(int i=1; i<prices.size(); i++){\r\n            if(prices[i]>m) ans=max(ans,prices[i]-m); \r\n            else \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"-910\"], \"prices_element1\": [\"-756\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void _push. /*FC*/class BSTIterator {\n/*FM*/void _push(TreeNode *n)\r\n    {\r\n        while(n)\r\n        {\r\n            st.push(n); \r\n            n=n->left; \r\n        }\r\n    };/*F*/stack<TreeNode *> st;/*C*/BSTIterator(TreeNode* root) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___BSTIterator\": [\"BSTIterator\", \"BSTIterator(TreeNode*)\"], \"AKA_INSTANCE___BSTIterator_root\": [2], \"AKA_INSTANCE___BSTIterator_root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"AKA_INSTANCE___BSTIterator_root0_x\": [\"578\"], \"AKA_INSTANCE___BSTIterator_root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"AKA_INSTANCE___BSTIterator_root1_x\": [\"-290\"], \"n\": [1], \"n[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"n0_x\": [\"781\"], \"n[0].left\": [2], \"n[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"n0_left0_x\": [\"644\"], \"n[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"n0_left1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCameraCover. /*FC*/class Solution {\n/*FM*/int minCameraCover(TreeNode* root) {\r\n        int ans = 0; \r\n        auto p = cal(root,ans); \r\n        if(p.second == false)   ans++; \r\n        return ans; \r\n    };/*F*//*C*//*M*/pair<bool,bool> cal(TreeNode* root,int &ans){\r\n        if(!root){\r\n            return {false,true}; \r\n        }\r\n        auto l = cal(root->left,ans); \r\n        auto r = cal(root->right,ans); \r\n        bool cam = false, mon = false; \r\n        if(l.first || r.first){\r\n           mon = true; \r\n        }\r\n        if(l.second==false || r.second==false){\r\n            ans++; \r\n            cam = true; \r\n            mon = true; \r\n        }\r\n        return {cam,mon}; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> levelOrder(TreeNode* root) {\r\n        vector<vector<int>> ans; \r\n        vector<int> add; \r\n        if(!root)\r\n            \r\n        \r\n        queue<TreeNode*> mq; \r\n        mq.push(root); \r\n\r\n        while(mq.size() > 0){\r\n            int count = mq.size(); \r\n            for(int i = 0;  i < count;  i++){\r\n                root = mq.front(); \r\n                mq.pop(); \r\n                add.push_back(root->val); \r\n\r\n                if(root->left != NULL)\r\n                    \r\n\r\n                if(root->right != NULL)\r\n                    \r\n                }\r\n                ans.push_back(add); \r\n                add.clear(); \r\n            }\r\n    \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-748\"], \"root[0].val\": [\"811\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"11\"], \"root[1].val\": [\"31\"], \"root[1].left\": [2], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1].left[0].val\": [\"-585\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_left1_x\": [\"-345\"], \"root[1].left[1].val\": [\"-756\"], \"root[1].right\": [2], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1].right[0].val\": [\"-881\"], \"root[1].right[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_right1_x\": [\"-925\"], \"root[1].right[1].val\": [\"-676\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> levelOrder(TreeNode* root) {\r\n            if(root==NULL)\r\n               \r\n           vector<vector<int>> ans;  \r\n            queue<TreeNode*> q; \r\n            q.push(root); \r\n            TreeNode *temp; \r\n            int len; \r\n            while(!q.empty()){\r\n               len=q.size(); \r\n\t\t       vector<int> v; \r\n               for(int i=0; i<len; i++){\r\n                    temp=q.front(); \r\n                    q.pop(); \r\n                    v.push_back(temp->val); \r\n\r\n                   if(temp->left) \r\n                   if(temp->right) \r\n                }\r\n\t\t        ans.push_back(v); \r\n            }\r\n          return ans; \r\n        };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sum. /*FC*/class Solution {\n/*FM*/int sum(TreeNode* root){\r\n        if(!root){\r\n            return 0; \r\n        }\r\n        if(!root->left && !root->right){\r\n            ans = max(ans,root->val); \r\n            return root->val; \r\n        }\r\n        int l = sum(root->left); \r\n        int r = sum(root->right); \r\n        int ret = max(l+root->val,r+root->val); \r\n        ans = max(ans,max(max(ret,root->val),l+r+root->val)); \r\n        return max(ret,root->val); \r\n    };/*F*/int ans = 0;/*C*//*M*/int sum(TreeNode* root){\r\n        if(!root){\r\n            return 0; \r\n        }\r\n        if(!root->left && !root->right){\r\n            ans = max(ans,root->val); \r\n            return root->val; \r\n        }\r\n        int l = sum(root->left); \r\n        int r = sum(root->right); \r\n        int ret = max(l+root->val,r+root->val); \r\n        ans = max(ans,max(max(ret,root->val),l+r+root->val)); \r\n        return max(ret,root->val); \r\n    } int sum(TreeNode* root){\r\n        if(!root){\r\n            return 0; \r\n        }\r\n        if(!root->left && !root->right){\r\n            ans = max(ans,root->val); \r\n            return root->val; \r\n        }\r\n        int l = sum(root->left); \r\n        int r = sum(root->right); \r\n        int ret = max(l+root->val,r+root->val); \r\n        ans = max(ans,max(max(ret,root->val),l+r+root->val)); \r\n        return max(ret,root->val); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->ans\": [\"359\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"813\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[0].val\": [\"594\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"393\"], \"root[0].left[1].val\": [\"433\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rangeBitwiseAnd. /*FC*/class Solution {\n/*FM*/int rangeBitwiseAnd(int left, int right) {\r\n        int ans = 0; \r\n        while(left<right){\r\n            left >>= 1; \r\n            right >>= 1; \r\n            ans++; \r\n        }\r\n        \r\n        return right<<ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"left\": [\"3\"], \"right\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string breakPalindrome. /*FC*/class Solution {\n/*FM*/string breakPalindrome(string palindrome) {\r\n        \n        int n = palindrome.length(); \r\n        if(n == 1)return \"\"; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"palindrome\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool xorGame. /*FC*/class Solution {\n/*FM*/bool xorGame(vector<int>& nums) {\r\n        int x=nums[0]; \r\n        for(int i=1; i<nums.size(); i++) x^=nums[i]; \r\n        if(x==0) \r\n        return !(nums.size()&1); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"878\"], \"nums_element1\": [\"-113\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> getConcatenation. /*FC*/class Solution {\n/*FM*/vector<int> getConcatenation(vector<int>& nums) {\r\n        vector<int> ans; \r\n        int n = nums.size(); \r\n        \r\n        for(int i=0; i<2*n; i++){\r\n            int x; \r\n            x = nums[i%n]; \r\n            ans.push_back(x); \r\n        }\r\n        \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"706\"], \"nums_element1\": [\"874\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution {\n/*FM*/int maxArea(vector<int>& h) {\r\n        int start=0; \r\n        int end=h.size()-1; \r\n        int max_area=0; \r\n        while(start<end){\r\n            int mini=min(h[start],h[end]); \r\n            int b=end-start; \r\n            int curr_area=mini*b; \r\n            max_area=max(curr_area,max_area); \r\n            if(h[start]<=h[end]){\r\n                start=start+1; \r\n            }\r\n            else if(h[start]>h[end]){\r\n                \r\n            }\r\n        }\r\n        return max_area; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"h\": [2], \"h_element0\": [\"587\"], \"h_element1\": [\"643\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyDuplicate(vector<int>& nums, int k) {\r\n        map<int,int>m; \r\n        for(int i=0; i<nums.size(); i++){\r\n            if(m.find(nums[i])!=m.end() && abs((m[nums[i]])-i)<=k)\r\n                \r\n            \r\n            m[nums[i]]=i; \r\n        }\r\n        return false; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-535\"], \"k\": [\"830672835\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsDuplicate. /*FC*/class Solution {\n/*FM*/bool containsDuplicate(vector<int>& nums) {\r\n        unordered_map<int,int>m; \r\n        for(int i=0; i<nums.size(); i++){\r\n            m[nums[i]]++; \r\n            if(m[nums[i]]!=1) \r\n        }\r\n        return false; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"209\"], \"nums_element1\": [\"687\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMaxLength. /*FC*/class Solution {\n/*FM*/int findMaxLength(vector<int>& nums) {\r\n        if(nums.size()<=1) \r\n        \r\n        unordered_map<int, int> mp; \r\n        mp[0] = -1; \r\n        \r\n        int cnt = (nums[0] == 1 ? 1 : -1); \r\n        mp[cnt] = 0; \r\n        \r\n        int maxi = 0; \r\n        \r\n        for(int i = 1;  i<nums.size();  i++){\r\n            cnt = (nums[i] == 1)? cnt+1 : cnt-1; \r\n            \r\n            if(mp.find(cnt) != mp.end())\r\n                \r\n            else\r\n                mp[cnt] = i; \r\n        }\r\n        \r\n        return maxi; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"979\"], \"nums_element1\": [\"-268\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMaxLength. /*FC*/class Solution {\n/*FM*/int findMaxLength(vector<int>& nums) {\r\n        if(nums.size()<=1) return 0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-207\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *func. /*FC*/class Solution {\n/*FM*/TreeNode *func(vector<int>v, int lo, int hi)\r\n    {\r\n        int m; \r\n        if(lo>hi)\r\n            return NULL; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/TreeNode *func(vector<int>v, int lo, int hi)\r\n    {\r\n        int m; \r\n        if(lo>hi)\r\n            return NULL; \r\n        m=(lo+hi)/2; \r\n        TreeNode *root=new TreeNode(v[m], func(v, lo, m-1), func(v, m+1, hi)); \r\n        return root; \r\n    } TreeNode *func(vector<int>v, int lo, int hi)\r\n    {\r\n        int m; \r\n        if(lo>hi)\r\n            return NULL; \r\n        m=(lo+hi)/2; \r\n        TreeNode *root=new TreeNode(v[m], func(v, lo, m-1), func(v, m+1, hi)); \r\n        return root; \r\n    } TreeNode(int x) : val(x), left(nullptr), right(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"v\": [1], \"v_element0\": [\"-344\"], \"lo\": [\"1965655145\"], \"hi\": [\"-346127300\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countHillValley. /*FC*/class Solution {\n/*FM*/int countHillValley(vector<int>& nums) {\r\n        int n=nums.size(); \r\n        int count =0; \r\n        int left; \r\n        int right; \r\n        for(int mid =1;  mid<n-1; ){\r\n            \r\n            \r\n                        \r\n            if(nums[mid]<nums[left] && nums[mid]<nums[right])\r\n                \r\n              }\r\n    return count; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"905\"], \"nums_element1\": [\"326\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countKDifference. /*FC*/class Solution {\n/*FM*/int countKDifference(vector<int>& nums, int k) {\r\n        int count=0; \r\n        for(int i=0; i<nums.size(); i++){\r\n            for(int j=0; j<nums.size(); j++){\r\n                if(abs(nums[i]-nums[j]) == k){\r\n                    \r\n                }\r\n            }\r\n        }\r\n        \r\n        return count/2; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"106\"], \"nums_element1\": [\"-84\"], \"k\": [\"-1939429556\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPrimes. /*FC*/class Solution {\n/*FM*/int countPrimes(int n) {\r\n        \r\n        int cnt=0; \r\n        \r\n        vector<bool> prime(n+1,true); \r\n        \r\n        prime[0]=prime[1]=false; \r\n        \r\n        for(int i=2; i<n; i++){\r\n            if(prime[i]){\r\n                cnt++; \r\n                \r\n                for(int j=2*i; j<n; j+=i){\r\n                    prime[j]=0; \r\n                }\r\n            }\r\n        }\r\n        \r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int scheduleCourse. /*FC*/class Solution {\n/*FM*/int scheduleCourse(vector<vector<int>>& courses) {\r\n        \r\n        int n = courses.size(); \r\n        int time = 0; \r\n        priority_queue<int> q; \r\n        \r\n        sort(courses.begin(), courses.end(), cmp); \r\n            \r\n        for(int i=0;  i<n;  i++) {\r\n            if(time+courses[i][0] <= courses[i][1]) {\r\n               \r\n                time+=courses[i][0]; \r\n                q.push(courses[i][0]); \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        \r\n        return q.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"courses\": [2], \"courses_element0\": [1], \"courses_element0_element0\": [\"-671\"], \"courses_element1\": [1], \"courses_element1_element0\": [\"-261\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int scheduleCourse. /*FC*/class Solution {\n/*FM*/int scheduleCourse(vector<vector<int>>& courses) {\r\n        \r\n        int n = courses.size(); \r\n        int time = 0; \r\n        priority_queue<int> q; \r\n        \r\n        sort(courses.begin(), courses.end(), cmp); \r\n            \r\n        for(int i=0;  i<n;  i++) {\r\n            if(time+courses[i][0] <= courses[i][1]) {\r\n               \r\n                \r\n                \r\n            } else {\r\n                if(!q.empty() && q.top() > courses[i][0]) {\r\n                   \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        \r\n        return q.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"courses\": [1], \"courses_element0\": [2], \"courses_element0_element0\": [\"-622\"], \"courses_element0_element1\": [\"-993\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string defangIPaddr. /*FC*/class Solution {\n/*FM*/string defangIPaddr(string address) {\r\n        string ans=\"\"; \r\n        for(int i=0; i<address.length(); i++){\r\n            if(address[i]=='.'){\r\n                \r\n            }\r\n            else{\r\n                ans+=address[i]; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"address\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/class Solution {\n/*FM*/int divide(int dividend, int divisor) {\r\n        if (dividend == INT_MIN && divisor == -1) {\r\n            \r\n        }\r\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0; \r\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1; \r\n        while (dvd >= dvs) {\r\n            long temp = dvs, m = 1; \r\n            while (temp << 1 <= dvd) {\r\n                temp <<= 1; \r\n                m <<= 1; \r\n            }\r\n            dvd -= temp; \r\n            ans += m; \r\n        }\r\n        return sign * ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dividend\": [\"786269805\"], \"divisor\": [\"278870892\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/class Solution \r {\n/*FM*/int minDistance(string word1, string word2) {\r\n        int n1=word1.size(); \r\n        int n2=word2.size(); \r\n        vector<vector<int>>dp(n2+1,vector<int>(n1+1,0)); \r\n        \n        for(int i=1; i<=n1; i++) dp[0][i]=i; \r\n        for(int i=1; i<=n2; i++) dp[i][0]=i; \r\n        for(int i=1; i<=n2; i++){\r\n            for(int j=1; j<=n1; j++){\r\n                if(word2[i-1]==word1[j-1]) \r\n                else dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1; \r\n            }\r\n        }\r\n        \n        \n        \n        \n        \n        \n        return dp[n2][n1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word1\": [\"1\"], \"word2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void addNum. /*FC*/class MedianFinder \r {\n/*FM*/void addNum(int num) {\r\n        if(pq1.empty()){\r\n            pq1.push(num); \r\n            return; \r\n        }\r\n        if(pq1.size()==pq2.size()){\r\n            \r\n        }\r\n        else{\r\n            \r\n        }\r\n    };/*F*/priority_queue<int> pq1;  priority_queue<int,vector<int>,greater<int>> pq2;/*C*/MedianFinder() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MedianFinder\": [\"MedianFinder\", \"MedianFinder()\"], \"num\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method Node *flatten. /*FC*/class Solution\r {\n/*FM*/Node *flatten(Node *head)\r\n    {\r\n        if (head == NULL)\r\n            return head; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method Node *flatten. /*FC*/class Solution\r {\n/*FM*/Node *flatten(Node *head)\r\n    {\r\n        if (head == NULL)\r\n            \r\n        Node *p = head; \r\n        while (p != NULL)\r\n        {\r\n            if (p->child == NULL)\r\n            {\r\n                p = p->next; \r\n                continue; \r\n            }\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"Node\", \"Node()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void flatten. /*FC*/class Solution\r {\n/*FM*/void flatten(TreeNode *root)\r\n    {\r\n        if (root == NULL || (root->left == NULL && root->right == NULL))\r\n            return; \r\n        if (root->left != NULL)\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/void flatten(TreeNode *root)\r\n    {\r\n        if (root == NULL || (root->left == NULL && root->right == NULL))\r\n            return; \r\n        if (root->left != NULL)\r\n        {\r\n            flatten(root->left); \r\n            TreeNode *temp = root->right; \r\n            root->right = root->left; \r\n            root->left = NULL; \r\n            TreeNode *t = root->right; \r\n            while (t->right)\r\n            {\r\n                t = t->right; \r\n            }\r\n            t->right = temp; \r\n        }\r\n        flatten(root->right); \r\n    } void flatten(TreeNode *root)\r\n    {\r\n        if (root == NULL || (root->left == NULL && root->right == NULL))\r\n            return; \r\n        if (root->left != NULL)\r\n        {\r\n            flatten(root->left); \r\n            TreeNode *temp = root->right; \r\n            root->right = root->left; \r\n            root->left = NULL; \r\n            TreeNode *t = root->right; \r\n            while (t->right)\r\n            {\r\n                t = t->right; \r\n            }\r\n            t->right = temp; \r\n        }\r\n        flatten(root->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void flatten. /*FC*/class Solution\r {\n/*FM*/void flatten(TreeNode *root)\r\n    {\r\n        if (root == NULL || (root->left == NULL && root->right == NULL))\r\n            return; \r\n        if (root->left != NULL)\r\n        {\r\n            flatten(root->left); \r\n            TreeNode *temp = root->right; \r\n            root->right = root->left; \r\n            root->left = NULL; \r\n            TreeNode *t = root->right; \r\n            while (t->right)\r\n            {\r\n                \r\n            }\r\n            t->right = temp; \r\n        }\r\n        flatten(root->right); \r\n    };/*F*//*C*//*M*/void flatten(TreeNode *root)\r\n    {\r\n        if (root == NULL || (root->left == NULL && root->right == NULL))\r\n            return; \r\n        if (root->left != NULL)\r\n        {\r\n            flatten(root->left); \r\n            TreeNode *temp = root->right; \r\n            root->right = root->left; \r\n            root->left = NULL; \r\n            TreeNode *t = root->right; \r\n            while (t->right)\r\n            {\r\n                t = t->right; \r\n            }\r\n            t->right = temp; \r\n        }\r\n        flatten(root->right); \r\n    } void flatten(TreeNode *root)\r\n    {\r\n        if (root == NULL || (root->left == NULL && root->right == NULL))\r\n            return; \r\n        if (root->left != NULL)\r\n        {\r\n            flatten(root->left); \r\n            TreeNode *temp = root->right; \r\n            root->right = root->left; \r\n            root->left = NULL; \r\n            TreeNode *t = root->right; \r\n            while (t->right)\r\n            {\r\n                t = t->right; \r\n            }\r\n            t->right = temp; \r\n        }\r\n        flatten(root->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].right[0].right\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution \r {\n/*FM*/string intToRoman(int num) {\r\n        \n        string ans=\"\"; \r\n        if(num/1000){\r\n            \r\n            \r\n                \r\n        }\r\n        if(num/100){\r\n            \r\n            \r\n            \r\n        }\r\n        if(num/10){\r\n            int d=num/10; \r\n            if(d==5) \r\n            else if(d==4) \r\n            else if(d==9) \r\n            else if(d<=3) for(int i=1; i<=d; i++) ans.push_back('X'); \r\n            else{\r\n                \r\n                \r\n            }\r\n            num%=10; \r\n        }\r\n        if(num){\r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution \r {\n/*FM*/string intToRoman(int num) {\r\n        \n        string ans=\"\"; \r\n        if(num/1000){\r\n            \r\n            \r\n                \r\n        }\r\n        if(num/100){\r\n            \r\n            \r\n            \r\n        }\r\n        if(num/10){\r\n            \r\n            \r\n            \r\n        }\r\n        if(num){\r\n            int d=num; \r\n            if(d==5) \r\n            else if(d==4) \r\n            else if(d==9) \r\n            else if(d<=3) \r\n            else{\r\n                ans.push_back('V'); \r\n                for(int i=1; i<=(d-5); i++) ans.push_back('I'); \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution \r {\n/*FM*/string intToRoman(int num) {\r\n        \n        string ans=\"\"; \r\n        if(num/1000){\r\n            \r\n            \r\n                \r\n        }\r\n        if(num/100){\r\n            \r\n            \r\n            \r\n        }\r\n        if(num/10){\r\n            \r\n            \r\n            \r\n        }\r\n        if(num){\r\n            int d=num; \r\n            if(d==5) \r\n            else if(d==4) \r\n            else if(d==9) \r\n            else if(d<=3) for(int i=1; i<=d; i++) ans.push_back('I'); \r\n            else{\r\n                \r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int add. /*FC*/class KthLargest {\n/*FM*/int add(int val) {\r\n        q.push(val); \r\n        if(q.size()>k_)\r\n        \r\n        return q.top(); \r\n    };/*F*/priority_queue<int, vector<int>, greater<int>> q;  int k_;/*C*/KthLargest(int k, vector<int>& nums) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___KthLargest\": [\"KthLargest\", \"KthLargest(int,vector<int>&)\"], \"AKA_INSTANCE___KthLargest_k\": [\"348\"], \"AKA_INSTANCE___KthLargest_nums\": [1], \"AKA_INSTANCE___KthLargest_nums_element0\": [\"-434\"], \"val\": [\"-1262869854\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int add. /*FC*/class KthLargest {\n/*FM*/int add(int val) {\r\n        q.push(val); \r\n        if(q.size()>k_)\r\n        q.pop(); \r\n        return q.top(); \r\n    };/*F*/priority_queue<int, vector<int>, greater<int>> q;  int k_;/*C*/KthLargest(int k, vector<int>& nums) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___KthLargest\": [\"KthLargest\", \"KthLargest(int,vector<int>&)\", \"STLListBaseType\"], \"AKA_INSTANCE___KthLargest_k\": [\"0\"], \"AKA_INSTANCE___KthLargest->k_\": [\"0\"], \"val\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findKthLargest. /*FC*/ {\n/*FM*/int findKthLargest(vector<int>& nums, int k) {\r\n    priority_queue<int> pq; \r\n    for(int i=0; i<nums.size(); i++){\r\n        pq.push(nums[i]); \r\n    }\r\n    k--; \r\n    while(k--){\r\n        pq.pop(); \r\n    }\r\n    return pq.top(); \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"nums\": [6], \"nums_element0\": [\"3\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"1\"], \"nums_element3\": [\"5\"], \"nums_element4\": [\"6\"], \"nums_element5\": [\"4\"], \"k\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void solve. /*FC*/class Solution {\n/*FM*/void solve(string digit, string output, int index, vector<string>& ans, string mapping[] ) {\r\n        \r\n        \n        if(index >= digit.length()) {\r\n            ans.push_back(output); \r\n            return; \r\n        }\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/void solve(string digit, string output, int index, vector<string>& ans, string mapping[] ) {\r\n        \r\n        \n        if(index >= digit.length()) {\r\n            ans.push_back(output); \r\n            return; \r\n        }\r\n        \r\n        int number = digit[index] - '0'; \r\n        string value = mapping[number]; \r\n        \r\n        for(int i=0;  i<value.length();  i++) {\r\n            output.push_back(value[i]); \r\n            solve(digit, output, index+1, ans, mapping); \r\n            output.pop_back(); \r\n        }\r\n        \r\n    } void solve(string digit, string output, int index, vector<string>& ans, string mapping[] ) {\r\n        \r\n        \n        if(index >= digit.length()) {\r\n            ans.push_back(output); \r\n            return; \r\n        }\r\n        \r\n        int number = digit[index] - '0'; \r\n        string value = mapping[number]; \r\n        \r\n        for(int i=0;  i<value.length();  i++) {\r\n            output.push_back(value[i]); \r\n            solve(digit, output, index+1, ans, mapping); \r\n            output.pop_back(); \r\n        }\r\n        \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digit\": [\"2\"], \"output\": [\"1\"], \"index\": [\"512\"], \"ans\": [2], \"ans_element0\": [\"1\"], \"ans_element1\": [\"1\"], \"mapping\": [2], \"mapping[0]\": [\"1\"], \"mapping[1]\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *detectCycle. /*FC*/class Solution\r {\n/*FM*/ListNode *detectCycle(ListNode *head)\r\n    {\r\n        ListNode *slow = head; \r\n        ListNode *fast = head; \r\n        if (head == NULL || head->next == NULL)\r\n            \r\n        while (fast != NULL && fast->next != NULL)\r\n        {\r\n            slow = slow->next; \r\n            fast = fast->next->next; \r\n            if (fast == slow)\r\n            {\r\n                \r\n                \r\n                \r\n            }\r\n        }\r\n        return NULL; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-791\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-808\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *detectCycle. /*FC*/class Solution\r {\n/*FM*/ListNode *detectCycle(ListNode *head)\r\n    {\r\n        ListNode *slow = head; \r\n        ListNode *fast = head; \r\n        if (head == NULL || head->next == NULL)\r\n            return NULL; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"828\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"786\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool helper. /*FC*/class Solution {\n/*FM*/bool helper(TreeNode* root, TreeNode* p, TreeNode* q){\r\n        if(!root){\r\n            return false; \r\n        }\r\n        \r\n        \r\n        \r\n        if(root->val==p->val || root->val==q->val){\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/bool helper(TreeNode* root, TreeNode* p, TreeNode* q){\r\n        if(!root){\r\n            return false; \r\n        }\r\n        bool left = helper(root->left,p,q); \r\n        bool right = helper(root->right,p,q); \r\n        if(left&&right){\r\n            ans = root; \r\n            return false; \r\n        }\r\n        if(root->val==p->val || root->val==q->val){\r\n            if(left || right){\r\n                ans = root; \r\n                return false; \r\n            }\r\n            else {\r\n                return true; \r\n            }\r\n        }\r\n        return left || right; \r\n    } bool helper(TreeNode* root, TreeNode* p, TreeNode* q){\r\n        if(!root){\r\n            return false; \r\n        }\r\n        bool left = helper(root->left,p,q); \r\n        bool right = helper(root->right,p,q); \r\n        if(left&&right){\r\n            ans = root; \r\n            return false; \r\n        }\r\n        if(root->val==p->val || root->val==q->val){\r\n            if(left || right){\r\n                ans = root; \r\n                return false; \r\n            }\r\n            else {\r\n                return true; \r\n            }\r\n        }\r\n        return left || right; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->ans\": [0], \"root\": [0], \"p\": [0], \"q\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestRectangleArea. /*FC*/class Solution {\n/*FM*/int largestRectangleArea(vector<int>& arr) {\r\n        stack<int>s; \r\n        int n=arr.size(); \r\n        vector<int> rl(n); \r\n        rl[n-1]=n; \r\n        s.push(n-1); \r\n        for(int i=n-2; i>=0; i--){\r\n            while(!s.empty() && arr[s.top()]>=arr[i]){\r\n                \r\n            }\r\n            if(s.empty()){\r\n                \r\n            }\r\n            else{\r\n                rl[i]=s.top(); \r\n            }\r\n            s.push(i); \r\n        }\r\n        stack<int>s1; \r\n        vector<int> ll(n); \r\n        ll[0]=-1; \r\n        s1.push(0); \r\n        for(int i=1; i<n; i++){\r\n            while(!s1.empty() && arr[s1.top()]>=arr[i]){\r\n                s1.pop(); \r\n            }\r\n            if(s1.empty()){\r\n                ll[i]=-1; \r\n            }\r\n            else{\r\n                \r\n            }\r\n            s1.push(i); \r\n        }\r\n        int ans=0; \r\n        for(int i=0; i<n; i++){\r\n            ans=max(ans, (rl[i]-ll[i]-1)*arr[i]); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"1028101380\"], \"arr_element1\": [\"629358811\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestRectangleArea. /*FC*/class Solution {\n/*FM*/int largestRectangleArea(vector<int>& arr) {\r\n        stack<int>s; \r\n        int n=arr.size(); \r\n        vector<int> rl(n); \r\n        rl[n-1]=n; \r\n        s.push(n-1); \r\n        for(int i=n-2; i>=0; i--){\r\n            while(!s.empty() && arr[s.top()]>=arr[i]){\r\n                s.pop(); \r\n            }\r\n            if(s.empty()){\r\n                rl[i]=n; \r\n            }\r\n            else{\r\n                \r\n            }\r\n            s.push(i); \r\n        }\r\n        stack<int>s1; \r\n        vector<int> ll(n); \r\n        ll[0]=-1; \r\n        s1.push(0); \r\n        for(int i=1; i<n; i++){\r\n            while(!s1.empty() && arr[s1.top()]>=arr[i]){\r\n                \r\n            }\r\n            if(s1.empty()){\r\n                \r\n            }\r\n            else{\r\n                ll[i]=s1.top(); \r\n            }\r\n            s1.push(i); \r\n        }\r\n        int ans=0; \r\n        for(int i=0; i<n; i++){\r\n            ans=max(ans, (rl[i]-ll[i]-1)*arr[i]); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"-801484741\"], \"arr_element1\": [\"-739201222\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalRectangle. /*FC*/class Solution {\n/*FM*/int maximalRectangle(vector<vector<char>>& arr) {\r\n        int m=arr.size(); \r\n        if(m==0){\r\n            return 0; \r\n        }\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> merge. /*FC*/class Solution {\n/*FM*/vector<vector<int>> merge(vector<vector<int>>& intervals) { \n        int n = intervals.size(); \r\n        if(n == 1) \r\n        vector<vector<int>> ans; \r\n        \r\n        sort(intervals.begin() , intervals.end()); \r\n        \r\n        vector<int> curr = intervals[0]; \r\n        for(int i=1 ;  i<n ;  i++){\r\n            if(curr[1] >= intervals[i][0]) \r\n            else{\r\n                ans.push_back(curr); \r\n                curr = intervals[i]; \r\n            }\r\n        }\r\n        ans.push_back(curr); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [1], \"intervals_element0_element0\": [\"899248237\"], \"intervals_element1\": [1], \"intervals_element1_element0\": [\"-1182972025\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> merge. /*FC*/class Solution {\n/*FM*/vector<vector<int>> merge(vector<vector<int>>& intervals) { \n        int n = intervals.size(); \r\n        if(n == 1) return intervals; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [1], \"intervals_element0\": [3], \"intervals_element0_element0\": [\"-1295481342\"], \"intervals_element0_element1\": [\"-436642895\"], \"intervals_element0_element2\": [\"-67418524\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> merge. /*FC*/class Solution {\n/*FM*/vector<vector<int>> merge(vector<vector<int>>& intervals) { \n        int n = intervals.size(); \r\n        if(n == 1) \r\n        vector<vector<int>> ans; \r\n        \r\n        sort(intervals.begin() , intervals.end()); \r\n        \r\n        vector<int> curr = intervals[0]; \r\n        for(int i=1 ;  i<n ;  i++){\r\n            if(curr[1] >= intervals[i][0]) curr[1] = max(curr[1] , intervals[i][1]); \r\n            else{\r\n                \r\n                \r\n            }\r\n        }\r\n        ans.push_back(curr); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [3], \"intervals_element0\": [2], \"intervals_element0_element0\": [\"-2122090488\"], \"intervals_element0_element1\": [\"1654052947\"], \"intervals_element1\": [3], \"intervals_element1_element0\": [\"1365525287\"], \"intervals_element1_element1\": [\"69635604\"], \"intervals_element1_element2\": [\"-71836145\"], \"intervals_element2\": [3], \"intervals_element2_element0\": [\"-1739483914\"], \"intervals_element2_element1\": [\"-1850691096\"], \"intervals_element2_element2\": [\"-410909710\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void merge. /*FC*/class Solution \r {\n/*FM*/void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n        vector<int>ans(m+n); \r\n        int a1,a2; \r\n        a1=a2=0; \r\n        while(a1!=m&& a2!=n){\r\n            if(nums1[a1]<nums2[a2]){ }\r\n            else{ ans[a1+a2]=nums2[a2]; a2++; }\r\n        }\r\n        \n        while(a1!=m){\r\n            ans[a1+a2]=nums1[a1]; \r\n            a1++; \r\n        }\r\n        while(a2!=n){\r\n            \r\n            \r\n        }\r\n        for(int i=0; i<m+n; i++) nums1[i]=ans[i]; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [1], \"nums1_element0\": [\"304199160\"], \"m\": [\"3\"], \"nums2\": [2], \"nums2_element0\": [\"-1926530865\"], \"nums2_element1\": [\"-2067649033\"], \"n\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void merge. /*FC*/class Solution \r {\n/*FM*/void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n        vector<int>ans(m+n); \r\n        int a1,a2; \r\n        a1=a2=0; \r\n        while(a1!=m&& a2!=n){\r\n            if(nums1[a1]<nums2[a2]){ ans[a1+a2]=nums1[a1]; a1++; }\r\n            else{ ans[a1+a2]=nums2[a2]; a2++; }\r\n        }\r\n        \n        while(a1!=m){\r\n            \r\n            \r\n        }\r\n        while(a2!=n){\r\n            ans[a1+a2]=nums2[a2]; \r\n            a2++; \r\n        }\r\n        for(int i=0; i<m+n; i++) nums1[i]=ans[i]; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"1943317480\"], \"nums1_element1\": [\"628471701\"], \"m\": [\"2\"], \"nums2\": [1], \"nums2_element0\": [\"-1051066676\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *mergeTwoLists. /*FC*/class Solution\r {\n/*FM*/ListNode *mergeTwoLists(ListNode *l1, ListNode *l2)\r\n    {\r\n        if (!l1)\r\n        {\r\n            return l2; \r\n        }\r\n        if (!l2)\r\n        {\r\n            \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/ListNode *mergeTwoLists(ListNode *l1, ListNode *l2)\r\n    {\r\n        if (!l1)\r\n        {\r\n            return l2; \r\n        }\r\n        if (!l2)\r\n        {\r\n            return l1; \r\n        }\r\n        ListNode *result; \r\n        if (l1->val < l2->val)\r\n        {\r\n            result = l1; \r\n            result->next = mergeTwoLists(l1->next, l2); \r\n        }\r\n        else\r\n        {\r\n            result = l2; \r\n            result->next = mergeTwoLists(l1, l2->next); \r\n        }\r\n        return result; \r\n    } ListNode *mergeTwoLists(ListNode *l1, ListNode *l2)\r\n    {\r\n        if (!l1)\r\n        {\r\n            return l2; \r\n        }\r\n        if (!l2)\r\n        {\r\n            return l1; \r\n        }\r\n        ListNode *result; \r\n        if (l1->val < l2->val)\r\n        {\r\n            result = l1; \r\n            result->next = mergeTwoLists(l1->next, l2); \r\n        }\r\n        else\r\n        {\r\n            result = l2; \r\n            result->next = mergeTwoLists(l1, l2->next); \r\n        }\r\n        return result; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [0], \"l2\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* middleNode. /*FC*/class Solution {\n/*FM*/ListNode* middleNode(ListNode* head) {\r\n        ListNode* slow = head; \r\n        ListNode* fast = head; \r\n        \r\n        while(true){\r\n            if(fast == nullptr || fast->next == nullptr){\r\n                return slow; \r\n            }\r\n            \r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[1]\": [\"ListNode\", \"ListNode()\"], \"head[2]\": [\"ListNode\", \"ListNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMinimumDifference. /*FC*/class Solution {\n/*FM*/int getMinimumDifference(TreeNode* root) {\r\n        int m; \r\n        TreeNode *p; \r\n        m=INT_MAX; \r\n        p=NULL; \r\n        func(root, p, m); \r\n        return m; \r\n    };/*F*//*C*//*M*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p)\r\n            m=min(m, abs(p->val-n->val)); \r\n        p=n; \r\n        func(n->right, p, m); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_x\": [\"434703940\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void func. /*FC*/class Solution {\n/*FM*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p)\r\n            m=min(m, abs(p->val-n->val)); \r\n        p=n; \r\n        func(n->right, p, m); \r\n    } void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p)\r\n            m=min(m, abs(p->val-n->val)); \r\n        p=n; \r\n        func(n->right, p, m); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [0], \"p\": [0], \"m\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void func. /*FC*/class Solution {\n/*FM*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p)\r\n            m=min(m, abs(p->val-n->val)); \r\n        p=n; \r\n        func(n->right, p, m); \r\n    };/*F*//*C*//*M*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p)\r\n            m=min(m, abs(p->val-n->val)); \r\n        p=n; \r\n        func(n->right, p, m); \r\n    } void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p)\r\n            m=min(m, abs(p->val-n->val)); \r\n        p=n; \r\n        func(n->right, p, m); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [1], \"n[0]\": [\"TreeNode\", \"TreeNode()\"], \"n[0].val\": [\"1963898574\"], \"n[0].left\": [1], \"n[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"n[0].left[0].val\": [\"-24321689\"], \"p\": [1], \"p[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_x\": [\"-231830658\"], \"p[0].val\": [\"1733209590\"], \"p[0].left\": [1], \"p[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"p[0].left[0].val\": [\"1100346573\"], \"p[0].right\": [3], \"p[0].right[0]\": [\"TreeNode\", \"TreeNode()\"], \"p[0].right[0].val\": [\"1335139007\"], \"p[0].right[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"p0_right1_x\": [\"-1019095960\"], \"p[0].right[1].val\": [\"2117093277\"], \"p[0].right[2]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"p0_right2_x\": [\"533911482\"], \"p[0].right[2].val\": [\"-158624086\"], \"m\": [\"-1599656611\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDiffInBST. /*FC*/class Solution {\n/*FM*/int minDiffInBST(TreeNode* root) {\r\n        int m; \r\n        TreeNode *p; \r\n        m=INT_MAX; \r\n        p=NULL; \r\n        func(root, p, m); \r\n        return m; \r\n    };/*F*//*C*//*M*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p && m>(n->val-p->val))\r\n            m=n->val-p->val; \r\n        p=n; \r\n        func(n->right, p, m); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"989828558\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1729731768\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void func. /*FC*/class Solution {\n/*FM*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        \r\n            \r\n    };/*F*//*C*//*M*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p && m>(n->val-p->val))\r\n            m=n->val-p->val; \r\n        p=n; \r\n        func(n->right, p, m); \r\n    } void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p && m>(n->val-p->val))\r\n            m=n->val-p->val; \r\n        p=n; \r\n        func(n->right, p, m); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [0], \"p\": [0], \"m\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void func. /*FC*/class Solution {\n/*FM*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            \r\n        func(n->left, p, m); \r\n            \r\n    };/*F*//*C*//*M*/void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p && m>(n->val-p->val))\r\n            m=n->val-p->val; \r\n        p=n; \r\n        func(n->right, p, m); \r\n    } void func(TreeNode *n, TreeNode *(&p), int &m)\r\n    {\r\n        if(!n)\r\n            return; \r\n        func(n->left, p, m); \r\n        if(p && m>(n->val-p->val))\r\n            m=n->val-p->val; \r\n        p=n; \r\n        func(n->right, p, m); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"968420710\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPathSum. /*FC*/class Solution {\n/*FM*/int minPathSum(vector<vector<int>>& grid) {\r\n        vector<vector<int>> dp(grid); \r\n        int r = grid.size(); \r\n        int c = grid[0].size(); \r\n        for(int i = 0;  i<grid.size();  i++){\r\n            for(int j = 0;  j<grid[0].size();  j++){\r\n                if(i-1 >= 0 && j-1 >= 0)\r\n                    dp[i][j] += min(dp[i-1][j], dp[i][j-1]); \r\n                else{\r\n                    if(i-1>=0)\r\n                        dp[i][j] += dp[i-1][j]; \r\n                    if(j-1>= 0)\r\n                        dp[i][j] += dp[i][j-1]; \r\n                }\r\n            }\r\n        }\r\n        \r\n        return dp[r-1][c-1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"-680743398\"], \"grid_element0_element1\": [\"-1267163900\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"-988482428\"], \"grid_element1_element1\": [\"1527830132\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxdiff. /*FC*/ {\n/*FM*/int maxdiff(vector<int> a){\r\n    if(a.size()<2){\r\n    return 0; \r\n    }\r\n\r\n\r\n\r\n\n\r\n\n\r\n\r\n\r\n\r\n\r\n\r\n\n\r\n\r\n\r\n\n\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"a\": [1], \"a_element0\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxdiff. /*FC*/ {\n/*FM*/int maxdiff(vector<int> a){\r\n    if(a.size()<2){\r\n    \r\n    }\r\nint mini =a[0]; \r\nint maxa=0; \r\n\r\n\nfor(int i =0;  i<a.size(); i++){\r\nmini = min(mini,a[i]); \r\nmaxa = max(maxa,a[i]); \r\n}\r\n\nint buckmin[(a.size()-1)]; \r\nint buckmax[(a.size()-1)]; \r\n\r\nfill_n(buckmin,(a.size()-1),INT_MAX); \r\nfill_n(buckmax,(a.size()-1),-1); \r\n\r\n\nint interval = int(ceil((maxa-mini+0.0)/((a.size()-1)))); \r\n\r\nfor(int i=0; i<a.size(); i++){\r\n\r\n\nif(a[i]==maxa || a[i]==mini ) continue; \r\nint index; \r\n\nindex = (a[i]-mini)/(interval); \r\nbuckmin[index]= min(a[i],buckmin[index]); \r\nbuckmax[index]= max(a[i],buckmax[index]); \r\n\r\n}\r\n\n\nint prv = mini; \r\nint max_gap=0; \r\n\r\nfor(int i=0; i<(a.size()-1); i++){\r\n\r\nif(buckmax[i]==-1)continue; \r\nmax_gap=max(buckmin[i]-prv,max_gap); \r\nprv= buckmax[i]; \r\n\r\n}\r\nmax_gap=max(maxa-prv,max_gap); \r\nreturn max_gap; \r\n\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"a\": [5], \"a_element0\": [\"1\"], \"a_element1\": [\"3\"], \"a_element2\": [\"7\"], \"a_element3\": [\"9\"], \"a_element4\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* addTwoNumbers. /*FC*/class Solution {\n/*FM*/ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\r\n        int carry = 0; \r\n        ListNode ans(0); \r\n        ListNode *temp = &ans; \r\n        while(carry || l1 || l2){\r\n            carry+=(l1?l1->val:0)+(l2?l2->val:0); \r\n            temp->next = new ListNode(carry%10); \r\n            temp = temp->next; \r\n            carry/=10; \r\n            if(l1) l1 = l1->next; \r\n            if(l2) l2 = l2->next; \r\n        }\r\n        return ans.next; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"-921\"], \"l1[0].val\": [\"1\"], \"l2\": [2], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"-125\"], \"l2[0].val\": [\"7\"], \"l2[0].next\": [0], \"l2[1]\": [\"ListNode\", \"ListNode()\"], \"l2[1].val\": [\"1\"], \"l2[1].next\": [1], \"l2[1].next[0]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"l21_next0_x\": [\"2\"], \"l2[1].next[0].val\": [\"-239\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList. /*FC*/class Solution {\n/*FM*/ListNode* reverseList(ListNode* head) {\r\n        \r\n        if(head == NULL || head->next == NULL) \r\n        \r\n        ListNode* p = NULL; \r\n        ListNode* q = head; \r\n        ListNode* r = head->next; \r\n        \r\n        while(q != NULL){\r\n            \r\n            q->next = p; \r\n            p = q; \r\n            q = r; \r\n            if(r) r = r->next; \r\n            \r\n        }\r\n        \r\n        return p; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int,ListNode*)\"], \"head0_x\": [\"-565\"], \"head0_next\": [1], \"head0_next[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList. /*FC*/class Solution {\n/*FM*/ListNode* reverseList(ListNode* head) {\r\n        \r\n        if(head == NULL || head->next == NULL) return head; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\r\n        ListNode* dummy= new ListNode(0); \r\n        ListNode* tail=dummy; \r\n        while(l1 && l2){\r\n            if(l1->val < l2->val){\r\n                tail->next=l1; \r\n                l1=l1->next; \r\n            }\r\n            else{\r\n                tail->next=l2; \r\n                l2=l2->next; \r\n            }\r\n            tail=tail->next; \r\n        }\r\n        if(l1)\r\n            tail->next=l1; \r\n        else\r\n            \r\n        return dummy->next; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [2], \"l1[0]\": [\"ListNode\", \"ListNode()\"], \"l1[0].val\": [\"-923\"], \"l1[0].next\": [1], \"l1[0].next[0]\": [\"ListNode\", \"ListNode()\"], \"l1[0].next[0].val\": [\"-89\"], \"l1[1]\": [\"ListNode\", \"ListNode()\"], \"l1[1].val\": [\"852\"], \"l2\": [1], \"l2[0]\": [\"ListNode\", \"ListNode()\"], \"l2[0].val\": [\"-195\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\r\n        ListNode* dummy= new ListNode(0); \r\n        ListNode* tail=dummy; \r\n        while(l1 && l2){\r\n            if(l1->val < l2->val){\r\n                tail->next=l1; \r\n                l1=l1->next; \r\n            }\r\n            else{\r\n                tail->next=l2; \r\n                l2=l2->next; \r\n            }\r\n            tail=tail->next; \r\n        }\r\n        if(l1)\r\n            \r\n        else\r\n            tail->next=l2; \r\n        return dummy->next; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [2], \"l1[0]\": [\"ListNode\", \"ListNode()\"], \"l1[0].val\": [\"445\"], \"l1[1]\": [\"ListNode\", \"ListNode(int)\"], \"l11_x\": [\"499\"], \"l1[1].val\": [\"-253\"], \"l1[1].next\": [1], \"l1[1].next[0]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"l11_next0_x\": [\"713\"], \"l1[1].next[0].val\": [\"-997\"], \"l2\": [1], \"l2[0]\": [\"ListNode\", \"ListNode()\"], \"l2[0].val\": [\"5\"], \"l2[0].next\": [2], \"l2[0].next[0]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"l20_next0_x\": [\"-665\"], \"l2[0].next[0].val\": [\"132\"], \"l2[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"l20_next1_x\": [\"-597\"], \"l2[0].next[1].val\": [\"-826\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMedian. /*FC*/ {\n/*FM*/int getMedian(int ar1[], int ar2[], int n, int m)\r\n{\r\n\tint i = 0;  \r\n\tint j = 0;  \r\n\tint count; \r\n\tint m1 = -1, m2 = -1; \r\n\r\n\t\n\t\n\t\n\t\n\tif((m + n) % 2 == 1)\r\n\t{\r\n\t\tfor (count = 0;  count <= (n + m)/2;  count++)\r\n\t\t{\r\n\t\t\tif(i != n && j != m)\r\n\t\t\t{\r\n\t\t\t\tm1 = (ar1[i] > ar2[j]) ? ar2[j++] : ar1[i++]; \r\n\t\t\t}\r\n\t\t\telse if(i < n)\r\n\t\t\t{\r\n\t\t\t\tm1 = ar1[i++]; \r\n\t\t\t}\r\n\t\t\t\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn m1; \r\n\t}\r\n\t\r\n\t\n\t\n\t\n\telse\r\n\t{\r\n\t\t\r\n\t\t\r\n\t}\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"ar1\": [2], \"ar1[0]\": [\"3\"], \"ar1[1]\": [\"4\"], \"ar2\": [1], \"ar2[0]\": [\"1\"], \"n\": [\"2\"], \"m\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMedian. /*FC*/ {\n/*FM*/int getMedian(int ar1[], int ar2[], int n, int m)\r\n{\r\n\tint i = 0;  \r\n\tint j = 0;  \r\n\tint count; \r\n\tint m1 = -1, m2 = -1; \r\n\r\n\t\n\t\n\t\n\t\n\tif((m + n) % 2 == 1)\r\n\t{\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\n\t\n\t\n\telse\r\n\t{\r\n\t\tfor (count = 0;  count <= (n + m)/2;  count++)\r\n\t\t{\r\n\t\t\tm2 = m1; \r\n\t\t\tif(i != n && j != m)\r\n\t\t\t{\r\n\t\t\t\tm1 = (ar1[i] > ar2[j]) ? ar2[j++] : ar1[i++]; \r\n\t\t\t}\r\n\t\t\telse if(i < n)\r\n\t\t\t{\r\n\t\t\t\tm1 = ar1[i++]; \r\n\t\t\t}\r\n\t\t\t\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (m1 + m2)/2; \r\n\t}\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"ar1\": [4], \"ar1[0]\": [\"3\"], \"ar1[1]\": [\"4\"], \"ar1[2]\": [\"5\"], \"ar1[3]\": [\"6\"], \"ar2\": [2], \"ar2[0]\": [\"1\"], \"ar2[1]\": [\"2\"], \"n\": [\"4\"], \"m\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMedian. /*FC*/ {\n/*FM*/int getMedian(int ar1[], int ar2[], int n, int m)\r\n{\r\n\tint i = 0;  \r\n\tint j = 0;  \r\n\tint count; \r\n\tint m1 = -1, m2 = -1; \r\n\r\n\t\n\t\n\t\n\t\n\tif((m + n) % 2 == 1)\r\n\t{\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\n\t\n\t\n\telse\r\n\t{\r\n\t\tfor (count = 0;  count <= (n + m)/2;  count++)\r\n\t\t{\r\n\t\t\tm2 = m1; \r\n\t\t\tif(i != n && j != m)\r\n\t\t\t{\r\n\t\t\t\tm1 = (ar1[i] > ar2[j]) ? ar2[j++] : ar1[i++]; \r\n\t\t\t}\r\n\t\t\telse if(i < n)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm1 = ar2[j++]; \r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (m1 + m2)/2; \r\n\t}\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"ar1\": [2], \"ar1[0]\": [\"1\"], \"ar1[1]\": [\"2\"], \"ar2\": [2], \"ar2[0]\": [\"3\"], \"ar2[1]\": [\"4\"], \"n\": [\"2\"], \"m\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMedian. /*FC*/ {\n/*FM*/int getMedian(int ar1[], int ar2[], int n, int m)\r\n{\r\n\tint i = 0;  \r\n\tint j = 0;  \r\n\tint count; \r\n\tint m1 = -1, m2 = -1; \r\n\r\n\t\n\t\n\t\n\t\n\tif((m + n) % 2 == 1)\r\n\t{\r\n\t\tfor (count = 0;  count <= (n + m)/2;  count++)\r\n\t\t{\r\n\t\t\tif(i != n && j != m)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if(i < n)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm1 = ar2[j++]; \r\n\t\t\t}\r\n\t\t}\r\n\t\treturn m1; \r\n\t}\r\n\t\r\n\t\n\t\n\t\n\telse\r\n\t{\r\n\t\t\r\n\t\t\r\n\t}\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"ar2\": [3], \"ar2[0]\": [\"2\"], \"ar2[1]\": [\"3\"], \"ar2[2]\": [\"4\"], \"n\": [\"0\"], \"m\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMedian. /*FC*/ {\n/*FM*/int getMedian(int ar1[], int ar2[], int n, int m)\r\n{\r\n\tint i = 0;  \r\n\tint j = 0;  \r\n\tint count; \r\n\tint m1 = -1, m2 = -1; \r\n\r\n\t\n\t\n\t\n\t\n\tif((m + n) % 2 == 1)\r\n\t{\r\n\t\tfor (count = 0;  count <= (n + m)/2;  count++)\r\n\t\t{\r\n\t\t\tif(i != n && j != m)\r\n\t\t\t{\r\n\t\t\t\tm1 = (ar1[i] > ar2[j]) ? ar2[j++] : ar1[i++]; \r\n\t\t\t}\r\n\t\t\telse if(i < n)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tm1 = ar2[j++]; \r\n\t\t\t}\r\n\t\t}\r\n\t\treturn m1; \r\n\t}\r\n\t\r\n\t\n\t\n\t\n\telse\r\n\t{\r\n\t\t\r\n\t\t\r\n\t}\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"ar1\": [3], \"ar1[0]\": [\"1\"], \"ar1[1]\": [\"2\"], \"ar1[2]\": [\"3\"], \"ar2\": [4], \"ar2[0]\": [\"4\"], \"ar2[1]\": [\"5\"], \"ar2[2]\": [\"6\"], \"ar2[3]\": [\"7\"], \"n\": [\"3\"], \"m\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarrayProductLessThanK. /*FC*/ {\n/*FM*/int numSubarrayProductLessThanK(vector<int>& nums, int k) {\r\n         int ans=0; \r\n        if(k==0)\r\n            \r\n        int prod=1; \r\n        int l=0,r=0,reach=0; \r\n        while(r<nums.size())\r\n        {\r\n            while(r<nums.size() and prod*nums[r]<k)\r\n                prod=prod*nums[r++];   \r\n            int kk=(r-reach); \r\n            int rem=reach-l; \r\n            ans+=(kk*(kk+1)/2)+(rem*kk); \r\n            reach=r; \r\n            if(r<nums.size())\r\n                prod=prod*nums[r++]; \r\n            while(prod>=k)\r\n               prod=prod/nums[l++]; \r\n\r\n        }\r\n            \r\n         int kk=(r-reach); \r\n         int rem=reach-l; \r\n         ans+=(kk*(kk+1)/2)+(rem*kk); \r\n       return ans<=0?0:ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"nums\": [4], \"nums_element0\": [\"10\"], \"nums_element1\": [\"5\"], \"nums_element2\": [\"2\"], \"nums_element3\": [\"6\"], \"k\": [\"100\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarrayProductLessThanK. /*FC*/ {\n/*FM*/int numSubarrayProductLessThanK(vector<int>& nums, int k) {\r\n         int ans=0; \r\n        if(k==0)\r\n            return 0; \r\n        \r\n        \r\n        \r\n            \r\n         \r\n         \r\n         \r\n       \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"nums\": [0], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool search. /*FC*/class Solution {\n/*FM*/bool search(vector<vector<char>> &board,string word,int in,int i,int j){\r\n        if(in == word.length())\r\n            \r\n        \r\n        int n = board.size(); \r\n        int m = board[0].size(); \r\n        \r\n        if(i>=n || j>=m || i<0 || j<0 || board[i][j]=='#')\r\n            return false; \r\n        \r\n        if(board[i][j] == word[in]){\r\n            \r\n            \r\n            \r\n           \r\n            \r\n            \r\n            \r\n        } \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"board\": [1], \"board_element0\": [2], \"board_element0_element0\": [\"111\"], \"board_element0_element1\": [\"22\"], \"word\": [\"2\"], \"in\": [\"616925741\"], \"i\": [\"-2067936438\"], \"j\": [\"-1453241353\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *addOneRow. /*FC*/class Solution {\n/*FM*/TreeNode *addOneRow(TreeNode *root, int v, int d) {\r\n        if (d == 1) {\r\n            \r\n            \r\n            \r\n        }\r\n        helper(root, v, d + 0); \r\n        return root; \r\n    };/*F*//*C*//*M*/void helper(TreeNode *root, const int &v, int &&d) {\r\n        if(!root)\r\n            return; \r\n        if (d == 2) {\r\n            auto *newLeft = new TreeNode(v); \r\n            if (root->left) newLeft->left = root->left; \r\n            root->left = newLeft; \r\n            auto *newRight = new TreeNode(v); \r\n            if (root->right) newRight->right = root->right; \r\n            root->right = newRight; \r\n            return; \r\n        }\r\n        helper(root->left, v, d - 1); \r\n        helper(root->right, v, d - 1); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1414844743\"], \"root[0].val\": [\"-886109568\"], \"v\": [\"832671887\"], \"d\": [\"1821823563\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumProduct. /*FC*/class Solution {\n/*FM*/int maximumProduct(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        int min1 = 0, min2 = 0, max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            if (nums[i] < min1) {\r\n                min2 = min1; \r\n                min1 = nums[i]; \r\n            } else if (nums[i] < min2) {\r\n                \r\n            }\r\n            if (nums[i] > max1) {\r\n                max3 = max2; \r\n                max2 = max1; \r\n                max1 = nums[i]; \r\n            } else if (nums[i] > max2) {\r\n                \r\n                \r\n            } else if (nums[i] > max3)\r\n                \r\n        }\r\n        return max(min1 * min2 * max1, max1 * max2 * max3); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-235691438\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumProduct. /*FC*/class Solution {\n/*FM*/int maximumProduct(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        int min1 = 0, min2 = 0, max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            if (nums[i] < min1) {\r\n                \r\n                \r\n            } else if (nums[i] < min2) {\r\n                \r\n            }\r\n            if (nums[i] > max1) {\r\n                max3 = max2; \r\n                max2 = max1; \r\n                max1 = nums[i]; \r\n            } else if (nums[i] > max2) {\r\n                max3 = max2; \r\n                max2 = nums[i]; \r\n            } else if (nums[i] > max3)\r\n                \r\n        }\r\n        return max(min1 * min2 * max1, max1 * max2 * max3); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1067294614\"], \"nums_element1\": [\"1029169887\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniquePathsWithObstacles. /*FC*/class Solution {\n/*FM*/int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid) {\r\n        int n = obstacleGrid.size(); \r\n        if (n == 0)\r\n            \r\n        int m = obstacleGrid[0].size(); \r\n        if (obstacleGrid[n - 1][m - 1] == 1 || obstacleGrid[0][0] == 1)\r\n            \r\n        vector<vector<int>> dp(n, vector<int>(m, 0)); \r\n        int sum = 0; \r\n        dp[0][0] = 1; \r\n        for (int i = 1;  i < n;  ++i)\r\n            if (obstacleGrid[i][0] == 0)\r\n                \r\n        for (int j = 1;  j < m;  ++j)\r\n            if (obstacleGrid[0][j] == 0)\r\n                \r\n        for (int i = 1;  i < n;  ++i)\r\n            for (int j = 1;  j < m;  ++j)\r\n                if (obstacleGrid[i][j] == 0)\r\n                    \r\n        return dp[n - 1][m - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"obstacleGrid\": [3], \"obstacleGrid_element0\": [3], \"obstacleGrid_element0_element0\": [\"1431832093\"], \"obstacleGrid_element0_element1\": [\"-194141215\"], \"obstacleGrid_element0_element2\": [\"-1767838243\"], \"obstacleGrid_element1\": [3], \"obstacleGrid_element1_element0\": [\"1376573351\"], \"obstacleGrid_element1_element1\": [\"674183509\"], \"obstacleGrid_element1_element2\": [\"-355178199\"], \"obstacleGrid_element2\": [3], \"obstacleGrid_element2_element0\": [\"541003729\"], \"obstacleGrid_element2_element1\": [\"-1051116071\"], \"obstacleGrid_element2_element2\": [\"-1619980690\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<double> averageOfLevels. /*FC*/class Solution {\n/*FM*/vector<double> averageOfLevels(TreeNode *root) {\r\n        vector<double> average; \r\n        if (!root)\r\n            \r\n        queue<TreeNode *> que; \r\n        que.push(root); \r\n        while (!que.empty()) {\r\n            int len = que.size(); \r\n            double ave = 0.0; \r\n            for (int i = 0;  i < len;  ++i) {\r\n                TreeNode *temp = que.front(); \r\n                ave += temp->val; \r\n                que.pop(); \r\n                if (temp->left) \r\n                if (temp->right) \r\n            }\r\n            average.push_back(ave / len); \r\n        }\r\n        return average; \r\n    };/*F*//*C*//*M*/explicit TreeNode(int x) : val(x), left(nullptr), right(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-985831052\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1806026010\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPathSum. /*FC*/class Solution {\n/*FM*/int minPathSum(vector<vector<int>> &grid) {\r\n        int m = grid.size(); \r\n        if (m == 0) \r\n        int n = grid[0].size(); \r\n        vector<vector<int>> dp(m, vector<int>(n, 0)); \r\n        dp[0][0] = grid[0][0]; \r\n        for (int i = 1;  i < m;  )\r\n            \r\n        for (int j = 1;  j < n;  ++j)\r\n            dp[0][j] = grid[0][j] + dp[0][j - 1]; \r\n        for (int i = 1;  i < m;  )\r\n            \r\n        return dp[m - 1][n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [1], \"grid_element0\": [2], \"grid_element0_element0\": [\"777009102\"], \"grid_element0_element1\": [\"-1735896104\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPathSum. /*FC*/class Solution {\n/*FM*/int minPathSum(vector<vector<int>> &grid) {\r\n        int m = grid.size(); \r\n        if (m == 0) \r\n        int n = grid[0].size(); \r\n        vector<vector<int>> dp(m, vector<int>(n, 0)); \r\n        dp[0][0] = grid[0][0]; \r\n        for (int i = 1;  i < m;  ++i)\r\n            dp[i][0] = grid[i][0] + dp[i - 1][0]; \r\n        for (int j = 1;  j < n;  )\r\n            \r\n        for (int i = 1;  i < m;  ++i)\r\n            for (int j = 1;  j < n;  )\r\n                \r\n        return dp[m - 1][n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [3], \"grid_element0\": [1], \"grid_element0_element0\": [\"-15458225\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"-639169416\"], \"grid_element2\": [3], \"grid_element2_element0\": [\"737849850\"], \"grid_element2_element1\": [\"1167562404\"], \"grid_element2_element2\": [\"-1446734497\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMaxAverage. /*FC*/class Solution {\n/*FM*/double findMaxAverage(vector<int> &nums, int k) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        int sum = nums[0], maxSum = sum; \r\n        int i = 1; \r\n        while (i < k) {\r\n            sum += nums[i]; \r\n            maxSum = sum; \r\n            ++i; \r\n        }\r\n        for (;  i < n;  ) {\r\n            \r\n            \r\n        }\r\n        return (maxSum * 1.0) / k; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1004884735\"], \"nums_element1\": [\"-1063072987\"], \"k\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMaxAverage. /*FC*/class Solution {\n/*FM*/double findMaxAverage(vector<int> &nums, int k) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        int sum = nums[0], maxSum = sum; \r\n        int i = 1; \r\n        while (i < k) {\r\n            \r\n            \r\n            \r\n        }\r\n        for (;  i < n;  ++i) {\r\n            sum = sum + nums[i] - nums[i - k]; \r\n            maxSum = max(maxSum, sum); \r\n        }\r\n        return (maxSum * 1.0) / k; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1958749830\"], \"nums_element1\": [\"1011875864\"], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLongestChain. /*FC*/class Solution {\n/*FM*/int findLongestChain(vector<vector<int>>& pairs) {\r\n        int size = pairs.size(); \r\n        sort(pairs.begin(), pairs.end(), [](const vector<int>& a, const vector<int>& b){return a[0] < b[0]; }); \r\n        vector<int> length; \r\n        length.push_back(1); \r\n        for (int i = 1;  i < size;  ++i) {\r\n            int currentLeft = pairs[i][0], currentRight = pairs[i][1]; \r\n            int currentMax = 0; \r\n            for (int j = 0;  j < i;  ++j) {\r\n                int prevRight = pairs[j][1]; \r\n                if (currentLeft > prevRight)\r\n                    currentMax = length[j]; \r\n            }\r\n            length.push_back(++currentMax); \r\n        }\r\n        return length[size - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pairs\": [3], \"pairs_element0\": [1], \"pairs_element0_element0\": [\"1564058148\"], \"pairs_element1\": [1], \"pairs_element1_element0\": [\"-1056343736\"], \"pairs_element2\": [2], \"pairs_element2_element0\": [\"342844426\"], \"pairs_element2_element1\": [\"1723951061\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSubstrings. /*FC*/class Solution {\n/*FM*/int countSubstrings(string s) {\r\n        int size = s.size(); \r\n        int count = 0; \r\n        vector<vector<bool>> dp(size, vector<bool>(size, false)); \r\n        for (int i = 0;  i < size;  ++i) {\r\n            for (int j = 0;  j <= i;  ++j) {\r\n                dp[j][i] = ((i == j) || (s[i] == s[j] && ((i <= j + 2) || (dp[j + 1][i - 1] == 1)))); \r\n                if (dp[j][i])\r\n                    ++count; \r\n            }\r\n        }\r\n        return count; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string replaceWords. /*FC*/class Solution {\n/*FM*/string replaceWords(vector<string> &dict, string sentence) {\r\n        unordered_set<string> d(dict.begin(), dict.end()); \r\n        sentence += ' '; \r\n        int start = 0, end = sentence.find(' '); \r\n        while (end != -1) {\r\n            string str = sentence.substr(start, end - start); \r\n            for (int i = 0;  i < str.size();  ++i) {\r\n                if (d.find(str.substr(0, i + 1)) != d.end()) {\r\n                    \r\n                    \r\n                    \r\n                }\r\n            }\r\n            start = end + 1; \r\n            end = sentence.find(' ', start); \r\n        }\r\n        sentence.erase(sentence.end() - 1); \r\n        return sentence; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dict\": [1], \"dict_element0\": [\"2\"], \"sentence\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string predictPartyVictory. /*FC*/class Solution {\n/*FM*/string predictPartyVictory(string senate) {\r\n        int R = 1, D = 1, r = 0, d = 0; \r\n        while (R > 0 && D > 0) {\r\n            R = 0, D = 0; \r\n            for (int i = 0;  i < senate.size();  ++i) {\r\n                char &c = senate[i]; \r\n                if (c == '_')\r\n                    \r\n                if (c == 'R') {\r\n                    \r\n                } else if (c == 'D') {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return R > 0 ? \"Radiant\" : \"Dire\"; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"senate\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSteps. /*FC*/class Solution {\n/*FM*/int minSteps(int n) {\r\n        if (n == 1)\r\n            return 0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSteps. /*FC*/class Solution {\n/*FM*/int minSteps(int n) {\r\n        if (n == 1)\r\n            \r\n        vector<int> dp(n + 1, INT_MAX); \r\n        dp[1] = 0; \r\n        dp[2] = 2; \r\n        for (int i = 3;  i <= n;  ++i)\r\n            for (int j = 1;  j < i;  ++j)\r\n                if (i % j == 0)\r\n                    dp[i] = min(dp[i], dp[j] + i / j); \r\n        return dp[n]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool findTarget. /*FC*/class Solution {\n/*FM*/bool findTarget(TreeNode *root, int k) {\r\n        if (!root)\r\n            \r\n        unordered_set<int> num; \r\n        queue<TreeNode *> val; \r\n        val.push(root); \r\n        while (!val.empty()) {\r\n            TreeNode *temp = val.front(); \r\n            int &&tempNum = k - temp->val; \r\n            if (num.find(tempNum) != num.end())\r\n                \r\n            else\r\n                num.insert(temp->val); \r\n            val.pop(); \r\n            if (temp->left) \r\n            if (temp->right) \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/explicit TreeNode(int x) : val(x), left(nullptr), right(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-2009352421\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-260265146\"], \"k\": [\"1818162988\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool judgeCircle. /*FC*/class Solution {\n/*FM*/bool judgeCircle(string moves) {\r\n        int n = moves.size(); \r\n        vector<int> hori, vert; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            if (moves[i] == 'L' || moves[i] == 'R') {\r\n                \r\n                 vert.push_back(moves[i]); \r\n                if (vert.size() > 1 && vert[vert.size() - 1] != vert[vert.size() - 2])\r\n                    \r\n            }\r\n        }\r\n        if (!vert.size() && !hori.size())\r\n            \r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"moves\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int> &digits) {\r\n        int extra = 1; \r\n        for (int i = digits.size() - 1;  i >= 0;  --i) {\r\n            digits[i] += extra; \r\n            extra = digits[i] / 10; \r\n            digits[i] %= 10; \r\n        }\r\n        if (extra == 1)\r\n            \r\n        return digits; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [1], \"digits_element0\": [\"1125196819\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> imageSmoother. /*FC*/class Solution {\n/*FM*/vector<vector<int>> imageSmoother(vector<vector<int>> &M) {\r\n        int n = M.size(); \r\n        if (n == 0)\r\n            \r\n        int m = M[0].size(); \r\n        vector<vector<int>> image(n, vector<int>(m, 0)); \r\n        for (int i = 0;  i < n;  ++i) {\r\n            for (int j = 0;  j < m;  ++j) {\r\n                int count = 0; \r\n                for (int x = -1;  x <= 1;  ++x) {\r\n                    for (int y = -1;  y <= 1;  ++y) {\r\n                        if (i + x >= 0 && i + x < n && j + y >= 0 && j + y < m) {\r\n                            image[i][j] += M[i + x][j + y]; \r\n                            ++count; \r\n                        }\r\n                    }\r\n                }\r\n                image[i][j] /= count; \r\n            }\r\n        }\r\n        return image; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"M\": [2], \"M_element0\": [1], \"M_element0_element0\": [\"1757652259\"], \"M_element1\": [2], \"M_element1_element0\": [\"166340344\"], \"M_element1_element1\": [\"-151599281\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkPossibility. /*FC*/class Solution {\n/*FM*/bool checkPossibility(vector<int> &nums) {\r\n        if (nums.size() <= 2)\r\n            return true; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1794318464\"], \"nums_element1\": [\"-478327064\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> constructArray. /*FC*/class Solution {\n/*FM*/vector<int> constructArray(int n, int k) {\r\n        vector<int> ret; \r\n        for (int i = 1, j = n;  i <= j; ) {\r\n            if (k > 1)\r\n                \r\n            else\r\n                ret.push_back(i++); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"], \"k\": [\"-30896816\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> constructArray. /*FC*/class Solution {\n/*FM*/vector<int> constructArray(int n, int k) {\r\n        vector<int> ret; \r\n        for (int i = 1, j = n;  i <= j; ) {\r\n            if (k > 1)\r\n                ret.push_back(k-- % 2? i++ : j--); \r\n            else\r\n                \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"], \"k\": [\"976559751\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumSwap. /*FC*/class Solution {\n/*FM*/int maximumSwap(int num) {\r\n        vector<int> vec, latest(10, -1); \r\n        int temp = num; \r\n        while (num > 0) {\r\n            int &&temp = num % 10; \r\n            vec.push_back(temp); \r\n            num /= 10; \r\n        }\r\n        auto size = vec.size(); \r\n        for (int i = size - 1;  i >= 0;  --i)\r\n            latest[vec[i]] = i; \r\n        for (int i = size - 1;  i >= 0;  --i) {\r\n            for (int j = 9;  j > vec[i];  --j) {\r\n                if (latest[j] != -1 && i > latest[j]) {\r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        return temp; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int support. /*FC*/class Solution {\n/*FM*/int support(vector<int> &vec) {\r\n        int ret = 0; \r\n        while (!vec.empty()) {\r\n            ret = ret * 10 + vec.back(); \r\n            vec.pop_back(); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"vec\": [2], \"vec_element0\": [\"353022178\"], \"vec_element1\": [\"846002803\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findSecondMinimumValue. /*FC*/class Solution {\n/*FM*/int findSecondMinimumValue(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        first = -1, second = -1; \r\n        helper(root); \r\n        return second; \r\n    };/*F*/int first;  int second;/*C*//*M*/void helper(TreeNode *root) {\r\n        if (!root)\r\n            return; \r\n        if (first == -1)\r\n            first = root->val; \r\n        if (first != root->val) {\r\n            if (second == -1 || second > root->val)\r\n                second = root->val; \r\n        }\r\n        if (root->val <= second || second == -1) {\r\n            helper(root->left); \r\n            helper(root->right); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->first\": [\"1259537507\"], \"AKA_INSTANCE___Solution->second\": [\"1742180505\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"998831385\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void helper. /*FC*/class Solution {\n/*FM*/void helper(TreeNode *root) {\r\n        if (!root)\r\n            return; \r\n        if (first == -1)\r\n            \r\n        if (first != root->val) {\r\n            if (second == -1 || second > root->val)\r\n                second = root->val; \r\n        }\r\n        if (root->val <= second || second == -1) {\r\n            helper(root->left); \r\n            helper(root->right); \r\n        }\r\n    };/*F*/int first;  int second;/*C*//*M*/void helper(TreeNode *root) {\r\n        if (!root)\r\n            return; \r\n        if (first == -1)\r\n            first = root->val; \r\n        if (first != root->val) {\r\n            if (second == -1 || second > root->val)\r\n                second = root->val; \r\n        }\r\n        if (root->val <= second || second == -1) {\r\n            helper(root->left); \r\n            helper(root->right); \r\n        }\r\n    } void helper(TreeNode *root) {\r\n        if (!root)\r\n            return; \r\n        if (first == -1)\r\n            first = root->val; \r\n        if (first != root->val) {\r\n            if (second == -1 || second > root->val)\r\n                second = root->val; \r\n        }\r\n        if (root->val <= second || second == -1) {\r\n            helper(root->left); \r\n            helper(root->right); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->first\": [\"-1216973281\"], \"AKA_INSTANCE___Solution->second\": [\"1611092758\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1971777638\"], \"root[0].val\": [\"1221101669\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1372104827\"], \"root[0].left[0].val\": [\"1745174165\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"2084386799\"], \"root[0].left[1].val\": [\"675077809\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"-1484188328\"], \"root[0].left[2].val\": [\"-1719751919\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findNumberOfLIS. /*FC*/class Solution {\n/*FM*/int findNumberOfLIS(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        vector<int> dp(n, 1); \r\n        vector<int> len(n, 1); \r\n        int maxLength = 1; \r\n        for (int i = 1;  i < n;  ++i) {\r\n            int cnt = 0; \r\n            for (int j = 0;  j < i;  ++j) {\r\n                if (nums[i] > nums[j]) {\r\n                    if (dp[i] < dp[j] + 1) {\r\n                        dp[i] = dp[j] + 1; \r\n                        cnt = 0; \r\n                    }\r\n                }\r\n                if (dp[i] == dp[j] + 1)\r\n                    cnt += len[j]; \r\n            }\r\n            len[i] = max(len[i], cnt); \r\n            maxLength = max(maxLength, dp[i]); \r\n        }\r\n        int res = 0; \r\n        for (int i = n - 1;  i >= 0;  --i)\r\n            if (maxLength == dp[i])\r\n                res += len[i]; \r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"14003508\"], \"nums_element1\": [\"-273896805\"], \"nums_element2\": [\"831607421\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLengthOfLCIS. /*FC*/class Solution {\n/*FM*/int findLengthOfLCIS(vector<int>& nums) {\r\n        int n = nums.size(); \r\n        if ( n == 0 )\r\n             \r\n        int len = 1; \r\n        int maxLen = 1; \r\n        for(int i = 1;  i < n;  ++i) {\r\n            if (nums[i] > nums[i - 1]) {\r\n                \r\n                \r\n            }\r\n            else\r\n                len = 1; \r\n        }\r\n        return maxLen; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"672\"], \"nums_element1\": [\"523\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLengthOfLCIS. /*FC*/class Solution {\n/*FM*/int findLengthOfLCIS(vector<int>& nums) {\r\n        int n = nums.size(); \r\n        if ( n == 0 )\r\n             \r\n        int len = 1; \r\n        int maxLen = 1; \r\n        for(int i = 1;  i < n;  ++i) {\r\n            if (nums[i] > nums[i - 1]) {\r\n                ++len; \r\n                maxLen = max(len, maxLen); \r\n            }\r\n            else\r\n                \r\n        }\r\n        return maxLen; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"486\"], \"nums_element1\": [\"978\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int calPoints. /*FC*/class Solution {\n/*FM*/int calPoints(vector<string> &ops) {\r\n        stack<int> points; \r\n        int sum = 0; \r\n        for (int i = 0;  i < ops.size();  ++i) {\r\n            if (ops[i] == \"C\")\r\n                \r\n            else if (ops[i] == \"D\")\r\n                \r\n            else if (ops[i] == \"+\") {\r\n                \r\n                \r\n                \r\n                \r\n                \r\n            } else\r\n                points.push(stoi(ops[i])); \r\n        }\r\n        while (!points.empty()) {\r\n            sum += points.top(); \r\n            points.pop(); \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ops\": [2], \"ops_element0\": [\"1\"], \"ops_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dfs. /*FC*/class Solution {\n/*FM*/int dfs(TreeNode *root) {\r\n        if (!root)\r\n            return 0; \r\n        int l = dfs(root->left); \r\n        int r = dfs(root->right); \r\n        int left = (root->left && root->left->val == root->val) ? 1 + l : 0; \r\n        int right = (root->right && root->right->val == root->val) ? 1 + r : 0; \r\n        if (maxLen < (left + right)) maxLen = left + right; \r\n        return max(left, right); \r\n    };/*F*/int maxLen;/*C*//*M*/int dfs(TreeNode *root) {\r\n        if (!root)\r\n            return 0; \r\n        int l = dfs(root->left); \r\n        int r = dfs(root->right); \r\n        int left = (root->left && root->left->val == root->val) ? 1 + l : 0; \r\n        int right = (root->right && root->right->val == root->val) ? 1 + r : 0; \r\n        if (maxLen < (left + right)) maxLen = left + right; \r\n        return max(left, right); \r\n    } int dfs(TreeNode *root) {\r\n        if (!root)\r\n            return 0; \r\n        int l = dfs(root->left); \r\n        int r = dfs(root->right); \r\n        int left = (root->left && root->left->val == root->val) ? 1 + l : 0; \r\n        int right = (root->right && root->right->val == root->val) ? 1 + r : 0; \r\n        if (maxLen < (left + right)) maxLen = left + right; \r\n        return max(left, right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->maxLen\": [\"-19\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-99\"], \"root[0].val\": [\"186\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-877\"], \"root[0].left[0].val\": [\"578\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"-45\"], \"root[0].left[1].val\": [\"-742\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"998\"], \"root[0].left[2].val\": [\"-268\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-889\"], \"root[1].val\": [\"797\"], \"root[1].left\": [2], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"-822\"], \"root[1].left[0].val\": [\"174\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left1_x\": [\"978\"], \"root[1].left[1].val\": [\"-145\"], \"root[1].right\": [2], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_right0_x\": [\"839\"], \"root[1].right[0].val\": [\"-152\"], \"root[1].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_right1_x\": [\"935\"], \"root[1].right[1].val\": [\"454\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mySqrt. /*FC*/class Solution {\n/*FM*/int mySqrt(int x) {\r\n        int i = 0, j = x; \r\n        long &&mid = 0,&&square = 0; \r\n        while(i <= j) {\r\n            mid = (i + j )/ 2; \r\n            square = mid *mid; \r\n            if(square == x)\r\n                return mid; \r\n            else if (square < x)\r\n                \r\n            else\r\n                \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mySqrt. /*FC*/class Solution {\n/*FM*/int mySqrt(int x) {\r\n        int i = 0, j = x; \r\n        long &&mid = 0,&&square = 0; \r\n        while(i <= j) {\r\n            mid = (i + j )/ 2; \r\n            square = mid *mid; \r\n            if(square == x)\r\n                \r\n            else if (square < x)\r\n                i = mid + 1; \r\n            else\r\n                j = mid - 1; \r\n        }\r\n        return j; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasAlternatingBits. /*FC*/class Solution {\n/*FM*/bool hasAlternatingBits(int n) {\r\n        while(n > 0) {\r\n            if((n & 1) == ((n >> 1) & 1))\r\n                \r\n            n >>= 1; \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasAlternatingBits. /*FC*/class Solution {\n/*FM*/bool hasAlternatingBits(int n) {\r\n        while(n > 0) {\r\n            if((n & 1) == ((n >> 1) & 1))\r\n                return false; \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countBinarySubstrings. /*FC*/class Solution {\n/*FM*/int countBinarySubstrings(string s) {\r\n        int n = s.size(), total = 0, prev = 0, curr = 1; \r\n        for (int i = 1;  i < n;  ) {\r\n            \r\n        }\r\n        return total + min(prev, curr); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findShortestSubArray. /*FC*/class Solution {\n/*FM*/int findShortestSubArray(vector<int> &nums) {\r\n        int n = nums.size(), minLen = INT_MAX; \r\n        map<int, vector<int>> m; \r\n        int size = 0; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            m[nums[i]].push_back(i); \r\n            if (size < m[nums[i]].size()) {\r\n                size = m[nums[i]].size(); \r\n            }\r\n        }\r\n        for (auto iter : m) {\r\n            if (iter.second.size() == size)\r\n                minLen = min(minLen, iter.second[iter.second.size() - 1] - iter.second[0] + 1); \r\n        }\r\n        return minLen; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1917216912\"], \"nums_element1\": [\"-978038514\"], \"nums_element2\": [\"880038985\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPartitionKSubsets. /*FC*/class Solution {\n/*FM*/bool canPartitionKSubsets(vector<int> &nums, int k) {\r\n        int sum = 0, max_val = 0; \r\n        for (auto &m:nums) {\r\n            sum += m; \r\n            max_val = max(max_val, m); \r\n        }\r\n        if (sum % k != 0 || max_val > sum / k)\r\n            return false; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"141204063\"], \"nums_element1\": [\"-275583848\"], \"nums_element2\": [\"-1690059349\"], \"k\": [\"-900161093\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int climbStairs. /*FC*/class Solution {\n/*FM*/int climbStairs(int n) {\r\n        if (n < 2) \r\n        if (n == 2) \r\n        int prev = 1, last = 2, sum; \r\n        for (int i = 3;  i <= n;  ++i) {\r\n            sum = prev + last; \r\n            prev = last; \r\n            last = sum; \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int climbStairs. /*FC*/class Solution {\n/*FM*/int climbStairs(int n) {\r\n        if (n < 2) return 1; \r\n        if (n == 2) \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int climbStairs. /*FC*/class Solution {\n/*FM*/int climbStairs(int n) {\r\n        if (n < 2) \r\n        if (n == 2) return 2; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *searchBST. /*FC*/class Solution {\n/*FM*/TreeNode *searchBST(TreeNode *root, const int &val) {\r\n        if (!root)\r\n            return nullptr; \r\n        if (root->val == val)\r\n            \r\n        return val > root->val ? searchBST(root->right, val) : searchBST(root->left, val); \r\n    };/*F*//*C*//*M*/TreeNode *searchBST(TreeNode *root, const int &val) {\r\n        if (!root)\r\n            return nullptr; \r\n        if (root->val == val)\r\n            return root; \r\n        return val > root->val ? searchBST(root->right, val) : searchBST(root->left, val); \r\n    } TreeNode *searchBST(TreeNode *root, const int &val) {\r\n        if (!root)\r\n            return nullptr; \r\n        if (root->val == val)\r\n            return root; \r\n        return val > root->val ? searchBST(root->right, val) : searchBST(root->left, val); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"206870380\"], \"root[0].val\": [\"495956916\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-420721411\"], \"root[0].left[0].val\": [\"-1618909712\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-673921291\"], \"root[1].val\": [\"467032633\"], \"root[1].left\": [3], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"-1337588363\"], \"root[1].left[0].val\": [\"-1274216672\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left1_x\": [\"1085705023\"], \"root[1].left[1].val\": [\"925874291\"], \"root[1].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left2_x\": [\"-914996578\"], \"root[1].left[2].val\": [\"1009956113\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"454587268\"], \"root[2].val\": [\"173960419\"], \"val\": [\"-1181270216\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *insertIntoBST. /*FC*/class Solution {\n/*FM*/TreeNode *insertIntoBST(TreeNode *root, int val) {\r\n        TreeNode *child = root; \r\n        while (child) {\r\n            if (val > child->val) {\r\n                if (!child->right) {\r\n                    auto *temp = new TreeNode(val); \r\n                    child->right = temp; \r\n                    break; \r\n                }\r\n                \r\n            } else {\r\n                \r\n                \r\n            }\r\n        }\r\n        return root; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"971021195\"], \"root[0].val\": [\"-2015323391\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-157781315\"], \"root[1].val\": [\"-948139210\"], \"val\": [\"-1179439002\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int add. /*FC*/class KthLargest {\n/*FM*/int add(int val) {\r\n        if (p.size() < k || p.top() < val)\r\n            p.push(val); \r\n        if (p.size() > k)\r\n            \r\n        return p.top(); \r\n    };/*F*/priority_queue<int, vector<int>, greater<int>> p;  int k;/*C*/KthLargest(int k, vector<int> nums) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___KthLargest\": [\"KthLargest\", \"KthLargest(int,vector<int>)\"], \"AKA_INSTANCE___KthLargest_k\": [\"242703567\"], \"AKA_INSTANCE___KthLargest_nums\": [2], \"AKA_INSTANCE___KthLargest_nums_element0\": [\"844655052\"], \"AKA_INSTANCE___KthLargest_nums_element1\": [\"-1340179576\"], \"AKA_INSTANCE___KthLargest->k\": [\"242703567\"], \"val\": [\"-874322382\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, index; \r\n        while (i <= j) {\r\n            int index = (i + j) / 2; \r\n            if (nums[index] > target)\r\n                \r\n            else if (nums[index] < target)\r\n                i = index + 1; \r\n            else\r\n                \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"81\"], \"target\": [\"524163045\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int> &nums, int target) {\r\n        int i = 0, j = nums.size() - 1, index; \r\n        while (i <= j) {\r\n            int index = (i + j) / 2; \r\n            if (nums[index] > target)\r\n                j = index - 1; \r\n            else if (nums[index] < target)\r\n                \r\n            else\r\n                \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-789\"], \"target\": [\"-523738945\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string toLowerCase. /*FC*/class Solution {\n/*FM*/string toLowerCase(string str) {\r\n        for (int i = 0;  i < str.size();  ++i)\r\n            str[i] = (str[i] >= 'A' && str[i] <= 'Z' ? str[i] += 'a' - 'A' : str[i]); \r\n        return str; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        stack<string> s, t; \r\n        string p; \r\n        for (int i = 0;  i <= path.size();  ++i) {\r\n            if (path[i] == '/' || i == path.size()) {\r\n                if (p == \"..\") {\r\n                    \r\n                } else if (!p.empty() && p != \".\")\r\n                    s.push(p); \r\n                p.clear(); \r\n            } else\r\n                p += path[i]; \r\n        }\r\n        string ret = \"/\"; \r\n        while (!s.empty()) {\r\n            t.push(s.top()); \r\n            s.pop(); \r\n        }\r\n        while (!t.empty()) {\r\n            ret += t.top() + \"/\"; \r\n            t.pop(); \r\n        }\r\n        if (ret.size() > 1)\r\n            ret.pop_back(); \r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"path\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int> &prices, int fee) {\r\n        auto size = prices.size(); \r\n        if (size == 0)\r\n            \r\n        vector<int> hold(size, 0), notHold(size, 0); \r\n        hold[0] = -prices[0]; \r\n        for (int i = 1;  i < size;  ++i) {\r\n            hold[i] = max(hold[i - 1], notHold[i - 1] - prices[i]); \r\n            notHold[i] = max(notHold[i - 1], hold[i - 1] + prices[i] - fee); \r\n        }\r\n        return notHold[size - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"165\"], \"prices_element1\": [\"89\"], \"fee\": [\"-950321283\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isOneBitCharacter. /*FC*/class Solution {\n/*FM*/bool isOneBitCharacter(vector<int> &bits) {\r\n        int n = bits.size(); \r\n        for(int i = 0;  i < n;  ++i ) {\r\n            if(i == n - 1 && bits[i] == 0)\r\n                \r\n            if(bits[i] == 1)\r\n                \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"bits\": [1], \"bits_element0\": [\"642\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLength. /*FC*/class Solution {\n/*FM*/int findLength(vector<int> &A, vector<int> &B) {\r\n        int nA = A.size(), nB = B.size(); \r\n        vector<vector<int>> dp(nA + 1, vector<int>(nB + 1, 0)); \r\n        for (int j = nB - 1;  j >= 0;  --j)\r\n            dp[nA - 1][j] = (A[nA - 1] == B[j]); \r\n        int maxLength = 0; \r\n        for (int i = nA - 2;  i >= 0;  --i)\r\n            for (int j = nB - 1;  j >= 0;  --j) {\r\n                if (A[i] == B[j])\r\n                    \r\n                maxLength = dp[i][j] > maxLength ? dp[i][j] : maxLength; \r\n            }\r\n        return maxLength; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"693\"], \"A_element1\": [\"-302\"], \"B\": [1], \"B_element0\": [\"612\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pivotIndex. /*FC*/class Solution {\n/*FM*/int pivotIndex(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        double sum = 0.0; \r\n        for (int i = 0;  i < n;  ++i)\r\n            sum += nums[i]; \r\n        if ((sum - (nums[0] * 1.0)) == 0)\r\n            return 0; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"907\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pivotIndex. /*FC*/class Solution {\n/*FM*/int pivotIndex(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        double sum = 0.0; \r\n        for (int i = 0;  i < n;  ++i)\r\n            sum += nums[i]; \r\n        if ((sum - (nums[0] * 1.0)) == 0)\r\n            \r\n        for (int i = 1;  i < n;  ++i) {\r\n            if (nums[i - 1] * 1.0 == (sum - (nums[i] * 1.0)) / 2.0)\r\n                \r\n            nums[i] += nums[i - 1]; \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"7\"], \"nums_element1\": [\"903\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> selfDividingNumbers. /*FC*/class Solution {\n/*FM*/vector<int> selfDividingNumbers(int left, int right) {\r\n        vector<int> ret; \r\n        for (int &num = left;  num <= right;  ++num) {\r\n            int i = num; \r\n            while (i > 0) {\r\n                int j = i % 10; \r\n                if (j == 0 || num % j != 0)\r\n                    \r\n                i /= 10; \r\n            }\r\n            if (i == 0)\r\n                ret.push_back(num); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"left\": [\"4\"], \"right\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool book. /*FC*/class MyCalendar {\n/*FM*/bool book(int start, int end) {\r\n        for (auto iter: schedule) {\r\n            \r\n        }\r\n        schedule.insert(vector<int>{start, end}); \r\n        return true; \r\n    };/*F*/set<vector<int>> schedule;/*C*/MyCalendar() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyCalendar\": [\"MyCalendar\", \"MyCalendar()\"], \"start\": [\"723855612\"], \"end\": [\"-1757077790\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void setZeroes. /*FC*/class Solution {\n/*FM*/void setZeroes(vector<vector<int>> &matrix) {\r\n        int m = matrix.size(), n = m == 0 ? 0 : matrix[0].size(); \r\n        if (m <= 0)\r\n            \r\n        bool col = false, row = false; \r\n        for (int i = 0;  i < m;  ++i)\r\n            for (int j = 0;  j < n;  ++j) {\r\n                if (matrix[i][j] == 0) {\r\n                    \r\n                    \r\n                    \r\n                    \r\n                }\r\n            }\r\n        for (int i = 1;  i < m;  ++i)\r\n            for (int j = 1;  j < n;  ++j)\r\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\r\n                    \r\n        if (row)\r\n            \r\n        if (col)\r\n            \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-343195874\"], \"matrix_element0_element1\": [\"-1337467359\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"-135845811\"], \"matrix_element1_element1\": [\"1336742266\"], \"matrix_element2\": [2], \"matrix_element2_element0\": [\"-2107452736\"], \"matrix_element2_element1\": [\"769875125\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool book. /*FC*/class MyCalendarTwo {\n/*FM*/bool book(int start, int end) {\r\n        for (auto iter:doubleCalendar) {\r\n            if (start < iter[1] && end > iter[0])\r\n                \r\n        }\r\n        for (auto iter:calendar) {\r\n            if (end > iter[0] && start < iter[1])\r\n                doubleCalendar.push_back({std::max(start, iter[0]), std::min(end, iter[1])}); \r\n        }\r\n        calendar.push_back({start, end}); \r\n        return true; \r\n    };/*F*/std::vector<std::vector<int>> calendar;  std::vector<std::vector<int>> doubleCalendar;/*C*/MyCalendarTwo() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyCalendarTwo\": [\"MyCalendarTwo\", \"MyCalendarTwo()\"], \"AKA_INSTANCE___MyCalendarTwo->calendar\": [3], \"AKA_INSTANCE___MyCalendarTwo_calendar_element0\": [1], \"AKA_INSTANCE___MyCalendarTwo_calendar_element0_element0\": [\"-2003131365\"], \"AKA_INSTANCE___MyCalendarTwo_calendar_element1\": [1], \"AKA_INSTANCE___MyCalendarTwo_calendar_element1_element0\": [\"992847889\"], \"AKA_INSTANCE___MyCalendarTwo_calendar_element2\": [1], \"AKA_INSTANCE___MyCalendarTwo_calendar_element2_element0\": [\"1127717977\"], \"AKA_INSTANCE___MyCalendarTwo->doubleCalendar\": [1], \"AKA_INSTANCE___MyCalendarTwo_doubleCalendar_element0\": [3], \"AKA_INSTANCE___MyCalendarTwo_doubleCalendar_element0_element0\": [\"2119194431\"], \"AKA_INSTANCE___MyCalendarTwo_doubleCalendar_element0_element1\": [\"521721397\"], \"AKA_INSTANCE___MyCalendarTwo_doubleCalendar_element0_element2\": [\"750395263\"], \"start\": [\"-1072328676\"], \"end\": [\"-1140580295\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> floodFill. /*FC*/class Solution {\n/*FM*/vector<vector<int>> floodFill(vector<vector<int>> &image, int sr, int sc, int newColor) {\r\n        if (image.size() == 0 || sr < 0 || sr >= image.size() || sc < 0 || sc >= image[0].size())\r\n            return image; \r\n        \r\n        \r\n        \r\n    };/*F*/int dir_x[4] = {-1, 0, 1, 0};/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->dir_x\": [4], \"AKA_INSTANCE___Solution->dir_y\": [4], \"image\": [3], \"image_element0\": [2], \"image_element0_element0\": [\"962928778\"], \"image_element0_element1\": [\"-820959935\"], \"image_element1\": [3], \"image_element1_element0\": [\"-922547854\"], \"image_element1_element1\": [\"2004678264\"], \"image_element1_element2\": [\"-184956190\"], \"image_element2\": [2], \"image_element2_element0\": [\"-2086144499\"], \"image_element2_element1\": [\"1084461031\"], \"sr\": [\"-1783073849\"], \"sc\": [\"1109003250\"], \"newColor\": [\"-1723215145\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> dailyTemperatures. /*FC*/class Solution {\n/*FM*/vector<int> dailyTemperatures(vector<int> &T) {\r\n        int n = T.size(); \r\n        stack<int> s; \r\n        vector<int> ret(n, 0); \r\n        for (int i = 0;  i < n;  ++i) {\r\n            while (!s.empty() && T[s.top()] < T[i]) {\r\n                ret[s.top()] = i - s.top(); \r\n                s.pop(); \r\n            }\r\n            s.push(i); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"T\": [3], \"T_element0\": [\"-1587696476\"], \"T_element1\": [\"1337758839\"], \"T_element2\": [\"1239080614\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>> &matrix, int target) {\r\n        int m = matrix.size(), n = m == 0 ? 0 : matrix[0].size(); \r\n        if (m == 0)\r\n            \r\n        int i = m - 1, j = 0; \r\n        while (j < n && i >= 0) {\r\n            if (matrix[i][j] > target)\r\n                \r\n            else if (matrix[i][j] < target)\r\n                ++j; \r\n            else\r\n                \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"467\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"-341\"], \"matrix_element1_element1\": [\"775\"], \"target\": [\"1567693593\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>> &matrix, int target) {\r\n        int m = matrix.size(), n = m == 0 ? 0 : matrix[0].size(); \r\n        if (m == 0)\r\n            \r\n        int i = m - 1, j = 0; \r\n        while (j < n && i >= 0) {\r\n            if (matrix[i][j] > target)\r\n                --i; \r\n            else if (matrix[i][j] < target)\r\n                \r\n            else\r\n                \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"989\"], \"target\": [\"-1866579260\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>> &matrix, int target) {\r\n        int m = matrix.size(), n = m == 0 ? 0 : matrix[0].size(); \r\n        if (m == 0)\r\n            return false; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int deleteAndEarn. /*FC*/class Solution {\n/*FM*/int deleteAndEarn(vector<int> &nums) {\r\n        int size = nums.size(); \r\n        if (size == 0)\r\n            \r\n        else if (size == 1)\r\n            return nums[0]; \r\n        \r\n        \r\n        \r\n        \r\n        ; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"197\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int deleteAndEarn. /*FC*/class Solution {\n/*FM*/int deleteAndEarn(vector<int> &nums) {\r\n        int size = nums.size(); \r\n        if (size == 0)\r\n            \r\n        else if (size == 1)\r\n            \r\n        map<int, int> value; \r\n        int maxNum = 0; \r\n        for (int i = 0;  i < size;  ++i) {\r\n            ++value[nums[i]]; \r\n            maxNum = maxNum < nums[i] ? nums[i] : maxNum; \r\n        }\r\n        for (int i = 1;  i <= maxNum;  ++i)\r\n            value[i] *= i; \r\n        vector<int> dp(maxNum + 1, 0); \r\n        dp[1] = value[1]; \r\n        for (int i = 2;  i <= maxNum;  ++i) {\r\n            dp[i] = max(dp[i - 1], dp[i - 2] + value[i]); \r\n        }\r\n        return dp[maxNum]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"817\"], \"nums_element1\": [\"-305\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int deleteAndEarn. /*FC*/class Solution {\n/*FM*/int deleteAndEarn(vector<int> &nums) {\r\n        int size = nums.size(); \r\n        if (size == 0)\r\n            return 0; \r\n        else if (size == 1)\r\n            \r\n        \r\n        \r\n        \r\n        \r\n        ; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char nextGreatestLetter. /*FC*/class Solution {\n/*FM*/char nextGreatestLetter(vector<char> &letters, char target) {\r\n        int size = letters.size(); \r\n        if (target >= letters.back())\r\n            return letters[0]; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"letters\": [1], \"letters_element0\": [\"-51\"], \"target\": [\"69\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char nextGreatestLetter. /*FC*/class Solution {\n/*FM*/char nextGreatestLetter(vector<char> &letters, char target) {\r\n        int size = letters.size(); \r\n        if (target >= letters.back())\r\n            \r\n        int i = 0, j = size - 1; \r\n        while (i <= j) {\r\n            int index = (j + i) / 2; \r\n            if (letters[index] > target)\r\n                j = index - 1; \r\n            else if (letters[index] <= target)\r\n                \r\n        }\r\n        return letters[i]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"letters\": [1], \"letters_element0\": [\"48\"], \"target\": [\"-71\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCostClimbingStairs. /*FC*/class Solution {\n/*FM*/int minCostClimbingStairs(vector<int> &cost) {\r\n        int size = cost.size(); \r\n        if (size < 2)\r\n            return 0; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"cost\": [1], \"cost_element0\": [\"160\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCostClimbingStairs. /*FC*/class Solution {\n/*FM*/int minCostClimbingStairs(vector<int> &cost) {\r\n        int size = cost.size(); \r\n        if (size < 2)\r\n            \r\n        int second = cost[0], first = 0, current; \r\n        for (int i = 1;  i < size;  ++i) {\r\n            current = min(first, second) + cost[i]; \r\n            first = second; \r\n            second = current; \r\n        }\r\n        return min(first, second); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"cost\": [2], \"cost_element0\": [\"352\"], \"cost_element1\": [\"-22\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dominantIndex. /*FC*/class Solution {\n/*FM*/int dominantIndex(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        else if (n == 1)\r\n            return 0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1818648489\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dominantIndex. /*FC*/class Solution {\n/*FM*/int dominantIndex(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        else if (n == 1)\r\n            \r\n        int first = nums[0] > nums[1] ? nums[0] : nums[1]; \r\n        int second = nums[0] > nums[1] ? nums[1] : nums[0]; \r\n        int iF = nums[0] > nums[1] ? 0 : 1; \r\n        int iS = nums[0] > nums[1] ? 1 : 0; \r\n        for (int i = 2;  i < n;  ++i) {\r\n            if (nums[i] > first) {\r\n                \r\n                \r\n                \r\n                \r\n            } else if (nums[i] > second) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return first >= second * 2 ? iF : -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1243096594\"], \"nums_element1\": [\"97553445\"], \"nums_element2\": [\"-1180884956\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dominantIndex. /*FC*/class Solution {\n/*FM*/int dominantIndex(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        else if (n == 1)\r\n            \r\n        int first = nums[0] > nums[1] ? nums[0] : nums[1]; \r\n        int second = nums[0] > nums[1] ? nums[1] : nums[0]; \r\n        int iF = nums[0] > nums[1] ? 0 : 1; \r\n        int iS = nums[0] > nums[1] ? 1 : 0; \r\n        for (int i = 2;  i < n;  ++i) {\r\n            if (nums[i] > first) {\r\n                second = first; \r\n                iS = iF; \r\n                first = nums[i]; \r\n                iF = i; \r\n            } else if (nums[i] > second) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return first >= second * 2 ? iF : -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1771860077\"], \"nums_element1\": [\"-1338314257\"], \"nums_element2\": [\"1112060369\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dominantIndex. /*FC*/class Solution {\n/*FM*/int dominantIndex(vector<int> &nums) {\r\n        int n = nums.size(); \r\n        if (n == 0)\r\n            \r\n        else if (n == 1)\r\n            \r\n        int first = nums[0] > nums[1] ? nums[0] : nums[1]; \r\n        int second = nums[0] > nums[1] ? nums[1] : nums[0]; \r\n        int iF = nums[0] > nums[1] ? 0 : 1; \r\n        int iS = nums[0] > nums[1] ? 1 : 0; \r\n        for (int i = 2;  i < n;  ++i) {\r\n            if (nums[i] > first) {\r\n                \r\n                \r\n                \r\n                \r\n            } else if (nums[i] > second) {\r\n                second = nums[i]; \r\n                iS = i; \r\n            }\r\n        }\r\n        return first >= second * 2 ? iF : -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"224720831\"], \"nums_element1\": [\"833207520\"], \"nums_element2\": [\"592656786\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors. /*FC*/class Solution {\n/*FM*/void sortColors(vector<int> &nums) {\r\n        int i = 0, j = 0, k = nums.size() - 1; \r\n        while (j <= k) {\r\n            if (nums[j] == 2) \r\n            else if (nums[j] == 0) \r\n            else\r\n                ++j; \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-699918612\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reachNumber. /*FC*/class Solution {\n/*FM*/int reachNumber(int target) {\r\n        int m = 0; \r\n        target = abs(target); \r\n        while (target > 0)\r\n            target -= ++m; \r\n        return target % 2 == 0 ? m : m + 1 + m % 2; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPrimeSetBits. /*FC*/class Solution {\n/*FM*/int countPrimeSetBits(int L, int R) {\r\n        int total = 0; \r\n        for(int i = L;  i <= R;  ++i) {\r\n            int bitNum = calcBit(i); \r\n            if(isPrime(bitNum))\r\n                ++total; \r\n        }\r\n        return total; \r\n    };/*F*//*C*//*M*/int calcBit(int i) {\r\n        if(i == 0) return 0; \r\n        else if(i == 1) return 1; \r\n        return calcBit(i >> 1) + (i & 1); \r\n    } bool isPrime(int bitNum) {\r\n        if (bitNum == 0 || bitNum == 1)\r\n            return false; \r\n        for(int j = 2;  j < bitNum;  ++j)\r\n            if(bitNum % j == 0)\r\n                return false; \r\n        return true; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"L\": [\"0\"], \"R\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPrimeSetBits. /*FC*/class Solution {\n/*FM*/int countPrimeSetBits(int L, int R) {\r\n        int total = 0; \r\n        for(int i = L;  i <= R;  ++i) {\r\n            int bitNum = calcBit(i); \r\n            if(isPrime(bitNum))\r\n                \r\n        }\r\n        return total; \r\n    };/*F*//*C*//*M*/int calcBit(int i) {\r\n        if(i == 0) return 0; \r\n        else if(i == 1) return 1; \r\n        return calcBit(i >> 1) + (i & 1); \r\n    } bool isPrime(int bitNum) {\r\n        if (bitNum == 0 || bitNum == 1)\r\n            return false; \r\n        for(int j = 2;  j < bitNum;  ++j)\r\n            if(bitNum % j == 0)\r\n                return false; \r\n        return true; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"L\": [\"0\"], \"R\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPrime. /*FC*/class Solution {\n/*FM*/bool isPrime(int bitNum) {\r\n        if (bitNum == 0 || bitNum == 1)\r\n            \r\n        for(int j = 2;  j < bitNum;  ++j)\r\n            if(bitNum % j == 0)\r\n                \r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"bitNum\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPrime. /*FC*/class Solution {\n/*FM*/bool isPrime(int bitNum) {\r\n        if (bitNum == 0 || bitNum == 1)\r\n            \r\n        for(int j = 2;  j < bitNum;  ++j)\r\n            if(bitNum % j == 0)\r\n                return false; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"bitNum\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPrime. /*FC*/class Solution {\n/*FM*/bool isPrime(int bitNum) {\r\n        if (bitNum == 0 || bitNum == 1)\r\n            return false; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"bitNum\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> partitionLabels. /*FC*/class Solution {\n/*FM*/vector<int> partitionLabels(string S) {\r\n        int start = 0, end = 0, n = S.size(); \r\n        vector<int> res, pos(26); \r\n        for (int i = 0;  i < n;  ++i)\r\n            pos[S[i] - 'a'] = i; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            end = max(end, pos[S[i] - 'a']); \r\n            if (end == i) {\r\n                res.push_back(end - start + 1); \r\n                start = i + 1; \r\n                end = start; \r\n            }\r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> partitionLabels. /*FC*/class Solution {\n/*FM*/vector<int> partitionLabels(string S) {\r\n        int start = 0, end = 0, n = S.size(); \r\n        vector<int> res, pos(26); \r\n        for (int i = 0;  i < n;  )\r\n            \r\n        for (int i = 0;  i < n;  ) {\r\n            \r\n            \r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSwapsCouples. /*FC*/class Solution {\n/*FM*/int minSwapsCouples(vector<int> &row) {\r\n        int res = 0, n = row.size(); \r\n        vector<int> pos(n); \r\n        for (int i = 0;  i < n;  )\r\n            \r\n        for (int i = 0;  i < n;  ) {\r\n            \r\n            \r\n            \r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSwapsCouples. /*FC*/class Solution {\n/*FM*/int minSwapsCouples(vector<int> &row) {\r\n        int res = 0, n = row.size(); \r\n        vector<int> pos(n); \r\n        for (int i = 0;  i < n;  ++i)\r\n            pos[row[i]] = i; \r\n        for (int i = 0;  i < n;  i += 2) {\r\n            int p = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1; \r\n            int c = row[i + 1]; \r\n            if (row[i + 1] != p) {\r\n                swap(row[pos[c]], row[pos[p]]); \r\n                swap(pos[c], pos[p]); \r\n                ++res; \r\n            }\r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"row\": [2], \"row_element0\": [\"-852\"], \"row_element1\": [\"391\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isToeplitzMatrix. /*FC*/class Solution {\n/*FM*/bool isToeplitzMatrix(vector<vector<int>>& matrix) {\r\n        int n = matrix.size(); \r\n        if(n == 0)\r\n            \r\n        int m = matrix[0].size(); \r\n        for(int i = 0;  i < n - 1;  ) {\r\n            int temp = matrix[i][0], j = i + 1,k = 1; \r\n            while(j < n && k < m) {\r\n                if(matrix[j][k] !=temp)\r\n                    return false; \r\n                \r\n                \r\n            }\r\n        }\r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-335\"], \"matrix_element0_element1\": [\"692\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"980\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isToeplitzMatrix. /*FC*/class Solution {\n/*FM*/bool isToeplitzMatrix(vector<vector<int>>& matrix) {\r\n        int n = matrix.size(); \r\n        if(n == 0)\r\n            \r\n        int m = matrix[0].size(); \r\n        for(int i = 0;  i < n - 1;  ++i) {\r\n            int temp = matrix[i][0], j = i + 1,k = 1; \r\n            while(j < n && k < m) {\r\n                \r\n                \r\n                \r\n            }\r\n        }\r\n        for(int i = 1;  i < m - 1;  ) {\r\n            \r\n            \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"-731\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"92\"], \"matrix_element1_element1\": [\"-191\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isToeplitzMatrix. /*FC*/class Solution {\n/*FM*/bool isToeplitzMatrix(vector<vector<int>>& matrix) {\r\n        int n = matrix.size(); \r\n        if(n == 0)\r\n            return true; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxChunksToSorted. /*FC*/class Solution {\n/*FM*/int maxChunksToSorted(vector<int> &arr) {\r\n        int maxChunk = 0, til = 0; \r\n        for (int i = 0;  i < arr.size();  ++i) {\r\n            til = max(til, arr[i]); \r\n            if (til == i)\r\n                ++maxChunk; \r\n        }\r\n        return maxChunk; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"-381\"], \"arr_element1\": [\"377\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> combine. /*FC*/class Solution {\n/*FM*/vector<vector<int>> combine(int m, int k) {\r\n        vector<int> nums; \r\n        for (int i = 1;  i <= m;  ++i)\r\n            nums.push_back(i); \r\n        vector<vector<int>> ret; \r\n        vector<int> subset; \r\n        vector<int> visited(m, 0); \r\n        BackTracking(nums, subset, ret, visited, 0, m,k); \r\n        return ret; \r\n    };/*F*//*C*//*M*/void\r\n    BackTracking(vector<int> &nums, vector<int> &subset, vector<vector<int>> &ret, vector<int> &visited, int i, int &n, int &k) {\r\n        if (subset.size() == k) {\r\n            ret.push_back(subset); \r\n            return; \r\n        }\r\n        for (int j = i;  j < n;  ++j) {\r\n            if (visited[j] != 1) {\r\n                visited[j] = 1; \r\n                subset.push_back(nums[j]); \r\n                BackTracking(nums, subset, ret, visited, j + 1, n,k); \r\n                subset.pop_back(); \r\n                visited[j] = 0; \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"1\"], \"k\": [\"1526381845\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isIdealPermutation. /*FC*/class Solution {\n/*FM*/bool isIdealPermutation(vector<int> &A) {\r\n        int size = A.size(), m = INT_MIN; \r\n        for (int i = 0;  i < size - 2;  ) {\r\n            \r\n            \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"53\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDiffInBST. /*FC*/class Solution {\n/*FM*/int minDiffInBST(TreeNode *root) {\r\n        min_diff = INT_MAX; \r\n        Traverse(root); \r\n        return min_diff; \r\n    };/*F*/int min_diff;/*C*//*M*/void Traverse(TreeNode *node) {\r\n        if (!node)\r\n            return; \r\n        if (node->left) {\r\n            auto s = node->left; \r\n            while (s->right)\r\n                s = s->right; \r\n            min_diff = min(min_diff, node->val - s->val); \r\n        }\r\n        if (node->right) {\r\n            auto s = node->right; \r\n            while (s->left)\r\n                s = s->left; \r\n            min_diff = min(min_diff, s->val - node->val); \r\n        }\r\n        Traverse(node->left); \r\n        Traverse(node->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-214\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"404\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void Traverse. /*FC*/class Solution {\n/*FM*/void Traverse(TreeNode *node) {\r\n        if (!node)\r\n            \r\n        if (node->left) {\r\n            auto s = node->left; \r\n            while (s->right)\r\n                s = s->right; \r\n            \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/void Traverse(TreeNode *node) {\r\n        if (!node)\r\n            return; \r\n        if (node->left) {\r\n            auto s = node->left; \r\n            while (s->right)\r\n                s = s->right; \r\n            min_diff = min(min_diff, node->val - s->val); \r\n        }\r\n        if (node->right) {\r\n            auto s = node->right; \r\n            while (s->left)\r\n                s = s->left; \r\n            min_diff = min(min_diff, s->val - node->val); \r\n        }\r\n        Traverse(node->left); \r\n        Traverse(node->right); \r\n    } void Traverse(TreeNode *node) {\r\n        if (!node)\r\n            return; \r\n        if (node->left) {\r\n            auto s = node->left; \r\n            while (s->right)\r\n                s = s->right; \r\n            min_diff = min(min_diff, node->val - s->val); \r\n        }\r\n        if (node->right) {\r\n            auto s = node->right; \r\n            while (s->left)\r\n                s = s->left; \r\n            min_diff = min(min_diff, s->val - node->val); \r\n        }\r\n        Traverse(node->left); \r\n        Traverse(node->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"node\": [1], \"node[0]\": [\"TreeNode\", \"TreeNode()\"], \"node[0].val\": [\"390\"], \"node[0].left\": [1], \"node[0].left[0]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"node0_left0_x\": [\"964\"], \"node[0].left[0].val\": [\"172\"], \"node[0].right\": [2], \"node[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_right0_x\": [\"-372\"], \"node[0].right[0].val\": [\"-983\"], \"node[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_right1_x\": [\"-687\"], \"node[0].right[1].val\": [\"-795\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/class Solution {\n/*FM*/void insert(string S, int sub) {\r\n        if(sub == size) {\r\n            \r\n            \r\n        }\r\n        insert(S, sub + 1); \r\n        \r\n    };/*F*/int size;/*C*//*M*/void insert(string S, int sub) {\r\n        if(sub == size) {\r\n            ret.insert(ret.end(), S); \r\n            return; \r\n        }\r\n        insert(S, sub + 1); \r\n        if(S[sub] >= 'a' && S[sub] <= 'z') {\r\n            S[sub] = toupper(S[sub]); \r\n            insert(S, sub + 1); \r\n        }\r\n        else if(S[sub] >= 'A' && S[sub] <= 'Z') {\r\n            S[sub] = tolower(S[sub]); \r\n            insert(S, sub + 1); \r\n        }\r\n    } void insert(string S, int sub) {\r\n        if(sub == size) {\r\n            ret.insert(ret.end(), S); \r\n            return; \r\n        }\r\n        insert(S, sub + 1); \r\n        if(S[sub] >= 'a' && S[sub] <= 'z') {\r\n            S[sub] = toupper(S[sub]); \r\n            insert(S, sub + 1); \r\n        }\r\n        else if(S[sub] >= 'A' && S[sub] <= 'Z') {\r\n            S[sub] = tolower(S[sub]); \r\n            insert(S, sub + 1); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"sub\": [\"-1866763249\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rotatedDigits. /*FC*/class Solution {\n/*FM*/int rotatedDigits(int N) {\r\n        int total = 0; \r\n        for (int i = 2;  i <= N;  ++i) {\r\n            int j = i; \r\n            bool valid = true; \r\n            int rotated = 0, cur = 1; \r\n            while (j > 0) {\r\n                int temp = j % 10; \r\n                if (temp == 1 || temp == 8 || temp == 0)\r\n                    \r\n                else if (temp == 2)\r\n                    rotated += 5 * cur; \r\n                else if (temp == 5)\r\n                    rotated += 2 * cur; \r\n                else if (temp == 6)\r\n                    rotated += 9 * cur; \r\n                else if (temp == 9)\r\n                    \r\n                else {\r\n                    valid = false; \r\n                    break; \r\n                }\r\n                cur *= 10; \r\n                j /= 10; \r\n            }\r\n            if (!valid)\r\n                continue; \r\n            if (i != rotated)\r\n                ++total; \r\n        }\r\n        return total; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool exist. /*FC*/class Solution {\n/*FM*/bool exist(vector<vector<char>> &board, string word) {\r\n        int n = board.size(); \r\n        if (n == 0)\r\n            \r\n        int m = board[0].size(), len = word.size(); \r\n        if (n == 1 && m == 1 && len == 1 && board[0][0] == word[0])\r\n            \r\n        for (int i = 0;  i < n;  ++i) {\r\n            for (int j = 0;  j < m;  ++j) {\r\n                if (board[i][j] == word[0]) {\r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        return found; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"board\": [2], \"board_element0\": [1], \"board_element0_element0\": [\"-42\"], \"board_element1\": [2], \"board_element1_element0\": [\"-40\"], \"board_element1_element1\": [\"-71\"], \"word\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string customSortString. /*FC*/class Solution {\n/*FM*/string customSortString(string &S, string &T) {\r\n        vector<int> pos(26, 26); \r\n        for (int i = 0;  i < S.size();  ++i)\r\n            pos[S[i] - 'a'] = i; \r\n        sort(T.begin(), T.end(), [pos](const char &t1, const char &t2) {\r\n            return pos[t1 - 'a'] < pos[t2 - 'a']; \r\n        }); \r\n        return T; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numMatchingSubseq. /*FC*/class Solution {\n/*FM*/int numMatchingSubseq(string S, vector<string> &words) {\r\n        unordered_map<char, vector<int>> sub; \r\n        int total = 0; \r\n        for (int i = 0;  i < S.size();  ++i) {\r\n            if (sub.find(S[i]) == sub.end())\r\n                sub[S[i]] = vector<int>(); \r\n            sub[S[i]].push_back(i); \r\n        }\r\n        for (int i = 0;  i < words.size();  ++i) {\r\n            auto &word = words[i]; \r\n            int j = 0, current_sub = -1; \r\n            bool exist = true; \r\n            while (j < word.size()) {\r\n                auto c = word[j]; \r\n                if (sub[c].size() == 0) {\r\n                    exist = false; \r\n                    break; \r\n                }\r\n                \r\n                \r\n                if (x == sub[c].size()) {\r\n                    \r\n                    \r\n                } else\r\n                    \r\n                \r\n            }\r\n            if (exist)\r\n                \r\n        }\r\n        return total; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"words\": [1], \"words_element0\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarrayBoundedMax. /*FC*/class Solution {\n/*FM*/int numSubarrayBoundedMax(vector<int> &A, int L, int R) {\r\n        int i = 0, j = 0, m = -1, total = 0; \r\n        while (j < A.size()) {\r\n            if (A[j] >= L && A[j] <= R) {\r\n                m = j; \r\n                total += j - i + 1; \r\n            } else if (A[j] < L) {\r\n                \r\n            } else if (A[j] > R) {\r\n                \r\n                \r\n            }\r\n            ++j; \r\n        }\r\n        return total; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"979\"], \"A_element1\": [\"-705\"], \"L\": [\"-1944760848\"], \"R\": [\"110849227\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarrayBoundedMax. /*FC*/class Solution {\n/*FM*/int numSubarrayBoundedMax(vector<int> &A, int L, int R) {\r\n        int i = 0, j = 0, m = -1, total = 0; \r\n        while (j < A.size()) {\r\n            if (A[j] >= L && A[j] <= R) {\r\n                \r\n                \r\n            } else if (A[j] < L) {\r\n                total += m != -1 ? m - i + 1 : 0; \r\n            } else if (A[j] > R) {\r\n                \r\n                \r\n            }\r\n            ++j; \r\n        }\r\n        return total; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"929\"], \"A_element1\": [\"-942\"], \"L\": [\"1362255907\"], \"R\": [\"1073764305\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int> &nums) {\r\n        int n = nums.size(), i = 0, j = 0, k = 0; \r\n        while (j < n) {\r\n            nums[i] = nums[j]; \r\n            k = j, ++i, ++j; \r\n            if (j >= n)\r\n                break; \r\n            while (j < n && nums[j] == nums[j - 1])\r\n                \r\n            if (j == k + 1)\r\n                continue; \r\n            \r\n            \r\n        }\r\n        return i; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-872\"], \"nums_element1\": [\"-17\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSwap. /*FC*/class Solution {\n/*FM*/int minSwap(vector<int> &A, vector<int> &B) {\r\n        int n = A.size(); \r\n        if (n == 0)\r\n            \r\n        vector<vector<int>> dp(2, vector<int>(n, INT_MAX)); \r\n        dp[0][0] = 0; \r\n        dp[1][0] = 1; \r\n        for (int i = 1;  i < n;  ++i) {\r\n            if (A[i - 1] < A[i] && B[i - 1] < B[i]) {\r\n                \r\n                \r\n            }\r\n            if (A[i - 1] < B[i] && B[i - 1] < A[i]) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return min(dp[0][n - 1], dp[1][n - 1]); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-579\"], \"A_element1\": [\"-579\"], \"B\": [1], \"B_element0\": [\"873\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSwap. /*FC*/class Solution {\n/*FM*/int minSwap(vector<int> &A, vector<int> &B) {\r\n        int n = A.size(); \r\n        if (n == 0)\r\n            \r\n        vector<vector<int>> dp(2, vector<int>(n, INT_MAX)); \r\n        dp[0][0] = 0; \r\n        dp[1][0] = 1; \r\n        for (int i = 1;  i < n;  ++i) {\r\n            if (A[i - 1] < A[i] && B[i - 1] < B[i]) {\r\n                dp[0][i] = dp[0][i - 1]; \r\n                dp[1][i] = dp[1][i - 1] + 1; \r\n            }\r\n            if (A[i - 1] < B[i] && B[i - 1] < A[i]) {\r\n                dp[0][i] = min(dp[0][i], dp[1][i - 1]); \r\n                dp[1][i] = min(dp[1][i], dp[0][i - 1] + 1); \r\n            }\r\n        }\r\n        return min(dp[0][n - 1], dp[1][n - 1]); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-130\"], \"A_element1\": [\"405\"], \"B\": [1], \"B_element0\": [\"-531\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniqueMorseRepresentations. /*FC*/class Solution {\n/*FM*/int uniqueMorseRepresentations(vector<string> &words) {\r\n        vector<string> morse{\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\",\r\n                             \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\",\r\n                             \"--..\"}; \r\n        map<string, int> uni; \r\n        for (int i = 0;  i < words.size();  ++i) {\r\n            string temp; \r\n            for (int j = 0;  j < words[i].size();  ++j)\r\n                temp += morse[words[i][j] - 'a']; \r\n            if (uni.find(temp) == uni.end())\r\n                uni.insert(map<string, int>::value_type(temp, 1)); \r\n            else\r\n                ++uni[temp]; \r\n        }\r\n        return uni.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [2], \"words_element0\": [\"1\"], \"words_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> numberOfLines. /*FC*/class Solution {\n/*FM*/vector<int> numberOfLines(vector<int> &widths, string &S) {\r\n        int line = 1, width = 0; \r\n        for (auto s:S) {\r\n            if (width + widths[s - 'a'] <= 100)\r\n                width += widths[s - 'a']; \r\n            else {\r\n                \r\n                \r\n            }\r\n        }\r\n        return vector<int>{line, width}; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"widths\": [2], \"widths_element0\": [\"-744\"], \"widths_element1\": [\"710\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> numberOfLines. /*FC*/class Solution {\n/*FM*/vector<int> numberOfLines(vector<int> &widths, string &S) {\r\n        int line = 1, width = 0; \r\n        for (auto s:S) {\r\n            if (width + widths[s - 'a'] <= 100)\r\n                \r\n            else {\r\n                width = widths[s - 'a']; \r\n                ++line; \r\n            }\r\n        }\r\n        return vector<int>{line, width}; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"widths\": [2], \"widths_element0\": [\"245\"], \"widths_element1\": [\"-184\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxIncreaseKeepingSkyline. /*FC*/class Solution {\n/*FM*/int maxIncreaseKeepingSkyline(vector<vector<int>> &grid) {\r\n        int m = grid.size(), n = m == 0 ? 0 : grid[0].size(); \r\n        if (m == 0)\r\n            \r\n        vector<int> row(m, 0), col(n, 0); \r\n        for (int i = 0;  i < m;  ++i) {\r\n            for (int j = 0;  j < n;  ++j) {\r\n                row[i] = max(row[i], grid[i][j]); \r\n                col[j] = max(col[j], grid[i][j]); \r\n            }\r\n        }\r\n        int total = 0; \r\n        for (int i = 0;  i < m;  ++i) {\r\n            for (int j = 0;  j < n;  ++j) {\r\n                int highest = min(row[i], col[j]); \r\n                total += max(0, highest - grid[i][j]); \r\n            }\r\n        }\r\n        return total; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [1], \"grid_element0_element0\": [\"-827\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"614\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *pruneTree. /*FC*/class Solution {\n/*FM*/TreeNode *pruneTree(TreeNode *root) {\r\n        if(!root || !TraverseFor1(root))\r\n            return nullptr; \r\n        \r\n    };/*F*//*C*//*M*/bool TraverseFor1(TreeNode *root) {\r\n        if (!root)\r\n            return false; \r\n        bool &&leftContains1 = TraverseFor1(root->left); \r\n        if (root->left && !leftContains1) {\r\n            delete root->left; \r\n            root->left = nullptr; \r\n        }\r\n        bool &&rightContains1 = TraverseFor1(root->right); \r\n        if (root->right && !rightContains1) {\r\n            delete root->right; \r\n            root->right = nullptr; \r\n        }\r\n\r\n        return leftContains1 || rightContains1 || (root->val == 1); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1819340875\"], \"root[1]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\r\n        auto node = head, prev = new ListNode(0), ret = prev; \r\n        while (node) {\r\n            if (!node->next || node->val != node->next->val) {\r\n                prev->next = node; \r\n                prev = node; \r\n                node = node->next; \r\n                prev->next = nullptr; \r\n                continue; \r\n            }\r\n            \r\n               return ret->next; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[1]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head1_x\": [\"-1593846459\"], \"head[2]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string toGoatLatin. /*FC*/class Solution {\n/*FM*/string toGoatLatin(string S) {\r\n        string ret; \r\n        int m = 1, n = S.size(); \r\n        for (int i = 0;  i < n;  ++i) {\r\n            int j = i + 1; \r\n            while (j != n && S[j] != ' ')\r\n                \r\n            string temp; \r\n            char t = tolower(S[i]); \r\n            bool vowel = (t == 'a' || t == 'e' || t == 'i' || t == 'o' || t == 'u'); \r\n            if (vowel)\r\n                \r\n            temp += S.substr(i + 1, j - i - 1); \r\n            if (!vowel)\r\n                temp += S[i]; \r\n            temp += \"ma\"; \r\n            for (int k = 0;  k < m;  ++k)\r\n                temp += 'a'; \r\n            ++m; \r\n            i = j; \r\n            if(i != n)\r\n                \r\n            ret += temp; \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\r\n        ListNode *curr = head; \r\n        while (curr && curr->next) {\r\n            \r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[1]\": [\"ListNode\", \"ListNode(int,ListNode*)\", \"ListNode\"], \"head1_x\": [\"185649787\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> largeGroupPositions. /*FC*/class Solution {\n/*FM*/vector<vector<int>> largeGroupPositions(string S) {\r\n\t\tvector<vector<int>> ret; \r\n\t\tfor (int i = 0;  i < S.size();  ++i) {\r\n\t\t\tvector<int> temp; \r\n\t\t\tchar current = S[i]; \r\n\t\t\tint count = 1, j = i; \r\n\t\t\twhile (j + 1 < S.size() && S[j + 1] == S[j]) {\r\n\t\t\t\t \r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tif (count >= 3) {\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\ti += count - 1; \r\n            cout << j << endl; \r\n\t\t}\r\n\t\treturn ret; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> flipAndInvertImage. /*FC*/class Solution {\n/*FM*/vector<vector<int>> flipAndInvertImage(vector<vector<int>> &A) {\r\n        for (int i = 0;  i < A.size();  ++i) {\r\n            int m = A[i].size(); \r\n            for (int j = 0;  j < m / 2;  ++j)\r\n                swap(A[i][j], A[i][m - j - 1]); \r\n            for (int j = 0;  j < m;  ++j)\r\n                A[i][j] ^= 1; \r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [1], \"A_element0_element0\": [\"652\"], \"A_element1\": [2], \"A_element1_element0\": [\"-372\"], \"A_element1_element1\": [\"-32\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void DFS. /*FC*/class Solution {\n/*FM*/void DFS(int root) {\r\n        visited[root] = true; \r\n        for (: graph[root]) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*/vector<unordered_set<int>> graph;  vector<bool> visited;/*C*//*M*/void DFS(int root) {\r\n        visited[root] = true; \r\n        for (auto &node: graph[root]) {\r\n            if (visited[node])\r\n                continue; \r\n            DFS(node); \r\n            contains[root] += contains[node]; \r\n            ret[root] += ret[node] + contains[node]; \r\n        }\r\n    } void DFS(int root) {\r\n        visited[root] = true; \r\n        for (auto &node: graph[root]) {\r\n            if (visited[node])\r\n                continue; \r\n            DFS(node); \r\n            contains[root] += contains[node]; \r\n            ret[root] += ret[node] + contains[node]; \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [\"-1244964467\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void CountDistance. /*FC*/class Solution {\n/*FM*/void CountDistance(int root) {\r\n        visited[root] = true; \r\n        for (:graph[root]) {\r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*/vector<unordered_set<int>> graph;  vector<bool> visited;/*C*//*M*/void CountDistance(int root) {\r\n        visited[root] = true; \r\n        for (auto &node:graph[root]) {\r\n            if (visited[node])\r\n                continue; \r\n            ret[node] = (ret[root] - ret[node] - contains[node] + n - contains[node]) + ret[node]; \r\n            CountDistance(node); \r\n        }\r\n    } void CountDistance(int root) {\r\n        visited[root] = true; \r\n        for (auto &node:graph[root]) {\r\n            if (visited[node])\r\n                continue; \r\n            ret[node] = (ret[root] - ret[node] - contains[node] + n - contains[node]) + ret[node]; \r\n            CountDistance(node); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [\"205894094\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double new21Game. /*FC*/class Solution {\n/*FM*/double new21Game(int total, int k, int n) {\r\n        if (k <= 0 || total >= k + n)\r\n            \r\n        vector<double> dp(total + 1, 0.0); \r\n        dp[0] = 1.0; \r\n        double temp = 1.0,res = 0.0; \r\n        for (int i = 1;  i <= total;  ++i) {\r\n            dp[i] = temp / (n * 1.0); \r\n            if (i < k)\r\n                temp += dp[i]; \r\n            else\r\n                \r\n            if (i >= n)\r\n                \r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"total\": [\"3\"], \"k\": [\"1615976044\"], \"n\": [\"127844815\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double new21Game. /*FC*/class Solution {\n/*FM*/double new21Game(int total, int k, int n) {\r\n        if (k <= 0 || total >= k + n)\r\n            return 1.0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"total\": [\"4\"], \"k\": [\"-1308672331\"], \"n\": [\"-846496207\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string pushDominoes. /*FC*/class Solution {\n/*FM*/string pushDominoes(string dominoes) {\r\n\t\tint length = dominoes.length(); \r\n\t\tstring ret; \r\n\t\tint start = 0; \r\n\t\tfor (int i = 0;  i <= length;  ++i) {\t\n\t\t\tif (dominoes[i] == 'L') {\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if (dominoes[i] == 'R') {\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tif (i == length)\r\n\t\t\t\tret.append(i - start, '.'); \r\n\t\t}\r\n\t\treturn ret; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dominoes\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numMagicSquaresInside. /*FC*/class Solution {\n/*FM*/int numMagicSquaresInside(vector<vector<int>>& grid) {\r\n\t\tint total = 0; \r\n\t\tif (grid.size() < 3 || grid[0].size() < 3)\r\n\t\t\treturn 0; \r\n\t\t\r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [1], \"grid_element0\": [2], \"grid_element0_element0\": [\"385\"], \"grid_element0_element1\": [\"676\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canVisitAllRooms. /*FC*/class Solution {\n/*FM*/bool canVisitAllRooms(vector<vector<int>>& rooms) {\r\n\t\tvector<int> locked; \r\n\t\tint size = rooms.size(); \r\n\t\tlocked.push_back(0); \r\n\t\tfor (int i = 1;  i < size;  ++i)\r\n\t\t\tlocked.push_back(1); \r\n\t\tfor (int i = 0;  i < rooms[0].size();  ++i) {\r\n\t\t\tlocked[rooms[0][i]] = 0; \r\n\t\t\tunlock(rooms[0][i], rooms, locked); \r\n\t\t}\r\n\t\tfor (int i = 0;  i < size;  ++i)\r\n\t\t\tif (locked[i] == 1)\r\n\t\t\t\treturn false; \r\n\t\t\r\n\t};/*F*//*C*//*M*/void unlock(int k, vector<vector<int>>& rooms, vector<int>& locked) {\r\n\t\tfor (int i = 0;  i < rooms[k].size();  ++i) {\r\n\t\t\tif (locked[rooms[k][i]] == 1) {\r\n\t\t\t\tlocked[rooms[k][i]] = 0; \r\n\t\t\t\tunlock(rooms[k][i], rooms, locked); \r\n\t\t\t}\r\n\t\t}\r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"rooms\": [2], \"rooms_element0\": [1], \"rooms_element0_element0\": [\"-755\"], \"rooms_element1\": [2], \"rooms_element1_element0\": [\"7\"], \"rooms_element1_element1\": [\"-451\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canVisitAllRooms. /*FC*/class Solution {\n/*FM*/bool canVisitAllRooms(vector<vector<int>>& rooms) {\r\n\t\tvector<int> locked; \r\n\t\tint size = rooms.size(); \r\n\t\tlocked.push_back(0); \r\n\t\tfor (int i = 1;  i < size;  )\r\n\t\t\t\r\n\t\tfor (int i = 0;  i < rooms[0].size();  ++i) {\r\n\t\t\tlocked[rooms[0][i]] = 0; \r\n\t\t\tunlock(rooms[0][i], rooms, locked); \r\n\t\t}\r\n\t\tfor (int i = 0;  i < size;  ++i)\r\n\t\t\tif (locked[i] == 1)\r\n\t\t\t\t\r\n\t\treturn true; \r\n\t};/*F*//*C*//*M*/void unlock(int k, vector<vector<int>>& rooms, vector<int>& locked) {\r\n\t\tfor (int i = 0;  i < rooms[k].size();  ++i) {\r\n\t\t\tif (locked[rooms[k][i]] == 1) {\r\n\t\t\t\tlocked[rooms[k][i]] = 0; \r\n\t\t\t\tunlock(rooms[k][i], rooms, locked); \r\n\t\t\t}\r\n\t\t}\r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"rooms\": [1], \"rooms_element0\": [2], \"rooms_element0_element0\": [\"-875\"], \"rooms_element0_element1\": [\"-380\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void unlock. /*FC*/class Solution {\n/*FM*/void unlock(int k, vector<vector<int>>& rooms, vector<int>& locked) {\r\n\t\tfor (int i = 0;  i < rooms[k].size();  ) {\r\n\t\t\t\r\n\t\t}\r\n\t};/*F*//*C*//*M*/void unlock(int k, vector<vector<int>>& rooms, vector<int>& locked) {\r\n\t\tfor (int i = 0;  i < rooms[k].size();  ++i) {\r\n\t\t\tif (locked[rooms[k][i]] == 1) {\r\n\t\t\t\tlocked[rooms[k][i]] = 0; \r\n\t\t\t\tunlock(rooms[k][i], rooms, locked); \r\n\t\t\t}\r\n\t\t}\r\n\t} void unlock(int k, vector<vector<int>>& rooms, vector<int>& locked) {\r\n\t\tfor (int i = 0;  i < rooms[k].size();  ++i) {\r\n\t\t\tif (locked[rooms[k][i]] == 1) {\r\n\t\t\t\tlocked[rooms[k][i]] = 0; \r\n\t\t\t\tunlock(rooms[k][i], rooms, locked); \r\n\t\t\t}\r\n\t\t}\r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"-910111050\"], \"rooms\": [1], \"rooms_element0\": [1], \"rooms_element0_element0\": [\"83\"], \"locked\": [2], \"locked_element0\": [\"787\"], \"locked_element1\": [\"268\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool backspaceCompare. /*FC*/class Solution {\n/*FM*/bool backspaceCompare(string S, string T) {\r\n\t\tvector<char> s, t; \r\n\t\tfor (int i = 0;  i < S.length();  ++i) {\r\n\t\t\tif (S[i] != '#')\r\n\t\t\t\ts.push_back(S[i]); \r\n\t\t\telse\r\n\t\t\t\tif(!s.empty())\r\n\t\t\t\t\t\r\n\t\t}\r\n\t\tfor (int j = 0;  j < T.length();  ++j) {\r\n\t\t\tif (T[j] != '#')\r\n\t\t\t\tt.push_back(T[j]); \r\n\t\t\telse\r\n\t\t\t\tif (!t.empty())\r\n\t\t\t\t\t\r\n\t\t}\r\n\t\treturn s == t; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNStraightHand. /*FC*/class Solution {\n/*FM*/bool isNStraightHand(vector<int>& hand, int W) {\r\n\t\tmap<int, int> group; \r\n\t\tfor (int i = 0;  i < hand.size();  ++i)\r\n\t\t\t++group[hand[i]]; \r\n\t\twhile (!group.empty())\r\n\t\t{\r\n\t\t\tint currentCard = group.begin()->first; \r\n\t\t\tfor (int i = 1;  i < W;  ) {\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t--group[currentCard]; \r\n\t\t\tif (group[currentCard] == 0)\r\n\t\t\t\tgroup.erase(currentCard); \r\n\t\t}\r\n\t\treturn true; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"hand\": [2], \"hand_element0\": [\"47\"], \"hand_element1\": [\"699\"], \"W\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNStraightHand. /*FC*/class Solution {\n/*FM*/bool isNStraightHand(vector<int>& hand, int W) {\r\n\t\tmap<int, int> group; \r\n\t\tfor (int i = 0;  i < hand.size();  ++i)\r\n\t\t\t++group[hand[i]]; \r\n\t\twhile (!group.empty())\r\n\t\t{\r\n\t\t\tint currentCard = group.begin()->first; \r\n\t\t\tfor (int i = 1;  i < W;  ) {\r\n\t\t\t\tauto iter = group.find(currentCard + i); \r\n\t\t\t\tif (iter != group.end()) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\treturn false; \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"hand\": [2], \"hand_element0\": [\"856\"], \"hand_element1\": [\"-156\"], \"W\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int peakIndexInMountainArray. /*FC*/class Solution {\n/*FM*/int peakIndexInMountainArray(vector<int> &A) {\r\n        int start = 0, end = A.size(), mid = 0; \r\n        while (start < end) {\r\n            mid = (start + end) / 2; \r\n            if (A[mid] > A[mid - 1] && A[mid] > A[mid + 1])\r\n                break; \r\n            else if (A[mid] < A[mid + 1])\r\n                \r\n            else\r\n                \r\n        }\r\n        return mid; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-908\"], \"A_element1\": [\"119\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int peakIndexInMountainArray. /*FC*/class Solution {\n/*FM*/int peakIndexInMountainArray(vector<int> &A) {\r\n        int start = 0, end = A.size(), mid = 0; \r\n        while (start < end) {\r\n            mid = (start + end) / 2; \r\n            if (A[mid] > A[mid - 1] && A[mid] > A[mid + 1])\r\n                \r\n            else if (A[mid] < A[mid + 1])\r\n                start = mid + 1; \r\n            else\r\n                \r\n        }\r\n        return mid; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-880\"], \"A_element1\": [\"444\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int carFleet. /*FC*/class Solution {\n/*FM*/int carFleet(int target, vector<int> &position, vector<int> &speed) {\r\n        int size = position.size(); \r\n        vector<Node> car; \r\n        vector<double> time(size, 0); \r\n        for (int i = 0;  i < size;  ++i)\r\n            car.push_back(Node(position[i], speed[i])); \r\n        sort(car.begin(), car.end(), CompareNode()); \r\n        for (int i = 0;  i < size;  ++i)\r\n            time[i] = 1.0 * (target - car[i].position) / car[i].speed; \r\n        int i = 0, fleet = 0; \r\n        while (i < size) {\r\n            double current = time[i]; \r\n            ++i; \r\n            while (i < size && current >= time[i])\r\n                ++i; \r\n            ++fleet; \r\n        }\r\n        return fleet; \r\n    };/*F*//*C*//*M*/Node(const int &pos, const int &spe) {\r\n            position = pos; \r\n            speed = spe; \r\n        };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"832005028\"], \"position\": [2], \"position_element0\": [\"-916\"], \"position_element1\": [\"871\"], \"speed\": [2], \"speed_element0\": [\"-987\"], \"speed_element1\": [\"798\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int carFleet. /*FC*/class Solution {\n/*FM*/int carFleet(int target, vector<int> &position, vector<int> &speed) {\r\n        int size = position.size(); \r\n        vector<Node> car; \r\n        vector<double> time(size, 0); \r\n        for (int i = 0;  i < size;  ++i)\r\n            car.push_back(Node(position[i], speed[i])); \r\n        sort(car.begin(), car.end(), CompareNode()); \r\n        for (int i = 0;  i < size;  ++i)\r\n            time[i] = 1.0 * (target - car[i].position) / car[i].speed; \r\n        int i = 0, fleet = 0; \r\n        while (i < size) {\r\n            double current = time[i]; \r\n            ++i; \r\n            while (i < size && current >= time[i])\r\n                \r\n            ++fleet; \r\n        }\r\n        return fleet; \r\n    };/*F*//*C*//*M*/Node(const int &pos, const int &spe) {\r\n            position = pos; \r\n            speed = spe; \r\n        };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"2120432058\"], \"position\": [2], \"position_element0\": [\"-996\"], \"position_element1\": [\"-448\"], \"speed\": [1], \"speed_element0\": [\"346\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool buddyStrings. /*FC*/class Solution {\n/*FM*/bool buddyStrings(string A, string B) {\r\n        int n = A.size(), m = B.size(); \r\n        if (n != m) \r\n        for (int i = n - 1;  i >= 0;  --i) {\r\n            for (int j = i - 1;  j >= 0;  ) {\r\n                \r\n                \r\n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"1\"], \"B\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *partition. /*FC*/class Solution {\n/*FM*/ListNode *partition(ListNode *head, int x) {\r\n        ListNode *l1 = new ListNode(0), *l2 = new ListNode(0); \r\n        ListNode *ret = l1, *temp = l2; \r\n        while (head) {\r\n            if (head->val < x) {\r\n                \r\n                \r\n            } else {\r\n                l2->next = head; \r\n                l2 = head; \r\n            }\r\n            head = head->next; \r\n        }\r\n        l1->next = temp->next; \r\n        l2->next = nullptr; \r\n        return ret->next; \r\n    };/*F*//*C*//*M*/ListNode(int x, ListNode *next) : val(x), next(next) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].val\": [\"-291\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[0].val\": [\"-498\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[1].val\": [\"-10\"], \"x\": [\"-297048245\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool lemonadeChange. /*FC*/class Solution {\n/*FM*/bool lemonadeChange(vector<int> &bills) {\r\n        int n = bills.size(); \r\n        int hold5 = 0, hold10 = 0, hold20 = 0; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            if (bills[i] == 5)\r\n                \r\n            else if (bills[i] == 10) {\r\n                \r\n            } else if (bills[i] == 20) {\r\n                 }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"bills\": [1], \"bills_element0\": [\"-44\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int matrixScore. /*FC*/class Solution {\n/*FM*/int matrixScore(vector<vector<int>> &A) {\r\n        vector<vector<int>> B(A); \r\n        int n = B.size(); \r\n        if (n == 0) \r\n        int m = B[0].size(); \r\n        for (int i = 0;  i < n;  ++i) {\r\n            if (B[i][0] == 0)\r\n                \r\n        }\r\n        for (int j = 1;  j < m;  ++j) {\r\n            int sumColumn = 0; \r\n            for (int i = 0;  i < n;  ++i)\r\n                sumColumn += B[i][j]; \r\n            if (sumColumn < (n + 1) / 2)\r\n                ToggleCol(B, j); \r\n        }\r\n        int sum = 0; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            for (int j = 0;  j < m;  ++j) {\r\n                sum += B[i][j] * pow(2, m - j - 1); \r\n            }\r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/void ToggleCol(vector<vector<int>> &B, int j) {\r\n        for (int i = 0;  i < B.size();  ++i)\r\n            B[i][j] = (B[i][j] == 0 ? 1 : 0); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [2], \"A_element0_element0\": [\"-390\"], \"A_element0_element1\": [\"-751\"], \"A_element1\": [2], \"A_element1_element0\": [\"-342\"], \"A_element1_element1\": [\"24\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void ToggleRow. /*FC*/class Solution {\n/*FM*/void ToggleRow(vector<vector<int>> &B, int i) {\r\n        for (int j = 0;  j < B[i].size();  )\r\n            \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"B\": [1], \"B_element0\": [1], \"B_element0_element0\": [\"-736\"], \"i\": [\"280934623\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void ToggleCol. /*FC*/class Solution {\n/*FM*/void ToggleCol(vector<vector<int>> &B, int j) {\r\n        for (int i = 0;  i < B.size();  )\r\n            B[i][j] = (B[i][j] == 0 ? 1 : 0); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"B\": [2], \"B_element0\": [1], \"B_element0_element0\": [\"-496\"], \"B_element1\": [1], \"B_element1_element0\": [\"-222\"], \"j\": [\"416713349\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> transpose. /*FC*/class Solution {\n/*FM*/vector<vector<int>> transpose(vector<vector<int>> &A) {\r\n        auto row = A.size(); \r\n        if (row == 0)\r\n            \r\n        vector<vector<int>> ret; \r\n        auto col = A[0].size(); \r\n        for (int i = 0;  i < col;  ++i) {\r\n            vector<int> temp; \r\n            for (int j = 0;  j < row;  ++j) {\r\n                temp.push_back(A[j][i]); \r\n            }\r\n            ret.push_back(temp); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [2], \"A_element0_element0\": [\"625\"], \"A_element0_element1\": [\"-397\"], \"A_element1\": [1], \"A_element1_element0\": [\"708\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int binaryGap. /*FC*/class Solution {\n/*FM*/int binaryGap(int N) {\r\n        vector<int> bin; \r\n        while (N) {\r\n            int temp = N % 2; \r\n            bin.push_back(temp); \r\n            N = N / 2; \r\n        }\r\n        int dis = 0, cur = 0; \r\n        for (int i = bin.size() - 2;  i >= 0;  --i) {\r\n            if (bin[i] == 1) {\r\n                dis = max(dis, cur + 1); \r\n                cur = 0; \r\n            } else\r\n                ++cur; \r\n        }\r\n        return dis; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"192083898\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> advantageCount. /*FC*/class Solution {\n/*FM*/vector<int> advantageCount(vector<int> &A, vector<int> &B) {\r\n        sort(A.begin(), A.end()); \r\n        vector<int> ret; \r\n        for (auto b:B) {\r\n            int i = 0, j = A.size(), mid = 0; \r\n            while (i < j) {\r\n                mid = i + (j - i) / 2; \r\n                if (A[mid] > b)\r\n                    \r\n                else\r\n                    i = mid + 1; \r\n            }\r\n            if (j == A.size()) {\r\n                ret.push_back(A[0]); \r\n                A.erase(A.begin()); \r\n            } else {\r\n                \r\n                \r\n            }\r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-756\"], \"A_element1\": [\"-697\"], \"B\": [2], \"B_element0\": [\"68\"], \"B_element1\": [\"608\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> advantageCount. /*FC*/class Solution {\n/*FM*/vector<int> advantageCount(vector<int> &A, vector<int> &B) {\r\n        sort(A.begin(), A.end()); \r\n        vector<int> ret; \r\n        for (auto b:B) {\r\n            int i = 0, j = A.size(), mid = 0; \r\n            while (i < j) {\r\n                mid = i + (j - i) / 2; \r\n                if (A[mid] > b)\r\n                    j = mid; \r\n                else\r\n                    \r\n            }\r\n            if (j == A.size()) {\r\n                \r\n                \r\n            } else {\r\n                ret.push_back(A[j]); \r\n                A.erase(A.begin() + j); \r\n            }\r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"903\"], \"B\": [1], \"B_element0\": [\"502\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minEatingSpeed. /*FC*/class Solution {\n/*FM*/int minEatingSpeed(vector<int> &piles, int H) {\r\n        int i = 1, j = pow(10, 9), mid = 1; \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (CanEat(piles, H, mid))\r\n                j = mid; \r\n            else\r\n                i = mid + 1; \r\n        }\r\n        return j; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"piles\": [3], \"piles_element0\": [\"271017704\"], \"piles_element1\": [\"1525737540\"], \"piles_element2\": [\"-953717204\"], \"H\": [\"919873579\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool CanEat. /*FC*/class Solution {\n/*FM*/bool CanEat(vector<int> &piles, int H, int e) {\r\n        int total = 0; \r\n        for (auto &p:piles) {\r\n            total += p / e + (p % e != 0); \r\n            if (total > H)\r\n                \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"piles\": [2], \"piles_element0\": [\"1223679517\"], \"piles_element1\": [\"616548476\"], \"H\": [\"1487010707\"], \"e\": [\"1856412168\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool CanEat. /*FC*/class Solution {\n/*FM*/bool CanEat(vector<int> &piles, int H, int e) {\r\n        int total = 0; \r\n        for (auto &p:piles) {\r\n            total += p / e + (p % e != 0); \r\n            if (total > H)\r\n                return false; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"piles\": [2], \"piles_element0\": [\"358515200\"], \"piles_element1\": [\"-2142910452\"], \"H\": [\"-456253541\"], \"e\": [\"242738075\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *middleNode. /*FC*/class Solution {\n/*FM*/ListNode *middleNode(ListNode *head) {\r\n        if (!head) \r\n        ListNode *first = head, *second = head; \r\n        while (first && first->next) {\r\n            \r\n            \r\n        }\r\n        return second; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1865166203\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-849836270\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void merge. /*FC*/class Solution {\n/*FM*/void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n        if(m == 0)\r\n            \r\n        int i = m - 1, j = n - 1, k = m + n - 1; \r\n        while(i >= 0 && j >= 0) {\r\n            if(nums1[i] <= nums2[j])\r\n                nums1[k--] = nums2[j--]; \r\n            else\r\n                nums1[k--] = nums1[i--]; \r\n        }\r\n        while (j >= 0) {\r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [3], \"nums1_element0\": [\"819436928\"], \"nums1_element1\": [\"-1555801276\"], \"nums1_element2\": [\"630230083\"], \"m\": [\"6\"], \"nums2\": [1], \"nums2_element0\": [\"1084666709\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void merge. /*FC*/class Solution {\n/*FM*/void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n        if(m == 0)\r\n            nums1 = nums2; \r\n        int i = m - 1, j = n - 1, k = m + n - 1; \r\n        while(i >= 0 && j >= 0) {\r\n            \r\n        }\r\n        while (j >= 0) {\r\n            nums1[k--] = nums2[j--]; \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"1956490866\"], \"nums1_element1\": [\"-182083260\"], \"m\": [\"0\"], \"nums2\": [1], \"nums2_element0\": [\"-370653026\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numRescueBoats. /*FC*/class Solution {\n/*FM*/int numRescueBoats(vector<int> &people, int limit) {\r\n        sort(people.begin(), people.end()); \r\n        int i = 0, j = people.size() - 1, n = 0; \r\n        while (i <= j) {\r\n            int weight = people[j]; \r\n            if (weight + people[i] <= limit && i <= j) {\r\n                weight += people[i]; \r\n                ++i; \r\n            }\r\n            --j; \r\n            ++n; \r\n        }\r\n        return n; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"people\": [3], \"people_element0\": [\"-865897716\"], \"people_element1\": [\"1678260867\"], \"people_element2\": [\"1580938594\"], \"limit\": [\"769288523\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int projectionArea. /*FC*/class Solution {\n/*FM*/int projectionArea(vector<vector<int>> &grid) {\r\n        int top = 0, front = 0, side = 0, n = grid.size(), total = 0; \r\n        vector<int> col; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            int current = grid[i][0]; \r\n            for (int j = 0;  j < grid[i].size();  ++j) {\r\n                if (col.size() <= j)\r\n                    col.push_back(grid[i][j]); \r\n                else\r\n                    col[j] = max(col[j], grid[i][j]); \r\n                current = max(current, grid[i][j]); \r\n                top += grid[i][j] != 0; \r\n            }\r\n            total += current; \r\n        }\r\n        for (int i = 0;  i < col.size();  ++i)\r\n            total += col[i]; \r\n        total += top; \r\n        return total; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [3], \"grid_element0\": [2], \"grid_element0_element0\": [\"-2069456481\"], \"grid_element0_element1\": [\"-1610765858\"], \"grid_element1\": [3], \"grid_element1_element0\": [\"1530539361\"], \"grid_element1_element1\": [\"-2104864776\"], \"grid_element1_element2\": [\"2049580823\"], \"grid_element2\": [2], \"grid_element2_element0\": [\"-3767337\"], \"grid_element2_element1\": [\"90306014\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> uncommonFromSentences. /*FC*/class Solution {\n/*FM*/vector<string> uncommonFromSentences(string A, string B) {\r\n        unordered_map<string, int> sentences; \r\n        vector<string> ret; \r\n        Traversal(A, sentences); \r\n        Traversal(B, sentences); \r\n        for (auto s:sentences) {\r\n            if (s.second == 1)\r\n                ret.push_back(s.first); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"1\"], \"B\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void Traversal. /*FC*/class Solution {\n/*FM*/void Traversal(string &S, unordered_map<string, int> &sentences) {\r\n        while (!S.empty()) {\r\n            int pos = S.find(\" \"); \r\n            if (pos != S.npos) {\r\n                \r\n                \r\n                \r\n            } else {\r\n                ++sentences[S]; \r\n                S = \"\"; \r\n            }\r\n        }\r\n        return; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void Increment. /*FC*/class Solution {\n/*FM*/void Increment(int &k, int &x, int &y, const int &R, const int &C, vector<vector<bool>> &visited,\r\n                   vector<vector<int>> &ret) {\r\n        if (x >= 0 && x < R && y >= 0 && y < C && !visited[x][y]) {\r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"-951189482\"], \"x\": [\"-1482200293\"], \"y\": [\"-597252335\"], \"R\": [\"-397133848\"], \"C\": [\"-2034092301\"], \"visited\": [2], \"visited_element0\": [1], \"visited_element0_element0\": [\"true\"], \"visited_element1\": [1], \"visited_element1_element0\": [\"false\"], \"ret\": [1], \"ret_element0\": [2], \"ret_element0_element0\": [\"926\"], \"ret_element0_element1\": [\"-891\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *constructFromPrePost. /*FC*/class Solution {\n/*FM*/TreeNode *constructFromPrePost(vector<int> &pre, vector<int> &post) {\r\n        if (pre.size() == 0)\r\n            \r\n        return ConstructTree(pre, post, 0, pre.size() - 1, 0, post.size() - 1); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pre\": [2], \"pre_element0\": [\"174\"], \"pre_element1\": [\"-877\"], \"post\": [2], \"post_element0\": [\"117\"], \"post_element1\": [\"-481\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> findAndReplacePattern. /*FC*/class Solution {\n/*FM*/vector<string> findAndReplacePattern(vector<string> &words, string pattern) {\r\n        vector<string> ret; \r\n        int size = pattern.size(); \r\n        for (string word: words) {\r\n            int wordSize = word.size(); \r\n            if (size != wordSize)\r\n                \r\n            map<char, char> p; \r\n            map<char, char> q; \r\n            int i = 0; \r\n            for (i = 0;  i < size;  ++i) {\r\n                if (p.find(pattern[i]) == p.end()) {\r\n                    p.insert(map<char, char>::value_type(pattern[i], word[i])); \r\n                } else {\r\n                    \r\n                }\r\n                if (q.find(word[i]) == q.end()) {\r\n                    q.insert(map<char, char>::value_type(word[i], pattern[i])); \r\n                } else {\r\n                    \r\n                }\r\n            }\r\n            if (i == size)\r\n                ret.push_back(word); \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"2\"], \"pattern\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int surfaceArea. /*FC*/class Solution {\n/*FM*/int surfaceArea(vector<vector<int>> &grid) {\r\n        int x = grid.size(), y = x ? grid[0].size() : 0; \r\n        if (x == 0)\r\n            \r\n        int total = 0, area = 0; \r\n        for (int i = 0;  i < x;  ++i) {\r\n            for (int j = 0;  j < y;  ++j) {\r\n                if (grid[i][j] == 0)\r\n                    \r\n                area = 2 + 4 * grid[i][j]; \r\n                if (i - 1 >= 0)\r\n                    area -= min(grid[i - 1][j], grid[i][j]); \r\n                if (j - 1 >= 0)\r\n                    area -= min(grid[i][j - 1], grid[i][j]); \r\n                if (i + 1 < x)\r\n                    area -= min(grid[i + 1][j], grid[i][j]); \r\n                if (j + 1 < y)\r\n                    area -= min(grid[i][j + 1], grid[i][j]); \r\n                total += area; \r\n            }\r\n        }\r\n        return total; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"283\"], \"grid_element0_element1\": [\"-612\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"-906\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isMonotonic. /*FC*/class Solution {\n/*FM*/bool isMonotonic(vector<int> &A) {\r\n        auto size = A.size(); \r\n        int &&inc = 0; \r\n        for (int i = 0;  i < size - 1;  ++i) {\r\n            if (A[i] < A[i + 1]) {\r\n                if (inc == -1)\r\n                    \r\n                inc = 1; \r\n            } else if (A[i] > A[i + 1]) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-496\"], \"A_element1\": [\"659\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\r\n        if (x < 0)\r\n            \r\n        vector<int> nums; \r\n        while (x) {\r\n            nums.push_back(x % 10); \r\n            x /= 10; \r\n        }\r\n        int i = 0, j = nums.size() - 1; \r\n        while (i < j) {\r\n            if (nums[i] != nums[j])\r\n                return false; \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"610222440\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\r\n        if (x < 0)\r\n            return false; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"-1195506633\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortArrayByParity. /*FC*/class Solution {\n/*FM*/vector<int> sortArrayByParity(vector<int> &A) {\r\n        int i = 0, j = 0; \r\n        while (j < A.size()) {\r\n            if (A[j] % 2 == 0) {\r\n                swap(A[i], A[j]); \r\n                ++i; \r\n            }\r\n            ++j; \r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-74\"], \"A_element1\": [\"993\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestRangeI. /*FC*/class Solution {\n/*FM*/int smallestRangeI(vector<int> &A, int K) {\r\n        int max_val = INT_MIN, min_val = INT_MAX; \r\n        for (auto &a : A) {\r\n            max_val = max(max_val, a); \r\n            min_val = min(min_val, a); \r\n        }\r\n        return max(0, max_val - min_val - 2 * K); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"34\"], \"K\": [\"-1008517492\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseOnlyLetters. /*FC*/class Solution {\n/*FM*/string reverseOnlyLetters(string S) {\r\n        int i = 0, j = S.size() - 1; \r\n        while (i < j) {\r\n            \r\n        }\r\n        return S; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseBetween. /*FC*/class Solution {\n/*FM*/ListNode *reverseBetween(ListNode *head, int m, int n) {\r\n        if (m >= n || m < 1)\r\n            return head; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-739\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"476\"], \"m\": [\"6\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minAddToMakeValid. /*FC*/class Solution {\n/*FM*/int minAddToMakeValid(string S) {\r\n        stack<char> parentheses; \r\n        for (auto c:S) {\r\n            if (c == '(')\r\n                \r\n            else {\r\n                if (!parentheses.empty() and parentheses.top() == '(')\r\n                    \r\n                else\r\n                    parentheses.push(c); \r\n            }\r\n        }\r\n        return parentheses.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortArrayByParityII. /*FC*/class Solution {\n/*FM*/vector<int> sortArrayByParityII(vector<int>& A) {\r\n        auto size = A.size(); \r\n        if(size <= 1)\r\n            return A; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"-422\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortArrayByParityII. /*FC*/class Solution {\n/*FM*/vector<int> sortArrayByParityII(vector<int>& A) {\r\n        auto size = A.size(); \r\n        if(size <= 1)\r\n            \r\n        int i = 0,j = 1; \r\n        while(i< size && j < size) {\r\n            while(A[i] % 2 == 0 && i < size)\r\n                i += 2; \r\n            while(A[j] % 2 == 1 && j < size)\r\n                \r\n            if(i < size && j < size) {\r\n                \r\n                \r\n                \r\n            }\r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-520\"], \"A_element1\": [\"-639\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isLongPressedName. /*FC*/class Solution {\n/*FM*/bool isLongPressedName(string name, string typed) {\r\n        int i = 0, j = 0, name_size = name.size(), typed_size = typed.size(); \r\n        while (i < name_size && j < typed_size) {\r\n            if (name[i] == typed[j]) {\r\n                \r\n                \r\n            } else\r\n                ++j; \r\n        }\r\n        if (i == name_size)\r\n            \r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"name\": [\"2\"], \"typed\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numUniqueEmails. /*FC*/class Solution {\n/*FM*/int numUniqueEmails(vector<string> &emails) {\r\n        unordered_set<string> email_set; \r\n        for (auto email:emails) {\r\n            int i = 0; \r\n            while (i < email.size()) {\r\n                if (email[i] == '.')\r\n                    email.erase(email.begin() + i); \r\n                else if (email[i] == '+') {\r\n                    \r\n                    \r\n                    \r\n                } else\r\n                    ++i; \r\n            }\r\n            email_set.insert(email); \r\n        }\r\n        return email_set.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"emails\": [2], \"emails_element0\": [\"2\"], \"emails_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void push. /*FC*/class Solution {\n/*FM*/void push(vector<int> &temp, vector<string> &ret) {\r\n        string s; \r\n        for (int i = 0;  i < 4;  ++i)\r\n            s += (to_string(temp[i]) + \".\"); \r\n        s.pop_back(); \r\n        ret.push_back(s); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"temp\": [1], \"temp_element0\": [\"934\"], \"ret\": [2], \"ret_element0\": [\"1\"], \"ret_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int ping. /*FC*/class RecentCounter {\n/*FM*/int ping(int t) {\r\n        ++j; \r\n        time.push_back(t); \r\n        while (i < j) {\r\n            if (time[j - 1] - time[i] <= 3000)\r\n                break; \r\n            \r\n        }\r\n        return j - i; \r\n    };/*F*/vector<int> time;  int i;  int j;/*C*/RecentCounter() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RecentCounter\": [\"RecentCounter\", \"RecentCounter()\"], \"AKA_INSTANCE___RecentCounter->time\": [2], \"AKA_INSTANCE___RecentCounter_time_element0\": [\"-797\"], \"AKA_INSTANCE___RecentCounter_time_element1\": [\"-41\"], \"AKA_INSTANCE___RecentCounter->i\": [\"-419\"], \"AKA_INSTANCE___RecentCounter->j\": [\"506\"], \"t\": [\"1992988476\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int ping. /*FC*/class RecentCounter {\n/*FM*/int ping(int t) {\r\n        ++j; \r\n        time.push_back(t); \r\n        while (i < j) {\r\n            \r\n            \r\n        }\r\n        return j - i; \r\n    };/*F*/vector<int> time;  int i;  int j;/*C*/RecentCounter() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RecentCounter\": [\"RecentCounter\", \"RecentCounter()\"], \"AKA_INSTANCE___RecentCounter->time\": [2], \"AKA_INSTANCE___RecentCounter_time_element0\": [\"98\"], \"AKA_INSTANCE___RecentCounter_time_element1\": [\"242\"], \"AKA_INSTANCE___RecentCounter->i\": [\"978\"], \"AKA_INSTANCE___RecentCounter->j\": [\"-301\"], \"t\": [\"-1145829354\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void DFS. /*FC*/class Solution {\n/*FM*/void DFS(TreeNode *node, int &L, int &R) {\r\n        if (!node)\r\n            return; \r\n        if (node->val >= L && node->val <= R)\r\n            \r\n        if (node->val < R)\r\n            DFS(node->right, L, R); \r\n        if (node->val > L)\r\n            \r\n    };/*F*//*C*//*M*/void DFS(TreeNode *node, int &L, int &R) {\r\n        if (!node)\r\n            return; \r\n        if (node->val >= L && node->val <= R)\r\n            sum += node->val; \r\n        if (node->val < R)\r\n            DFS(node->right, L, R); \r\n        if (node->val > L)\r\n            DFS(node->left, L, R); \r\n    } void DFS(TreeNode *node, int &L, int &R) {\r\n        if (!node)\r\n            return; \r\n        if (node->val >= L && node->val <= R)\r\n            sum += node->val; \r\n        if (node->val < R)\r\n            DFS(node->right, L, R); \r\n        if (node->val > L)\r\n            DFS(node->left, L, R); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"node\": [2], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"309\"], \"node[0].val\": [\"-347\"], \"node[0].left\": [1], \"node[0].left[0]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"node0_left0_x\": [\"-162\"], \"node[0].left[0].val\": [\"487\"], \"node[1]\": [\"TreeNode\", \"TreeNode()\"], \"node[1].val\": [\"-540\"], \"node[1].left\": [1], \"node[1].left[0]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"node1_left0_x\": [\"-750\"], \"node[1].left[0].val\": [\"-547\"], \"node[1].right\": [2], \"node[1].right[0]\": [\"TreeNode\", \"TreeNode()\"], \"node[1].right[0].val\": [\"440\"], \"node[1].right[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"node1_right1_x\": [\"-821\"], \"node[1].right[1].val\": [\"486\"], \"L\": [\"1864306455\"], \"R\": [\"1849894516\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void DFS. /*FC*/class Solution {\n/*FM*/void DFS(TreeNode *node, int &L, int &R) {\r\n        if (!node)\r\n            \r\n        if (node->val >= L && node->val <= R)\r\n            \r\n        if (node->val < R)\r\n            \r\n        if (node->val > L)\r\n            DFS(node->left, L, R); \r\n    };/*F*//*C*//*M*/void DFS(TreeNode *node, int &L, int &R) {\r\n        if (!node)\r\n            return; \r\n        if (node->val >= L && node->val <= R)\r\n            sum += node->val; \r\n        if (node->val < R)\r\n            DFS(node->right, L, R); \r\n        if (node->val > L)\r\n            DFS(node->left, L, R); \r\n    } void DFS(TreeNode *node, int &L, int &R) {\r\n        if (!node)\r\n            return; \r\n        if (node->val >= L && node->val <= R)\r\n            sum += node->val; \r\n        if (node->val < R)\r\n            DFS(node->right, L, R); \r\n        if (node->val > L)\r\n            DFS(node->left, L, R); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"L\": [\"-787291058\"], \"R\": [\"-68654597\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> inorderTraversal. /*FC*/class Solution {\n/*FM*/vector<int> inorderTraversal(TreeNode *root) {\r\n        vector<int> vec; \r\n        stack<TreeNode *> s; \r\n        while (root || !s.empty()) {\r\n            if (root) {\r\n                s.push(root); \r\n                root = root->left; \r\n            } else {\r\n                root = s.top(); \r\n                s.pop(); \r\n                vec.push_back(root->val); \r\n                root = root->right; \r\n            }\r\n        }\r\n        return vec; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-873\"], \"root[0].val\": [\"-472\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-158\"], \"root[0].left[0].val\": [\"391\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[1].val\": [\"-298\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].right[0].val\": [\"60\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validMountainArray. /*FC*/class Solution {\n/*FM*/bool validMountainArray(vector<int> &A) {\r\n        auto size = A.size(); \r\n        if (size < 3)\r\n            return false; \r\n        \r\n              if (i == 0 || i == size - 1)\r\n            \r\n              \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"-275\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> diStringMatch. /*FC*/class Solution {\n/*FM*/vector<int> diStringMatch(string S) {\r\n        S += 'E'; \r\n        int n = S.size(), m = S.size() - 1, j = 0; \r\n        vector<int> ret(n, 0); \r\n        for (int i = 0;  i < n;  ++i)\r\n            ret[i] = S[i] == 'I' ? j++ : m--; \r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDeletionSize. /*FC*/class Solution {\n/*FM*/int minDeletionSize(vector<string> &A) {\r\n        const int size = A.size(); \r\n        if (size <= 1) return 0; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDeletionSize. /*FC*/class Solution {\n/*FM*/int minDeletionSize(vector<string> &A) {\r\n        const int size = A.size(); \r\n        if (size <= 1) \r\n        const int len = A[0].size(); \r\n        int sum = 0; \r\n        for (int i = 0;  i < len;  ++i) {\r\n            for (int j = 1;  j < size;  ++j) {\r\n                if (A[j][i] < A[j - 1][i]) {\r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"2\"], \"A_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDeletionSize. /*FC*/class Solution {\n/*FM*/int minDeletionSize(vector<string> &A) {\r\n        const int size = A.size(); \r\n        if (size <= 1) \r\n        const int len = A[0].size(); \r\n        int sum = 0; \r\n        for (int i = 0;  i < len;  ++i) {\r\n            for (int j = 1;  j < size;  ) {\r\n                if (A[j][i] < A[j - 1][i]) {\r\n                    ++sum; \r\n                    break; \r\n                }\r\n            }\r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"1\"], \"A_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validateStackSequences. /*FC*/class Solution {\n/*FM*/bool validateStackSequences(vector<int> &pushed, vector<int> &popped) {\r\n        stack<int> res; \r\n        int i = 0, n = popped.size(); \r\n        for (auto &p:pushed) {\r\n            res.push(p); \r\n            while (!res.empty() && i < n && res.top() == popped[i]) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return i == n; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pushed\": [1], \"pushed_element0\": [\"-815\"], \"popped\": [2], \"popped_element0\": [\"599\"], \"popped_element1\": [\"-299\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeStones. /*FC*/class Solution {\n/*FM*/int removeStones(vector<vector<int>> &stones) {\r\n        int total = 0; \r\n        unordered_map<int, unordered_set<int>> row, col; \r\n        for (auto &s:stones) {\r\n            if (row.find(s[0]) == row.end())\r\n                row.insert(pair<int, unordered_set<int>>(s[0], unordered_set<int>())); \r\n            row[s[0]].insert(s[1]); \r\n            if (col.find(s[1]) == col.end())\r\n                col.insert(pair<int, unordered_set<int>>(s[1], unordered_set<int>())); \r\n            col[s[1]].insert(s[0]); \r\n        }\r\n        for (auto &s:stones) {\r\n            if (!row[s[0]].empty())\r\n                total += DFS(stones, s[0], s[1], row, col) - 1; \r\n        }\r\n        return total; \r\n    };/*F*//*C*//*M*/int DFS(vector<vector<int>> &stone, int x, int y, unordered_map<int, unordered_set<int>> &row,\r\n            unordered_map<int, unordered_set<int>> &col) {\r\n        int sum = 1; \r\n        row[x].erase(y); \r\n        col[y].erase(x); \r\n        for (auto r:row[x]) {\r\n            sum += DFS(stone, x, r, row, col); \r\n            if (row[x].empty())\r\n                break; \r\n        }\r\n        for (auto c:col[y]) {\r\n            sum += DFS(stone, c, y, row, col); \r\n            if (col[y].empty())\r\n                break; \r\n        }\r\n        return sum; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"stones\": [2], \"stones_element0\": [1], \"stones_element0_element0\": [\"853\"], \"stones_element1\": [1], \"stones_element1_element0\": [\"590\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string largestTimeFromDigits. /*FC*/class Solution {\n/*FM*/string largestTimeFromDigits(vector<int> &A) {\r\n        sort(A.begin(), A.end()); \r\n        string time; \r\n        do {\r\n            int h = A[0] * 10 + A[1], m = A[2] * 10 + A[3]; \r\n            if (h < 24 && m < 60)\r\n                \r\n        } while (next_permutation(A.begin(), A.end())); \r\n        return time; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-788\"], \"A_element1\": [\"-602\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string largestTimeFromDigits. /*FC*/class Solution {\n/*FM*/string largestTimeFromDigits(vector<int> &A) {\r\n        sort(A.begin(), A.end()); \r\n        string time; \r\n        do {\r\n            int h = A[0] * 10 + A[1], m = A[2] * 10 + A[3]; \r\n            if (h < 24 && m < 60)\r\n                time = to_string(A[0]) + to_string(A[1]) + \":\" + to_string(A[2]) + to_string(A[3]); \r\n        } while (next_permutation(A.begin(), A.end())); \r\n        return time; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-970\"], \"A_element1\": [\"-363\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool flipEquiv. /*FC*/class Solution {\n/*FM*/bool flipEquiv(TreeNode *root1, TreeNode *root2) {\r\n        if (!root1 && !root2)\r\n            \r\n        else if (!root1 || !root2)\r\n            \r\n        else if (root1->val != root2->val)\r\n            return false; \r\n        \r\n    };/*F*//*C*//*M*/bool flipEquiv(TreeNode *root1, TreeNode *root2) {\r\n        if (!root1 && !root2)\r\n            return true; \r\n        else if (!root1 || !root2)\r\n            return false; \r\n        else if (root1->val != root2->val)\r\n            return false; \r\n        return (flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right)) ||\r\n               (flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left)); \r\n    } bool flipEquiv(TreeNode *root1, TreeNode *root2) {\r\n        if (!root1 && !root2)\r\n            return true; \r\n        else if (!root1 || !root2)\r\n            return false; \r\n        else if (root1->val != root2->val)\r\n            return false; \r\n        return (flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right)) ||\r\n               (flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left)); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root1\": [2], \"root1[0]\": [\"TreeNode\", \"TreeNode()\"], \"root1[0].val\": [\"-931\"], \"root1[0].left\": [1], \"root1[0].left[0]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root10_left0_x\": [\"952\"], \"root1[0].left[0].val\": [\"-223\"], \"root1[0].right\": [1], \"root1[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root10_right0_x\": [\"-770\"], \"root1[0].right[0].val\": [\"-965\"], \"root1[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root11_x\": [\"-361\"], \"root1[1].val\": [\"565\"], \"root1[1].left\": [1], \"root1[1].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root1[1].left[0].val\": [\"-155\"], \"root1[1].right\": [1], \"root1[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root11_right0_x\": [\"147\"], \"root1[1].right[0].val\": [\"-366\"], \"root2\": [2], \"root2[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root20_x\": [\"-281\"], \"root2[0].val\": [\"521\"], \"root2[0].right\": [1], \"root2[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root20_right0_x\": [\"624\"], \"root2[0].right[0].val\": [\"-157\"], \"root2[1]\": [\"TreeNode\", \"TreeNode()\"], \"root2[1].val\": [\"89\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canReorderDoubled. /*FC*/class Solution {\n/*FM*/bool canReorderDoubled(vector<int> &A) {\r\n        auto size = A.size(); \r\n        if (size < 2)\r\n            \r\n        for (int i = 0;  i < A.size();  ++i)\r\n            if (A[i] < 0)\r\n                A[i] = -A[i]; \r\n        sort(A.begin(), A.end()); \r\n        for (int i = 0;  i < size;  ++i) {\r\n            bool deleted = false; \r\n            for (int j = i + 1;  j < size;  ++j) {\r\n                if (A[j] == A[i] * 2) {\r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                } else if (A[j] > A[i] * 2)\r\n                    \r\n\r\n            }\r\n            if (deleted)\r\n                \r\n        }\r\n        if (A.empty())\r\n            \r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-426\"], \"A_element1\": [\"-653\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canReorderDoubled. /*FC*/class Solution {\n/*FM*/bool canReorderDoubled(vector<int> &A) {\r\n        auto size = A.size(); \r\n        if (size < 2)\r\n            \r\n        for (int i = 0;  i < A.size();  ++i)\r\n            if (A[i] < 0)\r\n                A[i] = -A[i]; \r\n        sort(A.begin(), A.end()); \r\n        for (int i = 0;  i < size;  ) {\r\n            bool deleted = false; \r\n            for (int j = i + 1;  j < size;  ) {\r\n                if (A[j] == A[i] * 2) {\r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                } else if (A[j] > A[i] * 2)\r\n                    return false; \r\n\r\n            }\r\n            \r\n        }\r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-77\"], \"A_element1\": [\"383\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isCompleteTree. /*FC*/class Solution {\n/*FM*/bool isCompleteTree(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        queue<TreeNode *> que; \r\n        que.push(root); \r\n        int size = 1; \r\n        bool finished = false; \r\n        while (!que.empty()) {\r\n            while (size > 0) {\r\n                root = que.front(); \r\n                que.pop(); \r\n                if (finished && (root->left || root->right))\r\n                    \r\n                if (root->left && root->right) {\r\n                    \r\n                    \r\n                } else if (root->left) {\r\n                    \r\n                    \r\n                } else if (root->right)\r\n                    return false; \r\n                else\r\n                    \r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"467\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root0_right1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isCompleteTree. /*FC*/class Solution {\n/*FM*/bool isCompleteTree(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        queue<TreeNode *> que; \r\n        que.push(root); \r\n        int size = 1; \r\n        bool finished = false; \r\n        while (!que.empty()) {\r\n            while (size > 0) {\r\n                root = que.front(); \r\n                que.pop(); \r\n                if (finished && (root->left || root->right))\r\n                    \r\n                if (root->left && root->right) {\r\n                    \r\n                    \r\n                } else if (root->left) {\r\n                    que.push(root->left); \r\n                    finished = true; \r\n                } else if (root->right)\r\n                    \r\n                else\r\n                    finished = true; \r\n                --size; \r\n            }\r\n            size = que.size(); \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"596\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-231\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode()\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_x\": [\"385\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isCompleteTree. /*FC*/class Solution {\n/*FM*/bool isCompleteTree(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        queue<TreeNode *> que; \r\n        que.push(root); \r\n        int size = 1; \r\n        bool finished = false; \r\n        while (!que.empty()) {\r\n            while (size > 0) {\r\n                root = que.front(); \r\n                que.pop(); \r\n                if (finished && (root->left || root->right))\r\n                    return false; \r\n                if (root->left && root->right) {\r\n                    que.push(root->left); \r\n                    que.push(root->right); \r\n                } else if (root->left) {\r\n                    \r\n                    \r\n                } else if (root->right)\r\n                    \r\n                else\r\n                    finished = true; \r\n                --size; \r\n            }\r\n            size = que.size(); \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root0_x\": [\"768\"], \"root0_left\": [1], \"root0_left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_x\": [\"-63\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numTrees. /*FC*/class Solution {\n/*FM*/int numTrees(int n) {\r\n        vector<int> trees(n + 1, 0); \r\n        trees[0] = 1; \r\n        trees[1] = 1; \r\n        for (int i = 2;  i <= n;  ++i)\r\n            for (int j = 1;  j <= i;  ++j)\r\n                trees[i] += trees[j - 1] * trees[i - j]; \r\n        return trees[n]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxWidthRamp. /*FC*/class Solution {\n/*FM*/int maxWidthRamp(vector<int> &A) {\r\n        int size = A.size(); \r\n        for (int i = size - 1;  i >= 1;  --i) {\r\n            for (int j = 0;  j + i < size;  ++j) {\r\n                if (A[j + i] >= A[j])\r\n                    \r\n            }\r\n        }\r\n        return 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-242\"], \"A_element1\": [\"-389\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxWidthRamp. /*FC*/class Solution {\n/*FM*/int maxWidthRamp(vector<int> &A) {\r\n        int size = A.size(); \r\n        for (int i = size - 1;  i >= 1;  ) {\r\n            for (int j = 0;  j + i < size;  ) {\r\n                if (A[j + i] >= A[j])\r\n                    return i; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-100\"], \"A_element1\": [\"333\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUnivalTree. /*FC*/class Solution {\n/*FM*/bool isUnivalTree(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        return Traverse(root, root->val); \r\n    };/*F*//*C*//*M*/bool Traverse(TreeNode *node, const int &value) {\r\n        if (!node)\r\n            return true; \r\n        if (node->val != value)\r\n            return false; \r\n        return Traverse(node->left, node->val) && Traverse(node->right, node->val); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"-371\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool Traverse. /*FC*/class Solution {\n/*FM*/bool Traverse(TreeNode *node, const int &value) {\r\n        if (!node)\r\n            \r\n        if (node->val != value)\r\n            return false; \r\n        \r\n    };/*F*//*C*//*M*/bool Traverse(TreeNode *node, const int &value) {\r\n        if (!node)\r\n            return true; \r\n        if (node->val != value)\r\n            return false; \r\n        return Traverse(node->left, node->val) && Traverse(node->right, node->val); \r\n    } bool Traverse(TreeNode *node, const int &value) {\r\n        if (!node)\r\n            return true; \r\n        if (node->val != value)\r\n            return false; \r\n        return Traverse(node->left, node->val) && Traverse(node->right, node->val); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"node\": [1], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"327\"], \"node[0].val\": [\"-738\"], \"value\": [\"203284762\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void ToLower. /*FC*/class Solution {\n/*FM*/void ToLower(string &str) {\r\n        for (int i = 0;  i < str.size();  ++i)\r\n            str[i] = tolower(str[i]); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> numsSameConsecDiff. /*FC*/class Solution {\n/*FM*/vector<int> numsSameConsecDiff(int N, int K) {\r\n        if (N == 0)\r\n            \r\n        ret.clear(); \r\n        if (N == 1)\r\n            \r\n\r\n        for (int i = 1;  i <= 9;  ++i)\r\n            helper(i, N - 1, K, i); \r\n\r\n        return ret; \r\n    };/*F*/vector<int> ret;/*C*//*M*/void helper(int last, int N, int K, int x) {\r\n        if (N <= 0) {\r\n            ret.push_back(x); \r\n            return; \r\n        }\r\n        if (last + K < 10)\r\n            helper(last + K, N - 1, K, x * 10 + last + K); \r\n        if (last - K >= 0 && K != 0)\r\n            helper(last - K, N - 1, K, x * 10 + last - K); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->ret\": [2], \"AKA_INSTANCE___Solution_ret_element0\": [\"932\"], \"AKA_INSTANCE___Solution_ret_element1\": [\"513\"], \"N\": [\"-1367452110\"], \"K\": [\"1631231877\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> flipMatchVoyage. /*FC*/class Solution {\n/*FM*/vector<int> flipMatchVoyage(TreeNode *root, vector<int> &voyage) {\r\n        if (!root || voyage.size() == 0)\r\n            \r\n        this->voyage = voyage; \r\n        nodes.clear(); \r\n        index = 0; \r\n        helper(root); \r\n        if (!match)\r\n            return {-1}; \r\n        \r\n    };/*F*/vector<int> nodes;  int index;  vector<int> voyage;/*C*//*M*/void helper(TreeNode *root) {\r\n        if (!root)\r\n            return; \r\n        if (root->val != voyage[index] || !match) {\r\n            match = false; \r\n            return; \r\n        }\r\n        ++index; \r\n        if (root->left && root->left->val != voyage[index]) {\r\n            nodes.push_back(root->val); \r\n            helper(root->right); \r\n            helper(root->left); \r\n        } else {\r\n            helper(root->left); \r\n            helper(root->right); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->nodes\": [2], \"AKA_INSTANCE___Solution_nodes_element0\": [\"428\"], \"AKA_INSTANCE___Solution_nodes_element1\": [\"690\"], \"AKA_INSTANCE___Solution->index\": [\"931\"], \"AKA_INSTANCE___Solution->voyage\": [1], \"AKA_INSTANCE___Solution_voyage_element0\": [\"754\"], \"AKA_INSTANCE___Solution->match\": [\"true\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"697\"], \"voyage\": [2], \"voyage_element0\": [\"-775\"], \"voyage_element1\": [\"-31\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void helper. /*FC*/class Solution {\n/*FM*/void helper(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        if (root->val != voyage[index] || !match) {\r\n            match = false; \r\n            return; \r\n        }\r\n        \r\n        \r\n    };/*F*/int index;  vector<int> voyage;/*C*//*M*/void helper(TreeNode *root) {\r\n        if (!root)\r\n            return; \r\n        if (root->val != voyage[index] || !match) {\r\n            match = false; \r\n            return; \r\n        }\r\n        ++index; \r\n        if (root->left && root->left->val != voyage[index]) {\r\n            nodes.push_back(root->val); \r\n            helper(root->right); \r\n            helper(root->left); \r\n        } else {\r\n            helper(root->left); \r\n            helper(root->right); \r\n        }\r\n    } void helper(TreeNode *root) {\r\n        if (!root)\r\n            return; \r\n        if (root->val != voyage[index] || !match) {\r\n            match = false; \r\n            return; \r\n        }\r\n        ++index; \r\n        if (root->left && root->left->val != voyage[index]) {\r\n            nodes.push_back(root->val); \r\n            helper(root->right); \r\n            helper(root->left); \r\n        } else {\r\n            helper(root->left); \r\n            helper(root->right); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->nodes\": [2], \"AKA_INSTANCE___Solution_nodes_element0\": [\"320\"], \"AKA_INSTANCE___Solution_nodes_element1\": [\"382\"], \"AKA_INSTANCE___Solution->index\": [\"-511\"], \"AKA_INSTANCE___Solution->voyage\": [1], \"AKA_INSTANCE___Solution_voyage_element0\": [\"692\"], \"AKA_INSTANCE___Solution->match\": [\"true\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int subarraysDivByK. /*FC*/class Solution {\n/*FM*/int subarraysDivByK(vector<int> &A, int K) {\r\n        auto size = A.size(); \r\n        unordered_map<int, int> count; \r\n        int ret = 0, prefix = 0; \r\n        count[0] = 1; \r\n        for (int a : A) {\r\n            prefix = (prefix + a) % K; \r\n            if (prefix < 0) prefix += K; \r\n            ret += count[prefix]; \r\n            ++count[prefix]; \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"-241\"], \"K\": [\"-2138628167\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int subarraysDivByK. /*FC*/class Solution {\n/*FM*/int subarraysDivByK(vector<int> &A, int K) {\r\n        auto size = A.size(); \r\n        unordered_map<int, int> count; \r\n        int ret = 0, prefix = 0; \r\n        count[0] = 1; \r\n        for (int a : A) {\r\n            prefix = (prefix + a) % K; \r\n            if (prefix < 0) \r\n            ret += count[prefix]; \r\n            ++count[prefix]; \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"524\"], \"A_element1\": [\"352\"], \"K\": [\"2089981815\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestPerimeter. /*FC*/class Solution {\n/*FM*/int largestPerimeter(vector<int> &A) {\r\n        auto size = A.size(); \r\n        sort(A.begin(), A.end()); \r\n        for (int i = size - 3;  i >= 0;  ) {\r\n            \r\n        }\r\n        return 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-641\"], \"A_element1\": [\"935\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortedSquares. /*FC*/class Solution {\n/*FM*/vector<int> sortedSquares(vector<int> &A) {\r\n        vector<int> ret; \r\n        auto size = A.size(); \r\n        int i = 0, j = size - 1, mid = 0; \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (A[mid] < 0 && A[mid + 1] >= 0)\r\n                \r\n            else if (A[mid] >= 0)\r\n                j = mid; \r\n            else\r\n                \r\n        }\r\n        i = mid, j = mid + 1; \r\n        while (i >= 0 || j < size) {\r\n            if (i >= 0 && j < size) {\r\n                if (abs(A[i]) <= abs(A[j])) {\r\n                    ret.push_back(pow(A[i], 2)); \r\n                    --i; \r\n                } else {\r\n                    \r\n                    \r\n                }\r\n            } else if (i >= 0) {\r\n                \r\n                \r\n            } else if (j < size) {\r\n                ret.push_back(pow(A[j], 2)); \r\n                ++j; \r\n            }\r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"32\"], \"A_element1\": [\"846\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortedSquares. /*FC*/class Solution {\n/*FM*/vector<int> sortedSquares(vector<int> &A) {\r\n        vector<int> ret; \r\n        auto size = A.size(); \r\n        int i = 0, j = size - 1, mid = 0; \r\n        while (i < j) {\r\n            mid = i + (j - i) / 2; \r\n            if (A[mid] < 0 && A[mid + 1] >= 0)\r\n                \r\n            else if (A[mid] >= 0)\r\n                j = mid; \r\n            else\r\n                \r\n        }\r\n        i = mid, j = mid + 1; \r\n        while (i >= 0 || j < size) {\r\n            if (i >= 0 && j < size) {\r\n                if (abs(A[i]) <= abs(A[j])) {\r\n                    \r\n                    \r\n                } else {\r\n                    ret.push_back(pow(A[j], 2)); \r\n                    ++j; \r\n                }\r\n            } else if (i >= 0) {\r\n                ret.push_back(pow(A[i], 2)); \r\n                --i; \r\n            } else if (j < size) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"639\"], \"A_element1\": [\"447\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxTurbulenceSize. /*FC*/class Solution {\n/*FM*/int maxTurbulenceSize(vector<int> &A) {\r\n        int size = A.size(), maxSize = 1, curSize = 1; \r\n        if (size <= 2) return size; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"869\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int distributeCoins. /*FC*/class Solution {\n/*FM*/int distributeCoins(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        int total = 0; \r\n        CountCoins(root, total); \r\n        return total; \r\n    };/*F*//*C*//*M*/int CountCoins(TreeNode *node, int &total) {\r\n        if (!node)\r\n            return 0; \r\n        int &&value = node->val - 1 + CountCoins(node->left, total) + CountCoins(node->right, total); \r\n        total += abs(value); \r\n        return value; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"861\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_x\": [\"-290\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int CountCoins. /*FC*/class Solution {\n/*FM*/int CountCoins(TreeNode *node, int &total) {\r\n        if (!node)\r\n            return 0; \r\n        int &&value = node->val - 1 + CountCoins(node->left, total) + CountCoins(node->right, total); \r\n        total += abs(value); \r\n        return value; \r\n    };/*F*//*C*//*M*/int CountCoins(TreeNode *node, int &total) {\r\n        if (!node)\r\n            return 0; \r\n        int &&value = node->val - 1 + CountCoins(node->left, total) + CountCoins(node->right, total); \r\n        total += abs(value); \r\n        return value; \r\n    } int CountCoins(TreeNode *node, int &total) {\r\n        if (!node)\r\n            return 0; \r\n        int &&value = node->val - 1 + CountCoins(node->left, total) + CountCoins(node->right, total); \r\n        total += abs(value); \r\n        return value; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"node\": [1], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"-579\"], \"node[0].val\": [\"-64\"], \"node[0].left\": [1], \"node[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_left0_x\": [\"684\"], \"node[0].left[0].val\": [\"-117\"], \"node[0].right\": [2], \"node[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_right0_x\": [\"-58\"], \"node[0].right[0].val\": [\"-79\"], \"node[0].right[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"node0_right1_x\": [\"802\"], \"node[0].right[1].val\": [\"-825\"], \"total\": [\"-145427496\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidBST. /*FC*/class Solution {\n/*FM*/bool isValidBST(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        stack<tuple<TreeNode *, int *, int *>> s; \r\n        s.push(make_tuple(root, nullptr, nullptr)); \r\n        while (!s.empty()) {\r\n            auto curr = s.top(); \r\n            s.pop(); \r\n            auto node = get<0>(curr); \r\n            auto &min_val = get<1>(curr), &max_val = get<2>(curr); \r\n            if ((min_val && *min_val >= node->val) || (max_val && *max_val <= node->val))\r\n                return false; \r\n            if (node->left)\r\n                s.push(make_tuple(node->left, min_val, &node->val)); \r\n            if (node->right)\r\n                s.push(make_tuple(node->right, &node->val, max_val)); \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root0_x\": [\"937\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_x\": [\"919\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidBST. /*FC*/class Solution {\n/*FM*/bool isValidBST(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        stack<tuple<TreeNode *, int *, int *>> s; \r\n        s.push(make_tuple(root, nullptr, nullptr)); \r\n        while (!s.empty()) {\r\n            auto curr = s.top(); \r\n            s.pop(); \r\n            auto node = get<0>(curr); \r\n            auto &min_val = get<1>(curr), &max_val = get<2>(curr); \r\n            if ((min_val && *min_val >= node->val) || (max_val && *max_val <= node->val))\r\n                \r\n            if (node->left)\r\n                \r\n            if (node->right)\r\n                \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mincostTickets. /*FC*/class Solution {\n/*FM*/int mincostTickets(vector<int> &days, vector<int> &costs) {\r\n        int size = days.size(); \r\n        if (size < 2)\r\n            return costs[0] * size; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"days\": [1], \"days_element0\": [\"-929\"], \"costs\": [1], \"costs_element0\": [\"436\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mincostTickets. /*FC*/class Solution {\n/*FM*/int mincostTickets(vector<int> &days, vector<int> &costs) {\r\n        int size = days.size(); \r\n        if (size < 2)\r\n            \r\n        vector<int> dp(366, 0); \r\n        int k = 0; \r\n        for (int i = 1;  i < 366;  ++i) {\r\n            if (k < size && days[k] == i) {\r\n                dp[i] = min(dp[max(0, i - 1)] + costs[0], dp[max(0, i - 7)] + costs[1]); \r\n                ++k; \r\n            } else {\r\n                dp[i] = min(dp[i - 1], dp[max(0, i - 7)] + costs[1]); \r\n            }\r\n            dp[i] = min(dp[i], dp[max(0, i - 30)] + costs[2]); \r\n        }\r\n        return dp.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"days\": [2], \"days_element0\": [\"23\"], \"days_element1\": [\"927\"], \"costs\": [1], \"costs_element0\": [\"-168\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string strWithout3a3b. /*FC*/class Solution {\n/*FM*/string strWithout3a3b(int A, int B) {\r\n        int n = A + B; \r\n        string a = \"a\", b = \"b\"; \r\n        if (A < B) {\r\n            \r\n            \r\n        }\r\n        string ret; \r\n        while (n > 0) {\r\n            if (A >= B * 2) {\r\n                \r\n                \r\n            } else {\r\n                ret += A > 0 ? a : \"\"; \r\n                A -= A > 0 ? 1 : 0; \r\n            }\r\n            ret += B > 0 ? b : \"\"; \r\n            B -= B > 0 ? 1 : 0; \r\n            n = A + B; \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"7\"], \"B\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string strWithout3a3b. /*FC*/class Solution {\n/*FM*/string strWithout3a3b(int A, int B) {\r\n        int n = A + B; \r\n        string a = \"a\", b = \"b\"; \r\n        if (A < B) {\r\n            swap(A, B); \r\n            swap(a, b); \r\n        }\r\n        string ret; \r\n        while (n > 0) {\r\n            if (A >= B * 2) {\r\n                ret += A > 1 ? (a + a) : A == 1 ? a : \"\"; \r\n                A -= A > 1 ? 2 : 1; \r\n            } else {\r\n                ret += A > 0 ? a : \"\"; \r\n                A -= A > 0 ? 1 : 0; \r\n            }\r\n            ret += B > 0 ? b : \"\"; \r\n            B -= B > 0 ? 1 : 0; \r\n            n = A + B; \r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"4\"], \"B\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> intervalIntersection. /*FC*/class Solution {\n/*FM*/vector<Interval> intervalIntersection(vector<Interval> &A, vector<Interval> &B) {\r\n        int i = 0, j = 0, m = A.size(), n = B.size(); \r\n        if (m == 0 || n == 0)\r\n            \r\n        vector<Interval> ret; \r\n        while (i < m && j < n) {\r\n            if (B[j].start > A[i].end)\r\n                ++i; \r\n            else if (A[i].start > B[j].end)\r\n                \r\n            else {\r\n                ret.push_back(Interval(max(A[i].start, B[j].start), min(A[i].end, B[j].end))); \r\n                if (A[i].end > B[j].end)\r\n                    \r\n                else\r\n                    ++i; \r\n            }\r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"Interval\", \"Interval()\"], \"A_element0.start\": [\"-75728769\"], \"A_element0.end\": [\"-373445918\"], \"A_element1\": [\"Interval\", \"Interval()\"], \"A_element1.start\": [\"660719009\"], \"A_element1.end\": [\"-1021020723\"], \"A_element2\": [\"Interval\", \"Interval(int,int)\"], \"A_element2_s\": [\"1839881152\"], \"A_element2_e\": [\"-150646960\"], \"A_element2.start\": [\"673513249\"], \"A_element2.end\": [\"-114073144\"], \"B\": [2], \"B_element0\": [\"Interval\", \"Interval()\"], \"B_element0.start\": [\"-150685438\"], \"B_element0.end\": [\"797077660\"], \"B_element1\": [\"Interval\", \"Interval(int,int)\"], \"B_element1_s\": [\"1248667630\"], \"B_element1_e\": [\"-760180743\"], \"B_element1.start\": [\"-389534704\"], \"B_element1.end\": [\"1154576409\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> intervalIntersection. /*FC*/class Solution {\n/*FM*/vector<Interval> intervalIntersection(vector<Interval> &A, vector<Interval> &B) {\r\n        int i = 0, j = 0, m = A.size(), n = B.size(); \r\n        if (m == 0 || n == 0)\r\n            \r\n        vector<Interval> ret; \r\n        while (i < m && j < n) {\r\n            if (B[j].start > A[i].end)\r\n                \r\n            else if (A[i].start > B[j].end)\r\n                ++j; \r\n            else {\r\n                ret.push_back(Interval(max(A[i].start, B[j].start), min(A[i].end, B[j].end))); \r\n                if (A[i].end > B[j].end)\r\n                    ++j; \r\n                else\r\n                    \r\n            }\r\n        }\r\n        return ret; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"Interval\", \"Interval()\"], \"A_element0.start\": [\"-674786193\"], \"A_element0.end\": [\"653713143\"], \"B\": [2], \"B_element0\": [\"Interval\", \"Interval()\"], \"B_element0.start\": [\"-1045484051\"], \"B_element0.end\": [\"-340277430\"], \"B_element1\": [\"Interval\", \"Interval()\"], \"B_element1.start\": [\"-305340179\"], \"B_element1.end\": [\"-685050261\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> verticalTraversal. /*FC*/class Solution {\n/*FM*/vector<vector<int>> verticalTraversal(TreeNode *root) {\r\n        if (!root)\r\n            \r\n        nums.clear(); \r\n        Traverse(root, 0, 0); \r\n        vector<vector<int>> ret; \r\n        for (int i = -1000;  i <= 1000;  ++i) {\r\n            if (nums.find(i) != nums.end()) {\r\n                ret.push_back(vector<int>()); \r\n                for (int j = 0;  j <= 1000;  ++j) {\r\n                    if (nums[i].find(j) != nums[i].end())\r\n                        ret.back().insert(end(ret.back()), begin(nums[i][j]), end(nums[i][j])); \r\n                }\r\n            }\r\n        }\r\n        return ret; \r\n    };/*F*/unordered_map<int, unordered_map<int, set<int>>> nums;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-763207359\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> addToArrayForm. /*FC*/class Solution {\n/*FM*/vector<int> addToArrayForm(vector<int> &A, int K) {\r\n        int i = A.size() - 1, l = 0; \r\n        if (i <= -1)\r\n            \r\n        while (i >= 0) {\r\n            int temp = K % 10; \r\n            A[i] += temp + l; \r\n            l = A[i] / 10; \r\n            A[i] %= 10; \r\n            K /= 10; \r\n            --i; \r\n        }\r\n        while (K != 0) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        if (l == 1)\r\n            \r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-1960039101\"], \"A_element1\": [\"2005325047\"], \"K\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool equationsPossible. /*FC*/class Solution {\n/*FM*/bool equationsPossible(vector<string> &equations) {\r\n        match = vector<int>(26, 0); \r\n        for (int i = 0;  i < 26;  ++i)\r\n            match[i] = i; \r\n        for (auto &s:equations) {\r\n            if (s[1] == '=')\r\n                \r\n        }\r\n        for (auto &s:equations) {\r\n            if (s[1] == '!')\r\n                if (Match(match[s[0] - 'a']) == Match(match[s[3] - 'a']))\r\n                    \r\n        }\r\n        return true; \r\n    };/*F*/vector<int> match;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"equations\": [2], \"equations_element0\": [\"2\"], \"equations_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int> >& matrix, int target) {\r\n    if (matrix.empty()) \r\n\r\n    int lower = 0, upper = matrix.size() - 1; \r\n    while (lower <= upper)\r\n    {\r\n      int mid = (lower + upper) >> 1; \r\n      if (matrix[mid][0] == target) \r\n      else if (matrix[mid][0] < target)\r\n      {\r\n\t\r\n      }\r\n      else\r\n      {\r\n\tupper = mid - 1; \r\n      }\r\n    }\r\n\r\n    int row = upper; \r\n    if (row < 0 || row > matrix.size() - 1) return false; \r\n    \r\n    \r\n\r\n    \r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"1662082902\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"945047\"], \"matrix_element1_element1\": [\"529942969\"], \"target\": [\"1597612599\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> inorderTraversal. /*FC*/class Solution {\n/*FM*/vector<int> inorderTraversal(TreeNode* root) {\r\n    vector<int> ret; \r\n\r\n    if (root == NULL)\r\n    {\r\n      \r\n    }\r\n\r\n    stack<TreeNode *> st; \r\n    TreeNode *pnode = root; \r\n\r\n    while (pnode != NULL || !st.empty())\r\n    {\r\n      if (pnode != NULL)\r\n      {\r\n\tst.push(pnode); \r\n\tpnode = pnode -> left; \r\n      }\r\n      else\r\n      {\r\n\tpnode = st.top(); \r\n\tst.pop(); \r\n\tret.push_back(pnode -> val); \r\n\tpnode = pnode -> right; \r\n      }\r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1240000517\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidBST. /*FC*/class Solution {\n/*FM*/bool isValidBST(TreeNode* root) {\r\n    stack<TreeNode *> st; \r\n    TreeNode *pnode = root; \r\n\r\n    TreeNode *pre; \r\n    while(!st.empty() || pnode != NULL)\r\n    {\r\n      if (pnode != NULL)\r\n      {\r\n\tst.push(pnode); \r\n\tpnode = pnode -> left; \r\n      }\r\n      else\r\n      {\r\n\tpnode = st.top(); \r\n\tst.pop(); \r\n\tif (pre != NULL && pnode -> val <= pre -> val)\r\n\t{\r\n\t  return false; \r\n\t}\r\n\telse\r\n\t{\r\n\t  \r\n\t}\r\n\t\r\n      }\r\n    }\r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1822574757\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-727900359\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidBST. /*FC*/class Solution {\n/*FM*/bool isValidBST(TreeNode* root) {\r\n    stack<TreeNode *> st; \r\n    TreeNode *pnode = root; \r\n\r\n    TreeNode *pre; \r\n    while(!st.empty() || pnode != NULL)\r\n    {\r\n      if (pnode != NULL)\r\n      {\r\n\tst.push(pnode); \r\n\tpnode = pnode -> left; \r\n      }\r\n      else\r\n      {\r\n\tpnode = st.top(); \r\n\tst.pop(); \r\n\tif (pre != NULL && pnode -> val <= pre -> val)\r\n\t{\r\n\t  \r\n\t}\r\n\telse\r\n\t{\r\n\t  pre = pnode; \r\n\t}\r\n\tpnode = pnode -> right; \r\n      }\r\n    }\r\n    return true; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"739484198\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"2079027349\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(TreeNode * root, int n)\r\n  {\r\n    if (root != NULL)\r\n    {\r\n      n ++; \r\n      ret = n > ret ? n : ret; \r\n      dfs(root -> left, n); \r\n      dfs(root -> right, n); \r\n    }\r\n  };/*F*//*C*//*M*/void dfs(TreeNode * root, int n)\r\n  {\r\n    if (root != NULL)\r\n    {\r\n      n ++; \r\n      ret = n > ret ? n : ret; \r\n      dfs(root -> left, n); \r\n      dfs(root -> right, n); \r\n    }\r\n  } void dfs(TreeNode * root, int n)\r\n  {\r\n    if (root != NULL)\r\n    {\r\n      n ++; \r\n      ret = n > ret ? n : ret; \r\n      dfs(root -> left, n); \r\n      dfs(root -> right, n); \r\n    }\r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->ret\": [\"993128584\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1265057774\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-181936556\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"709226086\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"2007342448\"], \"n\": [\"-1452673429\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* dfs. /*FC*/class Solution {\n/*FM*/TreeNode* dfs(vector<int> &nums, int left, int right)\r\n   {\r\n     if (left > right)\r\n     {\r\n       return NULL; \r\n     }\r\n     \r\n\r\n     \r\n\r\n     \r\n     \r\n     \r\n   };/*F*//*C*//*M*/TreeNode* dfs(vector<int> &nums, int left, int right)\r\n   {\r\n     if (left > right)\r\n     {\r\n       return NULL; \r\n     }\r\n     int mid = (left + right) >> 1; \r\n\r\n     TreeNode *node = new TreeNode(nums[mid]); \r\n\r\n     node -> left = dfs(nums, left, mid - 1); \r\n     node -> right = dfs(nums, mid + 1, right); \r\n     return node; \r\n   } TreeNode* dfs(vector<int> &nums, int left, int right)\r\n   {\r\n     if (left > right)\r\n     {\r\n       return NULL; \r\n     }\r\n     int mid = (left + right) >> 1; \r\n\r\n     TreeNode *node = new TreeNode(nums[mid]); \r\n\r\n     node -> left = dfs(nums, left, mid - 1); \r\n     node -> right = dfs(nums, mid + 1, right); \r\n     return node; \r\n   } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"501981989\"], \"left\": [\"2145883062\"], \"right\": [\"1475290149\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isBalanced. /*FC*/class Solution {\n/*FM*/bool isBalanced(TreeNode* root) {\r\n    if (root == NULL)\r\n    {\r\n      return true; \r\n    }\r\n    int leftDepth = depth(root -> left); \r\n    int rightDepth = depth(root -> right); \r\n\r\n    return abs(leftDepth - rightDepth) <= 1 && isBalanced(root -> left) && isBalanced(root -> right); \r\n  };/*F*//*C*//*M*/int depth(TreeNode *root)\r\n  {\r\n    if (root == NULL)\r\n    {\r\n      return 0; \r\n    }\r\n    return max(depth(root -> left), depth(root -> right)) + 1; \r\n  } bool isBalanced(TreeNode* root) {\r\n    if (root == NULL)\r\n    {\r\n      return true; \r\n    }\r\n    int leftDepth = depth(root -> left); \r\n    int rightDepth = depth(root -> right); \r\n\r\n    return abs(leftDepth - rightDepth) <= 1 && isBalanced(root -> left) && isBalanced(root -> right); \r\n  } bool isBalanced(TreeNode* root) {\r\n    if (root == NULL)\r\n    {\r\n      return true; \r\n    }\r\n    int leftDepth = depth(root -> left); \r\n    int rightDepth = depth(root -> right); \r\n\r\n    return abs(leftDepth - rightDepth) <= 1 && isBalanced(root -> left) && isBalanced(root -> right); \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1853060783\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1406821870\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-510478532\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int depth. /*FC*/class Solution {\n/*FM*/int depth(TreeNode *root)\r\n  {\r\n    if (root == NULL)\r\n    {\r\n      return 0; \r\n    }\r\n    return max(depth(root -> left), depth(root -> right)) + 1; \r\n  };/*F*//*C*//*M*/int depth(TreeNode *root)\r\n  {\r\n    if (root == NULL)\r\n    {\r\n      return 0; \r\n    }\r\n    return max(depth(root -> left), depth(root -> right)) + 1; \r\n  } int depth(TreeNode *root)\r\n  {\r\n    if (root == NULL)\r\n    {\r\n      return 0; \r\n    }\r\n    return max(depth(root -> left), depth(root -> right)) + 1; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"380026007\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-2001810060\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDepth. /*FC*/class Solution {\n/*FM*/int minDepth(TreeNode* root) {\r\n    if (root == NULL)\r\n    {\r\n      return 0; \r\n    }\r\n    int lDepth = minDepth(root -> left); \r\n    int rDepth = minDepth(root -> right); \r\n    return 1 + (min(lDepth, rDepth) ? min(lDepth, rDepth) : max(lDepth, rDepth)); \r\n  };/*F*//*C*//*M*/int minDepth(TreeNode* root) {\r\n    if (root == NULL)\r\n    {\r\n      return 0; \r\n    }\r\n    int lDepth = minDepth(root -> left); \r\n    int rDepth = minDepth(root -> right); \r\n    return 1 + (min(lDepth, rDepth) ? min(lDepth, rDepth) : max(lDepth, rDepth)); \r\n  } int minDepth(TreeNode* root) {\r\n    if (root == NULL)\r\n    {\r\n      return 0; \r\n    }\r\n    int lDepth = minDepth(root -> left); \r\n    int rDepth = minDepth(root -> right); \r\n    return 1 + (min(lDepth, rDepth) ? min(lDepth, rDepth) : max(lDepth, rDepth)); \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1195052492\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-2113605834\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasPathSum. /*FC*/class Solution {\n/*FM*/bool hasPathSum(TreeNode* root, int sum) {\r\n    if (root == NULL)\r\n    {\r\n      \r\n    }\r\n    vector<int> nums; \r\n    dfs(root, nums, 0); \r\n    for (auto i : nums)\r\n    {\r\n      if (sum == i)\r\n      {\r\n        \r\n      }\r\n    }\r\n    return false; \r\n  };/*F*//*C*//*M*/void dfs(TreeNode *root, vector<int> &nums, int num)\r\n  {\r\n    num = num + root -> val; \r\n    if (root -> left != NULL)\r\n    {\r\n      dfs(root -> left, nums, num); \r\n    }\r\n    if (root -> right != NULL)\r\n    {\r\n      dfs(root -> right, nums, num); \r\n    }\r\n    if (root -> left == NULL && root -> right == NULL)\r\n    {\r\n      nums.push_back(num); \r\n    }\r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"570092972\"], \"sum\": [\"-764345146\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void flatten. /*FC*/class Solution {\n/*FM*/void flatten(TreeNode* root) {\r\n    if (root == NULL) \r\n    stack<TreeNode *> st; \r\n    st.push(root); \r\n\r\n    while (!st.empty())\r\n    {\r\n      TreeNode *pnode = st.top(); \r\n      st.pop(); \r\n\r\n      if (pnode -> right != NULL)\r\n      {\r\n\t\r\n      }\r\n\r\n      if (pnode -> left != NULL)\r\n      {\r\n\t\r\n      }\r\n\r\n      pnode -> left = NULL; \r\n      if (!st.empty())\r\n      {\r\n\t\r\n      }\r\n    }\r\n    \r\n  };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1203580770\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1491844834\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> getRow. /*FC*/class Solution {\n/*FM*/vector<int> getRow(int rowIndex) {\r\n    vector<int> row(rowIndex + 1, 1); \r\n\r\n    for (int i = 2;  i <= rowIndex;  i ++)\r\n    {\r\n      for (int j = i - 1;  j >= 1;  j --)\r\n      {\r\n\trow[j] = row[j] + row[j - 1]; \r\n      }\r\n    }\r\n    return row; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"rowIndex\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string s) {\r\n    if (s.size() == 0)\r\n    {\r\n      \r\n    }\r\n\r\n    int i = 0, j = s.size() - 1; \r\n    while (i <= j)\r\n    {\r\n      if (!isLetterOrDigit(s[i]))\r\n      {\r\n\ti ++; \r\n      }\r\n      else if (!isLetterOrDigit(s[j]))\r\n      {\r\n\t\r\n      }\r\n      else\r\n      {\r\n\t\r\n      \r\n        \r\n        \r\n      }\r\n    }\r\n    return true; \r\n  };/*F*//*C*//*M*/bool isLetterOrDigit(char ch)\r\n  {\r\n    if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))\r\n    {\r\n      return true; \r\n    }\r\n    return false; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isLetterOrDigit. /*FC*/class Solution {\n/*FM*/bool isLetterOrDigit(char ch)\r\n  {\r\n    if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))\r\n    {\r\n      return true; \r\n    }\r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ch\": [\"119\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isLetterOrDigit. /*FC*/class Solution {\n/*FM*/bool isLetterOrDigit(char ch)\r\n  {\r\n    if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))\r\n    {\r\n      \r\n    }\r\n    return false; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ch\": [\"124\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasCycle. /*FC*/class Solution {\n/*FM*/bool hasCycle(ListNode *head) {\r\n\r\n    if (head == NULL || head -> next == NULL)\r\n    {\r\n      \r\n    }\r\n\r\n    ListNode *fast = head; \r\n    ListNode *slow = head; \r\n\r\n    while (fast -> next && fast -> next -> next)\r\n    {\r\n      \r\n      \r\n      \r\n    }  \r\n\r\n    return false; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-934544087\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"1536746782\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"696131081\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasCycle. /*FC*/class Solution {\n/*FM*/bool hasCycle(ListNode *head) {\r\n\r\n    if (head == NULL || head -> next == NULL)\r\n    {\r\n      return false; \r\n    }\r\n\r\n    \r\n    \r\n\r\n      \r\n\r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1987694709\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1991926947\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"1610278044\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int get. /*FC*/class LRUCache {\n/*FM*/int get(int key)\r\n  {\r\n    map<int, CacheNode *>::iterator it = mp.find(key); \r\n    if (it != mp.end())\r\n    {\r\n      \r\n      \r\n      \r\n      \r\n    }\r\n    else\r\n    {\r\n      return -1; \r\n    }\r\n  };/*F*/map<int, CacheNode *> mp;/*C*/LRUCache(int capacity) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___LRUCache\": [\"LRUCache\", \"LRUCache(int)\"], \"AKA_INSTANCE___LRUCache_capacity\": [\"-1773516089\"], \"key\": [\"-1917881925\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void setHead. /*FC*/class LRUCache {\n/*FM*/void setHead(CacheNode *node)\r\n  {\r\n    node -> next = head; \r\n    node -> pre = NULL; \r\n\r\n    if (head != NULL)\r\n    {\r\n      \r\n    }\r\n    head = node; \r\n    if (tail == NULL)\r\n    {\r\n      tail = head; \r\n    }\r\n  };/*F*/CacheNode *head;  CacheNode *tail;/*C*/LRUCache(int capacity) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___LRUCache\": [\"LRUCache\", \"LRUCache(int)\"], \"AKA_INSTANCE___LRUCache_capacity\": [\"-1820391646\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method uint32_t reverseBits. /*FC*/class Solution {\n/*FM*/uint32_t reverseBits(uint32_t n) {\r\n    uint32_t ret = 0; \r\n\r\n    for (int i = 0;  i < 32;  i ++)\r\n    {\r\n      ret = (ret << 1) + (n & 1); \r\n      n >>= 1; \r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1948432986\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* removeElements. /*FC*/class Solution {\n/*FM*/ListNode* removeElements(ListNode* head, int val) {\r\n    if (head == NULL)\r\n    {\r\n      \r\n    }\r\n\r\n    ListNode *dummy = new ListNode(-1); \r\n    dummy -> next = head; \r\n\r\n    ListNode *pre; \r\n    pre = dummy; \r\n\r\n    while (head != NULL)\r\n    {\r\n      ListNode *pnext = head -> next; \r\n      if (head -> val == val)\r\n      {\r\n\t\r\n      }\r\n      else\r\n      {\r\n\tpre = head; \r\n      }\r\n      head = head -> next; \r\n    }\r\n    \r\n    return dummy -> next; \r\n  };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1236212822\"], \"head[0].val\": [\"1187442134\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1412456016\"], \"head[1].val\": [\"1684666100\"], \"head[1].next\": [1], \"head[1].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head1_next0_x\": [\"113531913\"], \"head[1].next[0].val\": [\"-931554971\"], \"val\": [\"-1969063660\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPrimes. /*FC*/class Solution {\n/*FM*/int countPrimes(int n) {\r\n    vector<bool> isPrime(n, true); \r\n    int ret = 0; \r\n\r\n    for (int i = 2;  i * i <= n;  i ++)\r\n    {\r\n      if (isPrime[i])\r\n      {\r\n\tfor (int j = i * i;  j <= n;  j += i)\r\n\t{\r\n\t  isPrime[j] = false; \r\n\t}\r\n      }\t\r\n    }\r\n\r\n    for (int i = 2;  i < n;  i ++)\r\n    {\r\n      if (isPrime[i])\r\n      {\r\n\tret ++; \r\n      }\r\n    }\r\n    \r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isIsomorphic. /*FC*/class Solution {\n/*FM*/bool isIsomorphic(string s, string t) {\r\n    unordered_map<char, char> umap1; \r\n    unordered_map<char, char> umap2; \r\n\r\n    for (int i = 0;  i < s.size();  i ++)\r\n    {\r\n      if (umap1.find(s[i]) != umap1.end() && umap1[s[i]] != t[i])\r\n      {\r\n\t\r\n      }\r\n      if (umap2.find(t[i]) != umap2.end() && umap2[t[i]] != s[i])\r\n      {\r\n\t\r\n      }\r\n      umap1[s[i]] = t[i]; \r\n      umap2[t[i]] = s[i]; \r\n    }\r\n    return true; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList. /*FC*/class Solution {\n/*FM*/ListNode* reverseList(ListNode* head) {\r\n    if (head == NULL || head -> next == NULL)\r\n    {\r\n      \r\n    }\r\n\r\n    ListNode *prev = NULL; \r\n    while (head != NULL)\r\n    {\r\n      ListNode *next = head -> next; \r\n      head -> next = prev; \r\n      prev = head; \r\n      head = next; \r\n    }\r\n    return prev; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"745291304\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-548418974\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution {\n/*FM*/bool isAnagram(string s, string t) {\r\n    unordered_map<char, int> umap; \r\n\r\n    for (auto i : s)\r\n    {\r\n      umap[i] ++; \r\n    }\r\n\r\n    for (auto j : t)\r\n    {\r\n      if (umap.find(j) != umap.end())\r\n      {\r\n\t\r\n      }\r\n      else\r\n      {\r\n\treturn false; \r\n      }\r\n    }\r\n\r\n    \r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"t\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> binaryTreePaths. /*FC*/class Solution {\n/*FM*/vector<string> binaryTreePaths(TreeNode* root) {\r\n    vector<string> ret; \r\n    if (root != NULL)\r\n    {\r\n      dfs(root, \"\", ret); \r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/void dfs(TreeNode *root, string str, vector<string> &ret)\r\n  {\r\n    if (root == NULL)\r\n    {\r\n      return; \r\n    }\r\n    if (str == \"\")\r\n    {\r\n      str = to_string(root -> val); \r\n    }\r\n    else\r\n    {\r\n      str = str + \"->\" + to_string(root -> val); \r\n    }\r\n\r\n    if (root -> left == NULL && root -> right == NULL)\r\n    {\r\n      ret.push_back(str); \r\n    }\r\n\r\n    dfs(root -> left, str, ret); \r\n    dfs(root -> right, str, ret); \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1174610913\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1921597838\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int addDigits. /*FC*/class Solution {\n/*FM*/int addDigits(int num) {\r\n    while (num >= 10)\r\n    {\r\n      int sum = 0; \r\n      while (num)\r\n      {\r\n\tsum += num % 10; \r\n\tnum /= 10; \r\n      }\r\n      num = sum; \r\n    }\r\n    return num; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void moveZeroes. /*FC*/class Solution {\n/*FM*/void moveZeroes(vector<int>& nums) {\r\n    int n = nums.size(); \r\n\r\n    int j = 0; \r\n    for (int i = 0;  i < n;  i ++)\r\n    {\r\n      if (nums[i] != 0)\r\n      {\r\n        nums[j ++] = nums[i]; \r\n      }\r\n    }\r\n\r\n    for (;  j < n;  )\r\n    {\r\n      \r\n    }\r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1816159061\"], \"nums_element1\": [\"431167576\"], \"nums_element2\": [\"-367897383\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseString. /*FC*/class Solution {\n/*FM*/string reverseString(string s) {\r\n    int i = 0, j = s.size() - 1; \r\n\r\n    while (i < j)\r\n    {\r\n      \r\n      \r\n      \r\n      \r\n      \r\n    }\r\n    return s; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> intersection. /*FC*/class Solution {\n/*FM*/vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\r\n    vector<int> ret; \r\n\r\n    unordered_map<int, int> umap; \r\n\r\n    for (auto i : nums1)\r\n    {\r\n      umap[i] ++; \r\n    }\r\n\r\n    for (auto j : nums2)\r\n    {\r\n      if (umap.find(j) != umap.end())\r\n      {\r\n\t\r\n\t\r\n      }\r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [3], \"nums1_element0\": [\"-1315047446\"], \"nums1_element1\": [\"-572402464\"], \"nums1_element2\": [\"250083204\"], \"nums2\": [1], \"nums2_element0\": [\"1389718735\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> intersect. /*FC*/class Solution {\n/*FM*/vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\r\n    vector<int> ret; \r\n    unordered_map<int, int> umap; \r\n    \r\n    for (auto i : nums1)\r\n    {\r\n      umap[i] ++; \r\n    }\r\n\r\n    for (auto j : nums2)\r\n    {\r\n      if (umap.find(j) != umap.end() && umap[j] > 0)\r\n      {\r\n\t\r\n\t\r\n      }\r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"-1836456153\"], \"nums1_element1\": [\"42908416\"], \"nums2\": [3], \"nums2_element0\": [\"-1964900787\"], \"nums2_element1\": [\"-760196868\"], \"nums2_element2\": [\"-1180818826\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char findTheDifference. /*FC*/class Solution {\n/*FM*/char findTheDifference(string s, string t) {\r\n    unordered_map<int, int> umap; \r\n    char ret; \r\n    \r\n    for (auto i : s)\r\n    {\r\n      umap[i] ++; \r\n    }\r\n\r\n    for (auto j : t)\r\n    {\r\n      if (umap.find(j) != umap.end() && umap[j] > 0)\r\n      {\r\n\t\r\n      }\r\n      else\r\n      {\r\n\tret = j; \r\n\tbreak; \r\n      }\r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/class Solution {\n/*FM*/string convert(string s, int numRows) {\r\n    if (numRows == 1 || s.length() <= numRows)\r\n    {\r\n      return s; \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numRows\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n    \r\n    int i = 0; \r\n    int sign = 1; \r\n    unsigned long long result = 0; \r\n\r\n    while (str[i] == ' ')\r\n    {\r\n      i ++; \r\n    }\r\n\r\n    \r\n    if (str[i] != '+' && str[i] != '-' && !isdigit(str[i]))\r\n    {\r\n      return 0; \r\n    }\r\n\r\n    if (str[i] == '+')\r\n    {\r\n      \r\n      \r\n    }\r\n    else if (str[i] == '-')\r\n    {\r\n      \r\n      \r\n    }\r\n\r\n    \r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution {\n/*FM*/int maxArea(vector<int>& height) {\r\n    int max = 0, size = height.size(), area, distance, h, min; \r\n\r\n    int i = 0, j = size - 1; \r\n\r\n    while (i < j)\r\n    {\r\n      distance = j - i; \r\n      if (height[i] < height[j])\r\n      {\r\n\tmin = height[i]; \r\n\ti ++; \r\n      }\r\n      else\r\n      {\r\n\tmin = height[j]; \r\n\tj --; \r\n      }\r\n      area = distance = distance * min; \r\n      max = area > max ? area : max; \r\n    }\r\n    return max; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [3], \"height_element0\": [\"-1331207166\"], \"height_element1\": [\"876398027\"], \"height_element2\": [\"281168828\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int romanToInt. /*FC*/class Solution {\n/*FM*/int romanToInt(string s) {\r\n    unordered_map<char, int> umap; \r\n    umap.insert(make_pair('I', 1)); \r\n    umap.insert(make_pair('V', 5)); \r\n    umap.insert(make_pair('X', 10)); \r\n    umap.insert(make_pair('L', 50)); \r\n    umap.insert(make_pair('C', 100)); \r\n    umap.insert(make_pair('D', 500)); \r\n    umap.insert(make_pair('M', 1000)); \r\n\r\n    int output = 0, last = 0, current; \r\n    for (int i = 0;  i < s.length();  )\r\n    {\r\n      \r\n    }\r\n\r\n    return output; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution {\n/*FM*/string longestCommonPrefix(vector<string>& strs) {\r\n    if (strs.empty())\r\n    {\r\n      return \"\"; \r\n    }\r\n    \r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution {\n/*FM*/string longestCommonPrefix(vector<string>& strs) {\r\n    if (strs.empty())\r\n    {\r\n      \r\n    }\r\n    for (int i = 0;  i < strs[0].size();  )\r\n    {\r\n      for (int j = 0;  j < strs.size();  j ++)\r\n      {\r\n\tif (strs[j].size() < i + 1 || strs[j][i] != strs[0][i])\r\n\t{\r\n\t  return strs[0].substr(0, i); \r\n\t}  \r\n      }\t\r\n    }\r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [3], \"strs_element0\": [\"3\"], \"strs_element1\": [\"2\"], \"strs_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > threeSum(vector<int>& nums) {\r\n    vector<vector<int> > ret; \r\n    int n = nums.size(); \r\n\r\n    if (n < 3)\r\n    {\r\n      return ret; \r\n    }\r\n\r\n    \r\n    \r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1386279614\"], \"nums_element1\": [\"2147218046\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string multiply. /*FC*/class Solution {\n/*FM*/string multiply(string num1, string num2) {\r\n    string ret = \"\"; \r\n    int l1 = num1.size(); \r\n    int l2 = num2.size(); \r\n\r\n    vector<int> v1(l1); \r\n    vector<int> v2(l2); \r\n    vector<int> v3(l1 + l2); \r\n    if (num1 == \"0\" || num2 == \"0\")\r\n    {\r\n      \r\n    }  \r\n    for (int i = 0;  i < l1;  i ++)\r\n    {\r\n      v1[l1 - i - 1] = num1[i] - '0'; \r\n    }\r\n\r\n    for (int j = 0;  j < l2;  j ++)\r\n    {\r\n      v2[l2 - j - 1] = num2[j] - '0'; \r\n    }\r\n\r\n    for (int i = 0;  i < l1;  i ++)\r\n    {\r\n      for (int j = 0;  j < l2;  j ++)\r\n      {\r\n\tv3[i + j] += v1[i] * v2[j]; \r\n\tif (v3[i + j] >= 10)\r\n\t{\r\n\t  v3[i + j + 1] += v3[i + j] / 10; \r\n\t  v3[i + j] %= 10; \r\n\t}  \r\n      }\r\n    }\r\n\r\n    for (int i = v3.size() - 1;  i >= 0;  i --)\r\n    {\r\n      if (i != v3.size() - 1 || (i == v3.size() - 1 && v3[i] != 0))\r\n      {\r\n        ret += v3[i] + '0'; \r\n      }\r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"1\"], \"num2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double myPow. /*FC*/class Solution {\n/*FM*/double myPow(double x, int n) {\r\n    long k = n; \r\n    if (k == 0)\r\n    {\r\n      \r\n    }\r\n\r\n    double ret = 1; \r\n    if (k < 0)\r\n    {\r\n      \r\n      \r\n    }\r\n\r\n    while (k > 0)\r\n    {\r\n      if (k % 2 == 1)\r\n      {\r\n\tret *= x; \r\n      }\r\n      x *= x; \r\n      k /= 2; \r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"0.8\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxSubArray. /*FC*/class Solution {\n/*FM*/int maxSubArray(vector<int>& nums) {\r\n    if (nums.size() == 0)\r\n    {\r\n      \r\n    }\r\n    int ret = nums[0]; \r\n\r\n    int largest = nums[0]; \r\n\r\n    for (int i = 1;  i < nums.size();  i ++)\r\n    {\r\n      if (largest > 0)\r\n      {\r\n        largest += nums[i]; \r\n      }\r\n      else\r\n      {\r\n\tlargest = nums[i]; \r\n      }\r\n      ret = max(ret, largest); \r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1696487056\"], \"nums_element1\": [\"2047617680\"], \"nums_element2\": [\"-588176366\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> spiralOrder. /*FC*/class Solution {\n/*FM*/vector<int> spiralOrder(vector<vector<int> >& matrix) {\r\n    vector<int> ret; \r\n\r\n    if (matrix.size() == 0)\r\n    {\r\n      \r\n    }\r\n\r\n    int rowBegin = 0, rowEnd = matrix.size() - 1; \r\n    int colBegin = 0, colEnd = matrix[0].size() - 1; \r\n\r\n    while (rowBegin <= rowEnd && colBegin <= colEnd)\r\n    {\r\n      for (int i = colBegin;  i <= colEnd;  i ++)\r\n      {\r\n\tret.push_back(matrix[rowBegin][i]); \r\n      }\r\n      rowBegin ++; \r\n\r\n      for (int i = rowBegin;  i <= rowEnd;  )\r\n      {\r\n\t\r\n      }\r\n      colEnd --; \r\n\r\n      if (rowBegin <= rowEnd)\r\n      {\r\n        \r\n        \r\n      }\r\n\r\n      if (colBegin <= colEnd)\r\n      {\r\n        for (int i = rowEnd;  i >= rowBegin;  )\r\n        {\r\n\t  \r\n        }\r\n        colBegin ++; \r\n      }\r\n    }\r\n\r\n    return ret; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"1404420131\"], \"matrix_element0_element1\": [\"-1119216242\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(string s) {\r\n    int ret = 0; \r\n    s = stripSpace(s); \r\n    int i = s.size(); \r\n    while (i > 0)\r\n    {\r\n      if (s[--i] != ' ')\r\n      {\r\n\tret ++; \r\n      }\r\n      else\r\n      {\r\n\t\r\n      }\r\n    }\r\n    return ret; \r\n  };/*F*//*C*//*M*/string stripSpace(string s)\r\n  {\r\n    int i = s.size() - 1; \r\n\r\n    while (i >= 0 && s[i] == ' ')\r\n    {\r\n      i --; \r\n    }\r\n    return s.substr(0, i + 1); \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string stripSpace. /*FC*/class Solution {\n/*FM*/string stripSpace(string s)\r\n  {\r\n    int i = s.size() - 1; \r\n\r\n    while (i >= 0 && s[i] == ' ')\r\n    {\r\n      \r\n    }\r\n    return s.substr(0, i + 1); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> inorderTraversal. /*FC*/class Solution\r {\n/*FM*/vector<int> inorderTraversal(TreeNode *root)\r\n    {\r\n        vector<TreeNode *> stack; \r\n        vector<int> v; \r\n\r\n        while (stack.size() > 0 || root != NULL)\r\n        {\r\n            if (root != NULL)\r\n            {\r\n                stack.push_back(root); \r\n                root = root->left; \r\n            }\r\n            else\r\n            {\r\n                if (stack.size() > 0)\r\n                {\r\n                    root = stack.back(); \r\n                    stack.pop_back(); \r\n                    v.push_back(root->val); \r\n                    root = root->right; \r\n                }\r\n            }\r\n        }\r\n        return v; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"930\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestPerimeter. /*FC*/class Solution {\n/*FM*/int largestPerimeter(vector < int > & nums) {\r\n\r\n      \n      sort(nums.begin(), nums.end()); \r\n\r\n      \n      for (int i = nums.size() - 3;  i >= 0;  ) {\r\n\r\n        \n        \r\n      }\r\n      return 0;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-701\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isBST. /*FC*/class Solution\r {\n/*FM*/bool isBST(TreeNode *root, long minValue = LONG_MIN, long maxValue = LONG_MAX)\r\n    {\r\n        \n        if (!root)\r\n            \r\n\r\n        \n        if (root->val > minValue && root->val < maxValue && isBST(root->left, minValue, root->val) && isBST(root->right, root->val, maxValue))\r\n            \r\n        else\r\n            return false; \r\n    };/*F*//*C*//*M*/bool isBST(TreeNode *root, long minValue = LONG_MIN, long maxValue = LONG_MAX)\r\n    {\r\n        \n        if (!root)\r\n            return true; \r\n\r\n        \n        if (root->val > minValue && root->val < maxValue && isBST(root->left, minValue, root->val) && isBST(root->right, root->val, maxValue))\r\n            return true; \r\n        else\r\n            return false; \r\n    } bool isBST(TreeNode *root, long minValue = LONG_MIN, long maxValue = LONG_MAX)\r\n    {\r\n        \n        if (!root)\r\n            return true; \r\n\r\n        \n        if (root->val > minValue && root->val < maxValue && isBST(root->left, minValue, root->val) && isBST(root->right, root->val, maxValue))\r\n            return true; \r\n        else\r\n            return false; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"171\"], \"root[0].val\": [\"-99\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[0].val\": [\"849\"], \"minValue\": [\"-1702227420\"], \"maxValue\": [\"2029220963\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\r\n      int a = x; \r\n      string str = to_string(a); \r\n      int n = str.length(); \r\n      string strrr = str; \r\n      for (int i = 0;  i < n / 2;  i++)\r\n        swap(str[i], str[n - i - 1]); \r\n      if (str == strrr)\r\n        \r\n      else\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"-300823626\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool helper. /*FC*/class Solution {\n/*FM*/bool helper(int len, string& s, ll po) {\r\n        unordered_set<ll> memo; \r\n        int l = 0; \r\n        \n        ll current_hash = 0; \r\n        for (int i = 0;  i < len;  ++i) {\r\n            current_hash = (current_hash * p) + s[i]; \r\n        }\r\n        memo.insert(current_hash); \r\n\r\n        \n        for (int i = len;  i < s_size;  ) {\r\n            \r\n            \r\n            \r\n\r\n            \r\n            \r\n        }\r\n        return false; \r\n    };/*F*/int s_size = 0;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"len\": [\"5\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(TreeNode * root) {\r\n      if (root == NULL) \r\n         return 0; \r\n      \r\n      int left = maxDepth(root -> left); \r\n      int right = maxDepth(root -> right); \r\n      \r\n      return max(left, right) + 1; \r\n    };/*F*//*C*//*M*/int maxDepth(TreeNode * root) {\r\n      if (root == NULL) \r\n         return 0; \r\n      \r\n      int left = maxDepth(root -> left); \r\n      int right = maxDepth(root -> right); \r\n      \r\n      return max(left, right) + 1; \r\n    } int maxDepth(TreeNode * root) {\r\n      if (root == NULL) \r\n         return 0; \r\n      \r\n      int left = maxDepth(root -> left); \r\n      int right = maxDepth(root -> right); \r\n      \r\n      return max(left, right) + 1; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-402\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-924\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\", \"TreeNode\"], \"root1_x\": [\"-698\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestSubsequence. /*FC*/class Solution {\n/*FM*/string smallestSubsequence(string s) {\r\n      vector < bool > vis(26, false);  \n      vector < int > lastOccurance(26, 1e5);  \n      for (int i = 0;  i < s.length();  i++) lastOccurance[s[i] - 'a'] = i; \r\n      stack < char > st;  \n      for (int i = 0;  i < s.length();  i++) {\r\n        char c = s[i]; \r\n        if (vis[c - 'a']) \r\n        if (st.size() == 0) { \n          st.push(c); \r\n          vis[c - 'a'] = true; \r\n          continue; \r\n        }\r\n\r\n        \r\n        \r\n        \r\n      }\r\n      string ans = \"\"; \r\n      while (st.size()) { \n        ans.push_back(st.top()); \r\n        st.pop(); \r\n      }\r\n      reverse(ans.begin(), ans.end());  \n      return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestCommonSubsequence. /*FC*/class Solution {\n/*FM*/int longestCommonSubsequence(string text1, string text2) {\r\n      int n = text1.length(), m = text2.length(); \r\n\r\n      \n\r\n      vector < vector < int >> dp(n + 1, vector < int > (m + 1, 0)); \r\n\r\n      \n      \n      for (int i = 0;  i <= m;  i++) dp[0][i] = 0; \r\n      for (int i = 0;  i <= n;  i++) dp[i][0] = 0; \r\n\r\n      \n      \n      for (int i = 1;  i <= n;  i++) {\r\n        for (int j = 1;  j <= m;  j++) {\r\n          if (text1[i - 1] == text2[j - 1]) \r\n          else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); \r\n        }\r\n      }\r\n      return dp[n][m]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"text1\": [\"1\"], \"text2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> criticalConnections. /*FC*/class Solution {\n/*FM*/vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\r\n        if(connections.size() == 1)  \n        return connections; \r\n        \r\n        for( : connections)  \n        {\r\n            \r\n            \r\n        }\r\n        \r\n        \n        \n        \n        \r\n        \r\n\r\n\r\n        \r\n        \r\n    };/*F*//*C*//*M*/void dfs(vector<int> &low,vector<int> &dist,vector<int> &parent,vector<int> adj[],vector<bool> &arti,int u)\r\n    {\r\n        static int time = 0;  \r\n        low[u] = dist[u] = time;  \n        time++; \r\n        int child = 0;  \n        for(auto v : adj[u])\r\n        {\r\n            if(dist[v] == -1)   \n            {\r\n                child++; \r\n                parent[v] = u; \r\n\r\n                dfs(low,dist,parent,adj,arti,v);     \n                low[u] = min(low[u],low[v]);     \n\r\n                if(parent[u] == -1 && child > 1)    \n                arti[u] = true; \r\n\r\n                if(parent[u] != -1 && low[v] >= dist[u]){   \n                    arti[u] = true; \r\n                }\r\n                if(low[v] > dist[u])    \n                res.push_back({u,v}); \r\n            }\r\n            else if(parent[u] != v)   \n            low[u] = min(low[u],dist[v]); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->res\": [1], \"AKA_INSTANCE___Solution_res_element0\": [1], \"AKA_INSTANCE___Solution_res_element0_element0\": [\"-536\"], \"n\": [\"6\"], \"connections\": [1], \"connections_element0\": [2], \"connections_element0_element0\": [\"-108\"], \"connections_element0_element1\": [\"408\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector < int > & prices) {\r\n      \n      \n\r\n      int n = prices.size(), s = 0; \r\n\r\n      for (int i = 1;  i < n;  i++) {\r\n        if (prices[i] > prices[i - 1])\r\n          s += prices[i] - prices[i - 1]; \r\n      }\r\n      return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"-463\"], \"prices_element1\": [\"970\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector < int > & prices) {\r\n      \n      \n\r\n      int n = prices.size(), s = 0; \r\n\r\n      for (int i = 1;  i < n;  i++) {\r\n        if (prices[i] > prices[i - 1])\r\n          \r\n      }\r\n      return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"734\"], \"prices_element1\": [\"-559\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int help. /*FC*/class Solution\r {\n/*FM*/int help(TreeNode *root)\r\n    {\r\n        if (!root)\r\n            return 0; \r\n        int left = max(0, help(root->left)); \r\n        int right = max(0, help(root->right)); \r\n        \r\n        sum = max(sum, left + right + root->val); \r\n        \r\n        return max(left, right) + root->val; \r\n    };/*F*/int sum;/*C*//*M*/int help(TreeNode *root)\r\n    {\r\n        if (!root)\r\n            return 0; \r\n        int left = max(0, help(root->left)); \r\n        int right = max(0, help(root->right)); \r\n        \r\n        sum = max(sum, left + right + root->val); \r\n        \r\n        return max(left, right) + root->val; \r\n    } int help(TreeNode *root)\r\n    {\r\n        if (!root)\r\n            return 0; \r\n        int left = max(0, help(root->left)); \r\n        int right = max(0, help(root->right)); \r\n        \r\n        sum = max(sum, left + right + root->val); \r\n        \r\n        return max(left, right) + root->val; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"-552\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[0].val\": [\"265\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].left[1].val\": [\"-662\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(int i, int j, vector<vector<int>> &grid, int n, int m) {\r\n        if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 1) {\r\n            return; \r\n        }\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/void dfs(int i, int j, vector<vector<int>> &grid, int n, int m) {\r\n        if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 1) {\r\n            return; \r\n        }\r\n        \r\n        grid[i][j] = 1; \r\n        dfs(i + 1, j, grid, n, m); \r\n        dfs(i, j + 1, grid, n, m); \r\n        dfs(i - 1, j, grid, n, m); \r\n        dfs(i, j - 1, grid, n, m); \r\n    } void dfs(int i, int j, vector<vector<int>> &grid, int n, int m) {\r\n        if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 1) {\r\n            return; \r\n        }\r\n        \r\n        grid[i][j] = 1; \r\n        dfs(i + 1, j, grid, n, m); \r\n        dfs(i, j + 1, grid, n, m); \r\n        dfs(i - 1, j, grid, n, m); \r\n        dfs(i, j - 1, grid, n, m); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"i\": [\"-257431824\"], \"j\": [\"-2060521489\"], \"grid\": [1], \"grid_element0\": [2], \"grid_element0_element0\": [\"884\"], \"grid_element0_element1\": [\"574\"], \"n\": [\"-606332476\"], \"m\": [\"534152853\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int ladderLength. /*FC*/class Solution {\n/*FM*/int ladderLength(string beginWord, string endWord, vector < string > & wordList) {\r\n      unordered_set < string > wordSet;  \n\r\n      bool isPresent = false;  \n\r\n      \n      for (string word: wordList) {\r\n        if (endWord.compare(word) == 0) \n        {\r\n          \r\n        }\r\n\r\n        wordSet.insert(word);  \n      }\r\n\r\n      if (isPresent == false) \n        return 0; \r\n\r\n       \n       \n\r\n       \n\r\n      \n      \r\n\r\n      \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"beginWord\": [\"1\"], \"endWord\": [\"1\"], \"wordList\": [1], \"wordList_element0\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution {\n/*FM*/string intToRoman(int n) {\r\n      string romans[] = {\r\n        \"M\",\r\n        \"CM\",\r\n        \"D\",\r\n        \"CD\",\r\n        \"C\",\r\n        \"XC\",\r\n        \"L\",\r\n        \"XL\",\r\n        \"X\",\r\n        \"IX\",\r\n        \"V\",\r\n        \"IV\",\r\n        \"I\"\r\n      }; \r\n      int nums[] = {\r\n        1000,\r\n        900,\r\n        500,\r\n        400,\r\n        100,\r\n        90,\r\n        50,\r\n        40,\r\n        10,\r\n        9,\r\n        5,\r\n        4,\r\n        1\r\n      }; \r\n      string ans = \"\"; \r\n      for (int i = 0;  i < 13;  ++i) {\r\n        while (n - nums[i] >= 0) {\r\n          ans = ans + romans[i]; \r\n          n = n - nums[i]; \r\n        }\r\n      }\r\n      return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string breakPalindrome. /*FC*/class Solution {\n/*FM*/string breakPalindrome(string palindrome) {\r\n\r\n      int n = palindrome.size(); \r\n\r\n      if (palindrome.size() <= 1) return \"\"; \r\n\r\n      \r\n\r\n      \r\n\r\n      \r\n\r\n      \n\r\n      \r\n\r\n      \r\n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"palindrome\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNumber. /*FC*/class Solution {\n/*FM*/int singleNumber(vector<int>& nums) {\r\n        int result = 0; \r\n\r\n        for(int i = 0;  i < nums.size();  i++){   \n\r\n            result ^= nums[i];       \n\r\n        }\r\n        return result;       \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"903\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int romanToInt. /*FC*/class Solution {\n/*FM*/int romanToInt(string s) {\r\n      int ans = 0, num = 0; \r\n      for (int i = s.size() - 1;  ~i;  i--) {\r\n        switch (s[i]) {\r\n        \r\n          \r\n          \r\n        \r\n          \r\n          \r\n        \r\n          \r\n          \r\n        \r\n          \r\n          \r\n        \r\n          \r\n          \r\n        \r\n          \r\n          \r\n        \r\n          \r\n          \r\n        }\r\n        if (4 * num < ans) \r\n        else ans += num; \r\n      }\r\n      return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasCycle. /*FC*/class Solution {\n/*FM*/bool hasCycle(ListNode * head) {\r\n      ListNode * h = head; \r\n      ListNode * p = head; \r\n\r\n      \n\r\n      bool collision = false; \r\n      while (h and h -> next) {\r\n        \r\n        \r\n\r\n        \n        \n\r\n        \r\n      }\r\n\r\n      return collision; \r\n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-635\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-573\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProduct. /*FC*/class Solution {\n/*FM*/int maxProduct(vector<int>& nums) \r\n    {\r\n        \n        if (nums.empty()) \r\n\t   \r\n\t\t\r\n        int best = INT_MIN; \r\n\t\r\n        \n        int maxProd = 1; \r\n        int minProd = 1; \r\n        \r\n        for (int n: nums) \r\n        {\r\n            if (n < 0) \r\n            {\r\n                \n                swap(maxProd, minProd); \r\n            }\r\n\t    \r\n            \n            \n            maxProd = max(maxProd * n, n); \r\n            minProd = min(minProd * n, n); \r\n\t    \r\n            \n            best = max(best, maxProd); \r\n        }\r\n        return best; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-829\"], \"nums_element1\": [\"243\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int fn. /*FC*/class Solution {\n/*FM*/int fn(int i, int j, vector < int > & cuts, vector < vector < int >> & dp) {\r\n      if (i > j)  \n      if (dp[i][j] != -1) return dp[i][j]; \r\n      \r\n\r\n      \n      \r\n      \r\n    };/*F*//*C*//*M*/int fn(int i, int j, vector < int > & cuts, vector < vector < int >> & dp) {\r\n      if (i > j) return 0;  \n      if (dp[i][j] != -1) return dp[i][j]; \r\n      int mini = 1e9; \r\n\r\n      \n      for (int ind = i;  ind <= j;  ind++) {\r\n        \n        int cost = cuts[j + 1] - cuts[i - 1] + fn(i, ind - 1, cuts, dp) + fn(ind + 1, j, cuts, dp);  \n\r\n        mini = min(mini, cost);  \n      }\r\n      return dp[i][j] = mini; \r\n    } int fn(int i, int j, vector < int > & cuts, vector < vector < int >> & dp) {\r\n      if (i > j) return 0;  \n      if (dp[i][j] != -1) return dp[i][j]; \r\n      int mini = 1e9; \r\n\r\n      \n      for (int ind = i;  ind <= j;  ind++) {\r\n        \n        int cost = cuts[j + 1] - cuts[i - 1] + fn(i, ind - 1, cuts, dp) + fn(ind + 1, j, cuts, dp);  \n\r\n        mini = min(mini, cost);  \n      }\r\n      return dp[i][j] = mini; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"i\": [\"0\"], \"j\": [\"3\"], \"cuts\": [1], \"cuts_element0\": [\"-907\"], \"dp\": [1], \"dp_element0\": [1], \"dp_element0_element0\": [\"546\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int fn. /*FC*/class Solution {\n/*FM*/int fn(int i, int j, vector < int > & cuts, vector < vector < int >> & dp) {\r\n      if (i > j) return 0;  \n      if (dp[i][j] != -1) \r\n      \r\n\r\n      \n      \r\n      \r\n    };/*F*//*C*//*M*/int fn(int i, int j, vector < int > & cuts, vector < vector < int >> & dp) {\r\n      if (i > j) return 0;  \n      if (dp[i][j] != -1) return dp[i][j]; \r\n      int mini = 1e9; \r\n\r\n      \n      for (int ind = i;  ind <= j;  ind++) {\r\n        \n        int cost = cuts[j + 1] - cuts[i - 1] + fn(i, ind - 1, cuts, dp) + fn(ind + 1, j, cuts, dp);  \n\r\n        mini = min(mini, cost);  \n      }\r\n      return dp[i][j] = mini; \r\n    } int fn(int i, int j, vector < int > & cuts, vector < vector < int >> & dp) {\r\n      if (i > j) return 0;  \n      if (dp[i][j] != -1) return dp[i][j]; \r\n      int mini = 1e9; \r\n\r\n      \n      for (int ind = i;  ind <= j;  ind++) {\r\n        \n        int cost = cuts[j + 1] - cuts[i - 1] + fn(i, ind - 1, cuts, dp) + fn(ind + 1, j, cuts, dp);  \n\r\n        mini = min(mini, cost);  \n      }\r\n      return dp[i][j] = mini; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"i\": [\"1\"], \"j\": [\"0\"], \"cuts\": [2], \"cuts_element0\": [\"53\"], \"cuts_element1\": [\"-218\"], \"dp\": [1], \"dp_element0\": [2], \"dp_element0_element0\": [\"-770\"], \"dp_element0_element1\": [\"63\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCost. /*FC*/class Solution {\n/*FM*/int minCost(string colors, vector < int > & neededTime) {\r\n      int n = colors.size(); \r\n      int ans = 0; \r\n      \n      for (int i = 0;  i < n;  i++) {\r\n        int j = i; \r\n        int sum = 0, ma = 0; \r\n        while (j < n && colors[j] == colors[i]) {\r\n          sum += neededTime[j]; \r\n          ma = max(ma, neededTime[j]); \r\n          j++; \r\n        }\r\n        j--; \r\n        \n        if (j - i + 1 >= 2) \r\n        i = j; \r\n      }\r\n      return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"colors\": [\"1\"], \"neededTime\": [1], \"neededTime_element0\": [\"-102\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int concatenatedBinary. /*FC*/class Solution {\n/*FM*/int concatenatedBinary(int n) {\r\n        long ans = 0, mod = 1e9+7, length = 0; \r\n        for (int i = 1;  i <= n;  ++i) {\r\n            \r\n            if ((i & (i - 1)) == 0) length++; \r\n            ans = ((ans << length) + i) % mod; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int threeSumClosest. /*FC*/class Solution {\n/*FM*/int threeSumClosest(vector<int>& nums, int target) {\r\n        sort(begin(nums), end(nums)); \r\n        int result = 0, min_diff = numeric_limits<int>::max(); \r\n        \n        for (int i = nums.size() - 1;  i >= 2;  ) {\r\n            \r\n             \n            \n            \r\n        }\r\n        return result;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"310\"], \"nums_element1\": [\"-639\"], \"target\": [\"35312901\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string maxValue. /*FC*/class Solution {\n/*FM*/string maxValue(string n, int x) {\r\n      int len = n.size() - 1; \r\n      int ans = len + 1; \r\n      if (n[0] == '-') {\r\n        \r\n      } else {\r\n        for (int i = len;  i >= 0;  --i) {\r\n          if (n[i] - '0' < x) \r\n        }\r\n      }\r\n      n.insert(n.begin() + ans, x + '0'); \r\n      return n; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1\"], \"x\": [\"-1536065000\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string maxValue. /*FC*/class Solution {\n/*FM*/string maxValue(string n, int x) {\r\n      int len = n.size() - 1; \r\n      int ans = len + 1; \r\n      if (n[0] == '-') {\r\n        \r\n      } else {\r\n        for (int i = len;  i >= 0;  --i) {\r\n          if (n[i] - '0' < x) ans = i; \r\n        }\r\n      }\r\n      n.insert(n.begin() + ans, x + '0'); \r\n      return n; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"], \"x\": [\"16126701\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> fourSum. /*FC*/class Solution\r {\n/*FM*/vector<vector<int>> fourSum(vector<int> &v, int t)\r\n    {\r\n        vector<vector<int>> ans; \r\n        int n = v.size(); \r\n        sort(v.begin(), v.end()); \r\n\r\n        for (int i = 0;  i < n;  i++)\r\n        {\r\n            for (int j = i + 1;  j < n;  j++)\r\n            {\r\n                long long req = (long long)t - (v[i] + v[j]); \r\n                int low = j + 1, high = n - 1; \r\n\r\n                while (low < high)\r\n                {\r\n                    \r\n                    \r\n                }\r\n\r\n                while (j + 1 < n && v[j] == v[j + 1])\r\n                    \r\n            }\r\n\r\n            while (i + 1 < n && v[i] == v[i + 1])\r\n                \r\n        }\r\n\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"v\": [2], \"v_element0\": [\"-620\"], \"v_element1\": [\"176\"], \"t\": [\"-1742005072\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSubIslands. /*FC*/class Solution {\n/*FM*/int countSubIslands(vector < vector < int >> & grid1, vector < vector < int >> & grid2) {\r\n    int n = grid2.size();  \n    int m = grid2[0].size();  \n    int count = 0; \r\n    for (int i = 0;  i < n;  i++) {\r\n      for (int j = 0;  j < m;  j++) {\r\n        if (grid2[i][j] == 1) {\r\n          \r\n          \r\n          \r\n        }\r\n      }\r\n    }\r\n    return count; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid1\": [2], \"grid1_element0\": [2], \"grid1_element0_element0\": [\"-751\"], \"grid1_element0_element1\": [\"957\"], \"grid1_element1\": [2], \"grid1_element1_element0\": [\"-901\"], \"grid1_element1_element1\": [\"570\"], \"grid2\": [2], \"grid2_element0\": [2], \"grid2_element0_element0\": [\"-322\"], \"grid2_element0_element1\": [\"-328\"], \"grid2_element1\": [1], \"grid2_element1_element0\": [\"744\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hammingWeight. /*FC*/class Solution {\n/*FM*/int hammingWeight(uint32_t n) {\r\n      int count = 0; \r\n      while (n > 0) {\r\n        \n        if (n & 1) {\r\n          count++; \r\n        }\r\n        \n        n = n >> 1; \r\n      }\r\n      return count; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector < int > canSeePersonsCount. /*FC*/class Solution {\n/*FM*/vector < int > canSeePersonsCount(vector < int > & heights) {\r\n      int n = heights.size(); \r\n      vector < int > res(n, 0); \r\n\r\n      stack < int > stk; \r\n\r\n      for (int i = n - 1;  i >= 0;  i--) {\r\n        int height = heights[i]; \r\n        int visible = 0; \r\n\r\n        while (!stk.empty() && height > stk.top()) {\r\n          \r\n          \r\n        }\r\n\r\n        if (!stk.empty()) {\r\n          visible += 1; \r\n        }\r\n        res[i] = visible; \r\n        stk.push(height); \r\n      }\r\n      return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"heights\": [2], \"heights_element0\": [\"-846\"], \"heights_element1\": [\"978\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector < int > canSeePersonsCount. /*FC*/class Solution {\n/*FM*/vector < int > canSeePersonsCount(vector < int > & heights) {\r\n      int n = heights.size(); \r\n      vector < int > res(n, 0); \r\n\r\n      stack < int > stk; \r\n\r\n      for (int i = n - 1;  i >= 0;  i--) {\r\n        int height = heights[i]; \r\n        int visible = 0; \r\n\r\n        while (!stk.empty() && height > stk.top()) {\r\n          visible += 1; \r\n          stk.pop(); \r\n        }\r\n\r\n        if (!stk.empty()) {\r\n          \r\n        }\r\n        res[i] = visible; \r\n        stk.push(height); \r\n      }\r\n      return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"heights\": [2], \"heights_element0\": [\"161\"], \"heights_element1\": [\"-435\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> twoSum. /*FC*/class Solution\r {\n/*FM*/vector<int> twoSum(vector<int> &nums, int target)\r\n    {\r\n        unordered_map<int, int> mp; \r\n        vector<int> ans; \r\n\r\n        for (int i = 0;  i < nums.size();  i++)\r\n        {\r\n            if (mp.find(target - nums[i]) != mp.end())\r\n            {\r\n                \r\n                \r\n                \r\n            }\r\n\r\n            mp[nums[i]] = i; \r\n        }\r\n\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-153\"], \"target\": [\"-1191090799\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n      stack < char > st; \r\n      bool ans = true; \r\n\r\n      for (int i = 0;  i < s.size();  i++) {\r\n        if (s[i] == '(' || s[i] == '[' || s[i] == '{') {\r\n          st.push(s[i]); \r\n        } else if (s[i] == ')') {\r\n          \r\n        } else if (s[i] == ']') {\r\n          \r\n        } else if (s[i] == '}') {\r\n          \r\n\r\n        }\r\n      }\r\n      if (!st.empty()) {\r\n        return false; \r\n      } else {\r\n        \r\n      }\r\n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n      stack < char > st; \r\n      bool ans = true; \r\n\r\n      for (int i = 0;  i < s.size();  i++) {\r\n        if (s[i] == '(' || s[i] == '[' || s[i] == '{') {\r\n          \r\n        } else if (s[i] == ')') {\r\n          \r\n        } else if (s[i] == ']') {\r\n          \r\n        } else if (s[i] == '}') {\r\n          \r\n\r\n        }\r\n      }\r\n      if (!st.empty()) {\r\n        \r\n      } else {\r\n        return true; \r\n      }\r\n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *mergeNodes. /*FC*/class Solution\r {\n/*FM*/ListNode *mergeNodes(ListNode *head)\r\n  {\r\n    ListNode *temp, *h = new ListNode;  \n    h = NULL;                           \n    int sum = 0;                        \n    while (head != NULL)\r\n    {\r\n      head = head->next; \r\n      if (head == 0)\r\n        continue;  \n      sum += head->val; \r\n      if (head->val == 0) \n      {\r\n         \n        \r\n      }\r\n    }\r\n    return temp; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].val\": [\"-912\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"521\"], \"head[0].next[0].val\": [\"779\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[1].val\": [\"775\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *mergeNodes. /*FC*/class Solution\r {\n/*FM*/ListNode *mergeNodes(ListNode *head)\r\n  {\r\n    ListNode *temp, *h = new ListNode;  \n    h = NULL;                           \n    int sum = 0;                        \n    while (head != NULL)\r\n    {\r\n      head = head->next; \r\n      if (head == 0)\r\n        continue;  \n      sum += head->val; \r\n      if (head->val == 0) \n      {\r\n        ListNode *ans = new ListNode;  \n        if (h == NULL)\r\n        {\r\n          ans->val = sum; \r\n          temp = ans; \r\n          h = ans; \r\n          sum = 0; \r\n        }\r\n        else \n        {\r\n          ans->val = sum; \r\n          h->next = ans; \r\n          h = ans; \r\n          sum = 0; \r\n        }\r\n      }\r\n    }\r\n    return temp; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[0].next\": [1], \"head[0].next[0].next[0]\": [\"ListNode\", \"ListNode()\"], \"head[0].next[0].next[0].val\": [\"0\"], \"head[0].next[0].next[0].next\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyDuplicate(vector<int>& nums, int k) {\r\n      \n        map<int, int> mp; \r\n      \n        for(int i = 0;  i < nums.size();  i++){\r\n          \n            if((mp.find(nums[i]) != mp.end()) && i - mp[nums[i]] <= k) \r\n              \r\n            mp[nums[i]] = i; \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-684\"], \"nums_element1\": [\"215\"], \"k\": [\"-479\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode * mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {\r\n      if (l1 == NULL) {\r\n        \r\n      }\r\n\r\n      if (l2 == NULL) {\r\n        \r\n      }\r\n\r\n      ListNode * head = NULL; \r\n\r\n      if (l1 -> val < l2 -> val) {\r\n        head = l1; \r\n        l1 = l1 -> next; \r\n      } else {\r\n        \r\n        \r\n      }\r\n\r\n      ListNode * p; \r\n      p = head; \r\n\r\n      while (l1 && l2) {\r\n        \r\n\r\n        \r\n      }\r\n\r\n      if (l1 != NULL) {\r\n        \r\n      } else {\r\n        p -> next = l2; \r\n      }\r\n\r\n      return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"-661\"], \"l1[0].val\": [\"-12\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode * mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {\r\n      if (l1 == NULL) {\r\n        \r\n      }\r\n\r\n      if (l2 == NULL) {\r\n        return l1; \r\n      }\r\n\r\n      \r\n\r\n      \r\n\r\n      \r\n      \r\n\r\n      \r\n\r\n      if (l1 != NULL) {\r\n        \r\n      } else {\r\n        \r\n      }\r\n\r\n      \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode()\"], \"l2\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode * mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {\r\n      if (l1 == NULL) {\r\n        \r\n      }\r\n\r\n      if (l2 == NULL) {\r\n        \r\n      }\r\n\r\n      ListNode * head = NULL; \r\n\r\n      if (l1 -> val < l2 -> val) {\r\n        \r\n        \r\n      } else {\r\n        head = l2; \r\n        l2 = l2 -> next; \r\n      }\r\n\r\n      ListNode * p; \r\n      p = head; \r\n\r\n      while (l1 && l2) {\r\n        if (l1 -> val < l2 -> val) {\r\n          \r\n          \r\n        } else {\r\n          p -> next = l2; \r\n          l2 = l2 -> next; \r\n        }\r\n\r\n        p = p -> next; \r\n      }\r\n\r\n      if (l1 != NULL) {\r\n        p -> next = l1; \r\n      } else {\r\n        \r\n      }\r\n\r\n      return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l2\": [2], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"928\"], \"l2[0].val\": [\"671\"], \"l2[0].next\": [1], \"l2[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_next0_x\": [\"56\"], \"l2[0].next[0].val\": [\"414\"], \"l2[1]\": [\"ListNode\", \"ListNode()\"], \"l2[1].val\": [\"-582\"], \"l2[1].next\": [1], \"l2[1].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"l21_next0_x\": [\"175\"], \"l2[1].next[0].val\": [\"172\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode * mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {\r\n      if (l1 == NULL) {\r\n        return l2; \r\n      }\r\n\r\n      if (l2 == NULL) {\r\n        \r\n      }\r\n\r\n      \r\n\r\n      \r\n\r\n      \r\n      \r\n\r\n      \r\n\r\n      if (l1 != NULL) {\r\n        \r\n      } else {\r\n        \r\n      }\r\n\r\n      \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [0], \"l2\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string removeDigit. /*FC*/class Solution {\n/*FM*/string removeDigit(string number, char digit) {\r\n        string res = \"\"; \r\n        for(int i = 0;  i < number.size();  i++){\r\n            if(number[i] == digit){\r\n                \r\n                \r\n            }\r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"number\": [\"11\"], \"digit\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void inorderSolve. /*FC*/class Solution\r {\n/*FM*/void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n          \n        \r\n           \n        \r\n        \r\n        \r\n          \n        \r\n        \n    };/*F*//*C*//*M*/void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n            result[1]= root->val;   \n            return; \r\n        }\r\n        \r\n        inorderSolve(root->right, k, result);   \n        \r\n        return; \n    } void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n            result[1]= root->val;   \n            return; \r\n        }\r\n        \r\n        inorderSolve(root->right, k, result);   \n        \r\n        return; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0], \"k\": [\"0\"], \"result\": [1]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void inorderSolve. /*FC*/class Solution\r {\n/*FM*/void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n           \n        \r\n        \r\n        \r\n          \n        \r\n        \n    };/*F*//*C*//*M*/void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n            result[1]= root->val;   \n            return; \r\n        }\r\n        \r\n        inorderSolve(root->right, k, result);   \n        \r\n        return; \n    } void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n            result[1]= root->val;   \n            return; \r\n        }\r\n        \r\n        inorderSolve(root->right, k, result);   \n        \r\n        return; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"674\"], \"result\": [2], \"result[0]\": [\"-553\"], \"result[1]\": [\"372\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void inorderSolve. /*FC*/class Solution\r {\n/*FM*/void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n            result[1]= root->val;   \n            return; \r\n        }\r\n        \r\n          \n        \r\n        \n    };/*F*//*C*//*M*/void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n            result[1]= root->val;   \n            return; \r\n        }\r\n        \r\n        inorderSolve(root->right, k, result);   \n        \r\n        return; \n    } void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n            result[1]= root->val;   \n            return; \r\n        }\r\n        \r\n        inorderSolve(root->right, k, result);   \n        \r\n        return; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"0\"], \"k\": [\"1\"], \"result\": [2], \"result[0]\": [\"0\"], \"result[1]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void inorderSolve. /*FC*/class Solution\r {\n/*FM*/void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n              \n            \r\n        }\r\n        \r\n        inorderSolve(root->right, k, result);   \n        \r\n        return; \n    };/*F*//*C*//*M*/void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n            result[1]= root->val;   \n            return; \r\n        }\r\n        \r\n        inorderSolve(root->right, k, result);   \n        \r\n        return; \n    } void inorderSolve(TreeNode* root, int k, int result[])\n    {\r\n        if(root == nullptr)  \n            return; \r\n        \r\n        inorderSolve(root->left, k, result);   \n        \r\n        result[0]= result[0] + 1;    \n        \r\n        if(result[0] == k)\r\n        {\r\n            \n            result[1]= root->val;   \n            return; \r\n        }\r\n        \r\n        inorderSolve(root->right, k, result);   \n        \r\n        return; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"k\": [\"0\"], \"result\": [1], \"result[0]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool check. /*FC*/class Solution {\n/*FM*/bool check(int idx, vector<int> &nums, vector<int> &dp){\r\n        \r\n\t\n        if((idx + 1) == 0) return true; \r\n        \r\n\t\n        if(dp[idx] != -1) \r\n\t\t\r\n\t\n        \r\n        \r\n\t\n        \r\n        \r\n        \r\n        \r\n\t\n        \r\n    };/*F*//*C*//*M*/bool check(int idx, vector<int> &nums, vector<int> &dp){\r\n        \r\n\t\n        if((idx + 1) == 0) return true; \r\n        \r\n\t\n        if(dp[idx] != -1) return dp[idx]; \r\n\t\t\r\n\t\n        bool ok = false; \r\n        \r\n\t\n        if(cond1(idx, nums)) ok |= check(idx - 2, nums, dp); \r\n        if(cond2(idx, nums)) ok |= check(idx - 3, nums, dp); \r\n        if(cond3(idx, nums)) ok |= check(idx - 3, nums, dp); \r\n        \r\n\t\n        return dp[idx] = ok; \r\n    } bool check(int idx, vector<int> &nums, vector<int> &dp){\r\n        \r\n\t\n        if((idx + 1) == 0) return true; \r\n        \r\n\t\n        if(dp[idx] != -1) return dp[idx]; \r\n\t\t\r\n\t\n        bool ok = false; \r\n        \r\n\t\n        if(cond1(idx, nums)) ok |= check(idx - 2, nums, dp); \r\n        if(cond2(idx, nums)) ok |= check(idx - 3, nums, dp); \r\n        if(cond3(idx, nums)) ok |= check(idx - 3, nums, dp); \r\n        \r\n\t\n        return dp[idx] = ok; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"idx\": [\"-1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool check. /*FC*/class Solution {\n/*FM*/bool check(int idx, vector<int> &nums, vector<int> &dp){\r\n        \r\n\t\n        if((idx + 1) == 0) \r\n        \r\n\t\n        if(dp[idx] != -1) return dp[idx]; \r\n\t\t\r\n\t\n        \r\n        \r\n\t\n        \r\n        \r\n        \r\n        \r\n\t\n        \r\n    };/*F*//*C*//*M*/bool check(int idx, vector<int> &nums, vector<int> &dp){\r\n        \r\n\t\n        if((idx + 1) == 0) return true; \r\n        \r\n\t\n        if(dp[idx] != -1) return dp[idx]; \r\n\t\t\r\n\t\n        bool ok = false; \r\n        \r\n\t\n        if(cond1(idx, nums)) ok |= check(idx - 2, nums, dp); \r\n        if(cond2(idx, nums)) ok |= check(idx - 3, nums, dp); \r\n        if(cond3(idx, nums)) ok |= check(idx - 3, nums, dp); \r\n        \r\n\t\n        return dp[idx] = ok; \r\n    } bool check(int idx, vector<int> &nums, vector<int> &dp){\r\n        \r\n\t\n        if((idx + 1) == 0) return true; \r\n        \r\n\t\n        if(dp[idx] != -1) return dp[idx]; \r\n\t\t\r\n\t\n        bool ok = false; \r\n        \r\n\t\n        if(cond1(idx, nums)) ok |= check(idx - 2, nums, dp); \r\n        if(cond2(idx, nums)) ok |= check(idx - 3, nums, dp); \r\n        if(cond3(idx, nums)) ok |= check(idx - 3, nums, dp); \r\n        \r\n\t\n        return dp[idx] = ok; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"idx\": [\"677\"], \"nums\": [1], \"nums_element0\": [\"552\"], \"dp\": [2], \"dp_element0\": [\"558\"], \"dp_element1\": [\"-501\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUgly. /*FC*/class Solution\r {\n/*FM*/bool isUgly(int n)\r\n    {\r\n        \n        if (n < 1)\r\n            \r\n\r\n        vector<int> divisors = {2, 3, 5}; \r\n\r\n        for (int i : divisors)\r\n        {\r\n            while (n % i == 0)\r\n                \r\n        }\r\n\r\n        return n == 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUgly. /*FC*/class Solution\r {\n/*FM*/bool isUgly(int n)\r\n    {\r\n        \n        if (n < 1)\r\n            return false; \r\n\r\n        \r\n\r\n        for ( : divisors)\r\n        {\r\n            \r\n        }\r\n\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUgly. /*FC*/class Solution\r {\n/*FM*/bool isUgly(int n)\r\n    {\r\n        \n        if (n < 1)\r\n            \r\n\r\n        vector<int> divisors = {2, 3, 5}; \r\n\r\n        for (int i : divisors)\r\n        {\r\n            while (n % i == 0)\r\n                n = n / i; \r\n        }\r\n\r\n        return n == 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector < int > & ct) {\r\n      sort(ct.begin(), ct.end());  \n\r\n      int res = 0; \r\n\r\n      for (int i = ct.size() - 1;  i >= 0;  ) \n      {\r\n        if (res >= ct[i]) \n          return res; \r\n        else \n          \r\n        \n      }\r\n\r\n       \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ct\": [1], \"ct_element0\": [\"-387\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector < int > & ct) {\r\n      sort(ct.begin(), ct.end());  \n\r\n      int res = 0; \r\n\r\n      for (int i = ct.size() - 1;  i >= 0;  ) \n      {\r\n        \r\n        \n      }\r\n\r\n      return res;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector < int > & ct) {\r\n      sort(ct.begin(), ct.end());  \n\r\n      int res = 0; \r\n\r\n      for (int i = ct.size() - 1;  i >= 0;  i--) \n      {\r\n        if (res >= ct[i]) \n          \r\n        else \n          res++; \r\n        \n      }\r\n\r\n      return res;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ct\": [1], \"ct_element0\": [\"200\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strStr. /*FC*/class Solution\r {\n/*FM*/int strStr(string haystack, string needle)\r\n    {\r\n        int m = haystack.size(), n = needle.size(); \r\n\r\n        \n        if (m < n)\r\n            \r\n\r\n        \n        for (int i = 0;  i < m - n + 1;  ++i)\r\n        {\r\n            \n            if (haystack[i] == needle[0])\r\n            {\r\n                \n                \r\n            }\r\n        }\r\n\r\n        \n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [\"1\"], \"needle\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strStr. /*FC*/class Solution\r {\n/*FM*/int strStr(string haystack, string needle)\r\n    {\r\n        int m = haystack.size(), n = needle.size(); \r\n\r\n        \n        if (m < n)\r\n            return -1; \r\n\r\n        \n        \r\n\r\n        \n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [\"1\"], \"needle\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string getHint. /*FC*/class Solution\r {\n/*FM*/string getHint(string secret, string guess)\r\n    {\r\n        int n = secret.size(); \r\n\r\n        \n        vector<int> v(10); \r\n        int bulls = 0, cows = 0; \r\n\r\n        \n        for (int i = 0;  i < n;  )\r\n        {\r\n            \n            \r\n        }\r\n\r\n        \n        return to_string(bulls) + 'A' + to_string(cows) + 'B'; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string getHint. /*FC*/class Solution\r {\n/*FM*/string getHint(string secret, string guess)\r\n    {\r\n        int n = secret.size(); \r\n\r\n        \n        vector<int> v(10); \r\n        int bulls = 0, cows = 0; \r\n\r\n        \n        for (int i = 0;  i < n;  ++i)\r\n        {\r\n            \n            if (secret[i] == guess[i])\r\n                \r\n\r\n            \n            else\r\n            {\r\n                \n                \n                if (v[secret[i] - '0']++ < 0)\r\n                    \r\n\r\n                \n                \n                if (v[guess[i] - '0']-- > 0)\r\n                    cows++; \r\n            }\r\n        }\r\n\r\n        \n        return to_string(bulls) + 'A' + to_string(cows) + 'B'; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"secret\": [\"2\"], \"guess\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string getHint. /*FC*/class Solution\r {\n/*FM*/string getHint(string secret, string guess)\r\n    {\r\n        int n = secret.size(); \r\n\r\n        \n        vector<int> v(10); \r\n        int bulls = 0, cows = 0; \r\n\r\n        \n        for (int i = 0;  i < n;  ++i)\r\n        {\r\n            \n            if (secret[i] == guess[i])\r\n                \r\n\r\n            \n            else\r\n            {\r\n                \n                \n                if (v[secret[i] - '0']++ < 0)\r\n                    \r\n\r\n                \n                \n                if (v[guess[i] - '0']-- > 0)\r\n                    \r\n            }\r\n        }\r\n\r\n        \n        return to_string(bulls) + 'A' + to_string(cows) + 'B'; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"secret\": [\"2\"], \"guess\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int solve. /*FC*/class Solution {\n/*FM*/int solve(vector < int > & nums, int i, int prev_i) {\r\n        if (i >= nums.size())\r\n            return 0; \r\n        if (dp[i][prev_i + 1] != -1)\r\n            \r\n        \r\n        f no previous element is chosen or current > nums[prev_i]\r\n        \r\n    };/*F*/vector < vector < int >> dp;/*C*//*M*/int solve(vector < int > & nums, int i, int prev_i) {\r\n        if (i >= nums.size())\r\n            return 0; \r\n        if (dp[i][prev_i + 1] != -1)\r\n            return dp[i][prev_i + 1]; \r\n        int take = 0, dontTake = solve(nums, i + 1, prev_i); \r\n        if (prev_i == -1 || nums[i] > nums[prev_i])\r\n            take = 1 + solve(nums, i + 1, i);  \n        return dp[i][prev_i + 1] = max(take, dontTake); \r\n    } int solve(vector < int > & nums, int i, int prev_i) {\r\n        if (i >= nums.size())\r\n            return 0; \r\n        if (dp[i][prev_i + 1] != -1)\r\n            return dp[i][prev_i + 1]; \r\n        int take = 0, dontTake = solve(nums, i + 1, prev_i); \r\n        if (prev_i == -1 || nums[i] > nums[prev_i])\r\n            take = 1 + solve(nums, i + 1, i);  \n        return dp[i][prev_i + 1] = max(take, dontTake); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"i\": [\"0\"], \"prev_i\": [\"-1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector <int> & nums) {\r\n      int n = nums.size(); \r\n      int k; \r\n\r\n      \n\r\n      for (k = n - 2;  k >= 0;  ) {\r\n        \r\n      }\r\n\r\n      int l; \r\n\r\n      \n\r\n      if (k < 0) {\r\n        reverse(nums.begin(), nums.end()); \r\n      } \r\n      \n      else {\r\n        \r\n\r\n        \n \r\n        \r\n\r\n        \n        \r\n        \r\n      }\r\n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector <int> & nums) {\r\n      int n = nums.size(); \r\n      int k; \r\n\r\n      \n\r\n      for (k = n - 2;  k >= 0;  ) {\r\n        if (nums[k] < nums[k + 1])\r\n          break; \r\n      }\r\n\r\n      int l; \r\n\r\n      \n\r\n      if (k < 0) {\r\n        \r\n      } \r\n      \n      else {\r\n        for (l = n - 1;  l >= 0;  ) {\r\n          if (nums[l] > nums[k])\r\n            break; \r\n        }\r\n\r\n        \n \r\n        swap(nums[k], nums[l]); \r\n\r\n        \n        \r\n        reverse(nums.begin() + k + 1, nums.end()); \r\n      }\r\n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-881\"], \"nums_element1\": [\"166\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector <int> & nums) {\r\n      int n = nums.size(); \r\n      int k; \r\n\r\n      \n\r\n      for (k = n - 2;  k >= 0;  k--) {\r\n        if (nums[k] < nums[k + 1])\r\n          \r\n      }\r\n\r\n      int l; \r\n\r\n      \n\r\n      if (k < 0) {\r\n        reverse(nums.begin(), nums.end()); \r\n      } \r\n      \n      else {\r\n        \r\n\r\n        \n \r\n        \r\n\r\n        \n        \r\n        \r\n      }\r\n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-638\"], \"nums_element1\": [\"-697\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfThree. /*FC*/class Solution {\n/*FM*/bool isPowerOfThree(int n) {\r\n        if(n <= 0)\r\n        {\r\n            return false; \r\n        }\r\n        \r\n        if(n == 1)\r\n        {\r\n            \r\n        }\r\n       \r\n        \r\n    };/*F*//*C*//*M*/bool isPowerOfThree(int n) {\r\n        if(n <= 0)\r\n        {\r\n            return false; \r\n        }\r\n        \r\n        if(n == 1)\r\n        {\r\n            return true; \r\n        }\r\n       \r\n        return (n % 3 == 0) && (isPowerOfThree(n/3)); \r\n    } bool isPowerOfThree(int n) {\r\n        if(n <= 0)\r\n        {\r\n            return false; \r\n        }\r\n        \r\n        if(n == 1)\r\n        {\r\n            return true; \r\n        }\r\n       \r\n        return (n % 3 == 0) && (isPowerOfThree(n/3)); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-538\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfThree. /*FC*/class Solution {\n/*FM*/bool isPowerOfThree(int n) {\r\n        if(n <= 0)\r\n        {\r\n            \r\n        }\r\n        \r\n        if(n == 1)\r\n        {\r\n            \r\n        }\r\n       \r\n        return (n % 3 == 0) && (isPowerOfThree(n/3)); \r\n    };/*F*//*C*//*M*/bool isPowerOfThree(int n) {\r\n        if(n <= 0)\r\n        {\r\n            return false; \r\n        }\r\n        \r\n        if(n == 1)\r\n        {\r\n            return true; \r\n        }\r\n       \r\n        return (n % 3 == 0) && (isPowerOfThree(n/3)); \r\n    } bool isPowerOfThree(int n) {\r\n        if(n <= 0)\r\n        {\r\n            return false; \r\n        }\r\n        \r\n        if(n == 1)\r\n        {\r\n            return true; \r\n        }\r\n       \r\n        return (n % 3 == 0) && (isPowerOfThree(n/3)); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"238\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfThree. /*FC*/class Solution {\n/*FM*/bool isPowerOfThree(int n) {\r\n        if(n <= 0)\r\n        {\r\n            \r\n        }\r\n        \r\n        if(n == 1)\r\n        {\r\n            return true; \r\n        }\r\n       \r\n        \r\n    };/*F*//*C*//*M*/bool isPowerOfThree(int n) {\r\n        if(n <= 0)\r\n        {\r\n            return false; \r\n        }\r\n        \r\n        if(n == 1)\r\n        {\r\n            return true; \r\n        }\r\n       \r\n        return (n % 3 == 0) && (isPowerOfThree(n/3)); \r\n    } bool isPowerOfThree(int n) {\r\n        if(n <= 0)\r\n        {\r\n            return false; \r\n        }\r\n        \r\n        if(n == 1)\r\n        {\r\n            return true; \r\n        }\r\n       \r\n        return (n % 3 == 0) && (isPowerOfThree(n/3)); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector < int > & nums, int target) {\r\n         int l = 0, r = nums.size() - 1; \r\n\r\n         while (l <= r) {\r\n\r\n            \n            int mid = (l + r) / 2; \r\n\r\n            if (target == nums[mid])\r\n               \r\n\r\n            \n            if (nums[mid] > nums[r]) {\r\n\r\n                 }\r\n\r\n            \n            else if (nums[mid] < nums[l]) {\r\n                 }\r\n\r\n            \n            else {\r\n\r\n               if (target < nums[mid])\r\n                  r = mid - 1; \r\n\r\n               else\r\n                  l = mid + 1; \r\n            }\r\n         }\r\n\r\n         return -1; \r\n      };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"237\"], \"nums_element1\": [\"999\"], \"target\": [\"797\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector < int > & nums, int target) {\r\n         int l = 0, r = nums.size() - 1; \r\n\r\n         while (l <= r) {\r\n\r\n            \n            int mid = (l + r) / 2; \r\n\r\n            if (target == nums[mid])\r\n               \r\n\r\n            \n            if (nums[mid] > nums[r]) {\r\n\r\n               if (target < nums[mid] && target >= nums[l])\r\n                  \r\n               else\r\n                  l = mid + 1; \r\n            }\r\n\r\n            \n            else if (nums[mid] < nums[l]) {\r\n                 }\r\n\r\n            \n            else {\r\n\r\n               if (target < nums[mid])\r\n                  \r\n\r\n               else\r\n                  l = mid + 1; \r\n            }\r\n         }\r\n\r\n         return -1; \r\n      };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-598\"], \"nums_element1\": [\"-973\"], \"target\": [\"419\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector < int > & nums, int target) {\r\n         int l = 0, r = nums.size() - 1; \r\n\r\n         while (l <= r) {\r\n\r\n            \n            \r\n\r\n            \r\n\r\n            \n            if (nums[mid] > nums[r]) {\r\n\r\n                 }\r\n\r\n            \n            else if (nums[mid] < nums[l]) {\r\n                 }\r\n\r\n            \n            else {\r\n\r\n               \r\n            }\r\n         }\r\n\r\n         return -1; \r\n      };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxEnvelopes. /*FC*/class Solution {\n/*FM*/int maxEnvelopes(vector < vector < int >> & envelopes) {\r\n\r\n      \n      \n\r\n      sort(envelopes.begin(), envelopes.end(), cmp); \r\n\r\n      \r\n\r\n      int n = envelopes.size(); \r\n      vector < int > ans; \r\n      ans.push_back(envelopes[0][1]); \r\n      for (int i = 1;  i < n;  i++) {\r\n        int v = ans.size(); \r\n        int s = 0, e = v - 1; \r\n        int k = v; \r\n        while (s <= e) {\r\n          int mid = s + (e - s) / 2; \r\n          if (ans[mid] >= envelopes[i][1]) {\r\n            k = mid; \r\n            e = mid - 1; \r\n          } else {\r\n            \r\n          }\r\n        }\r\n        \n        \n        if (k == v) {\r\n          \r\n        }\r\n        \n        else {\r\n          ans[k] = envelopes[i][1]; \r\n        }\r\n      }\r\n      return ans.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"envelopes\": [2], \"envelopes_element0\": [1], \"envelopes_element0_element0\": [\"-3\"], \"envelopes_element1\": [2], \"envelopes_element1_element0\": [\"56\"], \"envelopes_element1_element1\": [\"-590\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void solveSudoku. /*FC*/class Solution {\n/*FM*/void solveSudoku(vector < vector < char >> & board) {\r\n    if (sol(board)) \r\n  };/*F*//*C*//*M*/bool sol(vector < vector < char >> & board) {\r\n    for (int x = 0;  x < 9;  x++) {\r\n      for (int y = 0;  y < 9;  y++) {\r\n        \n        if (board[x][y] == '.') {\r\n          for (char i = '1';  i <= '9';  i++) {\r\n            \n            if (issafe(x, y, i, board)) {\r\n              board[x][y] = i; \r\n              if (sol(board)) return true; \r\n              else board[x][y] = '.'; \r\n            }\r\n          }\r\n          return false; \r\n        }\r\n      }\r\n    }\r\n    return true; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canConstruct. /*FC*/class Solution {\n/*FM*/bool canConstruct(string ransomNote, string magazine) \r\n    {\r\n        int n = ransomNote.length(); \r\n        int m = magazine.length(); \r\n        \r\n        if(n > m)\r\n        {\r\n                   \n        }\r\n        \r\n        map<char, int> m1;         \n        \r\n        for(int i = 0;  i < m;  )\r\n        {\r\n                  \n        }\r\n    \r\n        for(int i = 0;  i < n;  )\r\n        {\r\n            \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canConstruct. /*FC*/class Solution {\n/*FM*/bool canConstruct(string ransomNote, string magazine) \r\n    {\r\n        int n = ransomNote.length(); \r\n        int m = magazine.length(); \r\n        \r\n        if(n > m)\r\n        {\r\n                   \n        }\r\n        \r\n        map<char, int> m1;         \n        \r\n        for(int i = 0;  i < m;  i++)\r\n        {\r\n            m1[magazine[i]]++;       \n        }\r\n    \r\n        for(int i = 0;  i < n;  )\r\n        {\r\n            if(m1[ransomNote[i]] > 0)\r\n            {        \r\n                \n                \r\n            }\r\n            else\r\n            {\r\n                return false; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ransomNote\": [\"2\"], \"magazine\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canConstruct. /*FC*/class Solution {\n/*FM*/bool canConstruct(string ransomNote, string magazine) \r\n    {\r\n        int n = ransomNote.length(); \r\n        int m = magazine.length(); \r\n        \r\n        if(n > m)\r\n        {\r\n                   \n        }\r\n        \r\n        map<char, int> m1;         \n        \r\n        for(int i = 0;  i < m;  i++)\r\n        {\r\n            m1[magazine[i]]++;       \n        }\r\n    \r\n        for(int i = 0;  i < n;  i++)\r\n        {\r\n            if(m1[ransomNote[i]] > 0)\r\n            {        \r\n                \n                m1[ransomNote[i]]--; \r\n            }\r\n            else\r\n            {\r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ransomNote\": [\"2\"], \"magazine\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPartition. /*FC*/class Solution {\n/*FM*/bool canPartition(vector < int > & nums) {\r\n\r\n      int sum = 0; \r\n      for (auto x: nums) {\r\n        sum += x; \r\n      }\r\n      \n      if (sum % 2) return false; \r\n\r\n      \n      \r\n\r\n      \n      \r\n\r\n      \r\n       \n\r\n      \n      \r\n       \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"519\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int characterReplacement. /*FC*/class Solution {\n/*FM*/int characterReplacement(string s, int k) {\r\n        int n = s.length(); \r\n        int mcnt = 0; \r\n        int len = 0; \r\n        int ar[26] = {0}; \r\n        int win_start = 0; \r\n        for(int win_end = 0;  win_end<n;  )\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int characterReplacement. /*FC*/class Solution {\n/*FM*/int characterReplacement(string s, int k) {\r\n        int n = s.length(); \r\n        int mcnt = 0; \r\n        int len = 0; \r\n        int ar[26] = {0}; \r\n        int win_start = 0; \r\n        for(int win_end = 0;  win_end<n;  win_end++)\r\n        {\r\n            ar[s[win_end]-'A']++; \r\n            int x = ar[s[win_end]-'A']; \r\n            mcnt = max(mcnt, x); \r\n            \r\n            if(win_end - win_start - mcnt + 1 > k)\r\n            {\r\n                ar[s[win_start]-'A']--; \r\n                win_start++; \r\n            }\r\n            \r\n            len = max(len, win_end - win_start + 1); \r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"k\": [\"-434502728\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int characterReplacement. /*FC*/class Solution {\n/*FM*/int characterReplacement(string s, int k) {\r\n        int n = s.length(); \r\n        int mcnt = 0; \r\n        int len = 0; \r\n        int ar[26] = {0}; \r\n        int win_start = 0; \r\n        for(int win_end = 0;  win_end<n;  win_end++)\r\n        {\r\n            ar[s[win_end]-'A']++; \r\n            int x = ar[s[win_end]-'A']; \r\n            mcnt = max(mcnt, x); \r\n            \r\n            if(win_end - win_start - mcnt + 1 > k)\r\n            {\r\n                \r\n                \r\n            }\r\n            \r\n            len = max(len, win_end - win_start + 1); \r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"k\": [\"-1270769634\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isMatch. /*FC*/class Solution\r {\n/*FM*/bool isMatch(string s, string p)\r\n    {\r\n        int n1 = p.size(); \r\n        int n2 = s.size(); \r\n\r\n        vector<vector<bool>> dp(n1 + 1, vector<bool>(n2 + 1, false)); \r\n\r\n        \n        dp[0][0] = true; \r\n\r\n        \n        \n        for (int j = 1;  j < n2 + 1;  j++)\r\n            dp[0][j] = false; \r\n\r\n        \n        for (int i = 1;  i < n1 + 1;  i++)\r\n        {\r\n            bool flag = true; \r\n\r\n            for (int k = 1;  k <= i;  )\r\n            {\r\n                if (p[k - 1] != '*')\r\n                {\r\n                    flag = false; \r\n                    break; \r\n                }\r\n            }\r\n\r\n            dp[i][0] = flag; \r\n        }\r\n\r\n        for (int i = 1;  i < n1 + 1;  i++)\r\n        {\r\n            for (int j = 1;  j < n2 + 1;  j++)\r\n            {\r\n                if (p[i - 1] == s[j - 1] || p[i - 1] == '?')\r\n                    \r\n\r\n                else if (p[i - 1] == '*')\r\n                    \r\n\r\n                \n                else\r\n                    dp[i][j] = false; \r\n            }\r\n        }\r\n\r\n        return dp[n1][n2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"p\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isMatch. /*FC*/class Solution\r {\n/*FM*/bool isMatch(string s, string p)\r\n    {\r\n        int n1 = p.size(); \r\n        int n2 = s.size(); \r\n\r\n        vector<vector<bool>> dp(n1 + 1, vector<bool>(n2 + 1, false)); \r\n\r\n        \n        dp[0][0] = true; \r\n\r\n        \n        \n        for (int j = 1;  j < n2 + 1;  )\r\n            \r\n\r\n        \n        for (int i = 1;  i < n1 + 1;  )\r\n        {\r\n            \r\n\r\n            \r\n\r\n            \r\n        }\r\n\r\n        for (int i = 1;  i < n1 + 1;  )\r\n        {\r\n            \r\n        }\r\n\r\n        return dp[n1][n2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *FindMin. /*FC*/class Solution\r {\n/*FM*/TreeNode *FindMin(TreeNode *root)\r\n    {\r\n        while (root->left != NULL)\r\n            root = root->left; \r\n        return root; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-598\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1]\": [\"TreeNode\", \"TreeNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/class Solution {\n/*FM*/int jump(vector<int>& N) {\r\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0; \r\n        for (int i = 0;  next < len;  i++) {\r\n            if (i > curr) ans++, curr = next; \r\n            next = max(next, N[i] + i); \r\n        }; \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [2], \"N_element0\": [\"-208\"], \"N_element1\": [\"930\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int islandPerimeter. /*FC*/class Solution {\n/*FM*/int islandPerimeter(vector < vector < int >> & grid) {\r\n      int m = grid.size();  \n      int n = grid[0].size();  \n      int cnt = 0;  \n      \n      for (int i = 0;  i < m;  i++) {\r\n        for (int j = 0;  j < n;  j++) {\r\n          if (grid[i][j] == 1) {\r\n                                          }\r\n\r\n        }\r\n      }\r\n      return cnt; \r\n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"566\"], \"grid_element0_element1\": [\"851\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"803\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution\r {\n/*FM*/void rotate(vector<vector<int>> &matrix)\r\n    {\r\n        int n = matrix.size(); \r\n\r\n        for (int i = 0;  i < n;  )\r\n        {\r\n            \r\n        }\r\n\r\n        for (int row = 0;  row < n;  )\r\n        {\r\n            \r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution\r {\n/*FM*/void rotate(vector<vector<int>> &matrix)\r\n    {\r\n        int n = matrix.size(); \r\n\r\n        for (int i = 0;  i < n;  i++)\r\n        {\r\n            for (int j = 0;  j < n;  j++)\r\n            {\r\n                if (i < j)\r\n                {\r\n                    swap(matrix[i][j], matrix[j][i]); \r\n                }\r\n            }\r\n        }\r\n\r\n        for (int row = 0;  row < n;  row++)\r\n        {\r\n            int Start_Col = 0, End_Col = n - 1; \r\n            while (Start_Col < End_Col)\r\n            {\r\n                swap(matrix[row][Start_Col], matrix[row][End_Col]); \r\n                Start_Col++; \r\n                End_Col--; \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"-22\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"-285\"], \"matrix_element1_element1\": [\"-693\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkSubarraySum. /*FC*/class Solution {\n/*FM*/bool checkSubarraySum(vector < int > & nums, int k) {\r\n      \n      if (nums.size() < 2)\r\n        \r\n      \n      unordered_map < int, int > mp; \r\n      mp[0] = -1; \r\n      int runningSum = 0; \r\n      for (int i = 0;  i < nums.size();  i++) {\r\n        runningSum += nums[i]; \r\n        if (k != 0)\r\n          runningSum = runningSum % k; \r\n        \n        if (mp.find(runningSum) != mp.end()) {\r\n          \n          \r\n        } else {\r\n          \n          mp[runningSum] = i; \r\n        }\r\n      }\r\n      return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"345\"], \"nums_element1\": [\"-257\"], \"k\": [\"-849328852\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkSubarraySum. /*FC*/class Solution {\n/*FM*/bool checkSubarraySum(vector < int > & nums, int k) {\r\n      \n      if (nums.size() < 2)\r\n        return false; \r\n      \n      \r\n      \r\n      \r\n      \r\n      \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"564\"], \"k\": [\"1491046130\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxSubArray. /*FC*/class Solution {\n/*FM*/int maxSubArray(vector <int> &nums) {\r\n      int sum = 0, ans = INT_MIN; \r\n\r\n      \n      \n      \n\r\n      for (int i = 0;  i < nums.size();  i++) {\r\n        sum += nums[i]; \r\n        ans = max(ans, sum); \r\n\r\n        \n        \n        if (sum < 0)\r\n          sum = 0; \r\n      }\r\n\r\n      \n      return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"352\"], \"nums_element1\": [\"-360\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(vector < vector < int >> & isConnected, int i, vector < int > & visited, int n) {\r\n    visited[i] = 1; \r\n    for (int k = 0;  k < n;  ) {\r\n      \r\n    }\r\n    return; \r\n  };/*F*//*C*//*M*/void dfs(vector < vector < int >> & isConnected, int i, vector < int > & visited, int n) {\r\n    visited[i] = 1; \r\n    for (int k = 0;  k < n;  k++) {\r\n      if (isConnected[i][k] == 1 && visited[k] == 0) {\r\n        dfs(isConnected, k, visited, n); \r\n      }\r\n    }\r\n    return; \r\n  } void dfs(vector < vector < int >> & isConnected, int i, vector < int > & visited, int n) {\r\n    visited[i] = 1; \r\n    for (int k = 0;  k < n;  k++) {\r\n      if (isConnected[i][k] == 1 && visited[k] == 0) {\r\n        dfs(isConnected, k, visited, n); \r\n      }\r\n    }\r\n    return; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"isConnected\": [2], \"isConnected_element0\": [2], \"isConnected_element0_element0\": [\"-698\"], \"isConnected_element0_element1\": [\"256\"], \"isConnected_element1\": [1], \"isConnected_element1_element0\": [\"929\"], \"i\": [\"720\"], \"visited\": [2], \"visited_element0\": [\"-395\"], \"visited_element1\": [\"913\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(vector < vector < int >> & isConnected, int i, vector < int > & visited, int n) {\r\n    visited[i] = 1; \r\n    for (int k = 0;  k < n;  ) {\r\n      if (isConnected[i][k] == 1 && visited[k] == 0) {\r\n        \r\n      }\r\n    }\r\n    \r\n  };/*F*//*C*//*M*/void dfs(vector < vector < int >> & isConnected, int i, vector < int > & visited, int n) {\r\n    visited[i] = 1; \r\n    for (int k = 0;  k < n;  k++) {\r\n      if (isConnected[i][k] == 1 && visited[k] == 0) {\r\n        dfs(isConnected, k, visited, n); \r\n      }\r\n    }\r\n    return; \r\n  } void dfs(vector < vector < int >> & isConnected, int i, vector < int > & visited, int n) {\r\n    visited[i] = 1; \r\n    for (int k = 0;  k < n;  k++) {\r\n      if (isConnected[i][k] == 1 && visited[k] == 0) {\r\n        dfs(isConnected, k, visited, n); \r\n      }\r\n    }\r\n    return; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"isConnected\": [2], \"isConnected_element0\": [2], \"isConnected_element0_element0\": [\"659\"], \"isConnected_element0_element1\": [\"113\"], \"isConnected_element1\": [1], \"isConnected_element1_element0\": [\"862\"], \"i\": [\"-318\"], \"visited\": [1], \"visited_element0\": [\"872\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findCircleNum. /*FC*/class Solution {\n/*FM*/int findCircleNum(vector < vector < int >> & isConnected) {\r\n      int n = isConnected.size(); \r\n      int ans = 0; \r\n      vector < int > visited(n, 0); \r\n\r\n      \n      for (int i = 0;  i < n;  ) {\r\n        \r\n      }\r\n      return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findCircleNum. /*FC*/class Solution {\n/*FM*/int findCircleNum(vector < vector < int >> & isConnected) {\r\n      int n = isConnected.size(); \r\n      int ans = 0; \r\n      vector < int > visited(n, 0); \r\n\r\n      \n      for (int i = 0;  i < n;  i++) {\r\n        for (int j = 0;  j < n;  j++) {\r\n\r\n          \n          \n\r\n          if (isConnected[i][j] == 1 && visited[i] == 0) {\r\n            \r\n             \n          }\r\n        }\r\n      }\r\n      return ans; \r\n    };/*F*//*C*//*M*/void dfs(vector < vector < int >> & isConnected, int i, vector < int > & visited, int n) {\r\n    visited[i] = 1; \r\n    for (int k = 0;  k < n;  k++) {\r\n      if (isConnected[i][k] == 1 && visited[k] == 0) {\r\n        dfs(isConnected, k, visited, n); \r\n      }\r\n    }\r\n    return; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"isConnected\": [2], \"isConnected_element0\": [2], \"isConnected_element0_element0\": [\"-480\"], \"isConnected_element0_element1\": [\"714\"], \"isConnected_element1\": [2], \"isConnected_element1_element0\": [\"492\"], \"isConnected_element1_element1\": [\"-272\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> spiralOrder. /*FC*/class Solution {\n/*FM*/vector<int> spiralOrder(vector<vector<int>>& matrix) {\r\n       vector<int> ans; \r\n        int row = matrix.size(); \r\n        int col = matrix[0].size(); \r\n\r\n        int count = 0; \r\n        int total = row*col; \r\n\r\n        \n        int startingRow = 0; \r\n        int startingCol = 0; \r\n        int endingRow = row-1; \r\n        int endingCol = col-1; \r\n\r\n\r\n        while(count < total) {\r\n\r\n            \n            for(int index = startingCol;  count < total && index<=endingCol;  index++) {\r\n                ans.push_back(matrix[startingRow][index]); \r\n                count++; \r\n            }\r\n            startingRow++; \r\n\r\n            \n            for(int index = startingRow;  count < total && index<=endingRow;  index++) {\r\n                ans.push_back(matrix[index][endingCol]); \r\n                count++; \r\n            }\r\n            endingCol--; \r\n\r\n            \n            for(int index = endingCol;  count < total && index>=startingCol;  index--) {\r\n                ans.push_back(matrix[endingRow][index]); \r\n                count++; \r\n            }\r\n            endingRow--; \r\n\r\n            \n            for(int index = endingRow;  count < total && index>=startingRow;  ) {\r\n                \r\n                \r\n            }\r\n            startingCol++; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"383\"], \"matrix_element0_element1\": [\"310\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"339\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> merge. /*FC*/class Solution {\n/*FM*/vector<vector<int>> merge(vector<vector<int>>& intervals) {\r\n        vector<vector<int>> v; \r\n        \r\n        sort(intervals.begin(), intervals.end(), cmp);    \n\r\n        for(int i = 0;  i < intervals.size();  ){\r\n            \r\n            \r\n               \n        }\r\n        \r\n        return v; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> merge. /*FC*/class Solution {\n/*FM*/vector<vector<int>> merge(vector<vector<int>>& intervals) {\r\n        vector<vector<int>> v; \r\n        \r\n        sort(intervals.begin(), intervals.end(), cmp);    \n\r\n        for(int i = 0;  i < intervals.size();  ++i){\r\n            vector<int> res = intervals[i]; \r\n            while(i + 1 < intervals.size() && intervals[i + 1][0] <= res[1]) {     \n                if(intervals[i + 1][1] > res[1]) {\r\n                             \n                }\r\n                 ++i; \r\n            }\r\n            v.push_back(res);    \n        }\r\n        \r\n        return v; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [2], \"intervals_element0_element0\": [\"262\"], \"intervals_element0_element1\": [\"57\"], \"intervals_element1\": [1], \"intervals_element1_element0\": [\"-601\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkfunc. /*FC*/class Solution {\n/*FM*/bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      return root == NULL; \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      \r\n    }\r\n    \r\n\r\n  };/*F*//*C*//*M*/bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      return subRoot == NULL; \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      return root == NULL; \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      return checkfunc(root -> left, subRoot -> left) && checkfunc(root -> right, subRoot -> right); \r\n    }\r\n    return false; \r\n\r\n  } bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      return subRoot == NULL; \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      return root == NULL; \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      return checkfunc(root -> left, subRoot -> left) && checkfunc(root -> right, subRoot -> right); \r\n    }\r\n    return false; \r\n\r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"subRoot\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkfunc. /*FC*/class Solution {\n/*FM*/bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      return subRoot == NULL; \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      return checkfunc(root -> left, subRoot -> left) && checkfunc(root -> right, subRoot -> right); \r\n    }\r\n    \r\n\r\n  };/*F*//*C*//*M*/bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      return subRoot == NULL; \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      return root == NULL; \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      return checkfunc(root -> left, subRoot -> left) && checkfunc(root -> right, subRoot -> right); \r\n    }\r\n    return false; \r\n\r\n  } bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      return subRoot == NULL; \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      return root == NULL; \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      return checkfunc(root -> left, subRoot -> left) && checkfunc(root -> right, subRoot -> right); \r\n    }\r\n    return false; \r\n\r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"0\"], \"root[0].left\": [0], \"root[0].right\": [0], \"subRoot\": [1], \"subRoot[0]\": [\"TreeNode\", \"TreeNode()\"], \"subRoot[0].val\": [\"0\"], \"subRoot[0].left\": [0], \"subRoot[0].right\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkfunc. /*FC*/class Solution {\n/*FM*/bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      \r\n    }\r\n    return false; \r\n\r\n  };/*F*//*C*//*M*/bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      return subRoot == NULL; \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      return root == NULL; \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      return checkfunc(root -> left, subRoot -> left) && checkfunc(root -> right, subRoot -> right); \r\n    }\r\n    return false; \r\n\r\n  } bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      return subRoot == NULL; \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      return root == NULL; \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      return checkfunc(root -> left, subRoot -> left) && checkfunc(root -> right, subRoot -> right); \r\n    }\r\n    return false; \r\n\r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubtree. /*FC*/class Solution {\n/*FM*/bool isSubtree(TreeNode * root, TreeNode * subRoot) {\r\n      \n      if (root == NULL) {\r\n        return subRoot == NULL; \r\n      }\r\n      \n      if (root -> val == subRoot -> val) {\r\n        \r\n      }\r\n      \n      return (isSubtree(root -> left, subRoot) || isSubtree(root -> right, subRoot)); \r\n\r\n    };/*F*//*C*//*M*/bool isSubtree(TreeNode * root, TreeNode * subRoot) {\r\n      \n      if (root == NULL) {\r\n        return subRoot == NULL; \r\n      }\r\n      \n      if (root -> val == subRoot -> val) {\r\n        if (checkfunc(root, subRoot)) return true; \r\n      }\r\n      \n      return (isSubtree(root -> left, subRoot) || isSubtree(root -> right, subRoot)); \r\n\r\n    } bool isSubtree(TreeNode * root, TreeNode * subRoot) {\r\n      \n      if (root == NULL) {\r\n        return subRoot == NULL; \r\n      }\r\n      \n      if (root -> val == subRoot -> val) {\r\n        if (checkfunc(root, subRoot)) return true; \r\n      }\r\n      \n      return (isSubtree(root -> left, subRoot) || isSubtree(root -> right, subRoot)); \r\n\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"261\"], \"root[0].val\": [\"355\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-393\"], \"root[0].left[0].val\": [\"556\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int,TreeNode*,TreeNode*)\"], \"root1_x\": [\"682\"], \"root1_left\": [2], \"root1_left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root1_left[0].val\": [\"655\"], \"root1_left[1]\": [\"TreeNode\", \"TreeNode()\"], \"root1_left[1].val\": [\"-761\"], \"root1_right\": [1], \"root1_right[0]\": [\"TreeNode\", \"TreeNode()\"], \"root1_right[0].val\": [\"-968\"], \"root[1].val\": [\"157\"], \"root[1].left\": [2], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1].left[0].val\": [\"655\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode()\"], \"root[1].left[1].val\": [\"-761\"], \"root[1].right\": [1], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[1].right[0].val\": [\"-968\"], \"subRoot\": [1], \"subRoot[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"subRoot0_x\": [\"-455\"], \"subRoot[0].val\": [\"-602\"], \"subRoot[0].right\": [1], \"subRoot[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"subRoot0_right0_x\": [\"-851\"], \"subRoot[0].right[0].val\": [\"407\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubtree. /*FC*/class Solution {\n/*FM*/bool isSubtree(TreeNode * root, TreeNode * subRoot) {\r\n      \n      if (root == NULL) {\r\n        \r\n      }\r\n      \n      if (root -> val == subRoot -> val) {\r\n        if (checkfunc(root, subRoot)) return true; \r\n      }\r\n      \n      \r\n\r\n    };/*F*//*C*//*M*/bool checkfunc(TreeNode * root, TreeNode * subRoot) {\r\n    \n    if (root == NULL) {\r\n      return subRoot == NULL; \r\n    }\r\n    \n    if (subRoot == NULL) {\r\n      return root == NULL; \r\n    }\r\n    \n    if (root -> val == subRoot -> val) {\r\n      return checkfunc(root -> left, subRoot -> left) && checkfunc(root -> right, subRoot -> right); \r\n    }\r\n    return false; \r\n\r\n  } bool isSubtree(TreeNode * root, TreeNode * subRoot) {\r\n      \n      if (root == NULL) {\r\n        return subRoot == NULL; \r\n      }\r\n      \n      if (root -> val == subRoot -> val) {\r\n        if (checkfunc(root, subRoot)) return true; \r\n      }\r\n      \n      return (isSubtree(root -> left, subRoot) || isSubtree(root -> right, subRoot)); \r\n\r\n    } bool isSubtree(TreeNode * root, TreeNode * subRoot) {\r\n      \n      if (root == NULL) {\r\n        return subRoot == NULL; \r\n      }\r\n      \n      if (root -> val == subRoot -> val) {\r\n        if (checkfunc(root, subRoot)) return true; \r\n      }\r\n      \n      return (isSubtree(root -> left, subRoot) || isSubtree(root -> right, subRoot)); \r\n\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode()\"], \"root[0].val\": [\"0\"], \"subRoot\": [1], \"subRoot[0]\": [\"TreeNode\", \"TreeNode()\"], \"subRoot[0].val\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\r\n      int n = s.size(); \r\n      vector < vector < int >> lps(n, vector < int > (n, 0)); \r\n\r\n      int start = 0, len = 1; \r\n\r\n      for (int i = 0;  i < n;  i++)\r\n        lps[i][i] = 1; \r\n\r\n      for (int i = 0;  i < n - 1;  ) {\r\n        \r\n      }\r\n\r\n      for (int k = 3;  k <= n;  ) {\r\n        \r\n      }\r\n\r\n      string res = \"\"; \r\n      for (int i = start;  i < start + len;  i++)\r\n        res += s[i]; \r\n\r\n      return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool enQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool enQueue(int value) {\r\n    if (isFull()) \r\n    que[(front + cnt++) % que.size()] = value; \r\n    return true; \r\n  };/*F*/vector < int > que;/*C*/MyCircularQueue(int k): que(k) { };/*M*/bool isFull() {\r\n    return que.size() == cnt; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"204\"], \"value\": [\"623245708\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool deQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool deQueue() {\r\n    if (isEmpty()) return false; \r\n    \r\n    \r\n    \r\n  };/*F*//*C*/MyCircularQueue(int k): que(k) { };/*M*/bool isEmpty() {\r\n    return !cnt; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"954\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int Front. /*FC*/class MyCircularQueue {\n/*FM*/int Front() {\r\n    if (isEmpty()) return -1; \r\n    \r\n  };/*F*//*C*/MyCircularQueue(int k): que(k) { };/*M*/bool isEmpty() {\r\n    return !cnt; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"482\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int Rear. /*FC*/class MyCircularQueue {\n/*FM*/int Rear() {\r\n    if (isEmpty()) return -1; \r\n    \r\n  };/*F*//*C*/MyCircularQueue(int k): que(k) { };/*M*/bool isEmpty() {\r\n    return !cnt; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"732\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *addOneRow. /*FC*/class Solution\r {\n/*FM*/TreeNode *addOneRow(TreeNode *root, int val, int depth)\r\n    {\r\n        if (depth == 1) \n        {\r\n            \r\n            \r\n             \n        }\r\n\r\n        queue<TreeNode *> q;  \n        q.push(root);         \n        int count = 0;        \n\r\n        \n        while (!q.empty())\r\n        {\r\n            \n            \n            int n = q.size(); \r\n\r\n            count++;  \n            while (n--)\r\n            {\r\n                TreeNode *curr = q.front();  \n                q.pop();                     \n\r\n                \n                \n                if (count != depth - 1)\r\n                {\r\n                    if (curr->left)\r\n                        \r\n                    if (curr->right)\r\n                        \r\n                }\r\n                else \n                {\r\n                    \n                    \r\n                    \n                    \r\n                    \n                    \r\n\r\n                    \n                    \r\n                    \n                    \r\n                    \n                    \r\n                }\r\n            }\r\n        }\r\n\r\n        return root;  \n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(nullptr), right(nullptr) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-937\"], \"root[0].val\": [\"1681002654\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"17\"], \"root[1].val\": [\"-1589208988\"], \"val\": [\"-281961280\"], \"depth\": [\"1822654979\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniquePaths. /*FC*/class Solution {\n/*FM*/int uniquePaths(int m, int n) {\r\n      int N = n + m - 2; \r\n      int r = m - 1; \r\n      double res = 1; \r\n\r\n      for (int i = 1;  i <= r;  i++) {\r\n        res = res * (N - r + i) / i; \r\n      }\r\n\r\n      return (int) res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"10\"], \"n\": [\"1728846016\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int scheduleCourse. /*FC*/class Solution {\n/*FM*/int scheduleCourse(vector<vector<int>>& courses) {\r\n        \n        sort(courses.begin(), courses.end(), [&](vector<int>& a, vector<int>& b){return a[1] < b[1]; }); \r\n        \r\n        \n        priority_queue<int> pq; \r\n        int time = 0;  \n        \r\n        for(int i = 0;  i < courses.size();  i++){\r\n\r\n            \n            time += courses[i][0]; \r\n            pq.push(courses[i][0]); \r\n            \r\n            \n            \n            if(time > courses[i][1]){\r\n                time -= pq.top(); \r\n                pq.pop(); \r\n            }\r\n        }\r\n        \r\n        \n        return pq.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"courses\": [2], \"courses_element0\": [1], \"courses_element0_element0\": [\"344\"], \"courses_element1\": [2], \"courses_element1_element0\": [\"682\"], \"courses_element1_element1\": [\"339\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>>& matrix, int target) \r\n    {\r\n       \n       \n       int m = matrix.size(); \t\r\n       int n = matrix[0].size(); \r\n       \n       int row = 0, col = n-1; \r\n       \n       while(row < m && col >= 0)\r\n       {\r\n         \n         if(matrix[row][col] == target)\r\n             \r\n\t \n         if(matrix[row][col] > target)\r\n\t     col--; \r\n\t \n         else\r\n             \r\n       }\r\n       \n       return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-603\"], \"matrix_element0_element1\": [\"899\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"823\"], \"matrix_element1_element1\": [\"106\"], \"target\": [\"-1432196290\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>>& matrix, int target) \r\n    {\r\n       \n       \n       int m = matrix.size(); \t\r\n       int n = matrix[0].size(); \r\n       \n       int row = 0, col = n-1; \r\n       \n       while(row < m && col >= 0)\r\n       {\r\n         \n         if(matrix[row][col] == target)\r\n             \r\n\t \n         if(matrix[row][col] > target)\r\n\t     \r\n\t \n         else\r\n             row++; \r\n       }\r\n       \n       return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"-587\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"-314\"], \"matrix_element1_element1\": [\"-839\"], \"target\": [\"1708926309\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numTilings. /*FC*/class Solution {\n/*FM*/int numTilings(int n) {\r\n      int mod = 1e9 + 7; \r\n      vector < long long > dp(1001, 0); \r\n      dp[1] = 1;  \n      dp[2] = 2; \r\n      dp[3] = 5; \r\n      if (n <= 3) \r\n      for (int i = 4;  i <= n;  i++) {\r\n        dp[i] = dp[i - 1] + dp[i - 1] + dp[i - 3];  \n        dp[i] %= mod;  \n      }\r\n      return dp[n];  \n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numTilings. /*FC*/class Solution {\n/*FM*/int numTilings(int n) {\r\n      int mod = 1e9 + 7; \r\n      vector < long long > dp(1001, 0); \r\n      dp[1] = 1;  \n      dp[2] = 2; \r\n      dp[3] = 5; \r\n      if (n <= 3) return dp[n]; \r\n      \r\n       \n\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniqueLetterString. /*FC*/class Solution {\n/*FM*/int uniqueLetterString(string s) {\r\n\r\n      vector < vector < int >> arr(26, vector < int > ());  \n      for (int i = 0;  i < s.length();  i++) {\r\n        char c = s[i]; \r\n        arr[c - 'A'].push_back(i); \r\n      }\r\n\r\n      int ans = 0; \r\n      for (auto & v: arr) {\r\n        for (int i = 0;  i < v.size();  ) { \n          \r\n          \r\n           \n           \n           \n        }\r\n      }\r\n      return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode * deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode * deleteDuplicates(ListNode * head) {\r\n      ListNode * ptr = head; \r\n      if (head == nullptr) {\r\n        \r\n      }\r\n      while (ptr -> next != nullptr) {\r\n        \r\n      }\r\n      return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"120\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestRectangleArea. /*FC*/class Solution {\n/*FM*/int largestRectangleArea(vector < int > & heights) {\r\n\r\n      \n      stack < pair < int, int >> stk; \r\n      int result = 0; \r\n\r\n      \n      for (int i = 0;  i < heights.size();  i++) {\r\n        int start = i; \r\n        while (!stk.empty() && stk.top().second > heights[i]) {\r\n          int index = stk.top().first; \r\n          int width = i - index; \r\n          int height = stk.top().second; \r\n          stk.pop(); \r\n\r\n          result = max(result, height * width); \r\n          start = index; \r\n        }\r\n        stk.push({\r\n          start,\r\n          heights[i]\r\n        }); \r\n      }\r\n\r\n      \n      while (!stk.empty()) {\r\n        int width = heights.size() - stk.top().first; \r\n        int height = stk.top().second; \r\n        stk.pop(); \r\n\r\n        result = max(result, height * width); \r\n      }\r\n\r\n      return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"heights\": [2], \"heights_element0\": [\"-290\"], \"heights_element1\": [\"-467\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int peakIndexInMountainArray. /*FC*/class Solution {\n/*FM*/int peakIndexInMountainArray(vector<int>& arr) {\r\n        \n        int s = 0; \r\n        int e = arr.size() - 1; \r\n        \r\n        int mid = s + (e - s) / 2; \r\n        \r\n        \n        while(s < e) {\r\n             \n            if(arr[mid] < arr[mid + 1]) {\r\n                \r\n            }\r\n            else {\r\n                e = mid; \r\n            }\r\n            mid = s + (e - s) / 2; \r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"773\"], \"arr_element1\": [\"621\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int peakIndexInMountainArray. /*FC*/class Solution {\n/*FM*/int peakIndexInMountainArray(vector<int>& arr) {\r\n        \n        int s = 0; \r\n        int e = arr.size() - 1; \r\n        \r\n        int mid = s + (e - s) / 2; \r\n        \r\n        \n        while(s < e) {\r\n             \n            if(arr[mid] < arr[mid + 1]) {\r\n                s = mid + 1; \r\n            }\r\n            else {\r\n                \r\n            }\r\n            mid = s + (e - s) / 2; \r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"-224\"], \"arr_element1\": [\"679\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void markParents. /*FC*/class Solution {\n/*FM*/void markParents(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &parent_track) {\r\n    \t\n        queue<TreeNode*> queue; \r\n        \n        queue.push(root); \r\n        while(!queue.empty()) { \r\n            \n            TreeNode* current = queue.front();  \r\n            queue.pop(); \r\n            \n            if(current->left) {\r\n                \r\n                \r\n            }\r\n            \n            if(current->right) {\r\n                \r\n                \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"212\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void markParents. /*FC*/class Solution {\n/*FM*/void markParents(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &parent_track) {\r\n    \t\n        queue<TreeNode*> queue; \r\n        \n        queue.push(root); \r\n        while(!queue.empty()) { \r\n            \n            TreeNode* current = queue.front();  \r\n            queue.pop(); \r\n            \n            if(current->left) {\r\n                parent_track[current->left] = current; \r\n                queue.push(current->left); \r\n            }\r\n            \n            if(current->right) {\r\n                parent_track[current->right] = current; \r\n                queue.push(current->right); \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string orderlyQueue. /*FC*/class Solution {\n/*FM*/string orderlyQueue(string s, int k) {\r\n      if (k == 1) {\r\n        \r\n        \r\n        \r\n      }\r\n      sort(s.begin(), s.end()); \r\n      return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"k\": [\"1172362598\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int majorityElement. /*FC*/class Solution {\n/*FM*/int majorityElement(vector<int>& nums) {\n        sort(nums.begin(), nums.end()); \n        int temp = 0, maxvalue = 0, ans = nums[0]; \n        for(int i = 1;  i < nums.size();  i++) {\n            if(nums[i - 1] == nums[i]) {\n                \n                \n            } else {\n                temp = 0; \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1791692399\"], \"nums_element1\": [\"-538308216\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int titleToNumber. /*FC*/class Solution {\n/*FM*/int titleToNumber(string s) {\n        int ans = 0; \n        for(int i = 0;  i < s.length();  i++) {\n              ans = ans*26 + s[i] - 'A' + 1; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int trailingZeroes. /*FC*/class Solution {\n/*FM*/int trailingZeroes(int n) {\n        int cnt = 0; \n        while(n != 0) {\n            cnt = cnt + n / 5; \n            n = n / 5; \n        }\n        return cnt; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string largestNumber. /*FC*/class Solution {\n/*FM*/string largestNumber(vector<int>& nums) {\n        string result = \"\"; \n        vector<string> arr(nums.size()); \n        for(int i = 0;  i < nums.size();  i++)\n            arr[i] = to_string(nums[i]); \n        auto cmp = [](string a, string b) {\n            return (a + b) > (b + a); \n        }; \n        sort(arr.begin(), arr.end(), cmp); \n       for(int i = 0;  i < arr.size();  i++)\n            result += arr[i]; \n        return result[0] == '0' ? \"0\" : result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-473031687\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution {\n/*FM*/void rotate(vector<int>& nums, int k) {\n        int n = nums.size(); \n        k = k % n; \n        for(int i = 0;  i <= (n - 1 - k) / 2;  i++) {\n            swap(nums[i], nums[n - 1 - k - i]); \n        }\n        for(int i = n - k;  i <= (n - 1 + n - k) / 2;  i++) {\n            swap(nums[i], nums[n - 1 + n - k - i]); \n        }\n        for(int i = 0;  i <= (n - 1) / 2;  i++) {\n            swap(nums[i], nums[n - 1 - i]); \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"661647431\"], \"nums_element1\": [\"807044784\"], \"nums_element2\": [\"1587246255\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method uint32_t reverseBits. /*FC*/class Solution {\n/*FM*/uint32_t reverseBits(uint32_t n) {\n        uint32_t ans = 0; \n        for(int i = 0;  i < 32;  i++) {\n            ans = ans * 2 + n % 2; \n            n = n / 2; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2708380164\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hammingWeight. /*FC*/class Solution {\n/*FM*/int hammingWeight(uint32_t n) {\n        int ans = 0; \n        while(n != 0) {\n            ans = ans + n % 2; \n            n = n / 2; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int>& nums) {\n        int n = nums.size(); \n        if(n == 0) {\n            \n        }\n        if(n == 1) {\n            return nums[0]; \n        }\n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1975855281\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int>& nums) {\n        int n = nums.size(); \n        if(n == 0) {\n            \n        }\n        if(n == 1) {\n            \n        }\n        vector<int> dp(n, 0); \n        dp[0] = nums[0]; \n        dp[1] = nums[0] > nums[1] ? nums[0] : nums[1]; \n        for(int i = 2;  i < n;  i++) {\n            int temp = dp[i - 2] + nums[i]; \n            dp[i] = temp > dp[i - 1] ? temp : dp[i - 1]; \n        }\n        return dp[n - 1]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-191226167\"], \"nums_element1\": [\"946568727\"], \"nums_element2\": [\"-1630065992\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> rightSideView. /*FC*/class Solution {\n/*FM*/vector<int> rightSideView(TreeNode* root) {\n        vector<int> v; \n        queue<TreeNode*> q; \n        if(root == NULL)\n            \n        q.push(root); \n        TreeNode* h; \n        while(!q.empty()) {\n            int size = q.size(); \n            while(size--) {\n                h = q.front(); \n                q.pop(); \n                if(h->left != NULL)\n                    \n                if(h->right != NULL)\n                    \n            }\n            v.push_back(h->val); \n        }\n        return v; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1340615929\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"579537017\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numIslands. /*FC*/class Solution {\n/*FM*/int numIslands(vector<vector<char>>& grid) {\n        if (grid.size() == 0) \n        n = grid.size(), m = grid[0].size(); \n        for (int x = 0;  x < n;  x++) {\n            for (int y = 0;  y < m;  y++) {\n                if (grid[x][y] == '1') {\n                    \n                    \n                }\n            }\n        }\n        return cnt; \n    };/*F*/int n;  int m;  int cnt = 0;  int arr[5] = {1, 0, -1, 0, 1};/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->arr\": [5], \"grid\": [2], \"grid_element0\": [1], \"grid_element0_element0\": [\"-17\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"124\"], \"grid_element1_element1\": [\"26\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNumber. /*FC*/class Solution {\n/*FM*/int singleNumber(int A[], int n) {\n        vector<int> bit(32, 0); \n\n        for (int i = 0;  i < n;  ++i)\n        {\n            int k = 1; \n            for (int j = 0;  j < 32;  ++j)\n            {\n                int rotated; \n                if ((rotated = A[i] >> j) == 0) break; \n                bit[j] += rotated & k; \n            }\n        }\n\n        int target = 0; \n        for (int i = 0;  i < 32;  ++i)\n        {\n            target += (bit[i] % 3 << i); \n        }\n        return target; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A[0]\": [\"-432366185\"], \"A[1]\": [\"-1695412366\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> singleNumber. /*FC*/class Solution {\n/*FM*/vector<int> singleNumber(vector<int>& nums) {\n        int length = nums.size(); \n        \n        \n        int xor_result = 0; \n        for(int i =0;  i< length;  i++) {\n            xor_result ^= nums[i]; \n        }\n        \n        \n        int first_one_index = 0; \n        for(first_one_index =0;  first_one_index< 32;  first_one_index++) {\n            if((xor_result>>first_one_index) & 1 == 1) {\n                break; \n            }\n        }\n        \n        \n        \n        int xor_twice = 0; \n        for(int i =0;  i< length;  i++) {\n            if((nums[i]>>first_one_index) & 1 == 1) {\n                xor_twice ^= nums[i]; \n            }\n        }\n        \n        \n        vector<int> result = {xor_twice, xor_result ^ xor_twice };         \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-959727466\"], \"nums_element1\": [\"-521766104\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSlidingWindow. /*FC*/class Solution {\n/*FM*/vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> result; \n        vector<int> maxWindow; \n        for (int i = 0;  i < nums.size();  ++i) {\n            \n            while(!maxWindow.empty() && nums[maxWindow.back()] < nums[i]) maxWindow.pop_back(); \n            if(!maxWindow.empty() && maxWindow.front() == i-k)  \n            maxWindow.push_back(i); \n            if (i >= k - 1) result.push_back(nums[maxWindow.front()]); \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1632110048\"], \"nums_element1\": [\"-77033954\"], \"nums_element2\": [\"-37734600\"], \"k\": [\"-1634006109\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSlidingWindow. /*FC*/class Solution {\n/*FM*/vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> result; \n        vector<int> maxWindow; \n        for (int i = 0;  i < nums.size();  ++i) {\n            \n            while(!maxWindow.empty() && nums[maxWindow.back()] < nums[i]) \n            if(!maxWindow.empty() && maxWindow.front() == i-k)  \n            maxWindow.push_back(i); \n            if (i >= k - 1) \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-156779567\"], \"nums_element1\": [\"-616081899\"], \"k\": [\"1023143157\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors. /*FC*/class Solution {\n/*FM*/void sortColors(vector<int>& A) {\n        int redSt = 0, bluSt = A.size() - 1; \n        int i = 0; \n        while (i < bluSt + 1)\n        {\n            if (A[i] == 0)\n            {\n                \n                \n                   \n                \n            }\n            if (A[i] == 2)\n            {\n                \n                   \n                \n            }\n            i++; \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-501953711\"], \"A_element1\": [\"-153331646\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mySqrt. /*FC*/class Solution {\n/*FM*/int mySqrt(int x) {\n        int start = 0, end; \n        end = x / 2 < std::sqrt(INT_MAX) ?\n              x / 2 + 1 : std::sqrt(INT_MAX); \n        while (start <= end)\n        {\n            int mid = (start + end) / 2; \n            int sqr = mid * mid; \n            if (sqr == x)\n            {\n                \n            }\n            if (sqr < x)\n            {\n                start = mid + 1; \n            }\n            else\n            {\n                end = mid - 1; \n            }\n        }\n        return (start + end) / 2; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"1897820933\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\n        int num = 0; \n        int sign = 1; \n        int len = str.size(); \n        int i = 0; \n        int signNum = 0; \n        while (str[i] == ' ' && i < len) \n        if (str[i] == '+') {\n            \n            \n        }\n        if (str[i] == '-')\n        {\n             \n            \n            \n        }\n        for (;  i < len;  )\n        {\n            if (str[i] == ' ') \n            if (str[i] < '0' || str[i] > '9') break; \n            if (INT_MAX / 10 < num\n                    || INT_MAX / 10 == num\n                    && INT_MAX % 10 < (str[i] - '0'))\n            {\n                \n                break; \n            }\n            \n        }\n        return num * sign; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void generateSub. /*FC*/class Solution {\n/*FM*/void generateSub(\n        vector<int> &s,\n        int step,\n        vector<vector<int> > &result,\n        vector<int>& output)\n    {\n        for (int i = step;  i < s.size();   )\n        {\n            \n            \n            \n            \n        }\n    };/*F*//*C*//*M*/void generateSub(\n        vector<int> &s,\n        int step,\n        vector<vector<int> > &result,\n        vector<int>& output)\n    {\n        for (int i = step;  i < s.size();  i++ )\n        {\n            output.push_back(s[i]); \n            result.push_back(output); \n            if (i < s.size() - 1)\n                generateSub(s, i + 1, result, output); \n            output.pop_back(); \n        }\n    } void generateSub(\n        vector<int> &s,\n        int step,\n        vector<vector<int> > &result,\n        vector<int>& output)\n    {\n        for (int i = step;  i < s.size();  i++ )\n        {\n            output.push_back(s[i]); \n            result.push_back(output); \n            if (i < s.size() - 1)\n                generateSub(s, i + 1, result, output); \n            output.pop_back(); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [2], \"s_element0\": [\"1031018221\"], \"s_element1\": [\"-1848664797\"], \"step\": [\"4\"], \"result\": [2], \"result_element0\": [3], \"result_element0_element0\": [\"1945654305\"], \"result_element0_element1\": [\"-1377146944\"], \"result_element0_element2\": [\"2041022470\"], \"result_element1\": [2], \"result_element1_element0\": [\"-747309069\"], \"result_element1_element1\": [\"-1194209531\"], \"output\": [1], \"output_element0\": [\"1389020777\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void generateSub. /*FC*/class Solution {\n/*FM*/void generateSub(\n        vector<int> &s,\n        int step,\n        vector<vector<int> > &result,\n        vector<int>& output)\n    {\n        for (int i = step;  i < s.size();  i++ )\n        {\n            output.push_back(s[i]); \n            result.push_back(output); \n            if (i < s.size() - 1)\n                \n            output.pop_back(); \n        }\n    };/*F*//*C*//*M*/void generateSub(\n        vector<int> &s,\n        int step,\n        vector<vector<int> > &result,\n        vector<int>& output)\n    {\n        for (int i = step;  i < s.size();  i++ )\n        {\n            output.push_back(s[i]); \n            result.push_back(output); \n            if (i < s.size() - 1)\n                generateSub(s, i + 1, result, output); \n            output.pop_back(); \n        }\n    } void generateSub(\n        vector<int> &s,\n        int step,\n        vector<vector<int> > &result,\n        vector<int>& output)\n    {\n        for (int i = step;  i < s.size();  i++ )\n        {\n            output.push_back(s[i]); \n            result.push_back(output); \n            if (i < s.size() - 1)\n                generateSub(s, i + 1, result, output); \n            output.pop_back(); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [2], \"s_element0\": [\"1815014667\"], \"s_element1\": [\"1868426274\"], \"step\": [\"1\"], \"result\": [1], \"result_element0\": [2], \"result_element0_element0\": [\"659748901\"], \"result_element0_element1\": [\"-2098699754\"], \"output\": [3], \"output_element0\": [\"1209282910\"], \"output_element1\": [\"499369994\"], \"output_element2\": [\"1187852163\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void generateSub. /*FC*/class Solution {\n/*FM*/void generateSub(\n        vector<int> &s,\n        int step,\n        vector<vector<int> > &result,\n        vector<int>& output)\n    {\n        for (int i = step;  i < s.size();  i++ )\n        {\n            output.push_back(s[i]); \n            result.push_back(output); \n            if (i < s.size() - 1)\n                \n            output.pop_back(); \n            while (i < s.size() - 1 && s[i] == s[i + 1])\n                \n        }\n    };/*F*//*C*//*M*/void generateSub(\n        vector<int> &s,\n        int step,\n        vector<vector<int> > &result,\n        vector<int>& output)\n    {\n        for (int i = step;  i < s.size();  i++ )\n        {\n            output.push_back(s[i]); \n            result.push_back(output); \n            if (i < s.size() - 1)\n                generateSub(s, i + 1, result, output); \n            output.pop_back(); \n            while (i < s.size() - 1 && s[i] == s[i + 1])\n                i++; \n        }\n    } void generateSub(\n        vector<int> &s,\n        int step,\n        vector<vector<int> > &result,\n        vector<int>& output)\n    {\n        for (int i = step;  i < s.size();  i++ )\n        {\n            output.push_back(s[i]); \n            result.push_back(output); \n            if (i < s.size() - 1)\n                generateSub(s, i + 1, result, output); \n            output.pop_back(); \n            while (i < s.size() - 1 && s[i] == s[i + 1])\n                i++; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [3], \"s_element0\": [\"-416182066\"], \"s_element1\": [\"-1752699757\"], \"s_element2\": [\"1238268300\"], \"step\": [\"2\"], \"result\": [3], \"result_element0\": [2], \"result_element0_element0\": [\"-1491330667\"], \"result_element0_element1\": [\"-1811648740\"], \"result_element1\": [1], \"result_element1_element0\": [\"-2092225298\"], \"result_element2\": [3], \"result_element2_element0\": [\"-734703317\"], \"result_element2_element1\": [\"1767387695\"], \"result_element2_element2\": [\"342937497\"], \"output\": [2], \"output_element0\": [\"-745445898\"], \"output_element1\": [\"-2065708706\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sumPath. /*FC*/class Solution {\n/*FM*/void sumPath(TreeNode* node, int pathSum)\n    {\n        if (node == NULL) return; \n        \n        \n\n        \n\n        \n    };/*F*//*C*//*M*/void sumPath(TreeNode* node, int pathSum)\n    {\n        if (node == NULL) return; \n        int newSum = pathSum * 10 + node->val; \n        if (node->left == NULL && node->right == NULL)\n        {\n            total += newSum; \n            return; \n        }\n\n        sumPath(node->left, newSum); \n\n        sumPath(node->right, newSum); \n    } void sumPath(TreeNode* node, int pathSum)\n    {\n        if (node == NULL) return; \n        int newSum = pathSum * 10 + node->val; \n        if (node->left == NULL && node->right == NULL)\n        {\n            total += newSum; \n            return; \n        }\n\n        sumPath(node->left, newSum); \n\n        sumPath(node->right, newSum); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->total\": [\"-490351659\"], \"pathSum\": [\"-1379309474\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sumPath. /*FC*/class Solution {\n/*FM*/void sumPath(TreeNode* node, int pathSum)\n    {\n        if (node == NULL) \n        int newSum = pathSum * 10 + node->val; \n        if (node->left == NULL && node->right == NULL)\n        {\n            total += newSum; \n            return; \n        }\n\n        \n\n        \n    };/*F*/int total;/*C*//*M*/void sumPath(TreeNode* node, int pathSum)\n    {\n        if (node == NULL) return; \n        int newSum = pathSum * 10 + node->val; \n        if (node->left == NULL && node->right == NULL)\n        {\n            total += newSum; \n            return; \n        }\n\n        sumPath(node->left, newSum); \n\n        sumPath(node->right, newSum); \n    } void sumPath(TreeNode* node, int pathSum)\n    {\n        if (node == NULL) return; \n        int newSum = pathSum * 10 + node->val; \n        if (node->left == NULL && node->right == NULL)\n        {\n            total += newSum; \n            return; \n        }\n\n        sumPath(node->left, newSum); \n\n        sumPath(node->right, newSum); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->total\": [\"-1013894392\"], \"node\": [1], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"0\"], \"pathSum\": [\"-1951014643\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int romanToInt. /*FC*/class Solution {\n/*FM*/int romanToInt(string s) {\n        int result = 0; \n        for (int i = 0;  i < s.size();  i++)\n        {\n            if (i > 0 && c2n(s[i]) > c2n(s[i - 1]))\n            {\n                \n            }\n            else\n            {\n                result += c2n(s[i]); \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/inline int c2n(char c) {\n        switch (c) {\n        case 'I': return 1; \n        case 'V': return 5; \n        case 'X': return 10; \n        case 'L': return 50; \n        case 'C': return 100; \n        case 'D': return 500; \n        case 'M': return 1000; \n        default: return 0; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution {\n/*FM*/void rotate(vector<vector<int> > &matrix) {\n        int len = matrix[0].size(); \n        for (int i = 0;  i < len - 1;  i++)\n        {\n            for (int j = 0;  j < len - i;  j++)\n            {\n                swap(matrix[i][j], matrix[len - 1 - j][len - 1 - i]); \n            }\n        }\n        for (int i = 0;  i < len / 2;  i++)\n        {\n            for (int j = 0;  j < len;  j++)\n            {\n                swap(matrix[i][j], matrix[len - i - 1][j]); \n            }\n        }\n    };/*F*//*C*//*M*/void swap(int& a1, int&a2)\n    {\n        int temp = a1; \n        a1 = a2; \n        a2 = temp; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"-611748645\"], \"matrix_element0_element1\": [\"-232981486\"], \"matrix_element0_element2\": [\"-21838106\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"-1700508905\"], \"matrix_element1_element1\": [\"-992558780\"], \"matrix_element2\": [1], \"matrix_element2_element0\": [\"-515520560\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *rotateRight. /*FC*/class Solution {\n/*FM*/ListNode *rotateRight(ListNode *head, int k) {\n        if (head == NULL || k == 0) \n        int len = 1; \n        ListNode* p = head, *pre; \n        while (p->next != NULL)\n        {\n            \n            \n        }\n        k = len - k % len; \n        p->next = head; \n        int step = 0; \n        while (step < k)\n        {\n            p = p->next; \n            step++; \n        }\n        head = p->next; \n        p->next = NULL; \n        return head; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-409795534\"], \"k\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *rotateRight. /*FC*/class Solution {\n/*FM*/ListNode *rotateRight(ListNode *head, int k) {\n        if (head == NULL || k == 0) return head; \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int> > &matrix, int target) {\n        int row = matrix.size(); \n        if (row == 0) \n        int col = matrix[0].size(); \n        if (target < matrix[0][0]) \n        int start = 0, end = row - 1; \n\n        while (start <= end)\n        {\n            int mid = (start + end) / 2; \n            if (matrix[mid][0] == target) \n\n            if (matrix[mid][0] < target) start = mid + 1; \n            else end = mid - 1; \n        }\n\n        int searchRow = end; \n\n        start = 0, end = col - 1; \n        while (start <= end)\n        {\n            int mid = (start + end) / 2; \n            if (matrix[searchRow][mid] == target) \n\n            if (matrix[searchRow][mid] < target) start = mid + 1; \n            else \n        }\n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"281797903\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"1932105379\"], \"target\": [\"1921887517\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int> > &matrix, int target) {\n        int row = matrix.size(); \n        if (row == 0) \n        int col = matrix[0].size(); \n        if (target < matrix[0][0]) return false; \n        \n\n        \n\n        \n\n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"1758441611\"], \"matrix_element0_element1\": [\"228524373\"], \"matrix_element0_element2\": [\"-2083291523\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"1301226743\"], \"matrix_element1_element1\": [\"901618172\"], \"matrix_element1_element2\": [\"358204103\"], \"target\": [\"1309161598\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> searchRange. /*FC*/class Solution {\n/*FM*/vector<int> searchRange(vector<int>& A, int target) {\n        int n = A.size(); \n        vector<int> result; \n        result.push_back(-1); \n        result.push_back(-1); \n        \n        int start = 0, end = n - 1; \n        while (start < end)\n        {\n            int mid = (start + end) / 2; \n            if (A[mid] < target)\n            {\n                \n                \n            }\n            end = mid; \n        }\n        int low_bound = A[start] == target ? start : -1; \n        if (low_bound == -1)\n        {\n            return result; \n        }\n        \n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"614676678\"], \"A_element1\": [\"1168293877\"], \"A_element2\": [\"1569718200\"], \"target\": [\"-1419771569\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> searchRange. /*FC*/class Solution {\n/*FM*/vector<int> searchRange(vector<int>& A, int target) {\n        int n = A.size(); \n        vector<int> result; \n        result.push_back(-1); \n        result.push_back(-1); \n        \n        int start = 0, end = n - 1; \n        while (start < end)\n        {\n            int mid = (start + end) / 2; \n            if (A[mid] < target)\n            {\n                start = mid + 1; \n                continue; \n            }\n            \n        }\n        int low_bound = A[start] == target ? start : -1; \n        if (low_bound == -1)\n        {\n            return result; \n        }\n        \n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"2107025608\"], \"A_element1\": [\"-331097166\"], \"A_element2\": [\"1738199772\"], \"target\": [\"275020110\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/class Solution {\n/*FM*/int searchInsert(vector<int>& A, int target) {\n        int l = 0, r = A.size() - 1; \n        while (l <= r)\n        {\n            int mid = (l + r) / 2; \n            if (A[mid] == target) \n            if (mid > l && A[mid] > target && A[mid - 1] < target )\n                \n            if (A[mid] > target)\n                r = mid - 1; \n            else\n                \n        }\n        return l; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"999574071\"], \"A_element1\": [\"228953235\"], \"A_element2\": [\"1307763145\"], \"target\": [\"-112633900\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& A, int target) {\n        int l = 0, r = A.size() - 1; \n        while (l <= r)\n        {\n            int m = (l + r) / 2; \n            if (A[m] == target) \n            if (A[m] >= A[l])\n            {\n                \n                if (A[l] <= target && target <= A[m])\n                    \n                else\n                    l = m + 1; \n            }\n            else\n            {\n                \n                   }\n        }\n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"-209863316\"], \"target\": [\"-301393875\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& A, int target) {\n        int l = 0, r = A.size() - 1; \n        while (l <= r)\n        {\n            int m = (l + r) / 2; \n            if (A[m] == target) \n            if (A[m] >= A[l])\n            {\n                \n                if (A[l] <= target && target <= A[m])\n                    r = m - 1; \n                else\n                    l = m + 1; \n            }\n            else\n            {\n                \n                   }\n        }\n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"-365236744\"], \"A_element1\": [\"1252380236\"], \"A_element2\": [\"-1192890879\"], \"target\": [\"491075014\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& A, int target) {\n        int l = 0, r = A.size() - 1; \n        while (l <= r)\n        {\n            int m = (l + r) / 2; \n            if (A[m] == target) \n            if (A[m] >= A[l])\n            {\n                \n                if (A[l] <= target && target <= A[m])\n                    \n                else\n                    l = m + 1; \n            }\n            else\n            {\n                \n                if (A[m] < target && target < A[l])\n                    l = m + 1; \n                else\n                    \n            }\n        }\n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"-389811867\"], \"A_element1\": [\"-1780685630\"], \"A_element2\": [\"-1364401323\"], \"target\": [\"-569005752\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool search. /*FC*/class Solution {\n/*FM*/bool search(vector<int>& A, int target) {\n        int start = 0; \n        int end = A.size() - 1; \n        while (start <= end)\n        {\n            int mid = (start + end) / 2; \n            if (A[mid] == target) \n            if (A[start] < A[mid])\n            {\n                           else if (A[start] > A[mid])\n            {\n                \n            else \n                start++; \n        }\n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"1176429074\"], \"target\": [\"1904749862\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void setZeroes. /*FC*/class Solution {\n/*FM*/void setZeroes(vector<vector<int>>& matrix) {\n        assert(matrix.size() > 0); \n        int row = matrix.size(), col = matrix[0].size(); \n        bool zerorow = false, zerocol = false; \n        for (int i = 0;  i < col;  i++)\n            if (matrix[0][i] == 0)\n                \n        for (int i = 0;  i < row;  i++)\n            if (matrix[i][0] == 0)\n                \n        for (int i = 1;  i < row;  i++)\n            for (int j = 1;  j < col;  j++)\n                if (matrix[i][j] == 0)\n                {\n                    matrix[0][j] = 0; \n                    matrix[i][0] = 0; \n                }\n        for (int i = 1;  i < row;  i++)\n            for (int j = 1;  j < col;  j++)\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\n                    matrix[i][j] = 0; \n        if (zerorow == 1)\n            \n        if (zerocol == 1)\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"-29138321\"], \"matrix_element0_element1\": [\"546536672\"], \"matrix_element0_element2\": [\"1640600500\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"-593841814\"], \"matrix_element1_element1\": [\"-905003832\"], \"matrix_element2\": [2], \"matrix_element2_element0\": [\"-1893756381\"], \"matrix_element2_element1\": [\"1024269335\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNumber. /*FC*/class Solution {\n/*FM*/int singleNumber(int A[], int n) {\n        int left = A[0]; \n        for (int i = 1;  i < n;  i++)\n        {\n            left = left ^ A[i]; \n        }\n        return left; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A[0]\": [\"-1934456001\"], \"A[1]\": [\"-1845443906\"], \"A[2]\": [\"453451436\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int>& A) {\n        int n = A.size(); \n        if (n == 0) \n        int occur = 1; \n        int index = 0; \n\n        for (int i = 1;  i < n;  i++)\n        {\n            if (A[index] == A[i])\n            {\n                \n                \n            }\n            else\n            {\n                occur = 1 ; \n            }\n\n            A[++index] = A[i]; \n\n        }\n        return index + 1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-1128758943\"], \"A_element1\": [\"1069558161\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\n        if (head == NULL) \n        ListNode * pre = head; \n        ListNode *p = head->next; \n        while (p != NULL)\n        {\n            if (pre->val == p->val)\n            {\n                \n                \n                \n                \n                \n                \n            }\n            pre = pre->next; \n            p = p->next; \n        }\n        return head; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-119526535\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"637484978\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1854346102\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\n        if (head == NULL) return NULL; \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\n        ListNode* dummy =  new ListNode(INT_MIN); \n        dummy->next = head; \n\n        ListNode* pre = dummy, *cur = head; \n        while (cur != NULL)\n        {\n            ListNode* post = cur->next; \n            bool isDup = false; \n            while (post != NULL && cur->val == post->val)\n            {\n                \n                \n                \n                \n            }\n\n            if (isDup)\n            {\n                \n                \n                \n                \n            }\n\n            pre->next = cur; \n            pre = cur; \n            cur = cur->next; \n        }\n        pre->next = NULL; \n\n        ListNode* newHead = dummy->next; \n        delete dummy; \n        return newHead; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1709760028\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-862645152\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeElement. /*FC*/class Solution {\n/*FM*/int removeElement(vector<int>& nums, int val) {\n        int cur = 0; \n        for (int i = 0;  i < nums.size();  i++)\n        {\n            if (nums[i] == val)\n                \n            nums[cur] = nums[i]; \n            cur++; \n        }\n        return cur; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-928293287\"], \"val\": [\"1489741926\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *removeNthFromEnd. /*FC*/class Solution {\n/*FM*/ListNode *removeNthFromEnd(ListNode *head, int n) {\n        ListNode* pre, *cur; \n        pre = head;  cur = head; \n        int step = 0; \n        while (step < n && cur != NULL)\n        {\n            cur = cur->next; \n            step++; \n        }\n        if (step == n && cur == NULL)\n        {\n            \n            \n            \n        }\n        while (cur->next != NULL)\n        {\n            \n            \n        }\n        ListNode* temp = pre->next; \n        pre->next = temp->next; \n        delete temp; \n        return head; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"2103355208\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-2136340831\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reorderList. /*FC*/class Solution {\n/*FM*/void reorderList(ListNode *head) {\n        if (head == NULL) \n        \n        ListNode* fast = head; \n        ListNode* slow = head; \n        while (true)\n        {\n            fast = fast->next; \n            if (fast == NULL)\n                break; \n            \n            \n            \n        }\n\n        if (slow == NULL) \n\n        \n        ListNode* cur = slow; \n        ListNode* pre = slow->next; \n        cur->next = NULL; \n        while (pre != NULL)\n        {\n            \n            \n            \n            \n        }\n\n        \n        ListNode* first = head; \n        ListNode* second = cur; \n\n        while (second != NULL && first != NULL && first != second)\n        {\n            \n            \n            \n            \n            \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"192116574\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-229511570\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reorderList. /*FC*/class Solution {\n/*FM*/void reorderList(ListNode *head) {\n        if (head == NULL) return; \n        \n        \n        \n        \n\n        \n\n        \n        \n        \n        \n        \n\n        \n        \n        \n\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution {\n/*FM*/int reverse(int x) {\n          int newN = 0, left = 0; \n          while (x != 0)\n          {\n               left = x % 10; \n               if (newN > INT_MAX / 10 || newN < INT_MIN / 10) \n               newN = newN * 10 + left; \n               x = x / 10; \n          }\n          return newN; \n     };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseBetween. /*FC*/class Solution {\n/*FM*/ListNode *reverseBetween(ListNode *head, int m, int n) {\n        int step = n - m; \n        \n        ListNode* safeG = new ListNode(-1); \n        safeG->next = head; \n        head = safeG; \n        ListNode* pre = head; \n        while (m > 1)\n        {\n            \n            \n        }\n        ListNode* cur = pre->next, *post = cur->next; \n        if (step >= 1)\n        {\n            \n            while (step > 0 && post != NULL)\n            {\n                ListNode* temp = post->next; \n                post->next = cur; \n                cur = post; \n                post = temp; \n                step--; \n            }\n            \n            ListNode* temp = pre->next; \n            pre->next = cur; \n            temp->next = post; \n        }\n        safeG = head;   \n        head = head->next; \n        delete safeG; \n        return head; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1846188513\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-983613183\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"441464520\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"-1921292390\"], \"m\": [\"1\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseKGroup. /*FC*/class Solution {\n/*FM*/ListNode *reverseKGroup(ListNode *head, int k) {\n        ListNode* safeG = new ListNode(-1); \n        safeG->next = head; \n        if (head == NULL || k == 1) return head; \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseKGroup. /*FC*/class Solution {\n/*FM*/ListNode *reverseKGroup(ListNode *head, int k) {\n        ListNode* safeG = new ListNode(-1); \n        safeG->next = head; \n        if (head == NULL || k == 1) \n        ListNode* pre = safeG, *cur = head, *post = head->next; \n        while (cur != NULL)\n        {\n            post = cur->next; \n            int i = 0; \n            while (i < k - 1 && post != NULL)\n            {\n                ListNode *temp = post->next; \n                post->next = cur; \n                cur = post; \n                post = temp; \n                i++; \n            }\n            if (i != k - 1)\n            {\n                int k = 0; \n                ListNode * temp = post; \n                post = cur; \n                cur = temp; \n                while (k < i)\n                {\n                    temp = post->next; \n                    post->next = cur; \n                    cur = post; \n                    post = temp; \n                    k++; \n                }\n                break; \n            }\n            \n            \n            \n            \n            \n        }\n        head = safeG->next; \n        delete safeG; \n        return head; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-351369931\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-1873746946\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"k\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSquares. /*FC*/class Solution {\n/*FM*/int numSquares(int n) {\n        vector<int> dp_nums(1,0); \n        \n        while(dp_nums.size() <= n) {\n            int k = dp_nums.size(); \n            int least_num = INT_MAX; \n            for(int i =1;  i*i <=k;  i++){\n                least_num = min(least_num, dp_nums[k-i*i] +1);                \n            }\n            dp_nums.push_back(least_num); \n        }\n        return dp_nums[n]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > permute. /*FC*/class Solution {\n/*FM*/vector<vector<int> > permute(vector<int> &num) {\n        vector<vector<int> > coll; \n        vector<int> solution; \n        if (num.size() == 0) \n        vector<int> visited(num.size(), 0); \n        GeneratePermute(num, 0, visited, solution, coll); \n        return coll; \n    };/*F*//*C*//*M*/void GeneratePermute(vector<int> & num, int step,\n                         vector<int>& visited,\n                         vector<int>& solution,\n                         vector<vector<int> >& coll)\n    {\n        if (step == num.size())\n        {\n            coll.push_back(solution); \n            return; \n        }\n        for (int i = 0;  i < num.size();  i++)\n        {\n            \n            if (visited[i] == 0)\n            {\n                visited[i] = 1; \n                solution.push_back(num[i]); \n                GeneratePermute(\n                    num, step + 1, visited, solution, coll); \n                solution.pop_back(); \n                visited[i] = 0; \n            }\n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [2], \"num_element0\": [\"-1311150513\"], \"num_element1\": [\"431315312\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > permuteUnique. /*FC*/class Solution {\n/*FM*/vector<vector<int> > permuteUnique(vector<int> &num) {\n        vector<vector<int> > coll; \n        vector<int> solution; \n        if (num.size() == 0) \n        vector<int> visited(num.size(), 0); \n        sort(num.begin(), num.end()); \n        GeneratePermute(num, 0, visited, solution, coll); \n        return coll; \n    };/*F*//*C*//*M*/void GeneratePermute(vector<int> & num, int step, vector<int>& visited, vector<int>& solution, vector<vector<int> >& coll)\n    {\n        if (step == num.size())\n        {\n            coll.push_back(solution); \n            return; \n        }\n        for (int i = 0;  i < num.size();  i++)\n        {\n            if (visited[i] == 0)\n            {\n\n                visited[i] = 1; \n                solution.push_back(num[i]); \n                GeneratePermute(num, step + 1, visited, solution, coll); \n                solution.pop_back(); \n                visited[i] = 0; \n                while (i < num.size() - 1 && num[i] == num[i + 1])\n                    i++; \n            }\n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [2], \"num_element0\": [\"366242135\"], \"num_element1\": [\"-180288089\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string getPermutation. /*FC*/class Solution {\n/*FM*/string getPermutation(int n, int k) {\n        vector<int> nums(n); \n        int permCount = 1; \n        for (int i = 0;  i < n;  i++)\n        {\n            nums[i] = i + 1; \n            permCount *= (i + 1); \n        }\n        \n        k--; \n        string targetNum; \n        for (int i = 0;  i < n;  i++)\n        {\n            permCount = permCount / (n - i); \n            int choosed = k / permCount; \n            targetNum.push_back(nums[choosed] + '0'); \n            \n            for (int j = choosed;  j < n - i;  j++)\n            {\n                nums[j] = nums[j + 1]; \n            }\n            k = k % permCount; \n        }\n        return targetNum; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"6\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int> &digits) {\n        vector<int> result(digits.size(), 0); \n\n        int carryon = 1; \n        for (int i = digits.size() - 1;  i >= 0;  i--)\n        {\n            int digit = digits[i]; \n            result[i] = (digit + carryon) % 10; \n            carryon = (digit + carryon) / 10; \n        }\n\n        if (carryon > 0)\n        {\n            \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [1], \"digits_element0\": [\"-1467111841\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int> &digits) {\n        vector<int> result(digits.size(), 0); \n\n        int carryon = 1; \n        for (int i = digits.size() - 1;  i >= 0;  i--)\n        {\n            int digit = digits[i]; \n            result[i] = (digit + carryon) % 10; \n            carryon = (digit + carryon) / 10; \n        }\n\n        if (carryon > 0)\n        {\n            result.insert(result.begin(), carryon); \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [1], \"digits_element0\": [\"94593922\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double power. /*FC*/class Solution {\n/*FM*/double power(double x, int n)\n    {\n        if (n == 0)\n            return 1; \n        double v = power(x, n / 2); \n        if (n % 2 == 0)\n            return v * v; \n        else\n            return v * v * x; \n    };/*F*//*C*//*M*/double power(double x, int n)\n    {\n        if (n == 0)\n            return 1; \n        double v = power(x, n / 2); \n        if (n % 2 == 0)\n            return v * v; \n        else\n            return v * v * x; \n    } double power(double x, int n)\n    {\n        if (n == 0)\n            return 1; \n        double v = power(x, n / 2); \n        if (n % 2 == 0)\n            return v * v; \n        else\n            return v * v * x; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"0.99\"], \"n\": [\"-1698538576\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double myPow. /*FC*/class Solution {\n/*FM*/double myPow(double x, int n) {\n        if (n < 0)\n            return 1.0 / power(x, -n); \n        else\n            \n    };/*F*//*C*//*M*/double power(double x, int n)\n    {\n        if (n == 0)\n            return 1; \n        double v = power(x, n / 2); \n        if (n % 2 == 0)\n            return v * v; \n        else\n            return v * v * x; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"0.18\"], \"n\": [\"-1941861693\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> productExceptSelf. /*FC*/class Solution {\n/*FM*/vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int> products; \n        if(nums.size() == 0) \n\n        int product = 1; \n        products.push_back(1); \n        for(int i =1;  i< nums.size();  i++) {\n            product *= nums[i-1]; \n            products.push_back(product); \n        }\n        \n        product = 1; \n        for(int i =nums.size()-2;  i>=0;  i--) {\n            product = product * nums[i+1]; \n            products[i] = products[i] * product;  \n        }\n        return products; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1540650935\"], \"nums_element1\": [\"-1168614578\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int>& A) {\n        int n = A.size(); \n        if (n == 0) \n        int index = 0; \n        for (int i = 0;  i < n;  i++)\n        {\n            if (A[index] == A[i]) \n            {\n                continue; \n            }\n            index++;  \n            A[index] = A[i]; \n        }\n        return index + 1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"-395782704\"], \"A_element1\": [\"-1148562957\"], \"A_element2\": [\"268622350\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string multiply. /*FC*/class Solution {\n/*FM*/string multiply(string num1, string num2) {\n    if (num1.size() == 0 || num2.size() == 0) \n    string res(num1.size() + num2.size() + 1, '0'); \n    std::reverse(num1.begin(), num1.end()); \n    std::reverse(num2.begin(), num2.end()); \n    for (int i = 0;  i < num1.size();  i++)\n    {\n      int dig1 = num1[i] - '0'; \n      int carry = 0; \n      for (int j = 0;  j < num2.size();  j++)\n      {\n        int dig2 = num2[j] - '0'; \n        int exist = res[i + j] - '0'; \n        res[i + j] = (dig1 * dig2 + carry + exist) % 10 + '0'; \n        carry = (dig1 * dig2 + carry + exist) / 10; \n      }\n      if (carry > 0)\n      {\n        res[i + num2.size()] = carry + '0'; \n      }\n    }\n    std::reverse(res.begin(), res.end()); \n    int start = 0; \n    while (res[start] == '0' && start < res.size())\n    {\n      start++; \n    }\n    if (start == res.size()) \n    return res.substr(start, res.size() - start); \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"3\"], \"num2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string multiply. /*FC*/class Solution {\n/*FM*/string multiply(string num1, string num2) {\n    if (num1.size() == 0 || num2.size() == 0) \n    string res(num1.size() + num2.size() + 1, '0'); \n    std::reverse(num1.begin(), num1.end()); \n    std::reverse(num2.begin(), num2.end()); \n    for (int i = 0;  i < num1.size();  i++)\n    {\n      int dig1 = num1[i] - '0'; \n      int carry = 0; \n      for (int j = 0;  j < num2.size();  j++)\n      {\n        int dig2 = num2[j] - '0'; \n        int exist = res[i + j] - '0'; \n        res[i + j] = (dig1 * dig2 + carry + exist) % 10 + '0'; \n        carry = (dig1 * dig2 + carry + exist) / 10; \n      }\n      if (carry > 0)\n      {\n        \n      }\n    }\n    std::reverse(res.begin(), res.end()); \n    int start = 0; \n    while (res[start] == '0' && start < res.size())\n    {\n      start++; \n    }\n    if (start == res.size()) \n    return res.substr(start, res.size() - start); \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"1\"], \"num2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector<int> &num) {\n        assert(num.size() > 0); \n        int vioIndex = num.size() - 1; \n        while (vioIndex > 0)\n        {\n            if (num[vioIndex - 1] < num[vioIndex])\n                break; \n            \n        }\n        if (vioIndex > 0)\n        {\n            vioIndex--; \n            int rightIndex = num.size() - 1; \n            while (rightIndex >= 0 && num[rightIndex] <= num[vioIndex])\n            {\n                \n            }\n            int swap = num[vioIndex]; \n            num[vioIndex] = num[rightIndex]; \n            num[rightIndex] = swap; \n            vioIndex++; \n        }\n        int end = num.size() - 1; \n        while (end > vioIndex)\n        {\n            \n            \n            \n            \n            \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"-1952904769\"], \"num_element1\": [\"454893257\"], \"num_element2\": [\"2058382910\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector<int> &num) {\n        assert(num.size() > 0); \n        int vioIndex = num.size() - 1; \n        while (vioIndex > 0)\n        {\n            \n            \n        }\n        if (vioIndex > 0)\n        {\n            \n            \n            \n            \n            \n            \n            \n        }\n        int end = num.size() - 1; \n        while (end > vioIndex)\n        {\n            \n            \n            \n            \n            \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [1], \"num_element0\": [\"1392019461\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\n        if (x < 0) \n        int div = 1; \n        while (x / div >= 10)\n            \n        while (x > 0)\n        {\n            int l = x / div; \n            int r = x % 10; \n            if (l != r) \n            x = x % div / 10; \n            div /= 100; \n        }\n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void DFS. /*FC*/class Solution {\n/*FM*/void DFS(string &s, int start, vector<string>& output,\n             vector<vector<string>> &result)\n    {\n        if (start == s.size())\n        {\n            \n            \n        }\n        for (int i = start;  i < s.size();  )\n        {\n            \n        }\n    };/*F*//*C*//*M*/void DFS(string &s, int start, vector<string>& output,\n             vector<vector<string>> &result)\n    {\n        if (start == s.size())\n        {\n            result.push_back(output); \n            return; \n        }\n        for (int i = start;  i < s.size();  i++)\n        {\n            if (isPalindrome(s, start, i))\n            {\n                output.push_back(s.substr(start, i - start + 1)); \n                DFS(s, i + 1, output, result); \n                output.pop_back(); \n            }\n        }\n    } void DFS(string &s, int start, vector<string>& output,\n             vector<vector<string>> &result)\n    {\n        if (start == s.size())\n        {\n            result.push_back(output); \n            return; \n        }\n        for (int i = start;  i < s.size();  i++)\n        {\n            if (isPalindrome(s, start, i))\n            {\n                output.push_back(s.substr(start, i - start + 1)); \n                DFS(s, i + 1, output, result); \n                output.pop_back(); \n            }\n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"], \"start\": [\"9\"], \"output\": [1], \"output_element0\": [\"2\"], \"result\": [2], \"result_element0\": [2], \"result_element0_element0\": [\"3\"], \"result_element0_element1\": [\"1\"], \"result_element1\": [3], \"result_element1_element0\": [\"2\"], \"result_element1_element1\": [\"2\"], \"result_element1_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string &s, int start, int end)\n    {\n        while (start < end)\n        {\n            if (s[start] != s[end])\n                return false; \n             \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"start\": [\"6\"], \"end\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string &s, int start, int end)\n    {\n        while (start < end)\n        {\n            \n             \n        }\n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"start\": [\"10\"], \"end\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCut. /*FC*/class Solution {\n/*FM*/int minCut(string s) {\n        int len = s.size(); \n        int D[len + 1]; \n        bool P[len][len]; \n        \n        for (int i = 0;  i <= len;  i++)\n            D[i] = len - i; \n        for (int i = 0;  i < len;  i++)\n            for (int j = 0;  j < len;  j++)\n                P[i][j] = false; \n        for (int i = len - 1;  i >= 0;  i--) {\n            for (int j = i;  j < len;  j++) {\n                if (s[i] == s[j] && (j - i < 2 || P[i + 1][j - 1])) {\n                    P[i][j] = true; \n                    D[i] = min(D[i], D[j + 1] + 1); \n                }\n            }\n        }\n        return D[0] - 1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *partition. /*FC*/class Solution {\n/*FM*/ListNode *partition(ListNode *head, int x) {\n        ListNode* p = new ListNode(x - 1); \n        p->next = head; \n        head = p; \n        ListNode* pre; \n        while (p != NULL && p->val < x)\n        {\n            pre = p; \n            p = p->next; \n        }\n        if (p != NULL)\n        {\n            \n            \n            \n        }\n        ListNode* temp = head; \n        head = head->next; \n        delete temp; \n        return head; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *partition. /*FC*/class Solution {\n/*FM*/ListNode *partition(ListNode *head, int x) {\n        ListNode* p = new ListNode(x - 1); \n        p->next = head; \n        head = p; \n        ListNode* pre; \n        while (p != NULL && p->val < x)\n        {\n            pre = p; \n            p = p->next; \n        }\n        if (p != NULL)\n        {\n            \n            ListNode* cur = pre; \n            while (p != NULL)\n            {\n                if (p->val < x)\n                {\n                    ListNode* temp = cur->next; \n                    pre->next = p->next; \n                    cur->next = p; \n                    cur = p; \n                    p->next = temp; \n                    p = pre; \n                }\n                pre = p; \n                p = p->next; \n            }\n        }\n        ListNode* temp = head; \n        head = head->next; \n        delete temp; \n        return head; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"8\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"0\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"2\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"5\"], \"x\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> getRow. /*FC*/class Solution {\n/*FM*/vector<int> getRow(int rowIndex) {\n        vector<int> result; \n        result.resize(rowIndex + 2); \n        for (int i = 0;  i < rowIndex + 2;  i++)\n            result[i] = 0; \n        result[1] = 1; \n        for (int i = 0;  i < rowIndex;  i++)\n        {\n            \n            for (int j = rowIndex + 1;  j > 0;  j--)\n            {\n                result[j] = result[j - 1] + result[j]; \n            }\n        }\n        result.erase(result.begin()); \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"rowIndex\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasPathSum. /*FC*/class Solution {\n/*FM*/bool hasPathSum(TreeNode *root, int sum, int target) {\n        if (root == NULL) return false; \n        \n        \n        \n    };/*F*//*C*//*M*/bool hasPathSum(TreeNode *root, int sum, int target) {\n        if (root == NULL) return false; \n        sum += root->val; \n        if (root->left == NULL && root->right == NULL) \n        {\n            if (sum == target)\n                return true; \n            else\n                return false; \n        }\n        return hasPathSum(root->left, sum, target)\n               || hasPathSum(root->right, sum, target); \n    } bool hasPathSum(TreeNode *root, int sum, int target) {\n        if (root == NULL) return false; \n        sum += root->val; \n        if (root->left == NULL && root->right == NULL) \n        {\n            if (sum == target)\n                return true; \n            else\n                return false; \n        }\n        return hasPathSum(root->left, sum, target)\n               || hasPathSum(root->right, sum, target); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"sum\": [\"-1473857422\"], \"target\": [\"406321651\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > pathSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > pathSum(TreeNode *root, int sum) {\n        vector<vector<int> > collect; \n        vector<int> solution; \n        if (root != NULL)\n            GetPath(root, sum, 0, solution, collect); \n        return collect; \n    };/*F*//*C*//*M*/void GetPath(TreeNode* node, int sum, int cal, vector<int>& solution, vector<vector<int> >& collect)\n    {\n        solution.push_back(node->val); \n        cal += node->val; \n        if (cal == sum && node->left == NULL && node->right == NULL)\n        {\n            collect.push_back(solution); \n        }\n        else\n        {\n            if (node->left != NULL)\n            {\n                GetPath(node->left, sum, cal, solution, collect); \n            }\n            if (node->right != NULL)\n            {\n                GetPath(node->right, sum, cal, solution, collect); \n            }\n        }\n        solution.pop_back(); \n\n        return; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"867359617\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1698050142\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"], \"sum\": [\"-42122623\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMedianSortedArrays. /*FC*/class Solution {\n/*FM*/double findMedianSortedArrays(int A[], int m, int B[], int n) {\n    if ((n + m) % 2 == 0)\n    {\n      \n    }\n    else\n      return GetMedian(A, m, B, n, (m + n) / 2 + 1); \n  };/*F*//*C*//*M*/int GetMedian(int a[], int n, int b[], int m, int k)\n  {\n    assert(a && b); \n    if (n <= 0) return b[k - 1]; \n    if (m <= 0) return a[k - 1]; \n    if (k <= 1) return min(a[0], b[0]); \n    if (b[m / 2] >= a[n / 2])\n    {\n      if ((n / 2 + 1 + m / 2) >= k)\n        return GetMedian(a, n, b, m / 2, k); \n      else\n        return GetMedian(\n                 a + n / 2 + 1, n - (n / 2 + 1), b, m, k - (n / 2 + 1)); \n    }\n    else\n    {\n      if ((m / 2 + 1 + n / 2) >= k)\n        return GetMedian( a, n / 2, b, m, k); \n      else\n        return GetMedian(\n                 a, n, b + m / 2 + 1, m - (m / 2 + 1), k - (m / 2 + 1)); \n    }\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A[0]\": [\"-1711969970\"], \"A[1]\": [\"1767640385\"], \"m\": [\"1429476621\"], \"B\": [2], \"B[0]\": [\"-1525781\"], \"B[1]\": [\"-198821648\"], \"n\": [\"1252981046\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> merge. /*FC*/class Solution {\n/*FM*/vector<Interval> merge(vector<Interval> &intervals) {\n    vector<Interval> result; \n    for (int i = 0;  i < intervals.size();  i++)\n    {\n      insert(result, intervals[i]); \n    }\n    return result; \n  };/*F*//*C*//*M*/void insert(vector<Interval> &intervals, Interval newInterval) {\n    vector<Interval>::iterator it = intervals.begin(); \n    while (it != intervals.end())\n    {\n      if (newInterval.end < it->start)\n      {\n        intervals.insert(it, newInterval); \n        return; \n      }\n      else if (newInterval.start > it->end)\n      {\n        it++; \n        continue; \n      }\n      else\n      {\n        newInterval.start = min(newInterval.start, it->start); \n        newInterval.end = max(newInterval.end, it->end); \n        it = intervals.erase(it); \n      }\n    }\n    intervals.insert(intervals.end(), newInterval); \n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [3], \"intervals_element0\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element0_s\": [\"82591080\"], \"intervals_element0_e\": [\"1237456613\"], \"intervals_element1\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element1_s\": [\"935580941\"], \"intervals_element1_e\": [\"-624075942\"], \"intervals_element2\": [\"Interval\", \"Interval()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/class Solution {\n/*FM*/void insert(vector<Interval> &intervals, Interval newInterval) {\n    vector<Interval>::iterator it = intervals.begin(); \n    while (it != intervals.end())\n    {\n      if (newInterval.end < it->start)\n      {\n        intervals.insert(it, newInterval); \n        return; \n      }\n      else if (newInterval.start > it->end)\n      {\n        it++; \n        continue; \n      }\n      else\n      {\n        \n        \n        \n      }\n    }\n    \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [3], \"intervals_element0\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element0_s\": [\"-951249385\"], \"intervals_element0_e\": [\"-1514718729\"], \"intervals_element0.start\": [\"-1845406843\"], \"intervals_element0.end\": [\"-1982543543\"], \"intervals_element1\": [\"Interval\", \"Interval()\"], \"intervals_element1.start\": [\"544029471\"], \"intervals_element1.end\": [\"-1842307081\"], \"intervals_element2\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element2_s\": [\"1138024291\"], \"intervals_element2_e\": [\"-949098798\"], \"intervals_element2.start\": [\"-776732514\"], \"intervals_element2.end\": [\"-1826911375\"], \"newInterval\": [\"Interval\", \"Interval()\"], \"newInterval.start\": [\"1421872654\"], \"newInterval.end\": [\"26293137\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* merge2Lists. /*FC*/class Solution {\n/*FM*/ListNode* merge2Lists(ListNode* one, ListNode* two)\n    {\n        if (one == NULL) \n        if (two == NULL) \n        ListNode* newHead = new ListNode(-1); \n        ListNode* p = newHead; \n        while (one != NULL && two != NULL)\n        {\n            if (one->val < two->val)\n            {\n                p->next = one; \n                one = one->next; \n            }\n            else\n            {\n                p->next = two; \n                two = two->next; \n            }\n            p = p->next; \n        }\n\n        if (one == NULL)\n        {\n            \n        }\n        else\n        {\n            p->next = one; \n        }\n        p = newHead->next; \n        delete newHead; \n        return p; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"one\": [2], \"one[0]\": [\"ListNode\", \"ListNode(int)\"], \"one0_x\": [\"550322950\"], \"one[0].val\": [\"-794264609\"], \"one[0].next\": [2], \"one[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"one0_next0_x\": [\"1725422825\"], \"one[0].next[0].val\": [\"1553494237\"], \"one[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"one0_next1_x\": [\"831467603\"], \"one[0].next[1].val\": [\"1413227538\"], \"one[1]\": [\"ListNode\", \"ListNode(int)\"], \"one1_x\": [\"-1981156791\"], \"one[1].val\": [\"1298811016\"], \"two\": [1], \"two[0]\": [\"ListNode\", \"ListNode(int)\"], \"two0_x\": [\"-1861535685\"], \"two[0].val\": [\"986265838\"], \"two[0].next\": [2], \"two[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"two0_next0_x\": [\"-1629741016\"], \"two[0].next[0].val\": [\"1085757988\"], \"two[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"two0_next1_x\": [\"326193899\"], \"two[0].next[1].val\": [\"799174891\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n\n        ListNode* head = new ListNode(-1); \n\n        ListNode* cur = head, *first = l1, *second = l2; \n\n        while (first != NULL || second != NULL)\n        {\n            int lval = first == NULL ? INT_MAX : first->val; \n            int rval = second == NULL ? INT_MAX : second->val; \n            if (lval < rval)\n            {\n                cur->next = first; \n                cur = first; \n                first = first == NULL ? NULL : first->next; \n            }\n            else\n            {\n                cur->next = second; \n                cur = second; \n                second = second == NULL ? NULL : second->next; \n            }\n        }\n\n        ListNode* newhead = head->next; \n        delete head; \n        return newhead; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"-5330818\"], \"l2\": [2], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"1315663239\"], \"l2[1]\": [\"ListNode\", \"ListNode(int)\"], \"l21_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDepth. /*FC*/class Solution {\n/*FM*/int minDepth(TreeNode *root) {\n    if (root == NULL)\n      return 0; \n    int lmin = minDepth(root->left); \n    int rmin = minDepth(root->right); \n    if (lmin == 0 && rmin == 0)\n      return 1; \n    if (lmin == 0)\n    {\n      \n    }\n    if (rmin == 0)\n    {\n      rmin = INT_MAX; \n    }\n    return min(lmin, rmin) + 1; \n  };/*F*//*C*//*M*/int minDepth(TreeNode *root) {\n    if (root == NULL)\n      return 0; \n    int lmin = minDepth(root->left); \n    int rmin = minDepth(root->right); \n    if (lmin == 0 && rmin == 0)\n      return 1; \n    if (lmin == 0)\n    {\n      lmin = INT_MAX; \n    }\n    if (rmin == 0)\n    {\n      rmin = INT_MAX; \n    }\n    return min(lmin, rmin) + 1; \n  } int minDepth(TreeNode *root) {\n    if (root == NULL)\n      return 0; \n    int lmin = minDepth(root->left); \n    int rmin = minDepth(root->right); \n    if (lmin == 0 && rmin == 0)\n      return 1; \n    if (lmin == 0)\n    {\n      lmin = INT_MAX; \n    }\n    if (rmin == 0)\n    {\n      rmin = INT_MAX; \n    }\n    return min(lmin, rmin) + 1; \n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1797597251\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-704758566\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDepth. /*FC*/class Solution {\n/*FM*/int minDepth(TreeNode *root) {\n    if (root == NULL)\n      return 0; \n    int lmin = minDepth(root->left); \n    int rmin = minDepth(root->right); \n    if (lmin == 0 && rmin == 0)\n      return 1; \n    if (lmin == 0)\n    {\n      lmin = INT_MAX; \n    }\n    if (rmin == 0)\n    {\n      \n    }\n    return min(lmin, rmin) + 1; \n  };/*F*//*C*//*M*/int minDepth(TreeNode *root) {\n    if (root == NULL)\n      return 0; \n    int lmin = minDepth(root->left); \n    int rmin = minDepth(root->right); \n    if (lmin == 0 && rmin == 0)\n      return 1; \n    if (lmin == 0)\n    {\n      lmin = INT_MAX; \n    }\n    if (rmin == 0)\n    {\n      rmin = INT_MAX; \n    }\n    return min(lmin, rmin) + 1; \n  } int minDepth(TreeNode *root) {\n    if (root == NULL)\n      return 0; \n    int lmin = minDepth(root->left); \n    int rmin = minDepth(root->right); \n    if (lmin == 0 && rmin == 0)\n      return 1; \n    if (lmin == 0)\n    {\n      lmin = INT_MAX; \n    }\n    if (rmin == 0)\n    {\n      rmin = INT_MAX; \n    }\n    return min(lmin, rmin) + 1; \n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1700525655\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-1979203689\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"2118385594\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"1722335972\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPathSum. /*FC*/class Solution {\n/*FM*/int minPathSum(vector<vector<int> > &grid) {\n\t\tint row = grid.size(); \n\t\tif (row == 0) \n\t\tint col = grid[0].size(); \n\t\tif (col == 0) \n\t\tvector<int> steps(col, INT_MAX); \n\t\tsteps[0] = 0; \n\t\tfor (int i = 0;  i < row;  i++)\n\t\t{\n\t\t\tsteps[0] = steps[0] + grid[i][0]; \n\t\t\tfor (int j = 1;  j < col;  j++)\n\t\t\t{\n\t\t\t\tsteps[j] = min(steps[j], steps[j - 1]) + grid[i][j]; \n\t\t\t}\n\t\t}\n\t\treturn steps[col - 1]; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [3], \"grid_element0_element0\": [\"-1776273092\"], \"grid_element0_element1\": [\"455506778\"], \"grid_element0_element2\": [\"-2142020954\"], \"grid_element1\": [3], \"grid_element1_element0\": [\"1565600237\"], \"grid_element1_element1\": [\"-1447706445\"], \"grid_element1_element2\": [\"-291209498\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class Solution {\n/*FM*/string minWindow(string S, string T) {\n        if (S.size() == 0) \n        if (S.size() < T.size()) \n        int appearCount[256]; \n        int expectCount[256]; \n        memset(appearCount, 0, 256 * sizeof(appearCount[0])); \n        memset(expectCount, 0, 256 * sizeof(appearCount[0])); \n        for (int i = 0;  i < T.size();  i++)\n        {\n            expectCount[T[i]]++; \n        }\n        int minV = INT_MAX, min_start = 0; \n        int wid_start = 0; \n        int appeared = 0; \n        for (int wid_end = 0;  wid_end < S.size();  wid_end++)\n        {\n            if (expectCount[S[wid_end]] > 0) \n            {\n                \n                \n            }\n            if (appeared == T.size())\n            {\n                \n                if (minV > (wid_end - wid_start + 1))\n                {\n                    \n                    \n                }\n            }\n        }\n        if (minV == INT_MAX) return \"\"; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"3\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int missingNumber. /*FC*/class Solution {\n/*FM*/int missingNumber(vector<int>& nums) {\n        \n        int length = nums.size(); \n        for(int i =0;  i< length;  i++) {\n            if(nums[i] == i) {\n                \n            }\n            \n            int j=i; \n            while(nums[j]<length && j != nums[j]) {\n                \n                \n                \n            }\n        }\n        \n        for(int i =0;  i< length;  ) {\n            if(nums[i] != i)\n                return i; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"180550755\"], \"nums_element1\": [\"1984032419\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void moveZeroes. /*FC*/class Solution {\n/*FM*/void moveZeroes(vector<int>& nums) {\n        for(int zero_index = 0, none_zero_index = 0; \n            none_zero_index < nums.size() && zero_index < nums.size();  \n        ) {\n            if(nums[zero_index] != 0) {\n                zero_index++; \n                none_zero_index = zero_index; \n                continue; \n            } \n            \n            if(nums[none_zero_index] == 0) {\n                \n                \n            }\n            \n            \n            \n            \n            \n            \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1034524364\"], \"nums_element1\": [\"1335984642\"], \"nums_element2\": [\"-1586135471\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasCycle. /*FC*/class Solution {\n/*FM*/bool hasCycle(ListNode *head) {\n        if (head == NULL) \n        ListNode* first = head; \n        ListNode* second = head->next; \n\n        while (first != NULL && second != NULL)\n        {\n            if (first == second) \n            first = first->next; \n            second = second->next; \n            if (second == NULL)\n                return false; \n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-812291854\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-1296483454\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1724457270\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"811889108\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *detectCycle. /*FC*/class Solution {\n/*FM*/ListNode *detectCycle(ListNode *head) {\n\n        ListNode * first = head; \n        ListNode * second = head; \n\n        while (first != NULL && second != NULL)\n        {\n            \n            \n            \n            \n        }\n\n        if (second == NULL) return NULL; \n\n        \n        \n        \n\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *detectCycle. /*FC*/class Solution {\n/*FM*/ListNode *detectCycle(ListNode *head) {\n\n        ListNode * first = head; \n        ListNode * second = head; \n\n        while (first != NULL && second != NULL)\n        {\n            first = first->next; \n            second = second->next; \n            if (second != NULL)\n                \n            if (first == second)\n                break; \n        }\n\n        if (second == NULL) return NULL; \n\n        \n        \n        \n\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1710088710\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1796059737\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution {\n/*FM*/string longestCommonPrefix(vector<string> &strs) {\n    string prefix; \n    if (strs.size() == 0) \n    int len = 0; \n    while (1)\n    {\n      char var; \n      int i = 0; \n      for (;  i < strs.size();  i++)\n      {\n        if (i == 0) var = strs[0][len]; \n        if (strs[i].size() == len || var != strs[i][len])\n          break; \n      }\n      if (i != strs.size())\n        break; \n      len++; \n      prefix.append(1, var); \n    }\n    return prefix; \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [1], \"strs_element0\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution {\n/*FM*/string longestCommonPrefix(vector<string> &strs) {\n    string prefix; \n    if (strs.size() == 0) \n    int len = 0; \n    while (1)\n    {\n      char var; \n      int i = 0; \n      for (;  i < strs.size();  i++)\n      {\n        if (i == 0) var = strs[0][len]; \n        if (strs[i].size() == len || var != strs[i][len])\n          break; \n      }\n      if (i != strs.size())\n        break; \n      \n      \n    }\n    return prefix; \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [2], \"strs_element0\": [\"1\"], \"strs_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestConsecutive. /*FC*/class Solution {\n/*FM*/int longestConsecutive(vector<int> &num) {\n        unordered_map<int, int> hashmap; \n        vector<int> length(num.size(), 0); \n        for (int i = 0;  i < num.size();  i++)\n        {\n            hashmap[num[i]] = i; \n        }\n\n        for (int i = 0;  i < num.size();  i++)\n        {\n            \n            if (length[i] > 0) \n\n            length[i] = consecutiveLength(num[i], hashmap, length); \n        }\n\n        int maxV = INT_MIN; \n        for (int i = 0;  i < num.size();  i++)\n        {\n            maxV = length[i] > maxV ? length[i] : maxV; \n        }\n        return maxV; \n    };/*F*//*C*//*M*/int consecutiveLength(int num, unordered_map<int, int>& hashmap, vector<int>& length)\n    {\n        if (hashmap.find(num) == hashmap.end()) return 0; \n\n        int index = hashmap[num]; \n        if (length[index] > 0)  return length[index]; \n        else\n        {\n            \n            length[index] = consecutiveLength(num - 1, hashmap, length) + 1; \n            return length[index]; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [1], \"num_element0\": [\"-2031886457\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int consecutiveLength. /*FC*/class Solution {\n/*FM*/int consecutiveLength(int num, unordered_map<int, int>& hashmap, vector<int>& length)\n    {\n        if (hashmap.find(num) == hashmap.end()) return 0; \n\n        \n        \n    };/*F*//*C*//*M*/int consecutiveLength(int num, unordered_map<int, int>& hashmap, vector<int>& length)\n    {\n        if (hashmap.find(num) == hashmap.end()) return 0; \n\n        int index = hashmap[num]; \n        if (length[index] > 0)  return length[index]; \n        else\n        {\n            \n            length[index] = consecutiveLength(num - 1, hashmap, length) + 1; \n            return length[index]; \n        }\n    } int consecutiveLength(int num, unordered_map<int, int>& hashmap, vector<int>& length)\n    {\n        if (hashmap.find(num) == hashmap.end()) return 0; \n\n        int index = hashmap[num]; \n        if (length[index] > 0)  return length[index]; \n        else\n        {\n            \n            length[index] = consecutiveLength(num - 1, hashmap, length) + 1; \n            return length[index]; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1069067082\"], \"length\": [3], \"length_element0\": [\"1878268788\"], \"length_element1\": [\"-1438018068\"], \"length_element2\": [\"682407889\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\n    int len = s.size(); \n    int P[len][len]; \n    memset(P, 0, len * len * sizeof(int)); \n    int maxL = 0, start = 0, end = 0; \n    for (int i = 0;  i < s.size();  i++)\n    {\n      for (int j = 0;  j < i;  )\n      {\n        \n        \n      }\n      P[i][i] = 1; \n    }\n    return s.substr(start, end - start + 1); \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\n    int count[256]; \n    memset(count, -1, 256 * sizeof(int)); \n    int len = 0, maxL = 0; \n    for (int i = 0;  i < s.size();  i++, len++)\n    {\n      if (count[s[i]] >= 0)\n      {\n        \n        \n        \n        \n      }\n      count[s[i]] = i; \n    }\n    return max(len, maxL); \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\n    int count[256]; \n    memset(count, -1, 256 * sizeof(int)); \n    int len = 0, maxL = 0; \n    for (int i = 0;  i < s.size();  i++, len++)\n    {\n      if (count[s[i]] >= 0)\n      {\n        maxL = max(len, maxL); \n        len = 0; \n        i = count[s[i]] + 1; \n        memset(count, -1, 256 * sizeof(int)); \n      }\n      count[s[i]] = i; \n    }\n    return max(len, maxL); \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int get. /*FC*/class LRUCache {\n/*FM*/int get(int key) {\n\t\tif (m_map.find(key) == m_map.end())\n\t\t\treturn -1; \n\n\t\t\n\t\t\n\t};/*F*/unordered_map<int, list<CacheEntry>::iterator> m_map;/*C*/LRUCache(int capacity) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___LRUCache\": [\"LRUCache\", \"LRUCache(int)\"], \"AKA_INSTANCE___LRUCache_capacity\": [\"-2002164994\"], \"key\": [\"758766716\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void set. /*FC*/class LRUCache {\n/*FM*/void set(int key, int value) {\n\t\tif (m_map.find(key) == m_map.end())\n\t\t{\n\t\t\tCacheEntry newItem(key, value); \n\t\t\tif (m_LRU_cache.size() >= m_capacity)\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\n\t\t\t\n\t\t\tm_LRU_cache.push_front(newItem); \n\t\t\tm_map[key] = m_LRU_cache.begin(); \n\t\t\treturn; \n\t\t}\n\n\t\t\n\t\t\n\t};/*F*/unordered_map<int, list<CacheEntry>::iterator> m_map;  list<CacheEntry> m_LRU_cache;  int m_capacity;/*C*/LRUCache(int capacity) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___LRUCache\": [\"LRUCache\", \"LRUCache(int)\"], \"AKA_INSTANCE___LRUCache_capacity\": [\"-437761311\"], \"key\": [\"248266789\"], \"value\": [\"-1898350650\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(TreeNode *root) {\n\t\tif (root == NULL)\n\t\t\treturn 0; \n\t\tint lmax = maxDepth(root->left); \n\t\tint rmax = maxDepth(root->right); \n\t\treturn max(lmax, rmax) + 1; \n\t};/*F*//*C*//*M*/int maxDepth(TreeNode *root) {\n\t\tif (root == NULL)\n\t\t\treturn 0; \n\t\tint lmax = maxDepth(root->left); \n\t\tint rmax = maxDepth(root->right); \n\t\treturn max(lmax, rmax) + 1; \n\t} int maxDepth(TreeNode *root) {\n\t\tif (root == NULL)\n\t\t\treturn 0; \n\t\tint lmax = maxDepth(root->left); \n\t\tint rmax = maxDepth(root->right); \n\t\treturn max(lmax, rmax) + 1; \n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-178692090\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"2114158892\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"250339945\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\n        std::sort (citations.begin(), citations.end());    \n        \n        int length = citations.size(); \n        for(int i =0;  i< length;  i++) {\n            int h = length - i; \n            if(h<= citations[i]) {\n                \n                return h; \n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [2], \"citations_element0\": [\"587576534\"], \"citations_element1\": [\"-1504429951\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\n        std::sort (citations.begin(), citations.end());    \n        \n        int length = citations.size(); \n        for(int i =0;  i< length;  i++) {\n            int h = length - i; \n            if(h<= citations[i]) {\n                \n                \n            }\n        }\n        \n        return 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [3], \"citations_element0\": [\"-1076544479\"], \"citations_element1\": [\"-748644620\"], \"citations_element2\": [\"-232363815\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\n        int start = 0, end = citations.size()-1; \n        \n        int max_h = 0; \n        while(start<=end) {\n            int mid = start + (end - start)/2; \n            int h = citations.size() - mid; \n            if(h<= citations[mid]) {\n                end = mid -1; \n                max_h = h; \n            } else {\n                start = mid +1; \n            }\n        }\n        \n        return max_h; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [3], \"citations_element0\": [\"1919570907\"], \"citations_element1\": [\"-1924914188\"], \"citations_element2\": [\"1169562912\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char *strStr. /*FC*/class Solution {\n/*FM*/char *strStr(char *haystack, char *needle) {\n\t\tif (haystack == NULL || needle == NULL) \n\t\tint hlen = strlen(haystack); \n\t\tint nlen = strlen(needle); \n\t\tif (nlen == 0) \n\t\tif (hlen == 0 ) \n\t\tint pattern[100000]; \n\t\tGeneratePattern(needle, nlen, pattern); \n\t\treturn Match(haystack, needle, pattern); \n\t};/*F*//*C*//*M*/void GeneratePattern(char* str, int len, int* pattern)\n\t{\n\t\tpattern[0] = -1; \n\t\tint k = -1; \n\t\tfor (int j = 1;  j < len;  j++)\n\t\t{\n\t\t\twhile (k > -1 && str[k + 1] != str[j])\n\t\t\t\tk = pattern[k]; \n\t\t\tif (str[k + 1] == str[j])\n\t\t\t\tk++; \n\t\t\tpattern[j] = k; \n\t\t}\n\t} char* Match(char* haystack, char* needle, int* pattern)\n\t{\n\t\tint hlen = strlen(haystack); \n\t\tint nlen = strlen(needle); \n\t\tint k = -1; \n\t\tfor (int j = 0;  j < hlen;  j++, haystack++)\n\t\t{\n\t\t\twhile (k > -1 && needle[k + 1] != *haystack)\n\t\t\t\tk = pattern[k]; \n\t\t\tif (needle[k + 1] == *haystack)\n\t\t\t\tk++; \n\t\t\tif (k == nlen - 1)\n\t\t\t\treturn haystack - k; \n\t\t}\n\t\treturn NULL; \n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [1], \"haystack[0]\": [\"110\"], \"haystack[1]\": [\"-121\"], \"needle\": [1], \"needle[0]\": [\"87\"], \"needle[1]\": [\"105\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void GeneratePattern. /*FC*/class Solution {\n/*FM*/void GeneratePattern(char* str, int len, int* pattern)\n\t{\n\t\tpattern[0] = -1; \n\t\tint k = -1; \n\t\tfor (int j = 1;  j < len;  j++)\n\t\t{\n\t\t\twhile (k > -1 && str[k + 1] != str[j])\n\t\t\t\tk = pattern[k]; \n\t\t\tif (str[k + 1] == str[j])\n\t\t\t\tk++; \n\t\t\tpattern[j] = k; \n\t\t}\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [1], \"str[0]\": [\"-78\"], \"str[1]\": [\"0\"], \"len\": [\"9\"], \"pattern\": [3], \"pattern[0]\": [\"608585758\"], \"pattern[1]\": [\"1600065914\"], \"pattern[2]\": [\"-1078780463\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char* Match. /*FC*/class Solution {\n/*FM*/char* Match(char* haystack, char* needle, int* pattern)\n\t{\n\t\tint hlen = strlen(haystack); \n\t\tint nlen = strlen(needle); \n\t\tint k = -1; \n\t\tfor (int j = 0;  j < hlen;  j++, haystack++)\n\t\t{\n\t\t\twhile (k > -1 && needle[k + 1] != *haystack)\n\t\t\t\t\n\t\t\tif (needle[k + 1] == *haystack)\n\t\t\t\t\n\t\t\tif (k == nlen - 1)\n\t\t\t\t\n\t\t}\n\t\treturn NULL; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [1], \"haystack[0]\": [\"-88\"], \"haystack[1]\": [\"-20\"], \"pattern\": [2], \"pattern[0]\": [\"-691851130\"], \"pattern[1]\": [\"-902826089\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char* Match. /*FC*/class Solution {\n/*FM*/char* Match(char* haystack, char* needle, int* pattern)\n\t{\n\t\tint hlen = strlen(haystack); \n\t\tint nlen = strlen(needle); \n\t\tint k = -1; \n\t\tfor (int j = 0;  j < hlen;  j++, haystack++)\n\t\t{\n\t\t\twhile (k > -1 && needle[k + 1] != *haystack)\n\t\t\t\t\n\t\t\tif (needle[k + 1] == *haystack)\n\t\t\t\tk++; \n\t\t\tif (k == nlen - 1)\n\t\t\t\treturn haystack - k; \n\t\t}\n\t\t\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [1], \"haystack[0]\": [\"31\"], \"haystack[1]\": [\"64\"], \"needle\": [1], \"needle[0]\": [\"-86\"], \"needle[1]\": [\"-121\"], \"pattern\": [1], \"pattern[0]\": [\"1224160549\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution {\n/*FM*/string intToRoman(int num) {\n\t\tchar symbol[7] = { 'I', 'V', 'X', 'L', 'C', 'D', 'M'}; \n\t\tstring roman; \n\t\tint scale = 1000; \n\t\tfor (int i = 6;  i >= 0;  i -= 2)\n\t\t{\n\t\t\tint digit = num / scale; \n\t\t\tif (digit != 0)\n\t\t\t{\n\t\t\t\tif (digit <= 3)\n\t\t\t\t{\n\t\t\t\t\troman.append(digit, symbol[i]); \n\t\t\t\t}\n\t\t\t\telse if (digit == 4)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (digit == 5)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (digit <= 8)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (digit == 9)\n\t\t\t\t{\n\t\t\t\t\troman.append(1, symbol[i]); \n\t\t\t\t\troman.append(1, symbol[i + 2]); \n\t\t\t\t}\n\t\t\t}\n\t\t\tnum = num % scale; \n\t\t\tscale /= 10; \n\t\t}\n\t\treturn roman; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1404220290\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution {\n/*FM*/string intToRoman(int num) {\n\t\tchar symbol[7] = { 'I', 'V', 'X', 'L', 'C', 'D', 'M'}; \n\t\tstring roman; \n\t\tint scale = 1000; \n\t\tfor (int i = 6;  i >= 0;  i -= 2)\n\t\t{\n\t\t\tint digit = num / scale; \n\t\t\tif (digit != 0)\n\t\t\t{\n\t\t\t\tif (digit <= 3)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (digit == 4)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (digit == 5)\n\t\t\t\t{\n\t\t\t\t\troman.append(1, symbol[i + 1]); \n\t\t\t\t}\n\t\t\t\telse if (digit <= 8)\n\t\t\t\t{\n\t\t\t\t\troman.append(1, symbol[i + 1]); \n\t\t\t\t\troman.append(digit - 5, symbol[i]); \n\t\t\t\t}\n\t\t\t\telse if (digit == 9)\n\t\t\t\t{\n\t\t\t\t\troman.append(1, symbol[i]); \n\t\t\t\t\troman.append(1, symbol[i + 2]); \n\t\t\t\t}\n\t\t\t}\n\t\t\tnum = num % scale; \n\t\t\tscale /= 10; \n\t\t}\n\t\treturn roman; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1649788965\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution {\n/*FM*/string intToRoman(int num) {\n\t\tchar symbol[7] = { 'I', 'V', 'X', 'L', 'C', 'D', 'M'}; \n\t\tstring roman; \n\t\tint scale = 1000; \n\t\tfor (int i = 6;  i >= 0;  i -= 2)\n\t\t{\n\t\t\tint digit = num / scale; \n\t\t\tif (digit != 0)\n\t\t\t{\n\t\t\t\tif (digit <= 3)\n\t\t\t\t{\n\t\t\t\t\troman.append(digit, symbol[i]); \n\t\t\t\t}\n\t\t\t\telse if (digit == 4)\n\t\t\t\t{\n\t\t\t\t\troman.append(1, symbol[i]); \n\t\t\t\t\troman.append(1, symbol[i + 1]); \n\t\t\t\t}\n\t\t\t\telse if (digit == 5)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (digit <= 8)\n\t\t\t\t{\n\t\t\t\t\troman.append(1, symbol[i + 1]); \n\t\t\t\t\troman.append(digit - 5, symbol[i]); \n\t\t\t\t}\n\t\t\t\telse if (digit == 9)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum = num % scale; \n\t\t\tscale /= 10; \n\t\t}\n\t\treturn roman; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"36452614\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int>& nums) {\n    int n = nums.size(); \n    int maxCover = 0;   \n    for(int start =0;  start<= maxCover && start<n;  )  \n    {  \n      if(nums[start]+start > maxCover)  \n        maxCover = nums[start]+start;   \n        if(maxCover >= n-1) return true;   \n    }  \n      \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1224255788\"], \"nums_element1\": [\"907229388\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int>& nums) {\n    int n = nums.size(); \n    int maxCover = 0;   \n    for(int start =0;  start<= maxCover && start<n;  start++)  \n    {  \n      if(nums[start]+start > maxCover)  \n          \n        if(maxCover >= n-1)   \n    }  \n    return false;   \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1497644237\"], \"nums_element1\": [\"1156285712\"], \"nums_element2\": [\"-1169703912\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/class Solution {\n/*FM*/int jump(vector<int>& nums) {\n    int start = 0;    \n    int end = 0;    \n    int count =0;    \n    int n = nums.size(); \n    if(n == 1)    \n    while(end < n)   \n    {   \n      int max = 0;    \n      count++;    \n      for(int i =start;  i<= end ;   )   \n      {    \n        if(nums[i]+i >= n-1)   \n        {        \n          return count;    \n        }   \n        if(nums[i]+ i > max)   \n             \n      }   \n         \n            \n    }   \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1621705642\"], \"nums_element1\": [\"1236867576\"], \"nums_element2\": [\"101112397\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/class Solution {\n/*FM*/int jump(vector<int>& nums) {\n    int start = 0;    \n    int end = 0;    \n    int count =0;    \n    int n = nums.size(); \n    if(n == 1) return 0;    \n       \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-484381063\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestRectangleArea. /*FC*/class Solution {\n/*FM*/int largestRectangleArea(vector<int>& h) {\n    stack<int> S; \n    h.push_back(0);   \n    int sum = 0; \n    for (int i = 0;  i < h.size();  i++) {\n      if (S.empty() || h[i] > h[S.top()]) S.push(i); \n      else {\n        int tmp = S.top(); \n        S.pop(); \n        sum = max(sum, h[tmp] * (S.empty() ? i : i - S.top() - 1)); \n        i--; \n      }\n    }\n    return sum; \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"h\": [3], \"h_element0\": [\"-228466864\"], \"h_element1\": [\"1807653637\"], \"h_element2\": [\"137130868\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(const char *s) {\n        const char* pStart = s; \n        const char* pEnd = s; \n        const char* p = s; \n        const char* pre = s; \n\n        while (*p != '\\0')\n        {\n            if (*pre == ' ' && *p != ' ') \n            if (*pre != ' ' && *p == ' ') \n\n            pre = p; \n            p++; \n        }\n\n        if (*pre != ' ' && *p == '\\0') pEnd = p; \n        return pEnd - pStart; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [1], \"s_constantPointer[0]\": [\"33\"], \"s_constantPointer[1]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void Generater. /*FC*/class Solution {\n/*FM*/void Generater(string trans[], string& digits,\n                 int deep, string& result, vector<string>& set)\n  {\n    if (deep == digits.size())\n    {\n      \n      \n    }\n\n    \n    int curDig = digits[deep] - 48; \n    \n  };/*F*//*C*//*M*/void Generater(string trans[], string& digits,\n                 int deep, string& result, vector<string>& set)\n  {\n    if (deep == digits.size())\n    {\n      if (result != \"\")\n        set.push_back(result); \n      return; \n    }\n\n    \n    int curDig = digits[deep] - 48; \n    for (int i = 0;  i < trans[curDig].size();  i++)\n    {\n      result.push_back(trans[curDig][i]); \n      Generater(trans, digits, deep + 1, result, set); \n      result.resize(result.size() - 1); \n    }\n  } void Generater(string trans[], string& digits,\n                 int deep, string& result, vector<string>& set)\n  {\n    if (deep == digits.size())\n    {\n      if (result != \"\")\n        set.push_back(result); \n      return; \n    }\n\n    \n    int curDig = digits[deep] - 48; \n    for (int i = 0;  i < trans[curDig].size();  i++)\n    {\n      result.push_back(trans[curDig][i]); \n      Generater(trans, digits, deep + 1, result, set); \n      result.resize(result.size() - 1); \n    }\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"trans\": [3], \"trans[0]\": [\"1\"], \"trans[1]\": [\"2\"], \"trans[2]\": [\"3\"], \"digits\": [\"2\"], \"deep\": [\"-723757403\"], \"result\": [\"1\"], \"set\": [3], \"set_element0\": [\"3\"], \"set_element1\": [\"1\"], \"set_element2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reverseWords. /*FC*/class Solution {\n/*FM*/void reverseWords(string &s) {\n        stack<string> sstack; \n        int flag = 0; \n        string temp = \"\"; \n        for(int i = 0;  i < s.length();  i++) {\n            if(s[i] != ' ' && flag == 0) {\n                temp = \"\"; \n                temp += s[i]; \n                flag = 1; \n            } else if(s[i] != ' ') {\n                \n            } else if(s[i] == ' ' && flag == 1){\n                \n                \n            }\n            if(i == s.length() - 1 && flag == 1)\n                sstack.push(temp); \n        }\n        s = \"\"; \n        while(!sstack.empty()) {\n            string temp = sstack.top(); \n            s += temp; \n            sstack.pop(); \n            if(!sstack.empty())\n                \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProduct. /*FC*/class Solution {\n/*FM*/int maxProduct(vector<int>& nums) {\n        if (nums.size() == 0) \n        int result = nums[0], maxValue = nums[0], minValue = nums[0]; \n        for (int i = 1;  i < nums.size();  i++) {\n            int tempMax = max(nums[i], maxValue * nums[i]); \n            int tempMin = min(nums[i], maxValue * nums[i]); \n            maxValue = max(tempMax, minValue * nums[i]); \n            minValue = min(tempMin, minValue * nums[i]); \n            result = max(maxValue, result); \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1415885941\"], \"nums_element1\": [\"-1808036730\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMin. /*FC*/class Solution {\n/*FM*/int findMin(vector<int>& nums) {\n        int low = 0, high = nums.size() - 1; \n        while(low < high) {\n            int mid = (low + high) / 2; \n            if(nums[mid] < nums[high])\n                high = mid; \n            else\n                low = mid + 1; \n        }\n        return nums[low]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-116606699\"], \"nums_element1\": [\"-2139409303\"], \"nums_element2\": [\"-680406010\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getlength. /*FC*/class Solution {\n/*FM*/int getlength(ListNode *A) {\n        int len = 0; \n        while(A != NULL) {\n            len++; \n            A = A->next; \n        }\n        return len; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A[0]\": [\"ListNode\", \"ListNode(int)\"], \"A0_x\": [\"467311296\"], \"A[0].next\": [1], \"A[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"A0_next0_x\": [\"1673375287\"], \"A[1]\": [\"ListNode\", \"ListNode(int)\"], \"A1_x\": [\"1717099938\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPeakElement. /*FC*/class Solution {\n/*FM*/int findPeakElement(vector<int>& nums) {\n        if(nums.size() == 1 || (nums[0] > nums[1]))\n            \n        if(nums[nums.size() - 1] > nums[nums.size() - 2]) {\n            \n        }\n        for(int i = 1;  i < nums.size() - 1;  ) {\n            if(nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                return i; \n            }\n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1509093242\"], \"nums_element1\": [\"-190764589\"], \"nums_element2\": [\"-2099546070\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPeakElement. /*FC*/class Solution {\n/*FM*/int findPeakElement(vector<int>& nums) {\n        if(nums.size() == 1 || (nums[0] > nums[1]))\n            return 0; \n        if(nums[nums.size() - 1] > nums[nums.size() - 2]) {\n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1777071459\"], \"nums_element1\": [\"941651143\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> twoSum. /*FC*/class Solution {\n/*FM*/vector<int> twoSum(vector<int>& numbers, int target) {\n        vector<int> result(2); \n        for(int i = 0;  i < numbers.size();  i++) {\n            for(int j = i + 1;  j < numbers.size();  j++) {\n                if(numbers[i] + numbers[j] == target) {\n                    \n                    \n                    \n                } else if(numbers[i] + numbers[j] > target) {\n                    \n                }\n            }\n            if(result[0] != 0)\n                \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numbers\": [2], \"numbers_element0\": [\"893187254\"], \"numbers_element1\": [\"-1874129200\"], \"target\": [\"1097476114\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> twoSum. /*FC*/class Solution {\n/*FM*/vector<int> twoSum(vector<int>& numbers, int target) {\n        vector<int> result(2); \n        for(int i = 0;  i < numbers.size();  i++) {\n            for(int j = i + 1;  j < numbers.size();  ) {\n                if(numbers[i] + numbers[j] == target) {\n                    \n                    \n                    \n                } else if(numbers[i] + numbers[j] > target) {\n                    break; \n                }\n            }\n            if(result[0] != 0)\n                \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numbers\": [3], \"numbers_element0\": [\"1849278981\"], \"numbers_element1\": [\"-338324991\"], \"numbers_element2\": [\"1708083255\"], \"target\": [\"1280034539\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convertToTitle. /*FC*/class Solution {\n/*FM*/string convertToTitle(int n) {\n        string s; \n        while(n) {\n            s = (char)((n - 1) % 26 + 'A') + s; \n            n = (n - 1) / 26; \n        }\n        return s; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1824300771\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDistinct. /*FC*/class Solution {\n/*FM*/int numDistinct(string S, string T) {\n\t\tint match[200]; \n\t\tif (S.size() < T.size()) \n\t\tmatch[0] = 1; \n\t\tfor (int i = 1;  i <= T.size();  i++)\n\t\t\tmatch[i] = 0; \n\t\tfor (int i = 1;  i <= S.size();  i ++)\n\t\t\tfor (int j = T.size();  j >= 1;  j--)\n\t\t\t\tif (S[i - 1] == T[j - 1])\n\t\t\t\t\t\n\t\treturn match[T.size()]; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"], \"T\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/class Solution {\n/*FM*/int divide(int dividend, int divisor) {\n\t\tint sign = 1; \n\t\tif (dividend == 0) \n\t\tif (dividend < 0) \n\t\tif (divisor < 0) sign *= -1; \n\t\tunsigned int dvd = dividend > 0 ? dividend : -dividend; \n\t\tunsigned int dvs = divisor > 0 ? divisor : -divisor;  \n\t\tunsigned int inc[32]; \n\t\tunsigned int migValue = dvs; \n\t\tint i = 0; \n\t\twhile (migValue > 0 && migValue <= dvd)\n\t\t{\n\t\t\tinc[i] = migValue; \n\t\t\tmigValue = migValue << 1; \n\t\t\ti++; \n\t\t}\n\t\ti--; \n\t\tunsigned int res = 0; \n\t\twhile (i >= 0 && dvd != 0)\n\t\t{\n\t\t\tif (dvd >= inc[i])\n\t\t\t{\n\t\t\t\tdvd = dvd - inc[i]; \n\t\t\t\tres += 1 << i; \n\t\t\t}\n\t\t\ti--; \n\t\t}\n\t\tres *= sign; \n\t\treturn res; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dividend\": [\"787865649\"], \"divisor\": [\"-381420329\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/class Solution {\n/*FM*/int divide(int dividend, int divisor) {\n\t\tint sign = 1; \n\t\tif (dividend == 0) \n\t\tif (dividend < 0) \n\t\tif (divisor < 0) \n\t\tunsigned int dvd = dividend > 0 ? dividend : -dividend; \n\t\tunsigned int dvs = divisor > 0 ? divisor : -divisor;  \n\t\tunsigned int inc[32]; \n\t\tunsigned int migValue = dvs; \n\t\tint i = 0; \n\t\twhile (migValue > 0 && migValue <= dvd)\n\t\t{\n\t\t\tinc[i] = migValue; \n\t\t\tmigValue = migValue << 1; \n\t\t\ti++; \n\t\t}\n\t\ti--; \n\t\tunsigned int res = 0; \n\t\twhile (i >= 0 && dvd != 0)\n\t\t{\n\t\t\tif (dvd >= inc[i])\n\t\t\t{\n\t\t\t\tdvd = dvd - inc[i]; \n\t\t\t\tres += 1 << i; \n\t\t\t}\n\t\t\ti--; \n\t\t}\n\t\tres *= sign; \n\t\treturn res; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dividend\": [\"1904486058\"], \"divisor\": [\"167655176\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/class Solution {\n/*FM*/int minDistance(string word1, string word2) {\n\t\tif (word1.size() < word2.size())\n\t\t\t\n\t\tint * matchUp = new int[20000]; \n\t\tint* matchDown = new int[20000]; \n\t\tfor (int i = 0;  i <= word2.size();  i++)\n\t\t{\n\t\t\tmatchUp[i] = 0; \n\t\t\tmatchDown[i] = i; \n\t\t}\n\t\tfor (int i = 1;  i <= word1.size();  i++)\n\t\t{\n\t\t\tmatchUp[0] = i; \n\t\t\tfor (int j = 1;  j <= word2.size();  j++)\n\t\t\t{\n\t\t\t\tif (word1[i - 1] == word2[j - 1])\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmatchUp[j] = min(matchDown[j], matchDown[j - 1]); \n\t\t\t\t\tmatchUp[j] = min(matchUp[j], matchUp[j - 1]) + 1; \n\t\t\t\t}\n\t\t\t}\n\t\t\tint* temp = matchUp; \n\t\t\tmatchUp = matchDown; \n\t\t\tmatchDown = temp; \n\t\t}\n\t\treturn matchDown[word2.size()]; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word1\": [\"3\"], \"word2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstMissingPositive. /*FC*/class Solution {\n/*FM*/int firstMissingPositive(vector<int>& nums) {\n\t\tint i = 0; \n\t\tint n = nums.size(); \n\t\tfor (int i = 0;  i < n;  i++)\n\t\t{\n\t\t\twhile (nums[i] != i + 1)\n\t\t\t{\n\t\t\t\tif (nums[i] <= 0 || nums[i] > n || nums[i] == nums[nums[i] - 1]) break; \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0;  i < n;  )\n\t\t\tif (nums[i] != i + 1)\n\t\t\t\treturn i + 1; \n\t\t\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1855471353\"], \"nums_element1\": [\"-1336249172\"], \"nums_element2\": [\"69414847\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void flatten. /*FC*/class Solution {\n/*FM*/void flatten(TreeNode *root) {\n\t\tif (root == NULL) return; \n\n\t\tTreeNode* right = root->right; \n\t\tif (lastVisitedNode != NULL)\n\t\t{\n\t\t\tlastVisitedNode->left = NULL; \n\t\t\tlastVisitedNode->right = root; \n\t\t}\n\t\tlastVisitedNode = root; \n\t\tflatten(root->left); \n\t\tflatten(right); \n\t};/*F*/TreeNode *lastVisitedNode = NULL;/*C*//*M*/void flatten(TreeNode *root) {\n\t\tif (root == NULL) return; \n\n\t\tTreeNode* right = root->right; \n\t\tif (lastVisitedNode != NULL)\n\t\t{\n\t\t\tlastVisitedNode->left = NULL; \n\t\t\tlastVisitedNode->right = root; \n\t\t}\n\t\tlastVisitedNode = root; \n\t\tflatten(root->left); \n\t\tflatten(right); \n\t} void flatten(TreeNode *root) {\n\t\tif (root == NULL) return; \n\n\t\tTreeNode* right = root->right; \n\t\tif (lastVisitedNode != NULL)\n\t\t{\n\t\t\tlastVisitedNode->left = NULL; \n\t\t\tlastVisitedNode->right = root; \n\t\t}\n\t\tlastVisitedNode = root; \n\t\tflatten(root->left); \n\t\tflatten(right); \n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->lastVisitedNode\": [3], \"AKA_INSTANCE___Solution->lastVisitedNode[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"AKA_INSTANCE___Solution_lastVisitedNode0_x\": [\"1114795889\"], \"AKA_INSTANCE___Solution->lastVisitedNode[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"AKA_INSTANCE___Solution_lastVisitedNode1_x\": [\"-1993601462\"], \"AKA_INSTANCE___Solution->lastVisitedNode[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"AKA_INSTANCE___Solution_lastVisitedNode2_x\": [\"-2135627499\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"99881140\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"293649495\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1992228335\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int canCompleteCircuit. /*FC*/class Solution {\n/*FM*/int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\n\t\tvector<int> diff(gas.size()); \n\t\tfor (int i = 0;  i < gas.size();  ++i)\n\t\t{\n\t\t\tdiff[i] = gas[i] - cost[i]; \n\t\t}\n\t\tint leftGas = 0, sum = 0, startnode = 0; \n\t\tfor (int i = 0;  i < gas.size();  ++i)\n\t\t{\n\t\t\tleftGas += diff[i]; \n\t\t\tsum += diff[i]; \n\t\t\tif (sum < 0) \n\t\t\t{\n\t\t\t\tstartnode = i + 1; \n\t\t\t\tsum = 0; \n\t\t\t}\n\t\t}\n\t\tif (leftGas < 0)\n\t\t\treturn -1; \n\t\telse\n\t\t\t\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"gas\": [1], \"gas_element0\": [\"937289850\"], \"cost\": [2], \"cost_element0\": [\"-1833201190\"], \"cost_element1\": [\"1196860001\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int canCompleteCircuit. /*FC*/class Solution {\n/*FM*/int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\n\t\tvector<int> diff(gas.size()); \n\t\tfor (int i = 0;  i < gas.size();  ++i)\n\t\t{\n\t\t\tdiff[i] = gas[i] - cost[i]; \n\t\t}\n\t\tint leftGas = 0, sum = 0, startnode = 0; \n\t\tfor (int i = 0;  i < gas.size();  ++i)\n\t\t{\n\t\t\tleftGas += diff[i]; \n\t\t\tsum += diff[i]; \n\t\t\tif (sum < 0) \n\t\t\t{\n\t\t\t\tstartnode = i + 1; \n\t\t\t\tsum = 0; \n\t\t\t}\n\t\t}\n\t\tif (leftGas < 0)\n\t\t\t\n\t\telse\n\t\t\treturn startnode; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"gas\": [3], \"gas_element0\": [\"-285605742\"], \"gas_element1\": [\"1570242937\"], \"gas_element2\": [\"1504881029\"], \"cost\": [1], \"cost_element0\": [\"1249469597\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> generateParenthesis. /*FC*/class Solution {\n/*FM*/vector<string> generateParenthesis(int n) {\n\t\tvector<string> result; \n\t\tstring sample; \n\t\tif (n != 0)\n\t\t\tCombinationPar(result, sample, 0, n, 0, 0); \n\t\treturn result; \n\t};/*F*//*C*//*M*/void CombinationPar(vector<string>& result, string& sample,\n\t                    int deep, int n, int leftNum, int rightNum)\n\t{\n\t\tif (deep == 2 * n)\n\t\t{\n\t\t\tresult.push_back(sample); \n\t\t\treturn; \n\t\t}\n\t\tif (leftNum < n)\n\t\t{\n\t\t\tsample.push_back('('); \n\t\t\tCombinationPar(\n\t\t\t    result, sample, deep + 1, n, leftNum + 1, rightNum); \n\t\t\tsample.resize(sample.size() - 1); \n\t\t}\n\t\tif (rightNum < leftNum)\n\t\t{\n\t\t\tsample.push_back(')'); \n\t\t\tCombinationPar(\n\t\t\t    result, sample, deep + 1, n, leftNum, rightNum + 1); \n\t\t\tsample.resize(sample.size() - 1); \n\t\t}\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-1231405852\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution {\n/*FM*/int maxArea(vector<int> &height) {\n\t\tint start = 0; \n\t\tint end = height.size() - 1; \n\t\tint maxV = INT_MIN; \n\t\twhile (start < end)\n\t\t{\n\t\t\tint contain = min(height[end], height[start]) * (end - start); \n\t\t\tmaxV = max(maxV, contain); \n\t\t\tif (height[start] <= height[end])\n\t\t\t{\n\t\t\t\tstart++; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tend--; \n\t\t\t}\n\t\t}\n\t\treturn maxV; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [3], \"height_element0\": [\"-720420338\"], \"height_element1\": [\"-205071551\"], \"height_element2\": [\"-1772530273\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *BuildTree. /*FC*/class Solution {\n/*FM*/TreeNode *BuildTree(vector<int> &num, int start, int end)\n\t{\n\t\tif (start > end) return NULL; \n\t\tif (start == end) \n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t};/*F*//*C*//*M*/TreeNode *BuildTree(vector<int> &num, int start, int end)\n\t{\n\t\tif (start > end) return NULL; \n\t\tif (start == end) return new TreeNode(num[start]); \n\t\tint mid = (start + end) / 2; \n\t\tTreeNode *node = new TreeNode(num[mid]); \n\t\tnode->left = BuildTree(num, start, mid - 1); \n\t\tnode->right = BuildTree(num, mid + 1, end); \n\t\treturn node; \n\t} TreeNode *BuildTree(vector<int> &num, int start, int end)\n\t{\n\t\tif (start > end) return NULL; \n\t\tif (start == end) return new TreeNode(num[start]); \n\t\tint mid = (start + end) / 2; \n\t\tTreeNode *node = new TreeNode(num[mid]); \n\t\tnode->left = BuildTree(num, start, mid - 1); \n\t\tnode->right = BuildTree(num, mid + 1, end); \n\t\treturn node; \n\t} TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [2], \"num_element0\": [\"535907090\"], \"num_element1\": [\"-2119327318\"], \"start\": [\"-550576263\"], \"end\": [\"-1153102220\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *sortedListToBST. /*FC*/class Solution {\n/*FM*/TreeNode *sortedListToBST(ListNode *head) {\n\t\tint len = 0; \n\t\tListNode *p = head; \n\t\twhile (p)\n\t\t{\n\t\t\tlen++; \n\t\t\tp = p->next; \n\t\t}\n\t\treturn BuildBST(head, 0, len - 1); \n\t};/*F*//*C*//*M*/TreeNode* BuildBST(ListNode*& list, int start, int end)\n\t{\n\t\tif (start > end) return NULL; \n\t\tint mid = (start + end) / 2; \n\t\tTreeNode *leftChild = BuildBST(list, start, mid - 1); \n\t\tTreeNode *parent = new TreeNode(list->val); \n\t\tparent->left = leftChild; \n\t\tlist = list->next; \n\t\tparent->right = BuildBST(list, mid + 1, end); \n\t\treturn parent; \n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1627374467\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1629429134\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string countAndSay. /*FC*/class Solution {\n/*FM*/string countAndSay(int n) {\n\t\tstring seq = \"1\"; \n\t\tint it = 1; \n\t\twhile (it < n)\n\t\t{\n\t\t\tstringstream newSeq; \n\t\t\tchar last = seq[0]; \n\t\t\tint count = 0; \n\t\t\tfor (int i = 0;  i <= seq.size();  i++)\n\t\t\t{\n\t\t\t\tif (seq[i] == last)\n\t\t\t\t{\n\t\t\t\t\tcount ++; \n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewSeq << count << last; \n\t\t\t\t\tlast = seq[i]; \n\t\t\t\t\tcount = 1; \n\t\t\t\t}\n\t\t\t}\n\t\t\tseq = newSeq.str(); \n\t\t\tit++; \n\t\t}\n\t\treturn seq; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> diffWaysToCompute. /*FC*/class Solution {\n/*FM*/vector<int> diffWaysToCompute(string input) {\n        return diffWaysToComputeWithMemo(input, 0, input.size()-1); \n    };/*F*//*C*//*M*/vector<int> diffWaysToComputeWithMemo(string& input, int startIndex, int endIndex) {    \n        string cache_key = generateKey(startIndex, endIndex); \n        if(memo.find(cache_key) != memo.end()) return memo[cache_key]; \n        \n        int number = 0, i=startIndex; \n        for(;  i<= endIndex && isdigit(input[i]);  ++i) {\n            number  = number * 10 + input[i]-'0'; \n        }\n        \n        if(i > endIndex)  return {number}; \n        \n        vector<int> diffWays, lefts, rights; \n        for(int i =startIndex;  i< endIndex;  i++) {\n            if(isdigit(input[i])) continue; \n            lefts = \n                diffWaysToComputeWithMemo(input, startIndex, i-1); \n            rights = \n                diffWaysToComputeWithMemo(input, i+1, endIndex ); \n            for(int j = 0;  j < lefts.size();  ++j) \n                for( int k =0;  k < rights.size();  ++k) \n                    diffWays.push_back(compute(lefts[j], rights[k], input[i])); \n        }\n        memo[cache_key] = diffWays; \n        return diffWays; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"input\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> inorderTraversal. /*FC*/class Solution {\n/*FM*/vector<int> inorderTraversal(TreeNode *root) {\n\t\tvector<TreeNode*> sta; \n\t\tvector<int> result; \n\t\tif (root == NULL) \n\t\tTreeNode* node = root; \n\t\twhile (sta.size() > 0 || node != NULL)\n\t\t{\n\t\t\twhile (node != NULL)\n\t\t\t{\n\t\t\t\tsta.push_back(node); \n\t\t\t\tnode = node->left; \n\t\t\t}\n\t\t\tnode = sta.back(); \n\t\t\tsta.pop_back(); \n\t\t\tresult.push_back(node->val); \n\t\t\tnode = node->right; \n\t\t}\n\t\treturn result; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int> > levelOrder(TreeNode *root) {\n\t\tvector<vector<int> > result; \n\t\tif (root == NULL) \n\t\tqueue<TreeNode*> nodeQ; \n\t\tnodeQ.push(root); \n\t\tint nextLevelCnt = 0, currentLevelCnt = 1; \n\t\tvector<int> layer; \n\t\tint visitedCnt = 0; \n\t\twhile (nodeQ.size() != 0)\n\t\t{\n\t\t\tTreeNode* node = nodeQ.front(); \n\t\t\tnodeQ.pop(); \n\t\t\tvisitedCnt++; \n\t\t\tlayer.push_back(node->val); \n\t\t\tif (node->left != NULL)\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tif (node->right != NULL)\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tif (visitedCnt == currentLevelCnt)\n\t\t\t{\n\t\t\t\tvisitedCnt = 0; \n\t\t\t\tcurrentLevelCnt = nextLevelCnt; \n\t\t\t\tnextLevelCnt = 0; \n\t\t\t\tresult.push_back(layer); \n\t\t\t\tlayer.clear(); \n\t\t\t}\n\t\t}\n\t\treturn result; \n\t};/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"0\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> preorderTraversal. /*FC*/class Solution {\n/*FM*/vector<int> preorderTraversal(TreeNode *root) {\n\t\tstack<TreeNode*> tStack; \n\t\tvector<int> result; \n\t\twhile (tStack.size() > 0 || root != NULL)\n\t\t{\n\t\t\tif (root != NULL)\n\t\t\t{\n\t\t\t\tresult.push_back(root->val); \n\t\t\t\tif (root->right != NULL)\n\t\t\t\t\t\n\t\t\t\troot = root->left; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn result; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"0\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int climbStairs. /*FC*/class Solution {\n/*FM*/int climbStairs(int n) {\n\t\tint fn_2 = 1, fn_1 = 2; \n\t\tif (n == 1) \n\t\tif (n == 2) \n\t\tint fn; \n\t\tfor (int i = 3;  i <= n;  i++)\n\t\t{\n\t\t\tfn = fn_2 + fn_1; \n\t\t\tfn_2 = fn_1; \n\t\t\tfn_1 = fn; \n\t\t}\n\t\treturn fn; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void GetCombine. /*FC*/class Solution {\n/*FM*/void GetCombine(\n\t    int n,\n\t    int k,\n\t    int level,\n\t    vector<int>& solution,\n\t    vector<vector<int> >& result)\n\t{\n\t\tif (solution.size() == k)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t}\n\t\tfor (int i = level;  i <= n;  i++)\n\t\t{\n\t\t\tsolution.push_back(i); \n\t\t\tGetCombine(n, k, i + 1, solution, result); \n\t\t\tsolution.pop_back(); \n\t\t}\n\t};/*F*//*C*//*M*/void GetCombine(\n\t    int n,\n\t    int k,\n\t    int level,\n\t    vector<int>& solution,\n\t    vector<vector<int> >& result)\n\t{\n\t\tif (solution.size() == k)\n\t\t{\n\t\t\tresult.push_back(solution); \n\t\t\treturn; \n\t\t}\n\t\tfor (int i = level;  i <= n;  i++)\n\t\t{\n\t\t\tsolution.push_back(i); \n\t\t\tGetCombine(n, k, i + 1, solution, result); \n\t\t\tsolution.pop_back(); \n\t\t}\n\t} void GetCombine(\n\t    int n,\n\t    int k,\n\t    int level,\n\t    vector<int>& solution,\n\t    vector<vector<int> >& result)\n\t{\n\t\tif (solution.size() == k)\n\t\t{\n\t\t\tresult.push_back(solution); \n\t\t\treturn; \n\t\t}\n\t\tfor (int i = level;  i <= n;  i++)\n\t\t{\n\t\t\tsolution.push_back(i); \n\t\t\tGetCombine(n, k, i + 1, solution, result); \n\t\t\tsolution.pop_back(); \n\t\t}\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"], \"k\": [\"1615483956\"], \"level\": [\"0\"], \"solution\": [1], \"solution_element0\": [\"-1622678615\"], \"result\": [1], \"result_element0\": [1], \"result_element0_element0\": [\"-142848038\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > threeSum(vector<int> &num) {\n\t\tstd::sort(num.begin(), num.end()); \n\t\tvector<vector<int>> result; \n\t\tfor (int i = 0 ;  i < num.size() ;  i++ )\n\t\t{\n\t\t\tint target = 0 - num[i]; \n\t\t\tint start = i + 1, end = num.size() - 1; \n\t\t\twhile (start < end)\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\n\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t}\n\n\t\t\twhile (i < num.size() - 1 && num[i] == num[i + 1]) \n\t\t}\n\t\treturn result; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [2], \"num_element0\": [\"1368836020\"], \"num_element1\": [\"-1445626909\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\n        int carry = 0; \n        string result; \n        for (\n            int i = a.size() - 1, j = b.size() - 1; \n            i >= 0 || j >= 0; \n            --i, --j\n        )\n        {\n            int ai = i >= 0 ? a[i] - '0' : 0; \n            int bj = j >= 0 ? b[j] - '0' : 0; \n            int val = (ai + bj + carry) % 2; \n            carry = (ai + bj + carry) / 2; \n            result.insert(result.begin(), val + '0'); \n        }\n\n        if (carry == 1)\n        {\n            \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"2\"], \"b\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isBalanced. /*FC*/class Solution {\n/*FM*/bool isBalanced(TreeNode *root) {\n\t\tif (root == NULL) \n\t\tint val = GetBalance(root); \n\t\tif (val == -1) \n\t\treturn true; \n\t};/*F*//*C*//*M*/int GetBalance(TreeNode* node)\n\t{\n\t\tif (node == NULL)\n\t\t\treturn 0; \n\t\tint left = GetBalance(node->left); \n\t\tif (left == -1) return -1; \n\t\tint right = GetBalance(node->right); \n\t\tif (right == -1) return -1; \n\t\tif (left - right > 1 || right - left > 1)\n\t\t\treturn -1; \n\t\treturn left > right ? left + 1 : right + 1; \n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1608495920\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-706709504\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int GetBalance. /*FC*/class Solution {\n/*FM*/int GetBalance(TreeNode* node)\n\t{\n\t\tif (node == NULL)\n\t\t\treturn 0; \n\t\tint left = GetBalance(node->left); \n\t\tif (left == -1) \n\t\tint right = GetBalance(node->right); \n\t\tif (right == -1) \n\t\tif (left - right > 1 || right - left > 1)\n\t\t\t\n\t\treturn left > right ? left + 1 : right + 1; \n\t};/*F*//*C*//*M*/int GetBalance(TreeNode* node)\n\t{\n\t\tif (node == NULL)\n\t\t\treturn 0; \n\t\tint left = GetBalance(node->left); \n\t\tif (left == -1) return -1; \n\t\tint right = GetBalance(node->right); \n\t\tif (right == -1) return -1; \n\t\tif (left - right > 1 || right - left > 1)\n\t\t\treturn -1; \n\t\treturn left > right ? left + 1 : right + 1; \n\t} int GetBalance(TreeNode* node)\n\t{\n\t\tif (node == NULL)\n\t\t\treturn 0; \n\t\tint left = GetBalance(node->left); \n\t\tif (left == -1) return -1; \n\t\tint right = GetBalance(node->right); \n\t\tif (right == -1) return -1; \n\t\tif (left - right > 1 || right - left > 1)\n\t\t\treturn -1; \n\t\treturn left > right ? left + 1 : right + 1; \n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"node\": [1], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"452676054\"], \"node[0].left\": [1], \"node[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_left0_x\": [\"-723672690\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int>&prices) {\n\t\t\n\t\t\n\t\tint minV = INT_MAX;  int max = 0; \n\t\tint diff = 0; \n\t\tfor (int i = 0;  i < prices.size();  i++)\n\t\t{\n\t\t\tif (prices[i] < minV) minV = prices[i]; \n\t\t\tdiff = prices[i] - minV; \n\t\t\tif (max < diff)\n\t\t\t\tmax = diff; \n\t\t}\n\t\treturn max; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"1574380468\"], \"prices_element1\": [\"1981932300\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int>&prices) {\n\t\tint max = 0; \n\t\tint sum = 0; \n\t\tfor (int i = 1;  i < prices.size();  i++)\n\t\t{\n\t\t\tint diff = prices[i] - prices[i - 1]; \n\t\t\tif (diff > 0)\n\t\t\t\t\n\t\t}\n\t\treturn sum; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [3], \"prices_element0\": [\"1350035097\"], \"prices_element1\": [\"505684289\"], \"prices_element2\": [\"66359902\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int>&prices) {\n\t\tint max = 0; \n\t\tint sum = 0; \n\t\tfor (int i = 1;  i < prices.size();  i++)\n\t\t{\n\t\t\tint diff = prices[i] - prices[i - 1]; \n\t\t\tif (diff > 0)\n\t\t\t\tsum += diff; \n\t\t}\n\t\treturn sum; \n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"-2091266554\"], \"prices_element1\": [\"-568805241\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int> &prices) {\n    if (prices.size() <= 1) \n    vector<int> maxFromLeft(prices.size(), 0); \n    vector<int> maxFromRight(prices.size(), 0); \n    int minV = INT_MAX, maxP = INT_MIN; \n    for (int i = 0;  i < prices.size();  i++)\n    {\n      if (minV > prices[i]) minV = prices[i]; \n      int temp = prices[i] - minV; \n      if (temp > maxP) maxP = temp; \n      maxFromLeft[i] = maxP; \n    }\n\n    int maxV = INT_MIN; \n    maxP = INT_MIN; \n    for (int i = prices.size() - 1;  i >= 0;  i--)\n    {\n      if (maxV < prices[i]) maxV = prices[i]; \n      int temp = maxV - prices[i]; \n      if (temp > maxP) maxP = temp; \n      maxFromRight[i] = maxP; \n    }\n\n    int maxProfit = INT_MIN; \n    for (int i = 0;  i < prices.size() - 1;  i++)\n    {\n      int sum = maxFromLeft[i] + maxFromRight[i + 1]; \n      if (sum > maxProfit) maxProfit = sum; \n    }\n    if (maxProfit < maxFromRight[0])\n      \n    return maxProfit; \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [3], \"prices_element0\": [\"-64131444\"], \"prices_element1\": [\"-990651303\"], \"prices_element2\": [\"152652194\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int> &prices) {\n    if (prices.size() <= 1) return 0; \n    \n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n    \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [1], \"prices_element0\": [\"-1358352940\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> grayCode. /*FC*/class Solution {\n/*FM*/vector<int> grayCode(int n) \n    {\n        vector<int>rets; \n        rets.push_back(0); \n        for (int i=0;  i<n;  i++)\n        {\n            int len = rets.size(); \n            for (int j=len-1;  j>=0;  j--)\n            {\n                rets.push_back(rets[j]| (1<<i)); \n            }\n        }\n        return rets; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> grayCode. /*FC*/class Solution {\n/*FM*/vector<int> grayCode(int n) \n    {\n        vector<int>results(1<<n); \n        for (int i=0;  i<(1<<n);  i++)\n            results[i] = (i^(i>>1)); \n        return results; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPrimes. /*FC*/class Solution {\n/*FM*/int countPrimes(int n) \n    {\n        vector<int>isPrime(n, true); \n        int count = 0; \n        for (int i=2;  i<n;  i++)\n        {\n            if (isPrime[i]==false) continue; \n            count++; \n            \n            if (i < sqrt(n))\n                for (int j=2*i;  j<n;  j+=i)\n                    isPrime[j] = false; \n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int computeArea. /*FC*/class Solution {\n/*FM*/int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) \n    {\n        long x1 = max(A,E); \n        long y1 = max(B,F); \n        long x2 = min(C,G); \n        long y2 = min(D,H); \n        \n        long overlap; \n        if (x1>=x2 || y1>=y2)\n            \n        else\n        \n        return (long)(C-A)*(D-B) + (long)(G-E)*(H-F) - overlap; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"-308266067\"], \"B\": [\"-1393701673\"], \"C\": [\"797074516\"], \"D\": [\"650139816\"], \"E\": [\"-1668788327\"], \"F\": [\"-597595549\"], \"G\": [\"909580250\"], \"H\": [\"537213611\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countDigitOne. /*FC*/class Solution {\n/*FM*/int countDigitOne(int n) \n    {\n        string N = to_string(n); \n        long len = N.size(); \n        long count = 0; \n        \n        for (int i=1;  i<=len;  i++)\n        {   \n            long divisor = pow(10,i); \n            count += n/divisor*1*pow(10,i-1); \n\n            int digit = N[len-i]-'0'; \n            \n            if (digit > 1)\n                count += pow(10,i-1); \n            else if (digit == 1)\n                count += n%(int)pow(10,i-1) + 1; \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"104663559\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSelfCrossing. /*FC*/class Solution {\n/*FM*/bool isSelfCrossing(vector<int>& x) \n    {\n        x.insert(x.begin(), 4, 0); \n        \n        int i = 4; \n        while (i<x.size() && x[i]>x[i-2])\n            i++; \n        if (i==x.size()) \n        \n        if (x[i] >= x[i-2]-x[i-4])\n            \n        i++; \n        \n        while (i<x.size() &&  x[i]<x[i-2])\n            \n        \n        if (i==x.size()) \n        else return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [3], \"x_element0\": [\"54833446\"], \"x_element1\": [\"-156527413\"], \"x_element2\": [\"586502976\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSelfCrossing. /*FC*/class Solution {\n/*FM*/bool isSelfCrossing(vector<int>& x) \n    {\n        x.insert(x.begin(), 4, 0); \n        \n        int i = 4; \n        while (i<x.size() && x[i]>x[i-2])\n            \n        if (i==x.size()) \n        \n        if (x[i] >= x[i-2]-x[i-4])\n            \n        i++; \n        \n        while (i<x.size() &&  x[i]<x[i-2])\n            \n        \n        if (i==x.size()) return false; \n        else \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [1], \"x_element0\": [\"-1730156161\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSelfCrossing. /*FC*/class Solution {\n/*FM*/bool isSelfCrossing(vector<int>& x) \n    {\n        x.insert(x.begin(), 4, 0); \n        \n        int i = 4; \n        while (i<x.size() && x[i]>x[i-2])\n            i++; \n        if (i==x.size()) return false; \n        \n        if (x[i] >= x[i-2]-x[i-4])\n            \n        \n        \n             \n        if (i==x.size()) \n        else \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [1], \"x_element0\": [\"422435676\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int integerBreak. /*FC*/class Solution {\n/*FM*/int integerBreak(int n) \n    {\n        if (n==2) \n        if (n==3) \n        if (n==4) \n        if (n%3==0) \n        else if (n%3==1) \n        else return pow(3,n/3)*2; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1217659220\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int integerBreak. /*FC*/class Solution {\n/*FM*/int integerBreak(int n) \n    {\n        if (n==2) \n        if (n==3) \n        if (n==4) \n        if (n%3==0) \n        else if (n%3==1) return pow(3,n/3-1)*4; \n        else \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2018462104\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int integerBreak. /*FC*/class Solution {\n/*FM*/int integerBreak(int n) \n    {\n        if (n==2) \n        if (n==3) \n        if (n==4) \n        if (n%3==0) return pow(3,n/3); \n        else if (n%3==1) \n        else \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-835622226\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int integerBreak. /*FC*/class Solution {\n/*FM*/int integerBreak(int n) \n    {\n        if (n==2) \n        if (n==3) \n        vector<int>dp(n+1,0); \n        dp[2] = 2; \n        dp[3] = 3; \n        for (int i=4;  i<=n;  i++)\n        {\n            int temp = 0; \n            for (int j=2;  j<=i/2;  j++)\n            {\n                if (dp[j]*dp[i-j]>temp)\n                    temp = dp[j]*dp[i-j]; \n            }\n            dp[i] = temp; \n        }\n        return dp[n]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canMeasureWater. /*FC*/class Solution {\n/*FM*/bool canMeasureWater(int x, int y, int z) \n    {\n        if(x + y < z) \n        if (z==x||z==y||z==x+y) \n        return z% __gcd(x, y) ==0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"-1658317300\"], \"y\": [\"240259585\"], \"z\": [\"-1797779290\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canMeasureWater. /*FC*/class Solution {\n/*FM*/bool canMeasureWater(int x, int y, int z) \n    {\n        if(x + y < z) return false; \n        if (z==x||z==y||z==x+y) \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"-1212441179\"], \"y\": [\"-568558530\"], \"z\": [\"-1714675280\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getRandom. /*FC*/class Solution {\n/*FM*/int getRandom() \n    {\n        ListNode* h = node; \n        int k = 0; \n        int x = 0; \n        \n        while (h!=NULL)\n        {\n            k++; \n            int r = rand()%k; \n            if (r==0)\n                x = h->val; \n            h = h->next; \n        }\n        \n        return x; \n    };/*F*/ListNode * node;/*C*/Solution(ListNode* head) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution(ListNode*)\"], \"AKA_INSTANCE___Solution_head\": [2], \"AKA_INSTANCE___Solution_head[0]\": [\"ListNode\", \"ListNode(int)\"], \"AKA_INSTANCE___Solution_head0_x\": [\"1081483773\"], \"AKA_INSTANCE___Solution_head[1]\": [\"ListNode\", \"ListNode(int)\"], \"AKA_INSTANCE___Solution_head1_x\": [\"1348819128\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method static bool cmp. /*FC*/class Solution {\n/*FM*/static bool cmp(pair<int,int>a, pair<int,int>b)\n    {\n        if (a.first==b.first)\n            \n        else\n            return a.first<b.first; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a.first\": [\"1779297259\"], \"a.second\": [\"1435269217\"], \"b.first\": [\"438565037\"], \"b.second\": [\"720492842\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int arrangeCoins. /*FC*/class Solution {\n/*FM*/int arrangeCoins(int n) \n    {\n        if (n==0) \n        long m = n; \n        for (long k = sqrt(2*m)-1;   k < sqrt(2*m);  )\n        {\n            }\n        return -1;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-1081002914\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int arrangeCoins. /*FC*/class Solution {\n/*FM*/int arrangeCoins(int n) \n    {\n        if (n==0) \n        long m = n; \n        for (long k = sqrt(2*m)-1;   k < sqrt(2*m);  )\n        {\n            if (k*(k+1) <= 2*m && 2*m < (k+1)*(k+2))\n                return k; \n        }\n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"247221028\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minMoves2. /*FC*/class Solution {\n/*FM*/int minMoves2(vector<int>& nums) \n    {\n        sort(nums.begin(),nums.end()); \n        int median=nums[nums.size()/2]; \n        int result=0; \n        for (int i=0;  i<nums.size();  i++)\n            result+=abs(nums[i]-median); \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-412294877\"], \"nums_element1\": [\"-1778691725\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int flipLights. /*FC*/class Solution {\n/*FM*/int flipLights(int n, int m) \n    {        \n        if (m==0) {  }\n        \n        if (n==1)\n        {\n            \n        }\n        if (n==2)\n        {\n            \n            if (m>=2) {  }\n        }\n        if (n>=3)\n        {\n            \n            if (m==2) {  }\n            if (m>=3) {  }\n        }\n        \n        return 0;  \n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-619002193\"], \"m\": [\"-1516320323\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int flipLights. /*FC*/class Solution {\n/*FM*/int flipLights(int n, int m) \n    {        \n        if (m==0) {  }\n        \n        if (n==1)\n        {\n            \n        }\n        if (n==2)\n        {\n            \n            if (m>=2) {  }\n        }\n        if (n>=3)\n        {\n            if (m==1) {  }\n            if (m==2) {  }\n            if (m>=3) { return 8;  }\n        }\n        \n         \n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"636330494\"], \"m\": [\"690668604\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pick. /*FC*/class Solution {\n/*FM*/int pick() \n    {\n        int k = rand()%M; \n        if (Map.find(k)!=Map.end())\n            \n        else\n            return k; \n    };/*F*/unordered_map<int,int> Map;  int M;/*C*/Solution(int N, vector<int> blacklist) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution(int,vector<int>)\"], \"AKA_INSTANCE___Solution_N\": [\"-1049372988\"], \"AKA_INSTANCE___Solution_blacklist\": [2], \"AKA_INSTANCE___Solution_blacklist_element0\": [\"1572507093\"], \"AKA_INSTANCE___Solution_blacklist_element1\": [\"-350071989\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reachNumber. /*FC*/class Solution {\n/*FM*/int reachNumber(int target)     \n    {\n        target=abs(target); \n        int sum=0; \n        int i=0; \n        while (!(target<=sum && (target%2==sum%2)))\n        {\n            i++; \n            sum+=i;             \n        }\n        \n        return i; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"-21511813\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int consecutiveNumbersSum. /*FC*/class Solution {\n/*FM*/int consecutiveNumbersSum(int N) \n    {\n        int count = 0; \n        for (int m = 1;  2*N-m*m+m>0;  m++ )\n        {\n            if ((2*N-m*m+m)%(2*m)==0)\n                count++; \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mirrorReflection. /*FC*/class Solution {\n/*FM*/int mirrorReflection(int p, int q) \n    {\n        int m=1; \n        while (q*m%p!=0)\n            m++; \n        \n        int n = q*m/p; \n        \n        if (m%2==1 && n%2==1)\n            \n        else if (m%2==0 && n%2==1)\n            return 2; \n        else if (m%2==1 && n%2==0)\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"p\": [\"6\"], \"q\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mirrorReflection. /*FC*/class Solution {\n/*FM*/int mirrorReflection(int p, int q) \n    {\n        int m=1; \n        while (q*m%p!=0)\n            m++; \n        \n        int n = q*m/p; \n        \n        if (m%2==1 && n%2==1)\n            \n        else if (m%2==0 && n%2==1)\n            \n        else if (m%2==1 && n%2==0)\n            return 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"p\": [\"5\"], \"q\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mirrorReflection. /*FC*/class Solution {\n/*FM*/int mirrorReflection(int p, int q) \n    {\n        int m=1; \n        while (q*m%p!=0)\n            m++; \n        \n        int n = q*m/p; \n        \n        if (m%2==1 && n%2==1)\n            return 1; \n        else if (m%2==0 && n%2==1)\n            \n        else if (m%2==1 && n%2==0)\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"p\": [\"7\"], \"q\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int permu. /*FC*/class Solution {\n/*FM*/int permu(int M, int N)\n    {\n        int ans =1 ; \n        for (int i=0;  i<N;  i++)\n            ans*=(M-i); \n        return ans; \n    };/*F*/int count = 0;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"M\": [\"-402610228\"], \"N\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string orderlyQueue. /*FC*/class Solution {\n/*FM*/string orderlyQueue(string S, int K) \n    {\n        if (K>=2)\n        {\n            sort(S.begin(),S.end()); \n            return S; \n        }\n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"3\"], \"K\": [\"1138788141\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string orderlyQueue. /*FC*/class Solution {\n/*FM*/string orderlyQueue(string S, int K) \n    {\n        if (K>=2)\n        {\n            \n            \n        }\n        \n        string ret = S; \n        for (int i=0;  i<S.size();  i++)\n        {\n            S = S.substr(1) + S.substr(0,1); \n            if (S<ret)\n                \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"K\": [\"-429940515\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dfs. /*FC*/class Solution {\n/*FM*/int dfs(TreeNode* root) {\n        if(root == NULL)\n            \n        int l, r; \n        if(root->left == NULL) {\n           l = 0; \n        } else {\n           \n        }\n        if(root->right == NULL) {\n           r = 0; \n        } else {\n           \n        }\n        if(abs(l-r) >= 2) {\n            \n        }\n        return (l > r ? l : r) + 1; \n    };/*F*/int flag = 1;/*C*//*M*/int dfs(TreeNode* root) {\n        if(root == NULL)\n            return 1; \n        int l, r; \n        if(root->left == NULL) {\n           l = 0; \n        } else {\n           l = dfs(root->left); \n        }\n        if(root->right == NULL) {\n           r = 0; \n        } else {\n           r = dfs(root->right); \n        }\n        if(abs(l-r) >= 2) {\n            flag = 0; \n        }\n        return (l > r ? l : r) + 1; \n    } int dfs(TreeNode* root) {\n        if(root == NULL)\n            return 1; \n        int l, r; \n        if(root->left == NULL) {\n           l = 0; \n        } else {\n           l = dfs(root->left); \n        }\n        if(root->right == NULL) {\n           r = 0; \n        } else {\n           r = dfs(root->right); \n        }\n        if(abs(l-r) >= 2) {\n            flag = 0; \n        }\n        return (l > r ? l : r) + 1; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->flag\": [\"-573435799\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"0\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDepth. /*FC*/class Solution {\n/*FM*/int minDepth(TreeNode* root) {\n        if(root == NULL)\n            \n        if(root->left == NULL && root->right == NULL)\n            return 1; \n        if(root->left == NULL && root->right != NULL)\n            \n        if(root->right == NULL && root->left != NULL)\n            \n        if(root->left != NULL && root->right != NULL) {\n            \n            \n            \n        }\n    };/*F*//*C*//*M*/int minDepth(TreeNode* root) {\n        if(root == NULL)\n            return 0; \n        if(root->left == NULL && root->right == NULL)\n            return 1; \n        if(root->left == NULL && root->right != NULL)\n            return minDepth(root->right) + 1; \n        if(root->right == NULL && root->left != NULL)\n            return minDepth(root->left) + 1; \n        if(root->left != NULL && root->right != NULL) {\n            int leftdepth = minDepth(root->left); \n            int rightdepth = minDepth(root->right); \n            return leftdepth < rightdepth ? leftdepth + 1 : rightdepth + 1; \n        }\n    } int minDepth(TreeNode* root) {\n        if(root == NULL)\n            return 0; \n        if(root->left == NULL && root->right == NULL)\n            return 1; \n        if(root->left == NULL && root->right != NULL)\n            return minDepth(root->right) + 1; \n        if(root->right == NULL && root->left != NULL)\n            return minDepth(root->left) + 1; \n        if(root->left != NULL && root->right != NULL) {\n            int leftdepth = minDepth(root->left); \n            int rightdepth = minDepth(root->right); \n            return leftdepth < rightdepth ? leftdepth + 1 : rightdepth + 1; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasPathSum. /*FC*/class Solution {\n/*FM*/bool hasPathSum(TreeNode* root, int sum) {\n        if(root == NULL)\n            return false; \n        if(root->left == NULL && root->right == NULL && sum == root->val)\n                \n        if(hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val))\n            \n        else\n            return false; \n    };/*F*//*C*//*M*/bool hasPathSum(TreeNode* root, int sum) {\n        if(root == NULL)\n            return false; \n        if(root->left == NULL && root->right == NULL && sum == root->val)\n                return true; \n        if(hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val))\n            return true; \n        else\n            return false; \n    } bool hasPathSum(TreeNode* root, int sum) {\n        if(root == NULL)\n            return false; \n        if(root->left == NULL && root->right == NULL && sum == root->val)\n                return true; \n        if(hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val))\n            return true; \n        else\n            return false; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"sum\": [\"-103724861\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(TreeNode* root, int sum) {\n        if(root == NULL) return ; \n        if(root->val == sum && root->left == NULL && root->right == NULL) {\n            \n            \n            \n            \n        }\n        path.push_back(root->val); \n        dfs(root->left, sum - root->val); \n        dfs(root->right, sum - root->val); \n        path.pop_back(); \n    };/*F*/vector<int> path;/*C*//*M*/void dfs(TreeNode* root, int sum) {\n        if(root == NULL) return ; \n        if(root->val == sum && root->left == NULL && root->right == NULL) {\n            path.push_back(root->val); \n            result.push_back(path); \n            path.pop_back(); \n            return ; \n        }\n        path.push_back(root->val); \n        dfs(root->left, sum - root->val); \n        dfs(root->right, sum - root->val); \n        path.pop_back(); \n    } void dfs(TreeNode* root, int sum) {\n        if(root == NULL) return ; \n        if(root->val == sum && root->left == NULL && root->right == NULL) {\n            path.push_back(root->val); \n            result.push_back(path); \n            path.pop_back(); \n            return ; \n        }\n        path.push_back(root->val); \n        dfs(root->left, sum - root->val); \n        dfs(root->right, sum - root->val); \n        path.pop_back(); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->result\": [2], \"AKA_INSTANCE___Solution_result_element0\": [1], \"AKA_INSTANCE___Solution_result_element0_element0\": [\"194038701\"], \"AKA_INSTANCE___Solution_result_element1\": [3], \"AKA_INSTANCE___Solution_result_element1_element0\": [\"985203249\"], \"AKA_INSTANCE___Solution_result_element1_element1\": [\"1187254967\"], \"AKA_INSTANCE___Solution_result_element1_element2\": [\"-1517988004\"], \"AKA_INSTANCE___Solution->path\": [1], \"AKA_INSTANCE___Solution_path_element0\": [\"-2020416504\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"sum\": [\"-394078515\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> getRow. /*FC*/class Solution {\n/*FM*/vector<int> getRow(int rowIndex) {\n        vector<int> v(rowIndex+1); \n        v[0] = 1; \n        for(int i = 1;  i <= rowIndex;  i++) {\n            v[i] = (long long int)v[i-1] *(long long int)(rowIndex-i+1) / i; \n        }\n        return v; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"rowIndex\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumTotal. /*FC*/class Solution {\n/*FM*/int minimumTotal(vector<vector<int>>& triangle) {\n        for(int i = triangle.size() - 2;  i >= 0;  i--) {\n            for(int j = 0;  j <= i;  j++) {\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]); \n            }\n        }\n        return triangle[0][0]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"triangle\": [2], \"triangle_element0\": [2], \"triangle_element0_element0\": [\"291121895\"], \"triangle_element0_element1\": [\"-1413722202\"], \"triangle_element1\": [1], \"triangle_element1_element0\": [\"-1490028533\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int>& prices) {\n        int minvalue = 99999999; \n        int ans = 0; \n        for(int i = 0;  i < prices.size();  i++) {\n            if(minvalue > prices[i]) {\n                minvalue = prices[i]; \n            }\n            prices[i] = prices[i] - minvalue; \n            if(ans < prices[i]) {\n                ans = prices[i]; \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [3], \"prices_element0\": [\"673736296\"], \"prices_element1\": [\"-198650579\"], \"prices_element2\": [\"-1644860426\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int>& prices) {\n        int ans = 0; \n        for(int i = 1;  i < prices.size();  i++) {\n            if(prices[i] > prices[i - 1])\n                ans += prices[i] - prices[i - 1]; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"-1485752122\"], \"prices_element1\": [\"-290768071\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int>& prices) {\n        int ans = 0; \n        for(int i = 1;  i < prices.size();  i++) {\n            if(prices[i] > prices[i - 1])\n                \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [2], \"prices_element0\": [\"943133236\"], \"prices_element1\": [\"-588336489\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string s) {\n        if(s.length() == 0)\n            \n        int i = 0, j = s.length() - 1; \n        while(i < j) {\n            \n            \n            if(i < j && tolower(s[i]) != tolower(s[j])) {\n                \n            } else {\n                \n                \n            }\n        }\n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int ladderLength. /*FC*/class Solution {\n/*FM*/int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        set<string> dict, visit; \n        for(int i = 0;  i < wordList.size();  i++)\n            dict.insert(wordList[i]); \n        queue<pair<string, int>> q; \n        q.push(make_pair(beginWord, 1)); \n        while(!q.empty()) {\n            pair<string, int> temp = q.front(); \n            q.pop(); \n            string word = temp.first; \n            for(int i = 0;  i < word.length();  i++) {\n                string newword = word; \n                for(int j = 0;  j < 26;  j++) {\n                    newword[i] = 'a' + j; \n                    if(dict.find(newword) != dict.end() && visit.find(newword) == visit.end()) {\n                        if(newword == endWord)\n                            \n                        visit.insert(newword); \n                        q.push(make_pair(newword, temp.second + 1)); \n                    }\n                }\n            }\n        }\n        return 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"beginWord\": [\"1\"], \"endWord\": [\"1\"], \"wordList\": [2], \"wordList_element0\": [\"1\"], \"wordList_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(TreeNode* root) {\n        if (root == NULL) \n        if (root->left == NULL && root->right == NULL) {\n            result += root->val; \n            return; \n        }\n        if (root->left != NULL) {\n            root->left->val += root->val * 10; \n            dfs(root->left); \n        }\n        if (root->right != NULL) {\n            \n            \n        }\n    };/*F*//*C*//*M*/void dfs(TreeNode* root) {\n        if (root == NULL) return; \n        if (root->left == NULL && root->right == NULL) {\n            result += root->val; \n            return; \n        }\n        if (root->left != NULL) {\n            root->left->val += root->val * 10; \n            dfs(root->left); \n        }\n        if (root->right != NULL) {\n            root->right->val += root->val * 10; \n            dfs(root->right); \n        }\n    } void dfs(TreeNode* root) {\n        if (root == NULL) return; \n        if (root->left == NULL && root->right == NULL) {\n            result += root->val; \n            return; \n        }\n        if (root->left != NULL) {\n            root->left->val += root->val * 10; \n            dfs(root->left); \n        }\n        if (root->right != NULL) {\n            root->right->val += root->val * 10; \n            dfs(root->right); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-2121594531\"], \"root[0].val\": [\"2059556959\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1816899233\"], \"root[0].left[0].val\": [\"-710863991\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"274613349\"], \"root[1].val\": [\"-534880841\"], \"root[1].left\": [2], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"1838126764\"], \"root[1].left[0].val\": [\"1715811078\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left1_x\": [\"-183735656\"], \"root[1].left[1].val\": [\"-601617184\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"1033822529\"], \"root[2].val\": [\"115171674\"], \"root[2].left\": [1], \"root[2].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_left0_x\": [\"1535083021\"], \"root[2].left[0].val\": [\"1211062557\"], \"root[2].right\": [1], \"root[2].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_right0_x\": [\"-19474989\"], \"root[2].right[0].val\": [\"-1773378791\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(TreeNode* root) {\n        if (root == NULL) \n        if (root->left == NULL && root->right == NULL) {\n            result += root->val; \n            return; \n        }\n        if (root->left != NULL) {\n            root->left->val += root->val * 10; \n            dfs(root->left); \n        }\n        if (root->right != NULL) {\n            root->right->val += root->val * 10; \n            dfs(root->right); \n        }\n    };/*F*//*C*//*M*/void dfs(TreeNode* root) {\n        if (root == NULL) return; \n        if (root->left == NULL && root->right == NULL) {\n            result += root->val; \n            return; \n        }\n        if (root->left != NULL) {\n            root->left->val += root->val * 10; \n            dfs(root->left); \n        }\n        if (root->right != NULL) {\n            root->right->val += root->val * 10; \n            dfs(root->right); \n        }\n    } void dfs(TreeNode* root) {\n        if (root == NULL) return; \n        if (root->left == NULL && root->right == NULL) {\n            result += root->val; \n            return; \n        }\n        if (root->left != NULL) {\n            root->left->val += root->val * 10; \n            dfs(root->left); \n        }\n        if (root->right != NULL) {\n            root->right->val += root->val * 10; \n            dfs(root->right); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-328776145\"], \"root[0].val\": [\"1099718210\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-1937254088\"], \"root[0].left[0].val\": [\"-2092480464\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"-1963668654\"], \"root[0].left[1].val\": [\"252224505\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"-960093571\"], \"root[0].left[2].val\": [\"-1365278891\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-1409967152\"], \"root[0].right[0].val\": [\"1695055637\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"800298534\"], \"root[1].val\": [\"613802973\"], \"root[1].left\": [2], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"908162376\"], \"root[1].left[0].val\": [\"-418380548\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left1_x\": [\"1366289717\"], \"root[1].left[1].val\": [\"-881604249\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void solve. /*FC*/class Solution {\n/*FM*/void solve(vector<vector<char>>& board) {\n        if(board.size() == 0) \n        m = board.size(), n = board[0].size(); \n        for(int i = 0;  i < m;  i++) {\n            dfs(i, 0, board); \n            dfs(i, n - 1, board); \n        }\n        for(int j = 0;  j < n;  j++) {\n            dfs(0, j, board); \n            dfs(m - 1, j, board); \n        }\n        for(int i = 0;  i < m;  i++) {\n            for(int j = 0;  j < n;  j++) {\n                if(board[i][j] == '*')\n                    \n                else if(board[i][j] == 'O')\n                    \n            }\n        }\n    };/*F*/int m;  int n;/*C*//*M*/void dfs(int row, int col, vector<vector<char>>& board) {\n        if(board[row][col] != 'O') return; \n        board[row][col] = '*'; \n        if(row - 1 > 0) dfs(row - 1, col, board); \n        if(col - 1 > 0) dfs(row, col - 1, board); \n        if(row + 1 < m) dfs(row + 1, col, board); \n        if(col + 1 < n) dfs(row, col + 1, board); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"board\": [3], \"board_element0\": [1], \"board_element0_element0\": [\"52\"], \"board_element1\": [2], \"board_element1_element0\": [\"-63\"], \"board_element1_element1\": [\"78\"], \"board_element2\": [1], \"board_element2_element0\": [\"20\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int canCompleteCircuit. /*FC*/class Solution {\n/*FM*/int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        if(gas.empty())\n            \n        int total = 0, temp = 0, index = 0; \n        for(int i = 0;  i < gas.size();  i++) {\n            total += gas[i] - cost[i]; \n            if(temp >= 0) {\n                temp += gas[i] - cost[i]; \n            } else {\n                \n                \n            }\n        }\n        return total >= 0 ? index : -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"gas\": [3], \"gas_element0\": [\"-597574948\"], \"gas_element1\": [\"-1189027065\"], \"gas_element2\": [\"524448918\"], \"cost\": [3], \"cost_element0\": [\"-1135685121\"], \"cost_element1\": [\"-1124960312\"], \"cost_element2\": [\"-1760718312\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNumber. /*FC*/class Solution {\n/*FM*/int singleNumber(vector<int>& nums) {\n        sort(nums.begin(), nums.end()); \n        for(int i = 0;  i < nums.size() - 1;  ) {\n            if(nums[i] != nums[i + 1]) {\n                return nums[i]; \n            }\n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"256920136\"], \"nums_element1\": [\"-1976169577\"], \"nums_element2\": [\"1989832078\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNumber. /*FC*/class Solution {\n/*FM*/int singleNumber(vector<int>& nums) {\n        sort(nums.begin(), nums.end()); \n        for(int i = 0;  i < nums.size() - 1;  ) {\n            \n        }\n        return nums[nums.size() - 1]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1556896699\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasCycle. /*FC*/class Solution {\n/*FM*/bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            return false; \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasCycle. /*FC*/class Solution {\n/*FM*/bool hasCycle(ListNode *head) {\n        if(head == NULL)\n            \n        set<ListNode *> s; \n        ListNode *t; \n        t = head; \n        int cnt = 0; \n        while(t->next != NULL) {\n            \n            \n            \n            \n        }\n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"915403326\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-2024269769\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *detectCycle. /*FC*/class Solution {\n/*FM*/ListNode *detectCycle(ListNode *head) {\n        if(head == NULL) {\n            \n        }\n        set<ListNode *> s; \n        ListNode *p = head; \n        int cnt = 0; \n        while(p->next != NULL) {\n            \n            \n            \n            \n        }\n        return NULL; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"9033204\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1593343927\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *detectCycle. /*FC*/class Solution {\n/*FM*/ListNode *detectCycle(ListNode *head) {\n        if(head == NULL) {\n            return NULL; \n        }\n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reorderList. /*FC*/class Solution {\n/*FM*/void reorderList(ListNode* head) {\n        ListNode *p = head, *a = head, *b = head; \n        ListNode *mid = findMidNode(head); \n        ListNode *q = reverseList(mid); \n        while (p != NULL && q != NULL) {\n            \n            \n            \n            \n            \n            \n        }\n        if (q != NULL) \n    };/*F*//*C*//*M*/ListNode* findMidNode(ListNode* head) {\n        ListNode *mid = head, *tail = head, *last = head; \n        while (tail != NULL && tail->next != NULL) {\n            last = mid; \n            mid = mid->next; \n            tail = tail->next->next; \n        }\n        if (last != NULL) last->next = NULL; \n        return mid; \n    } ListNode* reverseList(ListNode* head) {\n        if (head == NULL) return head; \n        ListNode *cur = head, *pre = NULL, *temp = NULL; \n        while (cur != NULL) {\n            temp = cur->next; \n            cur->next = pre; \n            pre = cur; \n            cur = temp; \n        }\n        return pre; \n    } ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reorderList. /*FC*/class Solution {\n/*FM*/void reorderList(ListNode* head) {\n        ListNode *p = head, *a = head, *b = head; \n        ListNode *mid = findMidNode(head); \n        ListNode *q = reverseList(mid); \n        while (p != NULL && q != NULL) {\n            a = p; \n            b = q; \n            p = p->next; \n            q = q->next; \n            a->next = b; \n            b->next = p; \n        }\n        if (q != NULL) \n    };/*F*//*C*//*M*/ListNode* findMidNode(ListNode* head) {\n        ListNode *mid = head, *tail = head, *last = head; \n        while (tail != NULL && tail->next != NULL) {\n            last = mid; \n            mid = mid->next; \n            tail = tail->next->next; \n        }\n        if (last != NULL) last->next = NULL; \n        return mid; \n    } ListNode* reverseList(ListNode* head) {\n        if (head == NULL) return head; \n        ListNode *cur = head, *pre = NULL, *temp = NULL; \n        while (cur != NULL) {\n            temp = cur->next; \n            cur->next = pre; \n            pre = cur; \n            cur = temp; \n        }\n        return pre; \n    } ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-406811527\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* findMidNode. /*FC*/class Solution {\n/*FM*/ListNode* findMidNode(ListNode* head) {\n        ListNode *mid = head, *tail = head, *last = head; \n        while (tail != NULL && tail->next != NULL) {\n            \n            \n            \n        }\n        if (last != NULL) last->next = NULL; \n        return mid; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-380204817\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"128838611\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* findMidNode. /*FC*/class Solution {\n/*FM*/ListNode* findMidNode(ListNode* head) {\n        ListNode *mid = head, *tail = head, *last = head; \n        while (tail != NULL && tail->next != NULL) {\n            \n            \n            \n        }\n        if (last != NULL) \n        return mid; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList. /*FC*/class Solution {\n/*FM*/ListNode* reverseList(ListNode* head) {\n        if (head == NULL) return head; \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList. /*FC*/class Solution {\n/*FM*/ListNode* reverseList(ListNode* head) {\n        if (head == NULL) \n        ListNode *cur = head, *pre = NULL, *temp = NULL; \n        while (cur != NULL) {\n            temp = cur->next; \n            cur->next = pre; \n            pre = cur; \n            cur = temp; \n        }\n        return pre; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-673012523\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> preorderTraversal. /*FC*/class Solution {\n/*FM*/vector<int> preorderTraversal(TreeNode* root) {\n        stack<TreeNode*> s; \n        vector<int> v; \n        if(root == NULL) {\n            \n        }\n        TreeNode *p = root; \n        s.push(p); \n        while(!s.empty()) {\n            p = s.top(); \n            s.pop(); \n            v.push_back(p->val); \n            if(p->right != NULL) {\n                \n            }\n            if(p->left != NULL) {\n                \n            }\n        } \n        return v; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1214751605\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1277640125\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(TreeNode* root) {\n        if(root == NULL) return; \n        dfs(root->left); \n        dfs(root->right); \n        result.push_back(root->val); \n    };/*F*/vector<int> result;/*C*//*M*/void dfs(TreeNode* root) {\n        if(root == NULL) return; \n        dfs(root->left); \n        dfs(root->right); \n        result.push_back(root->val); \n    } void dfs(TreeNode* root) {\n        if(root == NULL) return; \n        dfs(root->left); \n        dfs(root->right); \n        result.push_back(root->val); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->result\": [3], \"AKA_INSTANCE___Solution_result_element0\": [\"-194916293\"], \"AKA_INSTANCE___Solution_result_element1\": [\"665687368\"], \"AKA_INSTANCE___Solution_result_element2\": [\"-963048206\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"935428669\"], \"root[0].val\": [\"1645933133\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-1997699403\"], \"root[0].left[0].val\": [\"-480115164\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"1009836402\"], \"root[0].left[1].val\": [\"853116354\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"1317502359\"], \"root[0].left[2].val\": [\"586488041\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"466095328\"], \"root[0].right[0].val\": [\"-898282279\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numTrees. /*FC*/class Solution {\n/*FM*/int numTrees(int n) {\n        vector<int> v(n+1); \n        v[0] = 1; \n        for(int i = 1;  i <= n;  i++) {\n            v[i] = 0; \n            if(i <= 2) {\n                v[i] = i; \n            } else {\n                for(int j = 1;  j <= i;  j++) {\n                    v[i] += v[j-1] * v[i-j]; \n                }\n            }\n        }\n        return v[n]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidBST. /*FC*/class Solution {\n/*FM*/bool isValidBST(TreeNode* root) {\n        if(root == NULL ||(root->left == NULL && root->right == NULL)) \n        inorder(root); \n        for(int i = 1;  i < v.size();  i++)\n            if(v[i] <= v[i-1]) \n        return true; \n    };/*F*/vector<int> v;/*C*//*M*/void inorder(TreeNode* root) {\n        if(root == NULL) return; \n        inorder(root->left); \n        v.push_back(root->val); \n        inorder(root->right); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"328248743\"], \"root[0].val\": [\"934508004\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"2087290120\"], \"root[0].right[0].val\": [\"982641529\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidBST. /*FC*/class Solution {\n/*FM*/bool isValidBST(TreeNode* root) {\n        if(root == NULL ||(root->left == NULL && root->right == NULL)) return true; \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1720624913\"], \"root[0].val\": [\"932195434\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-149246700\"], \"root[1].val\": [\"-831535104\"], \"root[1].left\": [2], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"-323990260\"], \"root[1].left[0].val\": [\"1606320226\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left1_x\": [\"-28983573\"], \"root[1].left[1].val\": [\"1647081173\"], \"root[1].right\": [2], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_right0_x\": [\"-207981406\"], \"root[1].right[0].val\": [\"-893336707\"], \"root[1].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_right1_x\": [\"1916474593\"], \"root[1].right[1].val\": [\"-1955229045\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"-304443494\"], \"root[2].val\": [\"71939345\"], \"root[2].left\": [1], \"root[2].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_left0_x\": [\"75610563\"], \"root[2].left[0].val\": [\"706848198\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidBST. /*FC*/class Solution {\n/*FM*/bool isValidBST(TreeNode* root) {\n        if(root == NULL ||(root->left == NULL && root->right == NULL)) \n        inorder(root); \n        for(int i = 1;  i < v.size();  )\n            if(v[i] <= v[i-1]) return false; \n        \n    };/*F*/vector<int> v;/*C*//*M*/void inorder(TreeNode* root) {\n        if(root == NULL) return; \n        inorder(root->left); \n        v.push_back(root->val); \n        inorder(root->right); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1147893996\"], \"root[0].val\": [\"-1496306562\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"36539235\"], \"root[0].left[0].val\": [\"-876860604\"], \"root[0].right\": [3], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-2132293219\"], \"root[0].right[0].val\": [\"-1147063747\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"1417389103\"], \"root[0].right[1].val\": [\"1590557824\"], \"root[0].right[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right2_x\": [\"-995711505\"], \"root[0].right[2].val\": [\"-537228690\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1980235498\"], \"root[1].val\": [\"-985330585\"], \"root[1].left\": [1], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"284169449\"], \"root[1].left[0].val\": [\"2033207802\"], \"root[1].right\": [1], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_right0_x\": [\"1738310413\"], \"root[1].right[0].val\": [\"-1186487332\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool func. /*FC*/class Solution {\n/*FM*/bool func(TreeNode *left, TreeNode *right) {\n        if(left == NULL && right == NULL)\n            return true; \n        if(left != NULL && right != NULL && left->val == right->val) {\n            \n        }\n        \n    };/*F*//*C*//*M*/bool func(TreeNode *left, TreeNode *right) {\n        if(left == NULL && right == NULL)\n            return true; \n        if(left != NULL && right != NULL && left->val == right->val) {\n            return func(left->left, right->right) && func(left->right, right->left); \n        }\n        return false; \n    } bool func(TreeNode *left, TreeNode *right) {\n        if(left == NULL && right == NULL)\n            return true; \n        if(left != NULL && right != NULL && left->val == right->val) {\n            return func(left->left, right->right) && func(left->right, right->left); \n        }\n        return false; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSymmetric. /*FC*/class Solution {\n/*FM*/bool isSymmetric(TreeNode* root) {\n        if(root == NULL)\n            return true; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSymmetric. /*FC*/class Solution {\n/*FM*/bool isSymmetric(TreeNode* root) {\n        if(root == NULL)\n            \n        return func(root->left, root->right); \n    };/*F*//*C*//*M*/bool func(TreeNode *left, TreeNode *right) {\n        if(left == NULL && right == NULL)\n            return true; \n        if(left != NULL && right != NULL && left->val == right->val) {\n            return func(left->left, right->right) && func(left->right, right->left); \n        }\n        return false; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1106579465\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"217798934\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<int> row; \n        vector<vector<int>> v; \n        queue<TreeNode *> q; \n        if(root == NULL)\n            \n        q.push(root); \n        TreeNode *temp; \n        while(!q.empty()) {\n            int size = q.size(); \n            while(size--) {\n                temp = q.front(); \n                q.pop(); \n                row.push_back(temp->val); \n                if(temp->left != NULL) {\n                    \n                }\n                if(temp->right != NULL) {\n                    \n                }\n            }\n            v.push_back(row); \n            row.clear(); \n        }\n        return v; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1704052065\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"114840694\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> zigzagLevelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<int> row; \n        vector<vector<int>> v; \n        queue<TreeNode *> q; \n        if(root == NULL)\n            \n        q.push(root); \n        TreeNode *temp; \n        int lev = 0; \n        while(!q.empty()) {\n            int size = q.size(); \n            while(size--) {\n                temp = q.front(); \n                q.pop(); \n                row.push_back(temp->val); \n                if(temp->left != NULL) {\n                    \n                }\n                if(temp->right != NULL) {\n                    \n                }\n            }\n            if(lev % 2) {\n                \n                \n            }\n            v.push_back(row); \n            lev++; \n            row.clear(); \n        }\n        return v; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1964765213\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(TreeNode* root) {\n        if(root == NULL)\n            \n        if(root->left == NULL && root->right == NULL)\n            return 1; \n        if(root->left != NULL && root->right == NULL)\n            return maxDepth(root->left) + 1; \n        if(root->right != NULL && root->left == NULL)\n            \n        if(root->right != NULL && root->left != NULL) {\n            \n            \n            \n        }\n    };/*F*//*C*//*M*/int maxDepth(TreeNode* root) {\n        if(root == NULL)\n            return 0; \n        if(root->left == NULL && root->right == NULL)\n            return 1; \n        if(root->left != NULL && root->right == NULL)\n            return maxDepth(root->left) + 1; \n        if(root->right != NULL && root->left == NULL)\n            return maxDepth(root->right) + 1; \n        if(root->right != NULL && root->left != NULL) {\n            int leftdepth = maxDepth(root->left); \n            int rightdepth = maxDepth(root->right); \n            return leftdepth > rightdepth ? leftdepth + 1 : rightdepth + 1; \n        }\n    } int maxDepth(TreeNode* root) {\n        if(root == NULL)\n            return 0; \n        if(root->left == NULL && root->right == NULL)\n            return 1; \n        if(root->left != NULL && root->right == NULL)\n            return maxDepth(root->left) + 1; \n        if(root->right != NULL && root->left == NULL)\n            return maxDepth(root->right) + 1; \n        if(root->right != NULL && root->left != NULL) {\n            int leftdepth = maxDepth(root->left); \n            int rightdepth = maxDepth(root->right); \n            return leftdepth > rightdepth ? leftdepth + 1 : rightdepth + 1; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1785591520\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1248838829\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1041699531\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"-1961934962\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(TreeNode* root) {\n        if(root == NULL)\n            \n        if(root->left == NULL && root->right == NULL)\n            return 1; \n        if(root->left != NULL && root->right == NULL)\n            \n        if(root->right != NULL && root->left == NULL)\n            return maxDepth(root->right) + 1; \n        if(root->right != NULL && root->left != NULL) {\n            \n            \n            \n        }\n    };/*F*//*C*//*M*/int maxDepth(TreeNode* root) {\n        if(root == NULL)\n            return 0; \n        if(root->left == NULL && root->right == NULL)\n            return 1; \n        if(root->left != NULL && root->right == NULL)\n            return maxDepth(root->left) + 1; \n        if(root->right != NULL && root->left == NULL)\n            return maxDepth(root->right) + 1; \n        if(root->right != NULL && root->left != NULL) {\n            int leftdepth = maxDepth(root->left); \n            int rightdepth = maxDepth(root->right); \n            return leftdepth > rightdepth ? leftdepth + 1 : rightdepth + 1; \n        }\n    } int maxDepth(TreeNode* root) {\n        if(root == NULL)\n            return 0; \n        if(root->left == NULL && root->right == NULL)\n            return 1; \n        if(root->left != NULL && root->right == NULL)\n            return maxDepth(root->left) + 1; \n        if(root->right != NULL && root->left == NULL)\n            return maxDepth(root->right) + 1; \n        if(root->right != NULL && root->left != NULL) {\n            int leftdepth = maxDepth(root->left); \n            int rightdepth = maxDepth(root->right); \n            return leftdepth > rightdepth ? leftdepth + 1 : rightdepth + 1; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"2023453932\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-587972177\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"236922177\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"1496136501\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> levelOrderBottom. /*FC*/class Solution {\n/*FM*/vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<int> row; \n        vector<vector<int>> v; \n        if(root == NULL) {\n            \n        }\n        queue<TreeNode *> q; \n        q.push(root); \n        TreeNode *temp; \n        while(!q.empty()) {\n            int size = q.size(); \n            while(size--) {\n                temp = q.front(); \n                q.pop(); \n                row.push_back(temp->val); \n                if(temp->left != NULL) {\n                    \n                }\n                if(temp->right != NULL) {\n                    \n                }\n            }\n            v.insert(v.begin(), row); \n            row.clear(); \n        }\n        \n        return v; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1191697414\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-53190589\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* func. /*FC*/class Solution {\n/*FM*/TreeNode* func(vector<int>& nums, int left, int right) {\n        if (left > right) return NULL; \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/TreeNode* func(vector<int>& nums, int left, int right) {\n        if (left > right) return NULL; \n        int mid = (left + right) / 2; \n        TreeNode* root = new TreeNode(nums[mid]); \n        root->left = func(nums, left, mid - 1); \n        root->right = func(nums, mid + 1, right); \n        return root; \n    } TreeNode* func(vector<int>& nums, int left, int right) {\n        if (left > right) return NULL; \n        int mid = (left + right) / 2; \n        TreeNode* root = new TreeNode(nums[mid]); \n        root->left = func(nums, left, mid - 1); \n        root->right = func(nums, mid + 1, right); \n        return root; \n    } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"354470734\"], \"left\": [\"641513862\"], \"right\": [\"-28224869\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors. /*FC*/class Solution {\n/*FM*/void sortColors(vector<int>& nums) {\n        int cnt0 = 0, cnt1 = 0, cnt2 = 0; \n        for(int i = 0;  i < nums.size();  i++) {\n            if(nums[i] == 0) {\n                \n            } else if (nums[i] == 1) {\n                \n            } else {\n                cnt2++; \n            }\n        }\n        for(int i = 0;  i < cnt0;  ) {\n            \n        }\n        for(int i = cnt0;  i < cnt0 + cnt1;  ) {\n            \n        }\n        for(int i = cnt1 + cnt0;  i < nums.size();  i++) {\n            nums[i] = 2; \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-2028606590\"], \"nums_element1\": [\"-1291485831\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(int cur, int cnt) {\n        if (cnt == k) {\n            \n            \n        }\n        for (int i = cur + 1;  i <= n;  ) {\n            \n            \n            \n        }\n    };/*F*/int n;  int k;/*C*//*M*/void dfs(int cur, int cnt) {\n        if (cnt == k) {\n            result.push_back(row); \n            return; \n        }\n        for (int i = cur + 1;  i <= n;  i++) {\n            row.push_back(i); \n            dfs(i, cnt + 1); \n            row.pop_back(); \n        }\n    } void dfs(int cur, int cnt) {\n        if (cnt == k) {\n            result.push_back(row); \n            return; \n        }\n        for (int i = cur + 1;  i <= n;  i++) {\n            row.push_back(i); \n            dfs(i, cnt + 1); \n            row.pop_back(); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"cur\": [\"8\"], \"cnt\": [\"1208006387\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool exist. /*FC*/class Solution {\n/*FM*/bool exist(vector<vector<char>>& board, string word) {\n        if (board.size() == 0) \n        m = board.size(), n = board[0].size(); \n        this->word = word; \n        this->board = board; \n        visit.resize(m, vector<bool>(n)); \n        for (int j = 0;  j < m;  j++) {\n            for (int k = 0;  k < n;  k++) {\n                if (board[j][k] == word[0]) {\n                    visit[j][k] = true; \n                    dfs(j, k, 0); \n                    visit[j][k] = false; \n                }\n            }\n        }\n        return flag; \n    };/*F*/bool flag = false;  vector<vector<bool>> visit;  vector<vector<char>> board;  int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};  int m;  int n;/*C*//*M*/void dfs(int x, int y, int index) {\n        if (flag == true) return ; \n        if (index == word.length() - 1) {\n            flag = true; \n            return ; \n        }\n        for (int i = 0;  i < 4;  i++) {\n            int tx = x + dir[i][0], ty = y + dir[i][1]; \n            if (tx >= 0 && tx < m && ty >= 0 && ty < n && board[tx][ty] == word[index + 1] && visit[tx][ty] == false) {\n                visit[tx][ty] = true; \n                dfs(tx, ty, index + 1); \n                visit[tx][ty] = false; \n            }\n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->dir\": [2], \"board\": [1], \"board_element0\": [2], \"board_element0_element0\": [\"5\"], \"board_element0_element1\": [\"-15\"], \"word\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int>& nums) {\n        if(nums.empty())\n            \n        int len = 1; \n        vector<int> v(nums.size()); \n        int cnt = 1; \n        v[0] = nums[0]; \n        for(int i = 1;  i < nums.size();  i++) {\n            if(nums[i] == nums[i - 1]) {\n                \n            } else {\n                cnt = 1; \n            }\n            if(cnt <= 2) {\n                v[len++] = nums[i]; \n            }\n        }\n        for(int i = 0;  i < len;  i++) {\n            nums[i] = v[i]; \n        }\n        return len; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"602004645\"], \"nums_element1\": [\"1083811590\"], \"nums_element2\": [\"713490659\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode* deleteDuplicates(ListNode* head) {\n        if (head == NULL || head->next == NULL) return head; \n        ListNode* p = head->next; \n        if (p->val != head->val) {\n            head->next = deleteDuplicates(p); \n            return head; \n        } else {\n             \n        }\n    };/*F*//*C*//*M*/ListNode* deleteDuplicates(ListNode* head) {\n        if (head == NULL || head->next == NULL) return head; \n        ListNode* p = head->next; \n        if (p->val != head->val) {\n            head->next = deleteDuplicates(p); \n            return head; \n        } else {\n            while (p != NULL && p->val == head->val) p = p->next; \n            return deleteDuplicates(p); \n        }\n    } ListNode* deleteDuplicates(ListNode* head) {\n        if (head == NULL || head->next == NULL) return head; \n        ListNode* p = head->next; \n        if (p->val != head->val) {\n            head->next = deleteDuplicates(p); \n            return head; \n        } else {\n            while (p != NULL && p->val == head->val) p = p->next; \n            return deleteDuplicates(p); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"294791615\"], \"head[0].val\": [\"-1409749741\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-2094905397\"], \"head[0].next[0].val\": [\"-1517157751\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"234540470\"], \"head[0].next[1].val\": [\"555029644\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode* deleteDuplicates(ListNode* head) {\n        if (head == NULL || head->next == NULL) return head; \n        \n        \n    };/*F*//*C*//*M*/ListNode* deleteDuplicates(ListNode* head) {\n        if (head == NULL || head->next == NULL) return head; \n        ListNode* p = head->next; \n        if (p->val != head->val) {\n            head->next = deleteDuplicates(p); \n            return head; \n        } else {\n            while (p != NULL && p->val == head->val) p = p->next; \n            return deleteDuplicates(p); \n        }\n    } ListNode* deleteDuplicates(ListNode* head) {\n        if (head == NULL || head->next == NULL) return head; \n        ListNode* p = head->next; \n        if (p->val != head->val) {\n            head->next = deleteDuplicates(p); \n            return head; \n        } else {\n            while (p != NULL && p->val == head->val) p = p->next; \n            return deleteDuplicates(p); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode* deleteDuplicates(ListNode* head) {\n        if(head == NULL || head->next == NULL) {\n            return head; \n        }\n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1206843636\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1858051135\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode* deleteDuplicates(ListNode* head) {\n        if(head == NULL || head->next == NULL) {\n            \n        }\n        ListNode *p = head; \n        while(p != NULL &&  p->next != NULL) {\n            while (p->next != NULL && p->next->val == p->val) {\n                    \n            }\n            p = p->next; \n        }\n        return head; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-747192594\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-197019089\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1791089726\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"716892957\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDecodings. /*FC*/class Solution {\n/*FM*/int numDecodings(string s) {\n        int len = s.length(); \n        vector<int> dp(len, 0); \n        if(len == 0 || s[0] == '0') \n            \n        if(len == 1)\n            return check(s[0]); \n        \n        \n        \n        \n    };/*F*//*C*//*M*/int check(char a) {\n        return a != '0'; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> restoreIpAddresses. /*FC*/class Solution {\n/*FM*/vector<string> restoreIpAddresses(string s) {\n        vector<string> result; \n        int len = s.length(); \n        for (int i = 1;  i <= 3 && i <= len - 3;  ) {\n            \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool find. /*FC*/class TwoSum {\n/*FM*/bool find(int value) \n\t{\n\t    for (auto a:Map)\n\t    {\n\t        \n\t    }\n\t    \n\t    return false; \n\t};/*F*/unordered_map<int,int> Map;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___TwoSum\": [\"TwoSum\", \"TwoSum()\"], \"value\": [\"935787009\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) \n    {\n        int left=0; \n        int N=citations.size(); \n        int right=N-1; \n        int mid; \n        \n        if (N==0) \n        \n        while (left<right)\n        {\n            int mid= left+(right-left)/2; \n            \n            if (N-mid==citations[mid])\n                \n            else if (N-mid<citations[mid])\n                \n            else\n                left= mid+1; \n        }\n        \n        return min(N-left,citations[left]); \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [3], \"citations_element0\": [\"869056154\"], \"citations_element1\": [\"-374883504\"], \"citations_element2\": [\"1376848284\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) \n    {\n        if (citations.size()==0) \n        \n        map<int,int>Map; \n        for (int i=0;  i<citations.size();  i++)\n            Map[citations[i]]++; \n        auto q = vector<pair<int,int>>(Map.begin(),Map.end()); \n        \n        int sum=0; \n        \n        for (int i=q.size()-1;  i>=0;  i--)\n        {\n            if (q[i].first>sum+q[i].second)\n                sum+=q[i].second; \n            else if (q[i].first==sum+q[i].second)\n                \n            else\n                return max(q[i].first,sum); \n        }\n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [3], \"citations_element0\": [\"1920408108\"], \"citations_element1\": [\"-816221199\"], \"citations_element2\": [\"1386143988\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) \n    {\n        if (citations.size()==0) \n        \n        map<int,int>Map; \n        for (int i=0;  i<citations.size();  i++)\n            Map[citations[i]]++; \n        auto q = vector<pair<int,int>>(Map.begin(),Map.end()); \n        \n        int sum=0; \n        \n        for (int i=q.size()-1;  i>=0;  i--)\n        {\n            if (q[i].first>sum+q[i].second)\n                sum+=q[i].second; \n            else if (q[i].first==sum+q[i].second)\n                \n            else\n                \n        }\n        \n        return sum;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [1], \"citations_element0\": [\"508856521\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) \n    {\n        if (citations.size()==0) \n        \n        sort(citations.begin(),citations.end()); \n        \n        int sum=0; \n        int i=citations.size()-1; \n        \n        while (i>=0)\n        {\n            sum++; \n            \n            if (citations[i]==sum)\n                \n            else if (citations[i]>sum)\n                i--; \n            else\n            {\n                \n            }\n            \n        }\n        \n        return sum; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [3], \"citations_element0\": [\"610861069\"], \"citations_element1\": [\"2126351799\"], \"citations_element2\": [\"219928217\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) \n    {\n        if (citations.size()==0) \n        \n        sort(citations.begin(),citations.end()); \n        \n        int sum=0; \n        int i=citations.size()-1; \n        \n        while (i>=0)\n        {\n            sum++; \n            \n            if (citations[i]==sum)\n                \n            else if (citations[i]>sum)\n                i--; \n            else\n            {\n                return max(citations[i],sum-1); \n            }\n            \n        }\n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [3], \"citations_element0\": [\"-1893643004\"], \"citations_element1\": [\"1903801258\"], \"citations_element2\": [\"2101718969\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSumOfThreeSubarrays. /*FC*/class Solution {\n/*FM*/vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) \n    {\n        int n = nums.size(); \n        vector<int>presum(n);         \n        for (int i=0;  i<n;  i++)\n            presum[i] = (i==0?0:presum[i-1]) + nums[i]; \n                        \n        vector<int>leftMax(n,0); \n        vector<int>leftIdx(n,0);  \n        int maxSum = 0; \n        int maxIdx = 0; \n        for (int i=k-1;  i<n;  i++)\n        {\n            \n            int sum = presum[i] - (i<k?0:presum[i-k]); \n            if (sum > maxSum)\n            {\n                maxSum = sum; \n                maxIdx = i-k+1; \n            }\n            leftMax[i] = maxSum; \n            leftIdx[i] = maxIdx; \n        }\n\n        vector<int>rightMax(n,0); \n        vector<int>rightIdx(n,0);  \n        maxSum = 0; \n        maxIdx = 0; \n        for (int i=n-k;  i>=0;  i--)\n        {\n            \n            int sum = presum[i+k-1] - (i==0?0:presum[i-1]); \n            if (sum >= maxSum)\n            {\n                maxSum = sum; \n                maxIdx = i; \n            }\n            rightMax[i] = maxSum; \n            rightIdx[i] = maxIdx; \n        }\n\n        vector<int>rets; \n        maxSum = 0; \n        for (int i=k;  i+2*k<=n;  )\n        {\n            \n            \n        }\n\n        return rets; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"2132938011\"], \"nums_element1\": [\"108960077\"], \"nums_element2\": [\"122639867\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class Solution {\n/*FM*/string minWindow(string S, string T) \n    {\n        int m = S.size(); \n        int n = T.size(); \n        S = \"#\"+S; \n        T = \"#\"+T; \n        auto dp = vector<vector<int>>(m+1,vector<int>(n+1,0)); \n        \n        for (int j=1;  j<=n;  j++)\n            dp[0][j] = INT_MAX/2; \n        for (int i=0;  i<=m;  i++)\n            dp[i][0] = 0; \n        \n        for (int i=1;  i<=m;  i++)\n            for (int j=1;  j<=n;  j++)\n            {\n                if (S[i]==T[j])\n                    \n                else\n                    dp[i][j] = dp[i-1][j]+1; \n            }\n        \n        int len  = INT_MAX/2; \n        int pos; \n        for (int i=1;  i<=m;  i++)\n        {\n            if (dp[i][n] < len)\n            {\n                \n                \n            }\n        }\n        \n        if (len>=INT_MAX/2)\n            return \"\"; \n        else\n            \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class Solution {\n/*FM*/string minWindow(string s1, string s2) \n    {\n        int m = s1.size(); \n        int next[m+1][26]; \n        s1 = \"#\" + s1; \n        \n        for (int ch=0;  ch<26;  ch++)\n            next[m][ch] = -1; \n        for (int i=m-1;  i>=0;  i--)\n        {\n            for (int ch=0;  ch<26;  ch++)\n                next[i][ch] = next[i+1][ch]; \n            next[i][s1[i+1]-'a'] = i+1; \n        }\n        \n        vector<int>start; \n        for (int i=1;  i<=m;  i++)\n        {\n            if (s1[i]==s2[0])\n                \n        }\n        \n        string ret = \"\"; \n        for (int i: start)\n        {\n            \n            \n            for (: s2)\n            {\n                \n                \n            }\n                    \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s1\": [\"1\"], \"s2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool book. /*FC*/class MyCalendarTwo {\n/*FM*/bool book(int start, int end) \n    {\n        vector<pair<int,int>>temp; \n        for (int i=0;  i<events.size();  )\n        {\n            \n        }\n        sort(temp.begin(),temp.end()); \n        \n        for (int i=1;  i<temp.size();  )\n        {\n            \n        }\n        \n        events.push_back({start,end});         \n\n        return true; \n    };/*F*/vector<pair<int,int>> events;/*C*/MyCalendarTwo() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyCalendarTwo\": [\"MyCalendarTwo\", \"MyCalendarTwo()\"], \"start\": [\"287049282\"], \"end\": [\"-351312420\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool book. /*FC*/class MyCalendarTwo {\n/*FM*/bool book(int start, int end) \n    {\n        vector<pair<int,int>>p; \n        for (auto x: Set)\n        {\n            \n            \n        }        \n        for (int i=1;  i<p.size();  )\n        {\n            \n        }\n        Set.insert({start,end}); \n        return true; \n    };/*F*/multiset<pair<int,int>> Set;/*C*/MyCalendarTwo() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyCalendarTwo\": [\"MyCalendarTwo\", \"MyCalendarTwo()\"], \"start\": [\"1285716717\"], \"end\": [\"-634197671\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method static bool cmp. /*FC*/class Solution {\n/*FM*/static bool cmp(vector<int>&a, vector<int>&b)\n    {\n        if (a[1]==b[1])\n            \n        else\n            return a[1]<b[1]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [1], \"a_element0\": [\"-711415925\"], \"b\": [2], \"b_element0\": [\"-1488713695\"], \"b_element1\": [\"-1644710574\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int intersectionSizeTwo. /*FC*/class Solution {\n/*FM*/int intersectionSizeTwo(vector<vector<int>>& intervals) \n    {\n        sort(intervals.begin(), intervals.end(), cmp); \n        int a = intervals[0][1]-1, b = intervals[0][1]; \n        int count = 2; \n\n        for (auto& interval: intervals)\n        {\n            if (interval[0]<=a)\n                continue; \n            else if (interval[0]<=b)\n            {\n                \n                \n                \n            }\n            else\n            {\n                \n                \n                \n            }\n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [1], \"intervals_element0\": [2], \"intervals_element0_element0\": [\"-1842570810\"], \"intervals_element0_element1\": [\"-1077221122\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int intersectionSizeTwo. /*FC*/class Solution {\n/*FM*/int intersectionSizeTwo(vector<vector<int>>& intervals) \n    {\n        sort(intervals.begin(), intervals.end(), cmp); \n        int a = intervals[0][1]-1, b = intervals[0][1]; \n        int count = 2; \n\n        for (auto& interval: intervals)\n        {\n            if (interval[0]<=a)\n                \n            else if (interval[0]<=b)\n            {\n                \n                \n                \n            }\n            else\n            {\n                count+=2; \n                a = interval[1]-1; \n                b = interval[1]; \n            }\n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [2], \"intervals_element0_element0\": [\"-959153562\"], \"intervals_element0_element1\": [\"-323005477\"], \"intervals_element1\": [2], \"intervals_element1_element0\": [\"1916728242\"], \"intervals_element1_element1\": [\"-966199180\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minAddToMakeValid. /*FC*/class Solution {\n/*FM*/int minAddToMakeValid(string S) \n    {        \n        int count = 0; \n        int ret = 0; \n        for (auto ch:S)\n        {\n            if (ch=='(')\n                \n            else\n                count--; \n            if (count < 0)\n            {\n                ret += 1; \n                count = 0; \n            }\n        }\n        ret += count; \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> diStringMatch. /*FC*/class Solution {\n/*FM*/vector<int> diStringMatch(string pattern) \n    {\n        pattern = \"I\" + pattern; \n        int n = pattern.size(); \n        \n        int mx = -1; \n        vector<int>arr; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            int j = i+1; \n            while (j<n && pattern[j]=='D')\n                \n            int count = j-i; \n            \n            for (int k= mx+count;  k>=mx+1;  k--)\n                arr.push_back(k); \n            \n            mx = mx+count; \n            \n            i = j-1;             \n        }\n        \n        return arr; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pattern\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int bagOfTokensScore. /*FC*/class Solution {\n/*FM*/int bagOfTokensScore(vector<int>& tokens, int P) \n    {\n        sort(tokens.begin(),tokens.end()); \n        int i = 0; \n        int j = tokens.size()-1; \n        int score = 0; \n        int result = 0; \n        \n        while (i<=j)\n        {\n            if (P>=tokens[i])\n            {\n                P-=tokens[i]; \n                i++; \n                score++; \n                result = max(result,score); \n            }\n            else if (score>0)\n            {\n                score--; \n                P+=tokens[j]; \n                j--; \n            }\n            else\n                \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tokens\": [2], \"tokens_element0\": [\"873198968\"], \"tokens_element1\": [\"-1384486116\"], \"P\": [\"1240225684\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int bagOfTokensScore. /*FC*/class Solution {\n/*FM*/int bagOfTokensScore(vector<int>& tokens, int P) \n    {\n        sort(tokens.begin(),tokens.end()); \n        int i = 0; \n        int j = tokens.size()-1; \n        int score = 0; \n        int result = 0; \n        \n        while (i<=j)\n        {\n            if (P>=tokens[i])\n            {\n                \n                \n                \n                \n            }\n            else if (score>0)\n            {\n                \n                \n                \n            }\n            else\n                break; \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tokens\": [1], \"tokens_element0\": [\"-1081947976\"], \"P\": [\"-2091235656\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDeletionSize. /*FC*/class Solution {\n/*FM*/int minDeletionSize(vector<string>& A) \n    {\n        int m = A.size(); \n        int n = A[0].size(); \n        vector<int>p(m, 0); \n        int ret = 0; \n        for (int j=0;  j<n;  j++)\n        {\n            vector<int>p2 = p; \n            int flag = true; \n            for (int i=1;  i<m;  )\n            {\n                if (p[i]==1) \n                if (p[i]==0)\n                {\n                    if (A[i][j]>A[i-1][j])\n                        \n                    else if (A[i][j]<A[i-1][j])\n                    {\n                        flag = false; \n                        break; \n                    }                        \n                }\n            }\n            if (flag==true)\n                \n            else\n                ret++; \n        }\n        return ret; \n\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"1\"], \"A_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDeletionSize. /*FC*/class Solution {\n/*FM*/int minDeletionSize(vector<string>& A) \n    {\n        int m = A.size(); \n        int n = A[0].size(); \n        vector<int>p(m, 0); \n        int ret = 0; \n        for (int j=0;  j<n;  j++)\n        {\n            vector<int>p2 = p; \n            int flag = true; \n            for (int i=1;  i<m;  i++)\n            {\n                if (p[i]==1) \n                if (p[i]==0)\n                {\n                    if (A[i][j]>A[i-1][j])\n                        p2[i] = 1; \n                    else if (A[i][j]<A[i-1][j])\n                    {\n                        \n                        \n                    }                        \n                }\n            }\n            if (flag==true)\n                p = p2; \n            else\n                \n        }\n        return ret; \n\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"1\"], \"A_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string strWithout3a3b. /*FC*/class Solution {\n/*FM*/string strWithout3a3b(int A, int B) \n    {\n        string ret; \n        \n        if (A>B)\n        {\n            int diff = A-B; \n            for (int i=0;  i<B;  i++)\n            {\n                ret.push_back('a'); \n                if (diff>0)\n                {\n                    ret.push_back('a'); \n                    diff--; \n                }\n                ret.push_back('b'); \n            }\n            for (int i=0;  i<diff;  i++)\n                ret.push_back('a'); \n        }\n        else\n        {\n            \n            \n            \n        }\n        \n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"10\"], \"B\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string strWithout3a3b. /*FC*/class Solution {\n/*FM*/string strWithout3a3b(int A, int B) \n    {\n        string ret; \n        \n        if (A>B)\n        {\n            \n            \n            \n        }\n        else\n        {\n            int diff = B-A; \n            for (int i=0;  i<A;  i++)\n            {\n                ret.push_back('b'); \n                if (diff>0)\n                {\n                    ret.push_back('b'); \n                    diff--; \n                }\n                ret.push_back('a'); \n            }\n            for (int i=0;  i<diff;  i++)\n                ret.push_back('b'); \n        }\n        \n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"2\"], \"B\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string strWithout3a3b. /*FC*/class Solution {\n/*FM*/string strWithout3a3b(int A, int B) \n    {\n        string ret; \n        \n        if (A>B)\n        {\n            int diff = A-B; \n            for (int i=0;  i<B;  i++)\n            {\n                ret.push_back('a'); \n                if (diff>0)\n                {\n                    ret.push_back('a'); \n                    diff--; \n                }\n                ret.push_back('b'); \n            }\n            for (int i=0;  i<diff;  )\n                \n        }\n        else\n        {\n            \n            \n            \n        }\n        \n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"9\"], \"B\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string strWithout3a3b. /*FC*/class Solution {\n/*FM*/string strWithout3a3b(int A, int B) \n    {\n        string ret; \n        \n        if (A>B)\n        {\n            \n            \n            \n        }\n        else\n        {\n            int diff = B-A; \n            for (int i=0;  i<A;  i++)\n            {\n                ret.push_back('b'); \n                if (diff>0)\n                {\n                    \n                    \n                }\n                ret.push_back('a'); \n            }\n            for (int i=0;  i<diff;  )\n                \n        }\n        \n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"2\"], \"B\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool check. /*FC*/class Solution {\n/*FM*/bool check(string A, vector<vector<int>>&table)\n    {\n        int i=0; \n        for (char ch:A)\n        {\n            auto iter = lower_bound(table[ch-'a'].begin(),table[ch-'a'].end(),i); \n            if (iter==table[ch-'a'].end()) return false; \n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"2\"], \"table\": [2], \"table_element0\": [2], \"table_element0_element0\": [\"1717864071\"], \"table_element0_element1\": [\"1897043212\"], \"table_element1\": [1], \"table_element1_element0\": [\"326550706\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numMatchingSubseq. /*FC*/class Solution {\n/*FM*/int numMatchingSubseq(string S, vector<string>& words) \n    {\n        int m = S.size(); \n        S = \"#\"+S; \n        int next[m+1][26]; \n        \n        for (int k=0;  k<26;  k++)\n            next[m][k] = -1; \n        for (int i=m;  i>=1;  i--)\n        {\n            for (int k=0;  k<26;  k++)\n                next[i-1][k] = next[i][k]; \n            next[i-1][S[i]-'a'] = i; \n        }\n        \n        int ret = 0; \n        for (auto word: words)\n        {\n            int flag = 1; \n            int i = 0; \n            for (auto ch: word)\n            {\n                i = next[i][ch-'a']; \n                if (i==-1)\n                {\n                    flag = 0; \n                    break; \n                }                \n            }\n            if (flag) \n        }\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"words\": [1], \"words_element0\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numMatchingSubseq. /*FC*/class Solution {\n/*FM*/int numMatchingSubseq(string S, vector<string>& words) \n    {\n        int m = S.size(); \n        S = \"#\"+S; \n        int next[m+1][26]; \n        \n        for (int k=0;  k<26;  k++)\n            next[m][k] = -1; \n        for (int i=m;  i>=1;  i--)\n        {\n            for (int k=0;  k<26;  k++)\n                next[i-1][k] = next[i][k]; \n            next[i-1][S[i]-'a'] = i; \n        }\n        \n        int ret = 0; \n        for (auto word: words)\n        {\n            int flag = 1; \n            int i = 0; \n            for (auto ch: word)\n            {\n                i = next[i][ch-'a']; \n                if (i==-1)\n                {\n                    \n                    \n                }                \n            }\n            if (flag) ret++; \n        }\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"], \"words\": [1], \"words_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniqueLetterString. /*FC*/class Solution {\n/*FM*/int uniqueLetterString(string s) \n    {\n        int n = s.size(); \n        vector<vector<int>>pos(26);  \n        \n        int ret = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            pos[s[i]-'A'].push_back(i); \n            for (int k=0;  k<26;  k++)\n            {\n                if (pos[k].size()>=2)\n                {\n                    \n                    \n                }\n                else if (pos[k].size()==1)\n                {\n                    \n                }\n            }\n        }\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniqueLetterString. /*FC*/class Solution {\n/*FM*/int uniqueLetterString(string s) \n    {\n        int n = s.size(); \n        vector<vector<int>>pos(26);  \n\n        for (int k=0;  k<26;  k++)\n            pos[k].push_back(-1); \n        for (int i=0;  i<n;  i++)    \n            pos[s[i]-'A'].push_back(i); \n        for (int i=0;  i<n;  i++)    \n            pos[s[i]-'A'].push_back(n); \n\n        int ret = 0; \n        for (int k=0;  k<26;  k++)\n            for (int i=1;  i<pos[k].size()-1;  )\n            {\n                \n            }\n\n        return ret;     \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> advantageCount. /*FC*/class Solution {\n/*FM*/vector<int> advantageCount(vector<int>& A, vector<int>& B) \n    {\n        int n = A.size(); \n        vector<pair<int,int>>BB; \n        for (int i=0;  i<n;  i++)\n            BB.push_back({B[i],i}); \n        sort(BB.begin(), BB.end()); \n        sort(A.begin(), A.end()); \n        \n        int j=0; \n        vector<int>rets(n,-1); \n        for (int i=0;  i<n;  i++)\n        {\n            while (j<n && A[j]<=BB[i].first)\n                j++; \n            if (j<n)\n            {\n                rets[BB[i].second] = A[j]; \n                A[j] = -1; \n            }                \n        }\n        \n        j = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            if (rets[i]!=-1) continue; \n            while (j<n && A[j]==-1) \n            rets[i] = A[j]; \n            j++; \n        }\n        return rets; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"1722476673\"], \"A_element1\": [\"227842833\"], \"B\": [2], \"B_element0\": [\"1647369346\"], \"B_element1\": [\"1356441285\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minRefuelStops. /*FC*/class Solution {\n/*FM*/int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) \n    {\n        if (startFuel>=target) return 0; \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"-496951613\"], \"startFuel\": [\"10\"], \"stations\": [1], \"stations_element0\": [2], \"stations_element0_element0\": [\"-955894830\"], \"stations_element0_element1\": [\"-1546345828\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minRefuelStops. /*FC*/class Solution {\n/*FM*/int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) \n    {\n        if (startFuel>=target) \n        \n        stations.push_back({target,0}); \n        \n        int stationID = 0; \n        int curFuel = startFuel; \n        priority_queue<int>pq; \n        int count = 0; \n        \n        while (stationID<stations.size())\n        {\n            if (curFuel>=stations[stationID][0])\n            {\n                pq.push(stations[stationID][1]); \n                stationID++;                 \n            }\n            else\n            {\n                while (curFuel<stations[stationID][0] && pq.size()>0)\n                {\n                    curFuel+=pq.top(); \n                    pq.pop(); \n                    count+=1; \n                }\n                \n                if (curFuel<stations[stationID][0] && pq.size()==0)\n                    return -1; \n            }\n        }\n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"1073314104\"], \"startFuel\": [\"1\"], \"stations\": [2], \"stations_element0\": [2], \"stations_element0_element0\": [\"-715783634\"], \"stations_element0_element1\": [\"-2027109324\"], \"stations_element1\": [1], \"stations_element1_element0\": [\"-1965582160\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numRescueBoats. /*FC*/class Solution {\n/*FM*/int numRescueBoats(vector<int>& people, int limit) \n    {\n        sort(people.begin(), people.end()); \n        int i=0, j=people.size()-1; \n        int count = 0; \n        while (i<=j)\n        {\n            if (people[i]+people[j]<=limit)\n                \n            j--; \n            count++; \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"people\": [2], \"people_element0\": [\"104572009\"], \"people_element1\": [\"1659066224\"], \"limit\": [\"-21542151\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numRescueBoats. /*FC*/class Solution {\n/*FM*/int numRescueBoats(vector<int>& people, int limit) \n    {\n        sort(people.begin(), people.end()); \n        int i=0, j=people.size()-1; \n        int count = 0; \n        while (i<=j)\n        {\n            if (people[i]+people[j]<=limit)\n                i++; \n            j--; \n            count++; \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"people\": [2], \"people_element0\": [\"996046594\"], \"people_element1\": [\"-2019380626\"], \"limit\": [\"-326091958\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method static bool cmp. /*FC*/class Solution {\n/*FM*/static bool cmp(vector<int>&a, vector<int>&b)\n    {\n        if (a[0]!=b[0])\n            return a[0]<b[0]; \n        else\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [1], \"a_element0\": [\"1323430600\"], \"b\": [3], \"b_element0\": [\"1644048462\"], \"b_element1\": [\"-1740121753\"], \"b_element2\": [\"215345221\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int T) \n    {\n        if (T==0) \n        sort(clips.begin(),clips.end(),cmp);         \n        \n        int far = 0; \n        int i = 0; \n        int count = 0; \n                \n        while (i < clips.size())\n        {            \n            int nextFar = far; \n            while (i<clips.size() && clips[i][0]<=far)\n            {\n                nextFar = max(nextFar, clips[i][1]); \n                i++; \n            }\n            count++; \n\n            if (nextFar >= T)\n                return count; \n            else if (nextFar == far)\n                                            \n            \n        }        \n\n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"clips\": [2], \"clips_element0\": [1], \"clips_element0_element0\": [\"-961983981\"], \"clips_element1\": [2], \"clips_element1_element0\": [\"1139150694\"], \"clips_element1_element1\": [\"-1920839496\"], \"T\": [\"-1203950785\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int T) \n    {\n        if (T==0) \n        sort(clips.begin(),clips.end(),cmp);         \n        \n        int far = 0; \n        int i = 0; \n        int count = 0; \n                \n        while (i < clips.size())\n        {            \n            int nextFar = far; \n            while (i<clips.size() && clips[i][0]<=far)\n            {\n                \n                \n            }\n            count++; \n\n            if (nextFar >= T)\n                \n            else if (nextFar == far)\n                return -1;                             \n            \n        }        \n\n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"clips\": [1], \"clips_element0\": [3], \"clips_element0_element0\": [\"1570646806\"], \"clips_element0_element1\": [\"-1095310713\"], \"clips_element0_element2\": [\"-588259856\"], \"T\": [\"1005117376\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> numMovesStonesII. /*FC*/class Solution {\n/*FM*/vector<int> numMovesStonesII(vector<int>& stones) \n    {\n        sort(stones.begin(),stones.end()); \n        int n = stones.size(); \n        \n        int a = (stones[n-2]-stones[0]+1)-(n-1); \n        int b = (stones[n-1]-stones[1]+1)-(n-1); \n        int y = max(a,b); \n        \n        int j = 0; \n        int x = INT_MAX; \n        for (int i=0;  i<n;  i++)\n        {\n            while (j<n && stones[j]-stones[i]+1<n)\n                \n            if (j==n) \n            \n            int gap; \n            if (stones[j]-stones[i]+1==n)\n                gap = n-(j-i+1); \n            else if (j-i==n-1)\n                \n            else\n                \n            \n            x = min(x,gap); \n        }\n        \n        return {x,y}; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"stones\": [1], \"stones_element0\": [\"1824278105\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> numMovesStonesII. /*FC*/class Solution {\n/*FM*/vector<int> numMovesStonesII(vector<int>& stones) \n    {\n        sort(stones.begin(),stones.end()); \n        int n = stones.size(); \n        \n        int a = (stones[n-2]-stones[0]+1)-(n-1); \n        int b = (stones[n-1]-stones[1]+1)-(n-1); \n        int y = max(a,b); \n        \n        int j = 0; \n        int x = INT_MAX; \n        for (int i=0;  i<n;  )\n        {\n            while (j<n && stones[j]-stones[i]+1<n)\n                j++; \n            if (j==n) break; \n            \n            \n            \n            \n            \n        }\n        \n        return {x,y}; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"stones\": [2], \"stones_element0\": [\"-697862648\"], \"stones_element1\": [\"1727078194\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int kConcatenationMaxSum. /*FC*/class Solution {\n/*FM*/int kConcatenationMaxSum(vector<int>& arr, int k) \n    {   \n        if (k==1)\n             \n        \n        long arrSum = 0;  \n        for (int i = 0;  i < arr.size();  i++) \n        {\n            arrSum += arr[i];  \n            arrSum %= M; \n        }            \n         \n        int len = arr.size(); \n        for (int i=0;  i<len;  i++)\n            arr.push_back(arr[i]); \n        \n        if (arrSum < 0)                     \n                     \n        else        \n            return (maxSubArrSum(arr) + ((long)k - 2) * arrSum)%M;                \n    };/*F*//*C*//*M*/long maxSubArrSum(vector<int>arr) \n    { \n        long max_so_far = 0;  \n        long max_ending_here = 0;  \n  \n        for (int i = 0;  i < arr.size();  i++) \n        { \n            max_ending_here = max_ending_here + arr[i];  \n            if (max_ending_here < 0) \n                max_ending_here = 0;  \n            if (max_so_far < max_ending_here) \n                max_so_far = max_ending_here; \n        } \n        return max_so_far;  \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"2118366544\"], \"arr_element1\": [\"821468519\"], \"k\": [\"2131153231\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int kConcatenationMaxSum. /*FC*/class Solution {\n/*FM*/int kConcatenationMaxSum(vector<int>& arr, int k) \n    {   \n        if (k==1)\n             \n        \n        long arrSum = 0;  \n        for (int i = 0;  i < arr.size();  i++) \n        {\n            arrSum += arr[i];  \n            arrSum %= M; \n        }            \n         \n        int len = arr.size(); \n        for (int i=0;  i<len;  i++)\n            arr.push_back(arr[i]); \n        \n        if (arrSum < 0)                     \n            return maxSubArrSum(arr)%M;          \n        else        \n                           \n    };/*F*//*C*//*M*/long maxSubArrSum(vector<int>arr) \n    { \n        long max_so_far = 0;  \n        long max_ending_here = 0;  \n  \n        for (int i = 0;  i < arr.size();  i++) \n        { \n            max_ending_here = max_ending_here + arr[i];  \n            if (max_ending_here < 0) \n                max_ending_here = 0;  \n            if (max_so_far < max_ending_here) \n                max_so_far = max_ending_here; \n        } \n        return max_so_far;  \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"1429094544\"], \"arr_element1\": [\"-452735955\"], \"k\": [\"-76805041\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jobScheduling. /*FC*/class Solution {\n/*FM*/int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) \n    {\n        int n = startTime.size(); \n        vector<vector<int>>jobs; \n        for (int i=0;  i<n;  i++)\n            jobs.push_back({startTime[i],endTime[i],profit[i]}); \n        sort(jobs.begin(), jobs.end(), cmp); \n        map<int,int>dp; \n        dp[-1] = 0; \n\n        int ret = 0; \n        for (int i=0;  i<n;  i++)\n        {            \n            int ans = ret; \n            auto iter = dp.upper_bound(jobs[i][0]); \n            ans = max(ans, prev(iter,1)->second + jobs[i][2]); \n            dp[jobs[i][1]] = ans; \n\n            ret = max(ret, ans); \n        }\n\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"startTime\": [2], \"startTime_element0\": [\"1800769485\"], \"startTime_element1\": [\"1171789635\"], \"endTime\": [1], \"endTime_element0\": [\"2067965904\"], \"profit\": [2], \"profit_element0\": [\"-1770223630\"], \"profit_element1\": [\"1439863675\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jobScheduling. /*FC*/class Solution {\n/*FM*/int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) \n    {\n        int n = startTime.size(); \n        vector<vector<int>>jobs; \n        for (int i=0;  i<n;  i++)\n            jobs.push_back({startTime[i],endTime[i],profit[i]}); \n        sort(jobs.begin(), jobs.end(), cmp); \n        vector<pair<int,int>>dp; \n        dp.push_back({-1,0}); \n\n        int ret = 0; \n        for (int i=0;  i<n;  i++)\n        {            \n            int ans = ret; \n            auto iter = upper_bound(dp.begin(), dp.end(), make_pair(jobs[i][0], INT_MAX)); \n            ans = max(ans, prev(iter,1)->second + jobs[i][2]);             \n            dp.push_back({jobs[i][1], ans}); \n\n            ret = max(ret, ans); \n        }\n\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"startTime\": [2], \"startTime_element0\": [\"1949850113\"], \"startTime_element1\": [\"-2118186350\"], \"endTime\": [2], \"endTime_element0\": [\"-150145556\"], \"endTime_element1\": [\"-702577613\"], \"profit\": [2], \"profit_element0\": [\"1965520558\"], \"profit_element1\": [\"215819380\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> reconstructMatrix. /*FC*/class Solution {\n/*FM*/vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) \n    {\n        vector<int>a; \n        vector<int>b; \n        \n        for (auto x: colsum)\n        {\n            if (x==2)\n            {\n                       \n                \n                \n                \n            }\n            else if (x==0)\n            {\n                \n                \n            }\n            else\n            {\n                if (upper>=lower && upper>0)\n                {\n                    \n                    \n                    \n                }\n                else if (lower>=upper && lower>0)\n                {\n                    a.push_back(0); \n                    b.push_back(1); \n                    lower--; \n                }\n                else\n                    \n            }\n        }\n        \n        if (upper!=0 || lower!=0)\n            return {}; \n        else\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"upper\": [\"-576593213\"], \"lower\": [\"1687103168\"], \"colsum\": [2], \"colsum_element0\": [\"-40740139\"], \"colsum_element1\": [\"231032843\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> reconstructMatrix. /*FC*/class Solution {\n/*FM*/vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) \n    {\n        vector<int>a; \n        vector<int>b; \n        \n        for (auto x: colsum)\n        {\n            if (x==2)\n            {\n                       \n                \n                \n                \n            }\n            else if (x==0)\n            {\n                \n                \n            }\n            else\n            {\n                if (upper>=lower && upper>0)\n                {\n                    a.push_back(1); \n                    b.push_back(0); \n                    upper--; \n                }\n                else if (lower>=upper && lower>0)\n                {\n                    \n                    \n                    \n                }\n                else\n                    \n            }\n        }\n        \n        if (upper!=0 || lower!=0)\n            return {}; \n        else\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"upper\": [\"1292822197\"], \"lower\": [\"-2122287685\"], \"colsum\": [2], \"colsum_element0\": [\"-631922741\"], \"colsum_element1\": [\"-1839150844\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getWinner. /*FC*/class Solution {\n/*FM*/int getWinner(vector<int>& arr, int k) \n    {\n        int curMax = arr[0]; \n        int times = 0; \n        for (int i=1;  i<arr.size();  i++)\n        {\n            if (arr[i]>curMax)\n            {\n                \n                \n            }\n            else\n            {\n                times+=1; \n            }\n            if (times == k) \n        }\n        return curMax; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"1631766155\"], \"arr_element1\": [\"372742972\"], \"k\": [\"-1734568290\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSwaps. /*FC*/class Solution {\n/*FM*/int minSwaps(vector<vector<int>>& grid) \n    {\n        int n = grid.size(); \n        vector<int>zeros(n); \n        for (int i=0;  i<n;  i++)\n        {\n            int count = 0; \n            for (int j=n-1;  j>=0;  )\n            {\n                if (grid[i][j]!=0)\n                    break; \n                \n            }\n            zeros[i] = count;             \n        }\n        \n        int count = 0; \n        for (int i=0;  i<n-1;  )\n        {\n            \n            \n            \n            \n            \n            \n            \n            \n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [1], \"grid_element0\": [2], \"grid_element0_element0\": [\"-1878691671\"], \"grid_element0_element1\": [\"426523088\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSwaps. /*FC*/class Solution {\n/*FM*/int minSwaps(vector<vector<int>>& grid) \n    {\n        int n = grid.size(); \n        vector<int>zeros(n); \n        for (int i=0;  i<n;  i++)\n        {\n            int count = 0; \n            for (int j=n-1;  j>=0;  j--)\n            {\n                if (grid[i][j]!=0)\n                    break; \n                count++; \n            }\n            zeros[i] = count;             \n        }\n        \n        int count = 0; \n        for (int i=0;  i<n-1;  i++)\n        {\n            int num = n-1-i; \n            int j = i; \n            for (;  j<n;  j++)\n            {\n                if (zeros[j]>=num)\n                    break; \n            }\n            if (j==n) return -1; \n            count += j-i; \n            int temp = zeros[j]; \n            for (int k=j;  k>i;  k--)\n                zeros[k] = zeros[k-1]; \n            zeros[i] = temp; \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [3], \"grid_element0\": [2], \"grid_element0_element0\": [\"-798056998\"], \"grid_element0_element1\": [\"475006715\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"-1973855562\"], \"grid_element2\": [3], \"grid_element2_element0\": [\"999284014\"], \"grid_element2_element1\": [\"-2140541947\"], \"grid_element2_element2\": [\"-1948349517\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMaxLen. /*FC*/class Solution {\n/*FM*/int getMaxLen(vector<int>& nums) \n    {\n        int ret = 0; \n\n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (nums[i]==0) \n            int j = i; \n            int count = 0; \n            int firstNeg = -1; \n\n            while (j<nums.size() && nums[j]!=0)\n            {\n                count += (nums[j]<0); \n                if (count % 2 ==0)\n                    ret = max(ret, j-i+1); \n                else if (firstNeg!=-1)\n                    ret = max(ret, j-firstNeg); \n\n                if (firstNeg==-1 && nums[j]<0)\n                    firstNeg = j; \n                j++; \n            }\n            i = j; \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-248670862\"], \"nums_element1\": [\"-1470630012\"], \"nums_element2\": [\"-748934295\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMaxLen. /*FC*/class Solution {\n/*FM*/int getMaxLen(vector<int>& nums) \n    {\n        int ret = 0; \n\n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (nums[i]==0) \n            int j = i; \n            int count = 0; \n            int firstNeg = -1; \n\n            while (j<nums.size() && nums[j]!=0)\n            {\n                count += (nums[j]<0); \n                if (count % 2 ==0)\n                    ret = max(ret, j-i+1); \n                else if (firstNeg!=-1)\n                    \n\n                if (firstNeg==-1 && nums[j]<0)\n                    \n                j++; \n            }\n            i = j; \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"242725449\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCost. /*FC*/class Solution {\n/*FM*/int minCost(string s, vector<int>& cost) \n    {\n        int ret = 0; \n        for (int i=0;  i<s.size(); )\n        {\n            int j=i; \n            int maxValue = 0; \n            int sum = 0; \n            while (j<s.size() && s[j]==s[i])\n            {\n                sum += cost[j]; \n                maxValue = max(maxValue, cost[j]); \n                j++; \n            }\n            ret += sum - maxValue; \n            i = j; \n        }\n        return ret; \n\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"], \"cost\": [1], \"cost_element0\": [\"-287570265\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int waysToMakeFair. /*FC*/class Solution {\n/*FM*/int waysToMakeFair(vector<int>& nums) \n    {\n        int n = nums.size(); \n        vector<int>leftEven(n+1); \n        vector<int>leftOdd(n+1); \n        int rightEven = 0, rightOdd = 0; \n        nums.insert(nums.begin(),0); \n        for (int i=1;  i<=n;  i++)\n        {\n            if (i%2==0)\n                rightEven+=nums[i]; \n            else\n                rightOdd+=nums[i]; \n            leftEven[i] = rightEven; \n            leftOdd[i] = rightOdd; \n        }\n        \n        rightEven = 0, rightOdd = 0; \n        int ret = 0; \n        for (int i=n;  i>=1;  i--)\n        {\n            if (leftEven[i-1]+rightOdd == leftOdd[i-1]+rightEven)\n                \n                \n            if (i%2==0)\n                rightEven+=nums[i]; \n            else\n                rightOdd+=nums[i];             \n        }\n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"252042806\"], \"nums_element1\": [\"-592503791\"], \"nums_element2\": [\"214427171\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int waysToMakeFair. /*FC*/class Solution {\n/*FM*/int waysToMakeFair(vector<int>& nums) \n    {\n        int n = nums.size(); \n        vector<int>leftEven(n+1); \n        vector<int>leftOdd(n+1); \n        int rightEven = 0, rightOdd = 0; \n        nums.insert(nums.begin(),0); \n        for (int i=1;  i<=n;  i++)\n        {\n            if (i%2==0)\n                \n            else\n                rightOdd+=nums[i]; \n            leftEven[i] = rightEven; \n            leftOdd[i] = rightOdd; \n        }\n        \n        rightEven = 0, rightOdd = 0; \n        int ret = 0; \n        for (int i=n;  i>=1;  i--)\n        {\n            if (leftEven[i-1]+rightOdd == leftOdd[i-1]+rightEven)\n                ret++; \n                \n            if (i%2==0)\n                \n            else\n                rightOdd+=nums[i];             \n        }\n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1245639460\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method static bool cmp. /*FC*/class Solution {\n/*FM*/static bool cmp(vector<int>&a, vector<int>&b)\n    {\n        if (a[1]-a[0] == b[1]-b[0])\n            \n        else\n            return a[1]-a[0]<b[1]-b[0]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [1], \"a_element0\": [\"393871174\"], \"b\": [2], \"b_element0\": [\"142907727\"], \"b_element1\": [\"1170037665\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumEffort. /*FC*/class Solution {\n/*FM*/int minimumEffort(vector<vector<int>>& tasks) \n    {\n        sort(tasks.begin(), tasks.end(), cmp);         \n        int start = 0; \n        for (auto x: tasks)\n        {            \n            start = max(start+x[0], x[1]);      \n        }\n        return start;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tasks\": [3], \"tasks_element0\": [3], \"tasks_element0_element0\": [\"590894656\"], \"tasks_element0_element1\": [\"1253555329\"], \"tasks_element0_element2\": [\"1699084807\"], \"tasks_element1\": [2], \"tasks_element1_element0\": [\"365424202\"], \"tasks_element1_element1\": [\"-300996839\"], \"tasks_element2\": [2], \"tasks_element2_element0\": [\"-1424304395\"], \"tasks_element2_element1\": [\"579779171\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumMountainRemovals. /*FC*/class Solution {\n/*FM*/int minimumMountainRemovals(vector<int>& nums) \n    {\n        int n = nums.size(); \n        vector<int>left(n,1); \n        vector<int>right(n,1); \n        \n        for (int i=0;  i<n;  i++)            \n            for (int j=0;  j<i;  j++)\n            {\n                if (nums[j]<nums[i])\n                    left[i] = max(left[i], left[j]+1);                 \n            }\n        \n        for (int i=n;  i>=0;  i--)            \n            for (int j=i+1;  j<n;  j++)\n            {\n                if (nums[j]<nums[i])\n                                    \n            }\n        \n        int count = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            if (left[i]>=2 && right[i]>=2)\n                \n        }\n        \n        return n-count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-495094673\"], \"nums_element1\": [\"727306147\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumMountainRemovals. /*FC*/class Solution {\n/*FM*/int minimumMountainRemovals(vector<int>& nums) \n    {\n        int n = nums.size(); \n        vector<int>left(n,1); \n        vector<int>right(n,1); \n        \n        for (int i=0;  i<n;  i++)            \n            for (int j=0;  j<i;  j++)\n            {\n                if (nums[j]<nums[i])\n                                    \n            }\n        \n        for (int i=n;  i>=0;  i--)            \n            for (int j=i+1;  j<n;  j++)\n            {\n                if (nums[j]<nums[i])\n                    right[i] = max(right[i], right[j]+1);                 \n            }\n        \n        int count = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            if (left[i]>=2 && right[i]>=2)\n                \n        }\n        \n        return n-count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1843494765\"], \"nums_element1\": [\"-625820429\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int stoneGameVI. /*FC*/class Solution {\n/*FM*/int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) \n    {\n        int n = aliceValues.size(); \n        vector<pair<int,int>>tmp(n); \n        for (int i=0;  i<n;  i++)\n        {\n            tmp[i] = {aliceValues[i]+bobValues[i],i}; \n        }\n        sort(tmp.begin(), tmp.end()); \n        reverse(tmp.begin(), tmp.end()); \n               \n        int x = 0, y = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            if (i%2==0)\n                x += aliceValues[tmp[i].second];                                 \n            else            \n                y += bobValues[tmp[i].second];             \n        }\n        \n        if (x>y)\n            return 1; \n        else if (x==y)\n            \n        else\n            \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"aliceValues\": [2], \"aliceValues_element0\": [\"611494331\"], \"aliceValues_element1\": [\"-2075158374\"], \"bobValues\": [1], \"bobValues_element0\": [\"-1004174866\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int stoneGameVI. /*FC*/class Solution {\n/*FM*/int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) \n    {\n        int n = aliceValues.size(); \n        vector<pair<int,int>>tmp(n); \n        for (int i=0;  i<n;  i++)\n        {\n            tmp[i] = {aliceValues[i]+bobValues[i],i}; \n        }\n        sort(tmp.begin(), tmp.end()); \n        reverse(tmp.begin(), tmp.end()); \n               \n        int x = 0, y = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            if (i%2==0)\n                x += aliceValues[tmp[i].second];                                 \n            else            \n                            \n        }\n        \n        if (x>y)\n            \n        else if (x==y)\n            \n        else\n            return -1; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"aliceValues\": [1], \"aliceValues_element0\": [\"-145345008\"], \"bobValues\": [2], \"bobValues_element0\": [\"-100005413\"], \"bobValues_element1\": [\"-667347181\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string maximumBinaryString. /*FC*/class Solution {\n/*FM*/string maximumBinaryString(string binary) \n    {\n        int n = binary.size(); \n        int m = 0;         \n        for (auto ch:binary)\n        {\n            if (ch=='0')\n                \n        }\n        if (m<=1)  return binary; \n        \n              \n          \n                            \n        \n        \n        \n    \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"binary\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minOperations. /*FC*/class Solution {\n/*FM*/int minOperations(vector<int>& target, vector<int>& arr) \n    {\n        unordered_map<int,int>Map; \n        for (int i=0;  i<target.size();  i++)\n            Map[target[i]] = i; \n        \n        vector<int>q; \n        for (int i=0;  i<arr.size();  i++)\n        {\n            if (Map.find(arr[i])==Map.end())\n                continue; \n            \n            \n        }\n        return target.size() - q.size();         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [1], \"target_element0\": [\"19290351\"], \"arr\": [2], \"arr_element0\": [\"-1939922690\"], \"arr_element1\": [\"1947875442\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumGain. /*FC*/class Solution {\n/*FM*/int maximumGain(string s, int x, int y) \n    {\n        if (x<y) \n        {\n            \n            \n        }\n        int ret = 0; \n        string t; \n        for (auto ch:s)\n        {\n            t.push_back(ch); \n            while (t.size()>=2 && t.substr(t.size()-2)==\"ab\")\n            {\n                \n                \n                \n            }\n        }\n        string w; \n        for (auto ch:t)\n        {\n            w.push_back(ch); \n            while (w.size()>=2 && w.substr(w.size()-2)==\"ba\")\n            {\n                \n                \n                \n            }\n        }\n        return ret; \n\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"x\": [\"1153304453\"], \"y\": [\"-1909185024\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumGain. /*FC*/class Solution {\n/*FM*/int maximumGain(string s, int x, int y) \n    {\n        if (x<y) \n        {\n            reverse(s.begin(), s.end()); \n            swap(x,y); \n        }\n        int ret = 0; \n        string t; \n        for (auto ch:s)\n        {\n            t.push_back(ch); \n            while (t.size()>=2 && t.substr(t.size()-2)==\"ab\")\n            {\n                \n                \n                \n            }\n        }\n        string w; \n        for (auto ch:t)\n        {\n            w.push_back(ch); \n            while (w.size()>=2 && w.substr(w.size()-2)==\"ba\")\n            {\n                \n                \n                \n            }\n        }\n        return ret; \n\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"x\": [\"-1951098348\"], \"y\": [\"-1867901473\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMaximumConsecutive. /*FC*/class Solution {\n/*FM*/int getMaximumConsecutive(vector<int>& coins) \n    {\n        sort(coins.begin(), coins.end()); \n        \n        int curMax = 0; \n        \n        for (auto c: coins)\n        {\n            if (c>curMax+1) break; \n            curMax+=c; \n            \n        }\n        return curMax+1; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"coins\": [2], \"coins_element0\": [\"-1970545444\"], \"coins_element1\": [\"1144950330\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minAbsoluteSumDiff. /*FC*/class Solution {\n/*FM*/int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) \n    {\n        auto arr = nums1; \n        sort(arr.begin(), arr.end()); \n        int n = nums2.size(); \n        int maxDecrease = 0; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            auto iter = lower_bound(arr.begin(), arr.end(), nums2[i]); \n            int a = INT_MAX/2, b = INT_MAX/2; \n            if (iter!=arr.end())\n                a = *iter; \n            if (iter!=arr.begin())\n                b = *prev(iter); \n            \n            int diff = min(abs(a-nums2[i]), abs(b-nums2[i])); \n            \n            int origin = abs(nums1[i]-nums2[i]);             \n            maxDecrease = max(maxDecrease, origin - diff);             \n        }\n        \n        long ret = 0; \n        long M = 1e9+7; \n        for (int i=0;  i<n;  i++)\n        {\n            ret = ret + abs((long)nums1[i] - (long)nums2[i]); \n            ret %= M; \n        }\n        ret -= maxDecrease; \n        ret = (ret+M)%M; \n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"1248274748\"], \"nums1_element1\": [\"-1681755617\"], \"nums2\": [2], \"nums2_element0\": [\"1689205761\"], \"nums2_element1\": [\"-1831516254\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxBuilding. /*FC*/class Solution {\n/*FM*/int maxBuilding(int n, vector<vector<int>>& restrictions) \n    {           \n        \n        restrictions.push_back({1,0}); \n        sort(restrictions.begin(), restrictions.end()); \n        \n        int m = restrictions.size(); \n        vector<int>h(m); \n        \n        for (int i=1;  i<m;  i++)\n        {\n            h[i] = min(restrictions[i][1], h[i-1] + restrictions[i][0] - restrictions[i-1][0]); \n        }\n        \n        for (int i=m-2;  i>=1;  i--)\n        {\n            h[i] = min(h[i], h[i+1] + restrictions[i+1][0] - restrictions[i][0]); \n        }\n        \n        int ret = 0; \n        for (int i=1;  i<m;  i++)\n        {\n            int y = ((h[i-1]-h[i]) - (restrictions[i-1][0]-restrictions[i][0]))/2; \n            ret = max(ret, h[i]+y); \n        }\n        \n        ret = max(ret, h[m-1] + n - restrictions[m-1][0]); \n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1848191138\"], \"restrictions\": [2], \"restrictions_element0\": [1], \"restrictions_element0_element0\": [\"-1836736439\"], \"restrictions_element1\": [1], \"restrictions_element1_element0\": [\"368545113\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMinSwaps. /*FC*/class Solution {\n/*FM*/int getMinSwaps(string num, int k) \n    {\n        auto num0 = num; \n        for (int i=0;  i<k;  i++)\n        {\n            std::next_permutation(num.begin(), num.end()); \n        }\n        \n        int ret = 0; \n        for (int i=0;  i<num.size();  i++)\n        {\n            int count = 0; \n            for (int j=0;  j<num0.size();  )\n            {\n                if (num0[j]==num[i])\n                {\n                    num0[j] = '#'; \n                    break; \n                }                    \n                if (num0[j]=='#')\n                    \n                \n            }\n            ret += count; \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1\"], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long maxAlternatingSum. /*FC*/class Solution {\n/*FM*/long long maxAlternatingSum(vector<int>& nums) \n    {        \n        long long dp_even = 0; \n        long long dp_odd = 0; \n        \n        for (int i=0;  i<nums.size();  i++)\n        {\n            long long dp_even_2 = dp_even; \n            long long dp_odd_2 = dp_odd; \n            \n            dp_even = max(dp_even_2, dp_odd_2 + nums[i]); \n            dp_odd = max(dp_odd_2, dp_even_2 - nums[i]); \n        }\n        \n        return dp_even; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1360598521\"], \"nums_element1\": [\"1757490354\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long maxAlternatingSum. /*FC*/class Solution {\n/*FM*/long long maxAlternatingSum(vector<int>& nums) \n    {\n        ll ret = 0; \n        int i = 0; \n        while (i<nums.size())\n        {\n            if (i+1<nums.size() && nums[i]>nums[i+1])            \n                ret+= nums[i] - nums[i+1]; \n            i++; \n        }\n\n        ret += nums.back(); \n\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1263492367\"], \"nums_element1\": [\"-1314061815\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSwaps. /*FC*/class Solution {\n/*FM*/int minSwaps(string s) \n    {\n        int count=0; \n        int unmatch = 0; \n        for (auto ch: s)\n        {\n            if (ch=='[')\n                \n            else\n                count--; \n            if (count < 0)\n            {\n                unmatch++; \n                count = 0; \n            }\n        }\n        return (unmatch+1)/2; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> longestObstacleCourseAtEachPosition. /*FC*/class Solution {\n/*FM*/vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) \n    {\n        vector<int>a; \n        vector<int>rets; \n        for (auto x: obstacles)\n        {\n            if (a.empty() || a.back()<= x)\n            {\n                a.push_back(x); \n                rets.push_back(a.size()); \n            }\n            else\n            {\n                \n                \n                \n            }                \n        }\n        return rets;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"obstacles\": [2], \"obstacles_element0\": [\"-715898170\"], \"obstacles_element1\": [\"1365102820\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int>split1. /*FC*/class Solution {\n/*FM*/vector<int>split1(vector<int>&sums, int x)\n    {        \n        int k = sums.size(); \n        vector<int>visited(k); \n        vector<int>rets; \n        int i = k-1, j = k-1; \n        for (int t=0;  t<k/2;  )\n        {\n                     if (i<0) \n            \n            \n                     if (j<0) \n            \n            \n            \n        }\n        return rets; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"sums\": [1], \"sums_element0\": [\"-1835312771\"], \"x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int>split1. /*FC*/class Solution {\n/*FM*/vector<int>split1(vector<int>&sums, int x)\n    {        \n        int k = sums.size(); \n        vector<int>visited(k); \n        vector<int>rets; \n        int i = k-1, j = k-1; \n        for (int t=0;  t<k/2;  )\n        {\n            while (i>=0 && visited[i])\n                \n            if (i<0) \n            visited[i] = 1; \n            \n            while (j>=0 && (visited[j]||sums[j]!=sums[i]-x))\n                j--; \n            if (j<0) return {}; \n            \n            \n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"sums\": [2], \"sums_element0\": [\"797564800\"], \"sums_element1\": [\"730545962\"], \"x\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int>split2. /*FC*/class Solution {\n/*FM*/vector<int>split2(vector<int>&sums, int x)\n    {\n        int k = sums.size(); \n        vector<int>visited(k); \n        vector<int>rets; \n        int i = 0, j = 0; \n        for (int t=0;  t<k/2;  )\n        {\n                     if (i>=k) \n            \n            \n                     if (j>=k) \n            \n            \n            \n        }\n        return rets; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"sums\": [1], \"sums_element0\": [\"-1042772165\"], \"x\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int>split2. /*FC*/class Solution {\n/*FM*/vector<int>split2(vector<int>&sums, int x)\n    {\n        int k = sums.size(); \n        vector<int>visited(k); \n        vector<int>rets; \n        int i = 0, j = 0; \n        for (int t=0;  t<k/2;  )\n        {\n            while (i<k && visited[i])\n                \n            if (i>=k) \n            visited[i] = 1; \n            \n            while (j<k && (visited[j]||sums[j]!=sums[i]-x))\n                j++; \n            if (j>=k) return {}; \n            \n            \n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"sums\": [2], \"sums_element0\": [\"1350619616\"], \"sums_element1\": [\"1272476675\"], \"x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfWeakCharacters. /*FC*/class Solution {\n/*FM*/int numberOfWeakCharacters(vector<vector<int>>& properties) \n    {\n        sort(properties.begin(), properties.end(), cmp); \n        stack<int>Stack; \n        int ret = 0; \n        for (int i=0;  i<properties.size();  i++)\n        {\n            while (!Stack.empty() && Stack.top() < properties[i][1])\n            {\n                Stack.pop(); \n                ret++; \n            }\n            Stack.push(properties[i][1]); \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"properties\": [2], \"properties_element0\": [1], \"properties_element0_element0\": [\"-1194580138\"], \"properties_element1\": [2], \"properties_element1_element0\": [\"-1795312215\"], \"properties_element1_element1\": [\"85031379\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfWeakCharacters. /*FC*/class Solution {\n/*FM*/int numberOfWeakCharacters(vector<vector<int>>& properties) \n    {\n        sort(properties.begin(), properties.end(), cmp); \n        stack<int>Stack; \n        int ret = 0; \n        for (int i=0;  i<properties.size();  i++)\n        {\n            while (!Stack.empty() && Stack.top() < properties[i][1])\n            {\n                \n                \n            }\n            Stack.push(properties[i][1]); \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"properties\": [2], \"properties_element0\": [1], \"properties_element0_element0\": [\"-19298851\"], \"properties_element1\": [2], \"properties_element1_element0\": [\"1119134312\"], \"properties_element1_element1\": [\"-2067695500\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findOriginalArray. /*FC*/class Solution {\n/*FM*/vector<int> findOriginalArray(vector<int>& changed) \n    {        \n        int n = changed.size(); \n        if (n%2!=0) \n        \n        multiset<int>Set(changed.begin(), changed.end()); \n        vector<int>rets; \n        for (int t=0;  t<n/2;  )\n        {\n            int mx = *prev(Set.end()); \n            if (mx%2!=0)\n                \n            if (Set.find(mx/2)==Set.end())\n                return {}; \n            \n            \n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"changed\": [2], \"changed_element0\": [\"-1426963564\"], \"changed_element1\": [\"-464786492\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findOriginalArray. /*FC*/class Solution {\n/*FM*/vector<int> findOriginalArray(vector<int>& changed) \n    {        \n        int n = changed.size(); \n        if (n%2!=0) \n        \n        multiset<int>Set(changed.begin(), changed.end()); \n        vector<int>rets; \n        for (int t=0;  t<n/2;  )\n        {\n            int mx = *prev(Set.end()); \n            if (mx%2!=0)\n                return {}; \n            if (Set.find(mx/2)==Set.end())\n                \n            \n            \n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"changed\": [2], \"changed_element0\": [\"1917247017\"], \"changed_element1\": [\"-196074672\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findOriginalArray. /*FC*/class Solution {\n/*FM*/vector<int> findOriginalArray(vector<int>& changed) \n    {        \n        int n = changed.size(); \n        if (n%2!=0) return {}; \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"changed\": [1], \"changed_element0\": [\"1908795006\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findOriginalArray. /*FC*/class Solution {\n/*FM*/vector<int> findOriginalArray(vector<int>& changed) \n    {\n        int n =changed.size(); \n        if (n%2!=0)  return {}; \n        \n        \n        \n        \n        \n        \n        \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"changed\": [1], \"changed_element0\": [\"-895849790\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findOriginalArray. /*FC*/class Solution {\n/*FM*/vector<int> findOriginalArray(vector<int>& changed) \n    {\n        int n =changed.size(); \n        if (n%2!=0)  \n        \n        sort(changed.begin(), changed.end()); \n        \n        vector<int>rets; \n        int left = 0, right = 0; \n        vector<int>used(n); \n        for (int i=0;  i<n/2;  )\n        {\n            while (left < n && used[left])\n                \n            if (left==n) \n            rets.push_back(changed[left]); \n            used[left] = 1; \n            while (right < n && (used[right]||changed[right]!=changed[left]*2))\n                right++; \n            if (right==n) return {};             \n            \n        }\n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"changed\": [2], \"changed_element0\": [\"-234006702\"], \"changed_element1\": [\"389742161\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLIS. /*FC*/class Solution {\n/*FM*/int lengthOfLIS(vector<int>& nums) \n    {\n        int n = nums.size();               \n        vector<int>q(n, INT_MAX); \n        for (int i=0;  i<n;  i++)\n        {\n            auto iter = upper_bound(q.begin(),q.end(),nums[i]); \n            *iter = nums[i]; \n        }\n        for (int i = n - 1;  i >= 0;  i--)\n        {\n            if (q[i] != INT_MAX)\n                return i + 1;   \n        }\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-439101658\"], \"nums_element1\": [\"1281625959\"], \"nums_element2\": [\"-2056262089\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canBeValid. /*FC*/class Solution {\n/*FM*/bool canBeValid(string s, string locked) \n    {\n        int n = s.size(); \n        if (n%2!=0) return false; \n        \n        if (!checkRight(s, locked)) \n        if (!checkLeft(s, locked)) \n        \n        \n    };/*F*//*C*//*M*/bool checkRight(string s, string locked)\n    {\n        int unmatched = 0; \n        int count = 0; \n        \n        for (int i = 0;  i<s.size();  i++)\n        {\n            if (s[i]=='(')\n                unmatched++; \n            else\n                unmatched--; \n\n            if (locked[i]=='0' && s[i]==')')            \n                count++; \n            \n            if (unmatched < 0)\n            {\n                if (count==0) return false; \n                unmatched += 2; \n                count--; \n            }\n        }\n        return true; \n    } bool checkLeft(string s, string locked)\n    {\n        int unmatched = 0; \n        int count = 0; \n        \n        for (int i = s.size()-1;  i>=0;  i--)\n        {\n            if (s[i]==')')\n                unmatched++; \n            else\n                unmatched--; \n\n            if (locked[i]=='0' && s[i]=='(')            \n                count++; \n            \n            if (unmatched < 0)\n            {\n                if (count==0) return false; \n                unmatched += 2; \n                count--; \n            }\n        }\n        return true; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"], \"locked\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canBeValid. /*FC*/class Solution {\n/*FM*/bool canBeValid(string s, string locked) \n    {\n        if (s.size() % 2 != 0) return false; \n        \n                \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"], \"locked\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> recoverArray. /*FC*/class Solution {\n/*FM*/vector<int> recoverArray(vector<int>& nums) \n    {\n        int n = nums.size()/2; \n        sort(nums.begin(), nums.end()); \n        \n        for (int i=1;  i<=n;  i++)\n        {\n            if (nums[i]==nums[0]) \n            if ((nums[i]+nums[0])%2==1) continue; \n            \n            \n\n            \n            \n            \n            \n            \n            \n        }\n        return {};         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"783433135\"], \"nums_element1\": [\"-607633818\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> recoverArray. /*FC*/class Solution {\n/*FM*/vector<int> recoverArray(vector<int>& nums) \n    {\n        int n = nums.size()/2; \n        sort(nums.begin(), nums.end()); \n        \n        for (int i=1;  i<=n;  )\n        {\n            if (nums[i]==nums[0]) \n            if ((nums[i]+nums[0])%2==1) \n            int mn = (nums[i]+nums[0])/2; \n            int k = (nums[i]-nums[0])/2; \n\n            int left = 0, right = 1; \n            int flag = 1; \n            vector<int>visited(2*n); \n            vector<int>rets; \n            for (int t=0;  t<n;  t++)\n            {\n                while (visited[left]) \n                if (left==2*n)\n                {\n                    \n                    \n                }\n                visited[left] = 1; \n                while (right<2*n && (visited[right]==1 || nums[right]!=nums[left]+2*k))\n                    \n                if (right<2*n)\n                    visited[right] = 1; \n                else\n                {\n                    \n                    \n                }                \n                rets.push_back(nums[left]+k);     \n            }\n            if (flag)\n                return rets; \n        }\n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-344315019\"], \"nums_element1\": [\"1687382877\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int earliestFullBloom. /*FC*/class Solution {\n/*FM*/int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) \n    {\n        int n = plantTime.size(); \n        vector<vector<int>>time(n); \n        for (int i=0;  i<n;  i++)\n        {\n            time[i] = {plantTime[i], -growTime[i]};             \n        }\n        sort(time.begin(), time.end(), [](vector<int>&a, vector<int>&b){return a[1]<b[1]; }); \n        \n        int left = 1, right = INT_MAX/2; \n        while (left < right)\n        {\n            int mid = left+(right-left)/2; \n            if (checkOK(mid, time))\n                right = mid; \n            else\n                \n        }\n        return left;         \n    };/*F*//*C*//*M*/bool checkOK(int T, vector<vector<int>>&time)\n    {\n        int n = time.size(); \n        int days = 0; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            days += time[i][0]; \n            \n            if (days > T+time[i][1])\n            {\n                return false; \n            }\n        }        \n        return true;       \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"plantTime\": [1], \"plantTime_element0\": [\"-735922774\"], \"growTime\": [2], \"growTime_element0\": [\"732801505\"], \"growTime_element1\": [\"-1071563908\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int earliestFullBloom. /*FC*/class Solution {\n/*FM*/int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) \n    {\n        int n = plantTime.size(); \n        vector<vector<int>>time(n); \n        for (int i=0;  i<n;  i++)\n        {\n            time[i] = {plantTime[i], -growTime[i]};             \n        }\n        sort(time.begin(), time.end(), [](vector<int>&a, vector<int>&b){return a[1]<b[1]; }); \n        \n        int left = 1, right = INT_MAX/2; \n        while (left < right)\n        {\n            int mid = left+(right-left)/2; \n            if (checkOK(mid, time))\n                \n            else\n                left = mid+1; \n        }\n        return left;         \n    };/*F*//*C*//*M*/bool checkOK(int T, vector<vector<int>>&time)\n    {\n        int n = time.size(); \n        int days = 0; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            days += time[i][0]; \n            \n            if (days > T+time[i][1])\n            {\n                return false; \n            }\n        }        \n        return true;       \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"plantTime\": [3], \"plantTime_element0\": [\"-1230702679\"], \"plantTime_element1\": [\"-1264434319\"], \"plantTime_element2\": [\"-1025842970\"], \"growTime\": [2], \"growTime_element0\": [\"885073371\"], \"growTime_element1\": [\"-244219037\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkOK. /*FC*/class Solution {\n/*FM*/bool checkOK(int T, vector<vector<int>>&time)\n    {\n        int n = time.size(); \n        int days = 0; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            days += time[i][0]; \n            \n            if (days > T+time[i][1])\n            {\n                return false; \n            }\n        }        \n              \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"T\": [\"-2034386009\"], \"time\": [2], \"time_element0\": [1], \"time_element0_element0\": [\"-293483878\"], \"time_element1\": [3], \"time_element1_element0\": [\"-585589554\"], \"time_element1_element1\": [\"191929869\"], \"time_element1_element2\": [\"-1553149892\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkOK. /*FC*/class Solution {\n/*FM*/bool checkOK(int T, vector<vector<int>>&time)\n    {\n        int n = time.size(); \n        int days = 0; \n        \n        for (int i=0;  i<n;  i++)\n        {\n            days += time[i][0]; \n            \n            if (days > T+time[i][1])\n            {\n                \n            }\n        }        \n        return true;       \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"T\": [\"-100544278\"], \"time\": [1], \"time_element0\": [1], \"time_element0_element0\": [\"1075967052\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int earliestFullBloom. /*FC*/class Solution {\n/*FM*/int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) \n    {\n        int n = plantTime.size(); \n        vector<vector<int>>time(n); \n        for (int i=0;  i<n;  i++)\n        {\n            time[i] = {plantTime[i], growTime[i]};             \n        }\n        sort(time.begin(), time.end(), [](vector<int>&a, vector<int>&b){return a[1]>b[1]; }); \n        \n        int ret = 0; \n        int days = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            days+=time[i][0]; \n            ret = max(ret, days+time[i][1]); \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"plantTime\": [1], \"plantTime_element0\": [\"1011238096\"], \"growTime\": [2], \"growTime_element0\": [\"1925742743\"], \"growTime_element1\": [\"-1983560599\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubsequence. /*FC*/class Solution {\n/*FM*/bool isSubsequence(string s, string t) \n    {\n        int i=0; \n        int j=0; \n        while (i<s.size() && j<t.size())\n        {\n            if (s[i]!=t[j])\n                j++; \n            else\n            {\n                \n                \n            }\n        }\n        if (i<s.size())\n            return false; \n        else\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubsequence. /*FC*/class Solution {\n/*FM*/bool isSubsequence(string s, string t) \n    {\n        unordered_map<char,vector<int>>Map; \n        for (int i=0;  i<t.size();  i++)\n            Map[t[i]].push_back(i); \n            \n        int NextStart = -1; \n        for (int i=0;  i<s.size();  )\n        {\n            char ch = s[i]; \n            int flag=0; \n            \n            for (int j:Map[ch])\n            {\n                \n            }\n            if (flag==0) return false; \n        }\n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestPalindrome. /*FC*/class Solution {\n/*FM*/int longestPalindrome(string s) \n    {\n        vector<int>Map(256,0); \n        for (int i=0;  i<s.size();  i++)\n            Map[s[i]]++; \n        \n        int sum=0; \n        int flag=0; \n        for (auto a:Map)\n        {\n            if ((a % 2) ==1)\n            {\n                sum+=a-1; \n                flag=1; \n            }\n            else\n                sum+=a; \n        }\n        \n        return sum+flag; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfArithmeticSlices. /*FC*/class Solution {\n/*FM*/int numberOfArithmeticSlices(vector<int>& A) \n    {\n        int n = A.size(); \n        unordered_map<long,int>dp[1000]; \n        int count = 0; \n        \n        for (int i=1;  i<A.size();  i++)\n        {\n            for (int j=i-1;  j>=0;  j--)\n            {\n                long diff = (long)A[i]-(long)A[j]; \n                count += dp[j][diff]; \n                \n                if (dp[j].find(diff)!=dp[j].end())\n                    dp[i][diff] += dp[j][diff]+1;                                     \n                else\n                    \n            }\n        }\n                    \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-1307397253\"], \"A_element1\": [\"-868743938\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfArithmeticSlices. /*FC*/class Solution {\n/*FM*/int numberOfArithmeticSlices(vector<int>& A) \n    {\n        unordered_map<int,vector<int>>Map; \n        for (int i=0;  i<A.size();  i++)\n            Map[A[i]].push_back(i); \n        \n        int N = A.size(); \n        auto dp = vector<vector<int>>(N,vector<int>(N,0)); \n        for (int i=0;  i<N;  i++)\n            for (int j=0;  j<i;  j++)\n            {\n                long m = A[j]*2L-A[i]; \n                if (m>INT_MAX || m<INT_MIN) continue; \n                for (:Map[m])\n                {\n                    \n                }\n            }\n        int count = 0; \n        for (int j=0;  j<N;  j++)\n            for (int i=j+1;  i<N;  i++)\n                count+=dp[j][i]; \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-1477991500\"], \"A_element1\": [\"204125768\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfArithmeticSlices. /*FC*/class Solution {\n/*FM*/int numberOfArithmeticSlices(vector<int>& A) \n    {\n        unordered_map<int,vector<int>>Map; \n        for (int i=0;  i<A.size();  i++)\n            Map[A[i]].push_back(i); \n        \n        int N = A.size(); \n        auto dp = vector<vector<int>>(N,vector<int>(N,0)); \n        for (int i=0;  i<N;  i++)\n            for (int j=0;  j<i;  j++)\n            {\n                long m = A[j]*2L-A[i]; \n                if (m>INT_MAX || m<INT_MIN) continue; \n                for (int k:Map[m])\n                {\n                    \n                }\n            }\n        int count = 0; \n        for (int j=0;  j<N;  j++)\n            for (int i=j+1;  i<N;  i++)\n                count+=dp[j][i]; \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"1761529670\"], \"A_element1\": [\"-1715849192\"], \"A_element2\": [\"-2024775975\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMaxLength. /*FC*/class Solution {\n/*FM*/int findMaxLength(vector<int>& nums) \n    {\n        unordered_map<int,int>Map;  \n        Map[0] = -1; \n        \n        int ret = 0; \n        int presum = 0; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (nums[i]==1)\n                \n            else\n                presum -= 1; \n            \n            if (Map.find(presum)!=Map.end())\n                \n            else\n                Map[presum] = i; \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1783960194\"], \"nums_element1\": [\"1306934501\"], \"nums_element2\": [\"-973056672\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPairs. /*FC*/class Solution {\n/*FM*/int findPairs(vector<int>& nums, int k) \n    {\n        if (k<0) \n        unordered_set<int>Set; \n        unordered_set<int>minSet; \n        \n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (Set.find(nums[i]-k)!=Set.end())\n                \n            if (Set.find(nums[i]+k)!=Set.end())\n                \n            Set.insert(nums[i]); \n        }\n        \n        return minSet.size();         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"240868810\"], \"nums_element1\": [\"134945493\"], \"nums_element2\": [\"-170318693\"], \"k\": [\"61493912\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPairs. /*FC*/class Solution {\n/*FM*/int findPairs(vector<int>& nums, int k) \n    {\n        if (k<0) return 0; \n        \n        \n        \n        \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-118475842\"], \"nums_element1\": [\"1808030065\"], \"nums_element2\": [\"-1309640390\"], \"k\": [\"-1128314431\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPairs. /*FC*/class Solution {\n/*FM*/int findPairs(vector<int>& nums, int k) \n    {\n        sort(nums.begin(),nums.end()); \n        \n        int i=0; \n        int j=1; \n        int result=0; \n        \n        while (j<nums.size())\n        {\n            while (nums[j]<nums[i]+k) \n            if (nums[j]==nums[i]+k)\n                \n            i++; \n            while (i<nums.size() && nums[i]==nums[i-1]) \n            j=max(j,i+1); \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-421913655\"], \"nums_element1\": [\"2104401406\"], \"k\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumTime. /*FC*/class Solution {\n/*FM*/int minimumTime(string s) \n    {\n        int n = s.size(); \n        vector<int>pre(n); \n                \n        vector<int>left(n); \n        left[0] = s[0]=='0'?0:1; \n        for (int i=1;  i<n;  )\n        {\n            \n        }\n                \n        vector<int>right(n); \n        right[n-1] = s[n-1]=='0'?0:1; \n        for (int i=n-2;  i>=0;  )\n        {\n            \n        }\n        \n        int ret = min(left[n-1], right[0]); \n        for (int i=1;  i<n-1;  )\n            \n                        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumTime. /*FC*/class Solution {\n/*FM*/int minimumTime(string s) \n    {\n        int n = s.size(); \n        \n        vector<int>pre(n);         \n        pre[0] = (s[0]=='1'); \n        for (int i=1;  i<n;  )\n            \n        \n        vector<int>arr(n); \n        for (int i=0;  i<n;  i++)\n            arr[i] = 2*pre[i] - i; \n        \n        int ret = n;         \n        int preMax = 1; \n        for (int i=0;  i<n;  i++)\n        {\n            ret = min(ret, arr[i]-preMax+n); \n            preMax = max(preMax, arr[i]); \n        }            \n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumOperations. /*FC*/class Solution {\n/*FM*/int minimumOperations(vector<int>& nums) \n    {\n        int n = nums.size(); \n        if (n==1) \n        \n        unordered_map<int,int>Map1; \n        unordered_map<int,int>Map2; \n        int count1 = 0, count2 = 0; \n        for (int i=0;  i<n;  i+=2)\n        {\n            Map1[nums[i]]++; \n            count1++; \n        }\n        for (int i=1;  i<n;  i+=2)\n        {\n            Map2[nums[i]]++; \n            count2++; \n        }\n        \n        vector<pair<int,int>>temp1(Map1.begin(), Map1.end());         \n        vector<pair<int,int>>temp2(Map2.begin(), Map2.end()); \n        sort(temp1.begin(), temp1.end(), cmp); \n        sort(temp2.begin(), temp2.end(), cmp); \n        \n        if (temp1.size()==1) temp1.push_back({0,0}); \n        if (temp2.size()==1) temp2.push_back({0,0}); \n                \n        if (temp1[0].first!=temp2[0].first)\n            return n - temp1[0].second - temp2[0].second; \n        else\n        {\n            \n            \n            \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1494976570\"], \"nums_element1\": [\"-1713415045\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumOperations. /*FC*/class Solution {\n/*FM*/int minimumOperations(vector<int>& nums) \n    {\n        int n = nums.size(); \n        if (n==1) return 0; \n        \n        \n        \n        \n        \n        \n        \n                \n        \n        \n        \n        \n        \n        \n                \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-340470387\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumRemoval. /*FC*/class Solution {\n/*FM*/long long minimumRemoval(vector<int>& beans) \n    {\n        sort(beans.rbegin(), beans.rend()); \n        LL total = accumulate(beans.begin(), beans.end(), 0LL); \n\n        LL ret = LLONG_MAX; \n        for (int i=0;  i<beans.size();  i++)\n        {            \n            ret = min(ret, total - (LL)beans[i]*(i+1)); \n        }\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"beans\": [2], \"beans_element0\": [\"-400642903\"], \"beans_element1\": [\"695627666\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minMovesToMakePalindrome. /*FC*/class Solution {\n/*FM*/int minMovesToMakePalindrome(string s) \n    {\n        int n = s.size(); \n        int ret = 0; \n        int count = 0;  \n        \n        for (int i=0;  i<n/2;  )\n        {            \n            \n            \n            if (i==j)\n            {\n                \n                \n            }\n            else\n            {\n                \n                \n                         \n                \n            }\n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minMovesToMakePalindrome. /*FC*/class Solution {\n/*FM*/int minMovesToMakePalindrome(string s) \n    {\n        int n = s.size(); \n        int count = 0;  \n        int ret = 0; \n        \n        unordered_map<char, deque<int>>dq; \n        for (int i=0;  i<n;  i++)\n            dq[s[i]].push_back(i); \n        \n        vector<int>arr; \n        for (int i=0;  i<n;  i++)\n        {\n            if (dq[s[i]].empty())\n                \n            else if (dq[s[i]].size()==1)\n            {\n                ret += i + (n/2-count) - n/2; \n                dq[s[i]].pop_back(); \n            }\n            else\n            {\n                \n                \n                \n                \n                                \n            }\n        }\n        \n        reverse(arr.begin(), arr.end()); \n        return ret + reversePairs(arr); \n    };/*F*//*C*//*M*/int reversePairs(vector<int>& nums) \n    {\n        int n = nums.size(); \n        vector<int>sorted = nums;         \n        return helper(nums, sorted, 0, n-1);         \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->temp\": [50001], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumTop. /*FC*/class Solution {\n/*FM*/int maximumTop(vector<int>& nums, int K) \n    {\n        int n = nums.size();         \n        int ret = INT_MIN; \n        for (int i=1;  i<=n;  i++)\n        {\n            int k = K; \n            if (k<i-1) continue; \n            \n            \n\n            \n\n            \n        }\n        return ret==INT_MIN? -1:ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"607671939\"], \"nums_element1\": [\"-837040825\"], \"K\": [\"-746850474\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumTop. /*FC*/class Solution {\n/*FM*/int maximumTop(vector<int>& nums, int K) \n    {\n        int n = nums.size();         \n        int ret = INT_MIN; \n        for (int i=1;  i<=n;  i++)\n        {\n            int k = K; \n            if (k<i-1) \n            k -= (i-1); \n            int flag = 0; \n\n            if (k==0)\n                \n            else if (k==1)\n                \n            else if (k%2==0)\n                \n            else if (k%2==1 && i<n)\n                \n            else if (k%2==1 && i>1)\n                \n\n            if (flag) \n        }\n        return ret==INT_MIN? -1:ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"949220207\"], \"K\": [\"230035627\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumTop. /*FC*/class Solution {\n/*FM*/int maximumTop(vector<int>& nums, int K) \n    {\n        int n = nums.size();         \n        int ret = INT_MIN; \n        for (int i=1;  i<=n;  i++)\n        {\n            int k = K; \n            if (k<i-1) \n            k -= (i-1); \n            int flag = 0; \n\n            if (k==0)\n                \n            else if (k==1)\n                \n            else if (k%2==0)\n                flag = 1; \n            else if (k%2==1 && i<n)\n                flag = 1; \n            else if (k%2==1 && i>1)\n                \n\n            if (flag) ret = max(ret, nums[i-1]); \n        }\n        return ret==INT_MIN? -1:ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1251236843\"], \"nums_element1\": [\"820273363\"], \"K\": [\"101311355\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDeletion. /*FC*/class Solution {\n/*FM*/int minDeletion(vector<int>& nums) \n    {\n        int n = nums.size(); \n        int ret = 0; \n        \n        int i = 0;         \n        \n        while (i<n)\n        {            \n            int j = i+1; \n            while (j<n && nums[j]==nums[i])\n            {\n                \n                \n            }\n            \n            if (j<n)\n            {\n                i = j+1; \n            }\n            else\n            {\n                \n                \n            }                \n        }\n        \n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1226614079\"], \"nums_element1\": [\"1511061297\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDeletion. /*FC*/class Solution {\n/*FM*/int minDeletion(vector<int>& nums) \n    {\n        int n = nums.size(); \n        int ret = 0; \n        \n        int i = 0;         \n        \n        while (i<n)\n        {            \n            int j = i+1; \n            while (j<n && nums[j]==nums[i])\n            {\n                \n                \n            }\n            \n            if (j<n)\n            {\n                \n            }\n            else\n            {\n                ret++; \n                break; \n            }                \n        }\n        \n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1682589252\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long maximumBeauty. /*FC*/class Solution {\n/*FM*/long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \n    {\n        sort(flowers.begin(), flowers.end()); \n        \n        LL ret0 = 0; \n        while (flowers.size()>0 && flowers.back()>=target)\n        {\n            \n            \n        }        \n        if (flowers.empty()) \n        \n        LL n = flowers.size();                 \n        vector<LL>presum(n); \n        for (LL i=0;  i<n;  i++)\n            presum[i] = (i==0?0:presum[i-1])+flowers[i]; \n        vector<LL>diff(n); \n        for (LL i=0;  i<n;  i++)\n            diff[i] = (i+1)*flowers[i] - presum[i];         \n                \n        LL ret = 0;         \n        for (int i=n-1;  i>=0;  )\n        {\n            if (newFlowers < 0) break; \n            \n            if (presum[i]+newFlowers >= (LL)(target-1)*(i+1))\n            {\n                                \n            }\n            else\n            {\n                \n                \n                \n                \n                                                      \n            }\n                         \n        }\n        \n        if (newFlowers>=0)\n            \n        \n        return ret + ret0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"flowers\": [1], \"flowers_element0\": [\"-283655102\"], \"newFlowers\": [\"-6764200232296292966\"], \"target\": [\"7\"], \"full\": [\"268807995\"], \"partial\": [\"-644413616\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long maximumBeauty. /*FC*/class Solution {\n/*FM*/long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \n    {\n        sort(flowers.begin(), flowers.end()); \n        \n        LL ret0 = 0; \n        while (flowers.size()>0 && flowers.back()>=target)\n        {\n            ret0 += full; \n            flowers.pop_back(); \n        }        \n        if (flowers.empty()) return ret0; \n        \n                        \n        \n        \n        \n                \n                \n                \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"flowers\": [1], \"flowers_element0\": [\"952377847\"], \"newFlowers\": [\"820971258686183991\"], \"target\": [\"7\"], \"full\": [\"-1238337115\"], \"partial\": [\"-1487656998\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long maximumBeauty. /*FC*/class Solution {\n/*FM*/long long maximumBeauty(vector<int>& flowers, long long newFlowers, int target, int full, int partial) \n    {\n        sort(flowers.begin(), flowers.end()); \n        \n        LL ret0 = 0; \n        while (flowers.size()>0 && flowers.back()>=target)\n        {\n            \n            \n        }        \n        if (flowers.empty()) \n        \n        LL n = flowers.size();                 \n        vector<LL>presum(n); \n        for (LL i=0;  i<n;  i++)\n            presum[i] = (i==0?0:presum[i-1])+flowers[i]; \n        vector<LL>diff(n); \n        for (LL i=0;  i<n;  i++)\n            diff[i] = (i+1)*flowers[i] - presum[i];         \n                \n        LL ret = 0;         \n        for (int i=n-1;  i>=0;  i--)\n        {\n            if (newFlowers < 0) \n            \n            if (presum[i]+newFlowers >= (LL)(target-1)*(i+1))\n            {\n                ret = max(ret, (LL)(target-1)*partial + (LL)(n-1-i)*full);                 \n            }\n            else\n            {\n                \n                \n                \n                \n                                                      \n            }\n            newFlowers -= target-flowers[i];              \n        }\n        \n        if (newFlowers>=0)\n            ret = max(ret, n*full); \n        \n        return ret + ret0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"flowers\": [1], \"flowers_element0\": [\"-997626865\"], \"newFlowers\": [\"2089862145949832449\"], \"target\": [\"10\"], \"full\": [\"-364595851\"], \"partial\": [\"1147567983\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long appealSum. /*FC*/class Solution {\n/*FM*/long long appealSum(string s) \n    {\n        vector<int>pos(26, -1); \n        long long result=0; \n        for (int i=0;  i<s.size();  i++)\n        {\n            pos[s[i]-'a'] = i; \n            for (int i=0;  i<26;  i++)\n            {\n                if (pos[i]!=-1)                                    \n                    result+=(long long)pos[i]+1;                   \n            }\n        }\n        return result;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long appealSum. /*FC*/class Solution {\n/*FM*/long long appealSum(string s) \n    {\n        int n = s.size(); \n        vector<int>last(26, -1);         \n            \n        long long ret = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            ret += (i-last[s[i]-'a']) * (n-i); \n            last[s[i]-'a']=i; \n        }\n            \n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int solve. /*FC*/class Solution {\n/*FM*/int solve(vector<int>& nums) {\n        int res = 0; \n        priority_queue<int> que; \n        for(auto num: nums) {\n            if(!que.empty() && que.top()>num) {\n                \n                \n                \n            }\n            que.push(num); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-540365984\"], \"nums_element1\": [\"1543075300\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int solve. /*FC*/class Solution {\n/*FM*/int solve(vector<int>& nums) {\n        int res = 0; \n        priority_queue<int> que; \n        for(auto num: nums) {\n            if(!que.empty() && que.top()>num) {\n                res += que.top() - num; \n                que.pop(); \n                que.push(num); \n            }\n            que.push(num); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"499370503\"], \"nums_element1\": [\"-563804075\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestCombination. /*FC*/class Solution {\n/*FM*/int largestCombination(vector<int>& candidates) \n    {\n        int ret = 0; \n        for (int i=0;  i<31;  i++)\n        {\n            int count = 0; \n            for (int x: candidates)\n            {\n                if ((x>>i)&1)\n                    count++; \n            }\n            ret = max(ret, count); \n        }\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"candidates\": [1], \"candidates_element0\": [\"-1015436337\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestSubsequence. /*FC*/class Solution {\n/*FM*/int longestSubsequence(string s, int k) \n    {\n        string t; \n        while (k>0)\n        {\n            if (k%2==0)\n                t.push_back('0'); \n            else\n                t.push_back('1'); \n            k/=2; \n        }\n        reverse(t.begin(), t.end()); \n        \n        int m = s.size(); \n        int n = t.size(); \n        \n        if (m<n) return m; \n        \n          \n        \n        \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestSubsequence. /*FC*/class Solution {\n/*FM*/int longestSubsequence(string s, int k) \n    {\n        string t; \n        while (k>0)\n        {\n            if (k%2==0)\n                \n            else\n                t.push_back('1'); \n            k/=2; \n        }\n        reverse(t.begin(), t.end()); \n        \n        int m = s.size(); \n        int n = t.size(); \n        \n        if (m<n) \n        \n        int ret = countZeros(s, m-n+1) + n-1;   \n        \n        for (int i=m-1;  i>=0;  )\n        {\n            if (check(s,i,t, 0))\n            {\n                ret = max(ret, countZeros(s, i) + n); \n                break; \n            }               \n        }\n        \n        return ret ;         \n    };/*F*//*C*//*M*/int countZeros(string&s, int k)\n    {\n        int count = 0; \n        for (int i=0;  i<k;  i++)\n            count+= s[i]=='0'; \n        return count; \n    } bool check(string& s, int i, string& t, int j)\n    {\n        if (j==t.size()) return true; \n        if (i==s.size()) return false; \n        \n        if (t[j]=='1')\n        {\n            if (s[i]=='1')\n                return check(s, i+1, t, j+1); \n            else\n                return (int)s.size() - i >= (int)t.size() - j; \n        }\n        else\n        {\n            while (i<s.size() && s[i]=='1')\n                i++; \n            if (i==s.size()) return false; \n            else return check(s, i+1, t, j+1); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countZeros. /*FC*/class Solution {\n/*FM*/int countZeros(string&s, int k)\n    {\n        int count = 0; \n        for (int i=0;  i<k;  i++)\n            count+= s[i]=='0'; \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"k\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestSubsequence. /*FC*/class Solution {\n/*FM*/int longestSubsequence(string s, int k) \n    {\n        string t; \n        while (k>0)\n        {\n            \n            \n        }\n        reverse(t.begin(), t.end()); \n        \n        int m = s.size(); \n        int n = t.size(); \n        \n        if (m<n) \n        \n        int ret = n-1;         \n        ret = max(ret, countZeros(s, m-n+1) + n-1); \n        \n        int i = m-n; \n        if (s.substr(i) <= t)\n        {\n            ret = max(ret, countZeros(s, i) + n); \n        }\n        \n        return ret ;         \n    };/*F*//*C*//*M*/int countZeros(string&s, int k)\n    {\n        int count = 0; \n        for (int i=0;  i<k;  i++)\n            count+= s[i]=='0'; \n        return count; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestSubsequence. /*FC*/class Solution {\n/*FM*/int longestSubsequence(string s, int k) \n    {\n        string t; \n        while (k>0)\n        {\n            if (k%2==0)\n                \n            else\n                t.push_back('1'); \n            k/=2; \n        }\n        reverse(t.begin(), t.end()); \n        \n        int m = s.size(); \n        int n = t.size(); \n        \n        if (m<n) return m; \n        \n                \n        \n        \n        \n        \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int latestTimeCatchTheBus. /*FC*/class Solution {\n/*FM*/int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) \n    {\n        int m = passengers.size(); \n        \n        sort(buses.begin(), buses.end()); \n        sort(passengers.begin(), passengers.end()); \n        \n        int j = 0; \n        int ret = -1;         \n        \n        for (int i=0;  i<buses.size();  i++)\n        {\n            int cap = capacity;         \n            while (j<m && passengers[j]<=buses[i] && cap>0)\n            {\n                cap--; \n                if (j>=1 && passengers[j]-1 != passengers[j-1])\n                    ret = passengers[j]-1; \n                else if (j==0)\n                    ret = passengers[j]-1; \n                j++; \n            }\n            \n            if (cap > 0)\n            {\n                if (j>=1 && passengers[j-1]!=buses[i])\n                    ret = buses[i]; \n                else if (j==0)\n                    ret = buses[i];                     \n            }\n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"buses\": [3], \"buses_element0\": [\"2001284976\"], \"buses_element1\": [\"-358076089\"], \"buses_element2\": [\"2020449440\"], \"passengers\": [2], \"passengers_element0\": [\"-7318680\"], \"passengers_element1\": [\"1151823711\"], \"capacity\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int latestTimeCatchTheBus. /*FC*/class Solution {\n/*FM*/int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) \n    {\n        int m = passengers.size(); \n        \n        sort(buses.begin(), buses.end()); \n        sort(passengers.begin(), passengers.end()); \n        \n        int j = 0; \n        int ret = -1;         \n        \n        for (int i=0;  i<buses.size();  i++)\n        {\n            int cap = capacity;         \n            while (j<m && passengers[j]<=buses[i] && cap>0)\n            {\n                \n                        }\n            \n            if (cap > 0)\n            {\n                     \n            }\n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"buses\": [2], \"buses_element0\": [\"2071565233\"], \"buses_element1\": [\"1018964037\"], \"passengers\": [2], \"passengers_element0\": [\"1972885060\"], \"passengers_element1\": [\"1025578107\"], \"capacity\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minSumSquareDiff. /*FC*/class Solution {\n/*FM*/long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \n    {\n        vector<LL>nums; \n        for (int i=0;  i<nums1.size();  i++)\n            nums.push_back(abs(nums1[i]-nums2[i])); \n        sort(nums.rbegin(), nums.rend()); \n        \n        int n = nums.size();         \n        vector<LL>presum(n); \n        presum[0] = nums[0]; \n        for (int i=1;  i<n;  i++)\n            presum[i] = presum[i-1]+nums[i]; \n        LL ret = 0; \n        \n        int k = k1+k2; \n        if (presum[n-1] <= k)\n                    \n        \n        int i = 0; \n        while (i<n && (presum[i] - nums[i]*(i+1) <= k))\n            i++;         \n        i--; \n        \n        LL diff = k - (presum[i] - nums[i]*(i+1)); \n        LL each = diff / (i+1); \n        LL extra = diff % (i+1); \n\n        int a = extra;   \n        int b = i+1-a;   \n        \n        ret += (nums[i]-each-1)*(nums[i]-each-1) * a; \n        ret += (nums[i]-each)*(nums[i]-each) * b;                         \n        \n        for (int j=i+1;  j<n;  j++)            \n            ret += nums[j]*nums[j]; \n                \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"2042750339\"], \"nums1_element1\": [\"-2092902332\"], \"nums2\": [1], \"nums2_element0\": [\"-1723415257\"], \"k1\": [\"8\"], \"k2\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minSumSquareDiff. /*FC*/class Solution {\n/*FM*/long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \n    {\n        vector<LL>nums; \n        for (int i=0;  i<nums1.size();  i++)\n            nums.push_back(abs(nums1[i]-nums2[i])); \n        sort(nums.rbegin(), nums.rend()); \n        \n        int n = nums.size();         \n        vector<LL>presum(n); \n        presum[0] = nums[0]; \n        for (int i=1;  i<n;  )\n            \n        LL ret = 0; \n        \n        int k = k1+k2; \n        if (presum[n-1] <= k)\n                    \n        \n        int i = 0; \n        while (i<n && (presum[i] - nums[i]*(i+1) <= k))\n            i++;         \n        i--; \n        \n        LL diff = k - (presum[i] - nums[i]*(i+1)); \n        LL each = diff / (i+1); \n        LL extra = diff % (i+1); \n\n        int a = extra;   \n        int b = i+1-a;   \n        \n        ret += (nums[i]-each-1)*(nums[i]-each-1) * a; \n        ret += (nums[i]-each)*(nums[i]-each) * b;                         \n        \n        for (int j=i+1;  j<n;  )            \n            \n                \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [1], \"nums1_element0\": [\"167996852\"], \"nums2\": [3], \"nums2_element0\": [\"-837299377\"], \"nums2_element1\": [\"-712883568\"], \"nums2_element2\": [\"-699095872\"], \"k1\": [\"3\"], \"k2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestSequence. /*FC*/class Solution {\n/*FM*/int shortestSequence(vector<int>& rolls, int k) \n    {\n        int n = rolls.size();         \n        unordered_set<int>Set; \n                \n        int ret = 0; \n        for (int i=n-1;  i>=0;  i--)\n        {\n            Set.insert(rolls[i]); \n            if (Set.size()==k)\n            {\n                \n                \n            }\n        }\n        return ret+1; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"rolls\": [3], \"rolls_element0\": [\"1925034380\"], \"rolls_element1\": [\"-645305207\"], \"rolls_element2\": [\"-1337493305\"], \"k\": [\"1420183233\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long taskSchedulerII. /*FC*/class Solution {\n/*FM*/long long taskSchedulerII(vector<int>& tasks, int space) \n    {\n        int n = tasks.size(); \n        unordered_map<int,LL>Map;         \n        LL cur = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            if (Map.find(tasks[i])!=Map.end())        \n                            \n            Map[tasks[i]] = cur+(LL)space+1; \n            cur++; \n        }\n        return cur;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tasks\": [2], \"tasks_element0\": [\"650298781\"], \"tasks_element1\": [\"381917507\"], \"space\": [\"-293885262\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumReplacement. /*FC*/class Solution {\n/*FM*/long long minimumReplacement(vector<int>& nums) \n    {\n        LL ret = 0; \n        for (int i = nums.size()-2;  i>=0;  i--)\n        {\n            LL x = nums[i+1]; \n            LL y = nums[i]; \n            if (y<=x) \n            \n            LL k = y/x; \n            LL d = y%x; \n            if (d==0)\n            {\n                \n                \n                \n            }\n                                    \n            \n            LL p = (x-d) / (k+1); \n            \n            LL x2 = x - p; \n            LL d2 = d + k*p; \n            \n            if (d2 < x2)\n            {\n                                \n            }\n            else\n            {\n                nums[i] = d2; \n            }\n            ret += k; \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-700091282\"], \"nums_element1\": [\"-1182788788\"], \"nums_element2\": [\"-1380895947\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumReplacement. /*FC*/class Solution {\n/*FM*/long long minimumReplacement(vector<int>& nums) \n    {\n        LL ret = 0; \n        for (int i = nums.size()-2;  i>=0;  i--)\n        {\n            LL x = nums[i+1]; \n            LL y = nums[i]; \n            if (y<=x) continue; \n            \n            \n            \n            \n                                    \n            \n            \n            \n            \n            \n            \n            \n            \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"578978971\"], \"nums_element1\": [\"2119816724\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumReplacement. /*FC*/class Solution {\n/*FM*/long long minimumReplacement(vector<int>& nums) \n    {\n        LL ret = 0; \n        for (int i = nums.size()-2;  i>=0;  i--)\n        {\n            LL x = nums[i+1]; \n            LL y = nums[i]; \n            if (y<=x) \n                        \n            if (y%x==0)\n            {\n                \n                                \n            }\n            else\n            {\n                int k = y/x+1; \n                ret += y/x; \n                nums[i] = y/k; \n            }\n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1895918896\"], \"nums_element1\": [\"-2052314806\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestIdealString. /*FC*/class Solution {\n/*FM*/int longestIdealString(string s, int k) \n    {\n        int n = s.size(); \n        s = \"#\"+s; \n        vector<int>prev(26, 0); \n        vector<int>dp(n+1,1); \n        dp[0] = 0; \n                \n        int ret = 0; \n        for (int i=1;  i<=n;  i++)\n        {\n            for (int j=max(0,s[i]-'a'-k);  j<=min(25, s[i]-'a'+k);  j++)\n            {\n                int p = prev[j]; \n                dp[i] = max(dp[i], dp[p]+1); \n            }       \n            prev[s[i]-'a'] = i; \n            ret = max(ret, dp[i]); \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"k\": [\"1844358678\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestIdealString. /*FC*/class Solution {\n/*FM*/int longestIdealString(string s, int k) \n    {\n        int n = s.size(); \n        vector<int>dp(26, 0);  \n        \n        int ret = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            int temp = 0; \n            for (int ch = max(0, s[i]-'a'-k);  ch <= min(25, s[i]-'a'+k);  ch++)            \n                temp = max(temp, dp[ch]+1);             \n            \n            dp[s[i]-'a'] = temp;             \n            ret = max(ret, temp); \n        }\n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"], \"k\": [\"1293279947\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long putMarbles. /*FC*/class Solution {\n/*FM*/long long putMarbles(vector<int>& weights, int k) \n    {\n        int n = weights.size(); \n        if (n==1) return 0; \n        \n        \n        \n                \n        \n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"weights\": [1], \"weights_element0\": [\"-21879201\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long putMarbles. /*FC*/class Solution {\n/*FM*/long long putMarbles(vector<int>& weights, int k) \n    {\n        int n = weights.size(); \n        if (n==1) \n        \n        vector<LL>arr; \n        for (int i=0;  i<n-1;  i++)\n            arr.push_back(weights[i]+weights[i+1]); \n                \n        sort(arr.begin(), arr.end()); \n        \n        LL ret = 0; \n        for (int i=0;  i<k-1;  i++)\n            ret += arr[(int)arr.size()-1-i]; \n        \n        for (int i=0;  i<k-1;  i++)\n            ret -= arr[i]; \n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"weights\": [2], \"weights_element0\": [\"267721110\"], \"weights_element1\": [\"-1474433324\"], \"k\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximizeWin. /*FC*/class Solution {\n/*FM*/int maximizeWin(vector<int>& p, int k) \n    {\n        int n = p.size(); \n        if (p[n-1]-p[0] <= 2*k) \n        \n        vector<int>pre(n); \n        vector<int>post(n); \n\n        int i = 0; \n        int mx = 0; \n        for (int j=0;  j<n;  j++)\n        {\n            while (p[j]-p[i]>k)\n                i++; \n            mx = max(mx, j-i+1); \n            pre[j] = mx; \n        }\n        \n        int j = n-1; \n        mx = 0; \n        for (int i=n-1;  i>=0;  i--)\n        {\n            while (p[j]-p[i]>k)\n                j--; \n            mx = max(mx, j-i+1); \n            post[i] = mx; \n        }\n        \n        int ret = 0;         \n        for (int i=0;  i+1<n;  i++)\n            ret = max(ret, pre[i] + post[i+1]); \n        \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"p\": [2], \"p_element0\": [\"2098925766\"], \"p_element1\": [\"-900780902\"], \"k\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximizeWin. /*FC*/class Solution {\n/*FM*/int maximizeWin(vector<int>& p, int k) \n    {\n        int n = p.size(); \n        if (p[n-1]-p[0] <= 2*k) return p.size(); \n        \n        \n        \n\n        \n        \n        \n        \n        \n        \n        \n        \n                \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"p\": [1], \"p_element0\": [\"1367045950\"], \"k\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isOK. /*FC*/class Solution {\n/*FM*/bool isOK(int len, string& s, string& t, vector<int>&left, vector<int>&right)\n    {\n        int m = s.size(); \n        int n = t.size(); \n        \n        if (right[len]>=0) return true; \n        if (left[n-len-1] < m) \n        \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"len\": [\"7\"], \"s\": [\"1\"], \"t\": [\"1\"], \"left\": [1], \"left_element0\": [\"-988251336\"], \"right\": [1], \"right_element0\": [\"365823285\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minImpossibleOR. /*FC*/class Solution {\n/*FM*/int minImpossibleOR(vector<int>& nums) \n    {\n        sort(nums.begin(), nums.end()); \n        int mx = 0; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (nums[i] > mx+1)\n                \n            else\n                mx = (mx | nums[i]); \n        }\n\n        return mx+1;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1491607581\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minImpossibleOR. /*FC*/class Solution {\n/*FM*/int minImpossibleOR(vector<int>& nums) \n    {\n        sort(nums.begin(), nums.end()); \n        int mx = 0; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (nums[i] > mx+1)\n                return mx+1; \n            else\n                mx = (mx | nums[i]); \n        }\n\n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1476359451\"], \"nums_element1\": [\"-1225638252\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minImpossibleOR. /*FC*/class Solution {\n/*FM*/int minImpossibleOR(vector<int>& nums) \n    {\n        unordered_set<int>Set(nums.begin(), nums.end()); \n        for (int i=0;  i<31;  )\n        {\n            if (Set.find(1<<i)==Set.end())\n                return (1<<i); \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1782228273\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minOperations. /*FC*/class Solution {\n/*FM*/int minOperations(int n) \n    {\n        int ret =0 ; \n        for (int i=0;  i<31;  i++)\n        {\n            if (count(n+(1<<i)) < count(n))\n            {\n                n += (1<<i); \n                ret++; \n            }\n        }\n        return ret + count(n);         \n    };/*F*//*C*//*M*/int count(int x)\n    {\n        return __builtin_popcount(x); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-2081999200\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMinimumTime. /*FC*/class Solution {\n/*FM*/int findMinimumTime(vector<vector<int>>& tasks) \n    {\n        sort(tasks.begin(), tasks.end(), [](vector<int>&a, vector<int>&b){\n            return a[1] < b[1]; \n        }); \n\n        vector<int>time(2005); \n        for (int i=0;  i<tasks.size();  i++)\n        {\n            int start = tasks[i][0], end = tasks[i][1], duration = tasks[i][2]; \n            int overlap = 0; \n            for (int t=start;  t<=end;  )\n                \n\n            if (overlap >= duration) \n            int diff = duration - overlap; \n            for (int t=end;  t>=start;  )\n            {\n                \n                \n            }\n        }\n\n        int ret = 0; \n        for (int t=0;  t<=2000;  t++)\n            ret += (time[t]==1); \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tasks\": [1], \"tasks_element0\": [3], \"tasks_element0_element0\": [\"774271883\"], \"tasks_element0_element1\": [\"-1700164766\"], \"tasks_element0_element2\": [\"1389320835\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMinimumTime. /*FC*/class Solution {\n/*FM*/int findMinimumTime(vector<vector<int>>& tasks) \n    {\n        sort(tasks.begin(), tasks.end(), [](vector<int>&a, vector<int>&b){\n            return a[1] < b[1]; \n        }); \n\n        vector<AI3>arr;    \n        arr.push_back({-2,-1,0}); \n\n        for (int i=0;  i<tasks.size();  i++)\n        {\n            int start = tasks[i][0], end = tasks[i][1], duration = tasks[i][2]; \n\n            auto iter = lower_bound(arr.begin(), arr.end(), AI3({start,0,0})); \n            iter = prev(iter); \n\n            int overlap; \n            if ((*iter)[1] < start)\n                overlap = arr.back()[2] - (*iter)[2]; \n            else\n                overlap = arr.back()[2] - (*iter)[2] + abs((*iter)[1] - start + 1); \n\n            int diff = duration - overlap; \n            int cur = end; \n            while (diff > 0)\n            {\n                if (abs(arr.back()[1] - cur) < diff)\n                {\n                    diff -= abs(arr.back()[1] - cur); \n                    cur = arr.back()[0] - 1; \n                    arr.pop_back(); \n                }\n                else\n                {\n                    arr.push_back({cur-diff+1, end, arr.back()[2] + end-(cur-diff)}); \n                    diff = 0; \n                }\n            }\n        }\n\n        return arr.back()[2]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tasks\": [2], \"tasks_element0\": [2], \"tasks_element0_element0\": [\"777883995\"], \"tasks_element0_element1\": [\"-844740108\"], \"tasks_element1\": [2], \"tasks_element1_element0\": [\"-1344011788\"], \"tasks_element1_element1\": [\"-2115418211\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkOK. /*FC*/class Solution {\n/*FM*/bool checkOK(string&s, int i, char ch)\n    {\n        if (i>=1 && s[i-1]==ch) \n        if (i>=2 && s[i-2]==ch) \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"i\": [\"-2045787784\"], \"ch\": [\"-115\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumCost. /*FC*/class Solution {\n/*FM*/long long minimumCost(string s) \n    {\n        int n = s.size(); \n        long long ret = 0; \n        for (int i=1;  i<n;  )\n        {\n            \n        }\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> transformArray. /*FC*/class Solution {\n/*FM*/vector<int> transformArray(vector<int>& a) {\n        while (true) {\n            bool changed = false; \n            vector<int> b; \n            b.push_back(a[0]); \n            for (int i = 1;  i < a.size() - 1;  ) {\n                         b.push_back(a[a.size() - 1]); \n            if (!changed) break; \n            else \n        }\n        return a; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [1], \"a_element0\": [\"-1028882654\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstringSet. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstringSet(string s) {\n        int n = s.length(); \n        int i = 0, j = 0, ans = 0; \n        set<char> chars; \n        while (i < n && j < n) {\n            if (chars.count(s[j])) {\n                \n            } else {\n                chars.insert(s[j++]); \n                ans = max(ans, j - i); \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int expand. /*FC*/class Solution {\n/*FM*/int expand(string s, int start, int end) {\n        int L = start, R = end; \n        while (L > 0 && R < s.length() && s[L-1] == s[R]) {\n            \n            \n        }\n        return R - L; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"start\": [\"1\"], \"end\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMaximizedCapital. /*FC*/class Solution {\n/*FM*/int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n        int n = profits.size(); \n        vector<int> idx(n); \n        for (int i = 0;  i < n;  i++) idx[i] = i; \n        sort(idx.begin(), idx.end(), [&capital](int i, int j) {\n            return capital[i] < capital[j]; \n        }); \n        int i = 0; \n        priority_queue<int> pq; \n        while (i < n && capital[idx[i]] <= w) {\n            pq.push(profits[idx[i]]); \n            i++; \n        }\n        while (pq.size() && k--) {\n            w += pq.top(); \n            pq.pop(); \n            while (i < n && capital[idx[i]] <= w) {\n                pq.push(profits[idx[i]]); \n                i++; \n            }\n        }\n        return w; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"513905754\"], \"w\": [\"2\"], \"profits\": [3], \"profits_element0\": [\"-1454632364\"], \"profits_element1\": [\"603251488\"], \"profits_element2\": [\"320470447\"], \"capital\": [1], \"capital_element0\": [\"-869142201\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMaximizedCapital. /*FC*/class Solution {\n/*FM*/int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {\n        int n = profits.size(); \n        vector<int> idx(n); \n        for (int i = 0;  i < n;  i++) idx[i] = i; \n        sort(idx.begin(), idx.end(), [&capital](int i, int j) {\n            return capital[i] < capital[j]; \n        }); \n        int i = 0; \n        priority_queue<int> pq; \n        while (i < n && capital[idx[i]] <= w) {\n            pq.push(profits[idx[i]]); \n            i++; \n        }\n        while (pq.size() && k--) {\n            w += pq.top(); \n            pq.pop(); \n            while (i < n && capital[idx[i]] <= w) {\n                \n                \n            }\n        }\n        return w; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"78066290\"], \"w\": [\"10\"], \"profits\": [3], \"profits_element0\": [\"-379389694\"], \"profits_element1\": [\"-2129535979\"], \"profits_element2\": [\"-1157198812\"], \"capital\": [2], \"capital_element0\": [\"-1435938288\"], \"capital_element1\": [\"-1891252188\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> outerTrees. /*FC*/class Solution {\n/*FM*/vector<vector<int>> outerTrees(vector<vector<int>> &trees) {\n        set<vector<int>> ans; \n        if (trees.size() < 4) {\n            for (auto &tree : trees) {\n                ans.insert(tree); \n            }\n            return {ans.begin(), ans.end()}; \n        }\n        \n        \n        \n        do {\n            \n            \n            \n            \n            \n            \n        } while (p != leftMost); \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"trees\": [2], \"trees_element0\": [3], \"trees_element0_element0\": [\"-344317208\"], \"trees_element0_element1\": [\"407419609\"], \"trees_element0_element2\": [\"225761984\"], \"trees_element1\": [1], \"trees_element1_element0\": [\"-483188013\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/class Solution {\n/*FM*/string convert(string s, int numRows) {\n        char m[1010][1010]; \n        \n        \n        \n        \n        \n        fill_n(&m[0][0], 1010 * 1010, 0); \n        int maxJ = 0; \n\n        int delta_i = 1, delta_j = 0; \n        int i = -1, j = 0; \n        for (char ch : s) {\n            i += delta_i; \n            j += delta_j; \n            i = max(0, i); \n            i = min(i, numRows - 1); \n            m[i][j] = ch; \n            maxJ = max(maxJ, j); \n\n            \n            if (i == numRows - 1) {\n                \n                \n            }\n            \n            else if (i == 0) {\n                delta_i = 1; \n                delta_j = 0; \n            }\n        }\n\n        string ans; \n        for (int i = 0;  i < numRows;  i++) {\n            for (int j = 0;  j <= maxJ;  j++) {\n                if (m[i][j]) ans += m[i][j]; \n            }\n        }\n\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"], \"numRows\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sumSubarrayMins. /*FC*/class Solution {\n/*FM*/int sumSubarrayMins(vector<int>& arr) {\n        int n = arr.size(); \n        vector<pair<int, int>> a; \n        \n        a.push_back({-1, 0}); \n        for (int i = 0;  i < n;  i++) {\n            a.push_back({arr[i], i + 1}); \n        }\n        \n        a.push_back({-1, n + 1}); \n\n        vector<int> left(n + 1), right(n + 1); \n        stack<int> s; \n        s.push(0); \n        for (int i = 1;  i <= n;  i++) {\n            while (a[s.top()] > a[i]) \n            left[i] = s.top(); \n            s.push(i); \n        }\n        s = stack<int>(); \n        s.push(n + 1); \n        for (int i = n;  i >= 1;  i--) {\n            while (a[s.top()] > a[i]) \n            right[i] = s.top(); \n            s.push(i); \n        }\n\n        long long ans = 0; \n        for (int i = 1;  i <= n;  i++) {\n            ans += (long long)a[i].first * (i - left[i]) * (right[i] - i); \n        }\n        return ans % P; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [1], \"arr_element0\": [\"284757997\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeStones. /*FC*/class Solution {\n/*FM*/int removeStones(vector<vector<int>>& stones) {\n        map<int, map<int, bool>> m, m1; \n        map<int, map<int, int>> parent; \n\n        int rows = 0, cols = 0; \n        for (auto stone : stones) {\n            m[stone[0]][stone[1]] = true; \n            m1[stone[1]][stone[0]] = true; \n            parent[stone[0]][stone[1]] = -1; \n        }\n\n        int ans = 0; \n\n        for (auto mi : m) {\n            int i = mi.first; \n            for (auto mj : mi.second) {\n                int j = mj.first; \n\n                int curRoot = find(parent, i, j); \n                int xi = i, xj = j; \n                \n\n                \n                for (auto point : mi.second) {\n                    int xj = point.first; \n                    if (!m[xi][xj] || !(xj > j)) continue; \n                    \n                    \n                    \n                }\n                \n                for (auto point : m1[j]) {\n                    int xi = point.first; \n                    if (!m[xi][xj] || !(xi > i)) continue; \n                    \n                    \n                    \n                }\n            }\n        }\n\n        return ans; \n    };/*F*//*C*//*M*/int find(map<int, map<int, int>>& parent, int i, int j) {\n        if (parent[i][j] == -1)\n            return i + j * 10000; \n        else\n            return find(parent, parent[i][j] % 10000, parent[i][j] / 10000); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"stones\": [2], \"stones_element0\": [1], \"stones_element0_element0\": [\"-1291766125\"], \"stones_element1\": [3], \"stones_element1_element0\": [\"-12200822\"], \"stones_element1_element1\": [\"896145822\"], \"stones_element1_element2\": [\"284320912\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method LL ask. /*FC*/ {\n/*FM*/LL ask(LL x) {\n    LL ans = 0; \n    for (;  x;  ) \n    return ans; \n};/*F*//*C*//*M*/\n}",
        "target": "{\"x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> longestObstacleCourseAtEachPosition. /*FC*/class Solution {\n/*FM*/vector<int> longestObstacleCourseAtEachPosition(vector<int>& a) {\n        unordered_map<int, LL> mp; \n        memset(c, 0, sizeof c); \n        n = a.size(); \n        a.insert(a.begin(), 0); \n        vector<int> ans(n + 1); \n        \n        for (int i = 1;  i <= n;  i++) {\n            b[i] = a[i]; \n        }\n        sort(b + 1, b + n + 1); \n        LL m = 0; \n        for (int i = 1;  i <= n;  i++) {\n            if (!mp.count(b[i])) {\n                mp[b[i]] = ++m; \n            }\n        }\n        for (int i = 1;  i <= n;  i++) {\n            \n            \n            \n            ans[i] = max(1ll, ask(mp[a[i]]) + 1); \n            \n            add(mp[a[i]], ans[i]); \n        }\n        ans.erase(ans.begin()); \n        return ans; \n    };/*F*//*C*//*M*/LL ask(LL x) {\n    LL ans = 0; \n    for (;  x;  x -= x & -x) ans = max(ans, c[x]); \n    return ans; \n} void add(int x, LL y) {\n    for (;  x <= n;  x += x & -x) c[x] = max(c[x], y); \n};\n}",
        "target": "{\"n\": [\"0\"], \"a\": [2, 1], \"a[0]\": [\"-205430477778223319\"], \"a[1]\": [\"441965860062850615\"], \"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a_element0\": [\"-1447935344\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void add. /*FC*/ {\n/*FM*/void add(int x, LL y) {\n    for (;  x <= n;  ) \n};/*F*//*C*//*M*/\n}",
        "target": "{\"n\": [\"0\"], \"x\": [\"5\"], \"y\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findGCD. /*FC*/class Solution {\n/*FM*/int findGCD(vector<int>& nums) {\n        int mi = INT_MAX, ma = INT_MIN; \n        for (auto& a : nums) {\n            mi = min(a, mi); \n            ma = max(a, ma); \n        }\n        return __gcd(mi, ma); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1799716656\"], \"nums_element1\": [\"926090359\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string findDifferentBinaryString. /*FC*/class Solution {\n/*FM*/string findDifferentBinaryString(vector<string>& nums) {\n        n = nums[0].length(); \n        s = set<string>(nums.begin(), nums.end()); \n        dfs(\"\"); \n        return ans; \n    };/*F*/set<string> s;  int n;  string ans;/*C*//*M*/void dfs(string cur) {\n        if (ans.length()) return; \n        if (cur.length() == n) {\n            if (!s.count(cur)) ans = cur; \n            return; \n        }\n        dfs(cur + '0'); \n        dfs(cur + '1'); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->s\": [2], \"AKA_INSTANCE___Solution->n\": [\"1244592175\"], \"AKA_INSTANCE___Solution->ans\": [\"1\"], \"nums\": [2], \"nums_element0\": [\"2\"], \"nums_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void add. /*FC*/class CountIntervals {\n/*FM*/void add(int left, int right) {\n        \n        auto it = st.lower_bound({left - 1, -1}); \n        while (it != st.end()) {\n            \n            \n            \n            \n            \n            \n        }\n        ans += right - left + 1; \n        st.insert({right, left}); \n    };/*F*/set<pii> st;/*C*/CountIntervals() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___CountIntervals\": [\"CountIntervals\", \"CountIntervals()\"], \"left\": [\"-1227596909\"], \"right\": [\"1758545142\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int totalMoney. /*FC*/class Solution {\n/*FM*/int totalMoney(int n) {\n        int ans = 0; \n        for (int i = 0, j = 1;  i < n;  i++) {\n            ans += i % 7 + j; \n            if ((i + 1) % 7 == 0) j++; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumGain. /*FC*/class Solution {\n/*FM*/int maximumGain(string s, int x, int y) {\n        int ans = 0; \n        int n = s.length(); \n        if (x < y) {\n            \n            \n        }\n        \n        stack<char> stk; \n        for (int i = 0;  i < n;  i++) {\n            if (stk.size() && stk.top() == 'a' && s[i] == 'b') {\n                \n                \n            } else {\n                stk.push(s[i]); \n            }\n        }\n        s = \"\"; \n        while (stk.size()) {\n            s += stk.top(); \n            stk.pop(); \n        }\n        n = s.length(); \n        for (int i = 0;  i < n;  i++) {\n            if (stk.size() && stk.top() == 'a' && s[i] == 'b') {\n                \n                \n            } else {\n                stk.push(s[i]); \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"x\": [\"1372777196\"], \"y\": [\"-192445975\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumGain. /*FC*/class Solution {\n/*FM*/int maximumGain(string s, int x, int y) {\n        int ans = 0; \n        int n = s.length(); \n        if (x < y) {\n            swap(x, y); \n            for (int i = 0;  i < n;  i++) {\n                if (s[i] == 'a')\n                    \n                else if (s[i] == 'b')\n                    \n            }\n        }\n        \n        stack<char> stk; \n        for (int i = 0;  i < n;  i++) {\n            if (stk.size() && stk.top() == 'a' && s[i] == 'b') {\n                \n                \n            } else {\n                stk.push(s[i]); \n            }\n        }\n        s = \"\"; \n        while (stk.size()) {\n            s += stk.top(); \n            stk.pop(); \n        }\n        n = s.length(); \n        for (int i = 0;  i < n;  i++) {\n            if (stk.size() && stk.top() == 'a' && s[i] == 'b') {\n                \n                \n            } else {\n                stk.push(s[i]); \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"x\": [\"-493767970\"], \"y\": [\"1430787275\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isV. /*FC*/class Solution {\n/*FM*/bool isV(char ch) {\n        string s = \"aeiouAEIOU\"; \n        for (int i = 0;  i < s.length();  i++) {\n            if (ch == s[i]) \n        }\n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ch\": [\"120\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool halvesAreAlike. /*FC*/class Solution {\n/*FM*/bool halvesAreAlike(string s) {\n        int n = s.length(); \n        int x = 0, y = 0; \n        for (int i = 0, j = n / 2;  i < n / 2;  ) {\n            \n            \n        }\n        return x == y; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int eatenApples. /*FC*/class Solution {\n/*FM*/int eatenApples(vector<int>& a, vector<int>& d) {\n        int n = a.size(); \n        typedef pair<int, int> PII; \n        priority_queue<PII, vector<PII>, greater<PII>> pq; \n        int ans = 0; \n        for (int i = 1;  i++) {\n            if (i <= n) {\n                pq.emplace(i + d[i - 1], a[i - 1]); \n            }\n            \n            while (pq.size() && pq.top().first <= i) pq.pop(); \n            if (pq.empty() && i <= n) continue; \n            if (pq.empty()) break; \n            \n            \n            \n            \n            \n            \n            \n            \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [2], \"a_element0\": [\"168804719\"], \"a_element1\": [\"1427250439\"], \"d\": [3], \"d_element0\": [\"-1893868883\"], \"d_element1\": [\"-415395633\"], \"d_element2\": [\"213962295\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int eatenApples. /*FC*/class Solution {\n/*FM*/int eatenApples(vector<int>& a, vector<int>& d) {\n        int n = a.size(); \n        typedef pair<int, int> PII; \n        priority_queue<PII, vector<PII>, greater<PII>> pq; \n        int ans = 0; \n        for (int i = 1;  i++) {\n            if (i <= n) {\n                pq.emplace(i + d[i - 1], a[i - 1]); \n            }\n            \n            while (pq.size() && pq.top().first <= i) pq.pop(); \n            if (pq.empty() && i <= n) continue; \n            if (pq.empty()) break; \n            \n            ans++; \n            auto top = pq.top(); \n            pq.pop(); \n            top.second--; \n            if (top.second > 0) pq.push(top); \n            \n            \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [3], \"a_element0\": [\"-229692959\"], \"a_element1\": [\"523077668\"], \"a_element2\": [\"-2089837162\"], \"d\": [1], \"d_element0\": [\"-541601598\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string encode. /*FC*/class Solution {\n/*FM*/string encode(string longUrl) \n    {\n        if (long2short.find(longUrl)!=long2short.end())\n            \n        \n        string s; \n        for (int i=0;  i<6;  i++)\n            s+= dict[rand()%62]; \n        \n        long2short[longUrl]=s; \n        short2long[s]=longUrl; \n        \n        return \"http:\n    };/*F*/unordered_map<string, string> short2long;  unordered_map<string, string> long2short;  string dict;/*C*/Solution() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"longUrl\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string decode. /*FC*/class Solution {\n/*FM*/string decode(string shortUrl) \n    {\n        string randStr = shortUrl.substr(shortUrl.find_last_of(\"/\") + 1); \n        string longUrl; \n        \n        if (short2long.find(randStr)!=short2long.end())\n            \n        else\n            longUrl = shortUrl; \n        \n        return longUrl; \n    };/*F*/unordered_map<string, string> short2long;/*C*/Solution() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"shortUrl\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLHS. /*FC*/class Solution {\n/*FM*/int findLHS(vector<int>& nums) \n    {\n        map<int,int>Map; \n        for (int i=0;  i<nums.size();  i++)\n            Map[nums[i]]++; \n        \n        int lastFreq=0; \n        int lastNum; \n        int result=0; \n        for (auto a:Map)\n        {\n            if (lastFreq==0)\n            {\n                lastNum=a.first; \n                lastFreq=a.second; \n            }\n            else\n            {\n                if (lastNum+1==a.first)\n                    \n                lastNum = a.first; \n                lastFreq = a.second; \n            }\n        }\n        \n        return result; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"404364664\"], \"nums_element1\": [\"626120974\"], \"nums_element2\": [\"1991682649\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string crackSafe. /*FC*/class Solution {\n/*FM*/string crackSafe(int n, int k) \n    {\n        string ans; \n        ans.assign(n-1,'0'); \n        unordered_map<string,int>record; \n        \n        int total = pow(k,n); \n        \n        for (int i=0;  i<total;  )\n        {\n            \n            ; \n            \n        }\n        return ans;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"561038063\"], \"k\": [\"-1280432578\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string encode. /*FC*/class Solution {\n/*FM*/string encode(string s)\n    {\n        int num = 0; \n        unordered_map<char, int>Map; \n        string ret; \n        for (auto ch: s)\n        {\n            if (Map.find(ch)!=Map.end())\n                \n            else\n            {\n                Map[ch] = num; \n                ret+=to_string(num); \n                num++; \n            }            \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> findAndReplacePattern. /*FC*/class Solution {\n/*FM*/vector<string> findAndReplacePattern(vector<string>& words, string pattern) \n    {\n        string p = encode(pattern); \n        vector<string>rets; \n        \n        for (auto word: words)\n        {\n            string t = encode(word); \n            if(t==p)\n                rets.push_back(word);                 \n        }\n        return rets; \n    };/*F*//*C*//*M*/string encode(string s)\n    {\n        int num = 0; \n        unordered_map<char, int>Map; \n        string ret; \n        for (auto ch: s)\n        {\n            if (Map.find(ch)!=Map.end())\n                ret+=to_string(Map[ch]); \n            else\n            {\n                Map[ch] = num; \n                ret+=to_string(num); \n                num++; \n            }            \n        }\n        return ret; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"1\"], \"pattern\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarraysWithSum. /*FC*/class Solution {\n/*FM*/int numSubarraysWithSum(vector<int>& A, int S) \n    {\n        unordered_map<int,int>Map; \n        Map[0] = 1; \n        int sum = 0, ret = 0; \n        for (int i=0;  i<A.size();  i++)\n        {\n            sum += A[i]; \n            if (Map.find(sum-S)!=Map.end())\n                \n            Map[sum]+=1; \n        }\n        return ret; \n\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-632606670\"], \"A_element1\": [\"-1838350483\"], \"S\": [\"244000129\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarraysWithSum. /*FC*/class Solution {\n/*FM*/int numSubarraysWithSum(vector<int>& A, int S) \n    {       \n        int n = A.size(); \n        vector<int>postZeros(n); \n        int count = 0; \n        for (int i=n-1;  i>=0;  i--)\n        {\n            postZeros[i] = count; \n            if (A[i]==0)            \n                            \n            else\n                count = 0; \n        }\n        \n        int j = 0, sum = 0; \n        int ret = 0; \n        for (int i=0;  i<n;  i++)\n        {\n            while (j<=i || (j<n && sum < S))\n            {\n                sum += A[j]; \n                j++; \n            }\n            \n            if (sum==S)\n                \n            sum -= A[i];  \n        }\n        \n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"-514110778\"], \"A_element1\": [\"181832645\"], \"A_element2\": [\"-1991351193\"], \"S\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int subarraysDivByK. /*FC*/class Solution {\n/*FM*/int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int,int>Map; \n        Map[0] = 1; \n        \n        int r = 0; \n        int count = 0; \n        for (int i=0;  i<nums.size();  i++)\n        {            \n            r = ((r + nums[i]) % k + k) % k; \n            count += Map[r]; \n            Map[r]++; \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1901372371\"], \"k\": [\"841611053\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMinDistance. /*FC*/class Solution {\n/*FM*/int getMinDistance(vector<int>& nums, int target, int start) {\n        int ans = INT_MAX; \n        for (int i = 0;  i < nums.size();  i++) {\n            if (nums[i] == target) {\n                \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1788034267\"], \"target\": [\"-1006578276\"], \"start\": [\"49813930\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMinSwaps. /*FC*/class Solution {\n/*FM*/int getMinSwaps(string num, int k) {\n        string target(num); \n        for (int i = 0;  i < k;  ++i)\n            next_permutation(target.begin(), target.end()); \n\n        int ans = 0, n = num.size(); \n        for (int i = 0;  i < n;  ++i) {\n            if (num[i] != target[i]) {\n                \n                \n                \n            }\n        }\n\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1\"], \"k\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMinSwaps. /*FC*/class Solution {\n/*FM*/int getMinSwaps(string num, int k) {\n        string target = num; \n        while (k--) next_permutation(target.begin(), target.end()); \n\n        int ans = 0, n = num.size(); \n        for (int i = 0;  i < n;  i++) {\n            if (num[i] != target[i]) {\n                \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"3\"], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string largestOddNumber. /*FC*/class Solution {\n/*FM*/string largestOddNumber(string num) {\n        for (int i = num.length() - 1;  i >= 0;  ) {\n            if ((num[i] - '0') % 2) {\n                return num.substr(0, i + 1); \n            }\n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string largestOddNumber. /*FC*/class Solution {\n/*FM*/string largestOddNumber(string num) {\n        for (int i = num.length() - 1;  i >= 0;  i--) {\n            if ((num[i] - '0') % 2) {\n                \n            }\n        }\n        return \"\"; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumUnits. /*FC*/class Solution {\n/*FM*/int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\n        typedef pair<int, int> PII; \n        vector<PII> v; \n        for (int i = 0;  i < boxTypes.size();  ++i) {\n            v.emplace_back(boxTypes[i][1], boxTypes[i][0]); \n        }\n        sort(v.begin(), v.end(), greater<PII>()); \n        int ans = 0; \n        for (int i = 0;  i < v.size() && truckSize > 0;  ++i) {\n            if (truckSize >= v[i].second) {\n                \n                \n            } else {\n                ans += v[i].first * truckSize; \n                truckSize = 0; \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"boxTypes\": [2], \"boxTypes_element0\": [1], \"boxTypes_element0_element0\": [\"441861398\"], \"boxTypes_element1\": [2], \"boxTypes_element1_element0\": [\"-1158107928\"], \"boxTypes_element1_element1\": [\"-2107817452\"], \"truckSize\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumUnits. /*FC*/class Solution {\n/*FM*/int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\n        typedef pair<int, int> PII; \n        vector<PII> v; \n        for (int i = 0;  i < boxTypes.size();  ++i) {\n            v.emplace_back(boxTypes[i][1], boxTypes[i][0]); \n        }\n        sort(v.begin(), v.end(), greater<PII>()); \n        int ans = 0; \n        for (int i = 0;  i < v.size() && truckSize > 0;  ++i) {\n            if (truckSize >= v[i].second) {\n                ans += v[i].first * v[i].second; \n                truckSize -= v[i].second; \n            } else {\n                \n                \n            }\n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"boxTypes\": [1], \"boxTypes_element0\": [2], \"boxTypes_element0_element0\": [\"-1001057993\"], \"boxTypes_element0_element1\": [\"1496810549\"], \"truckSize\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minOperations. /*FC*/class Solution {\n/*FM*/int minOperations(vector<int>& target, vector<int>& arr) {\n        int ans = 0; \n        unordered_map<int, int> pos; \n        for (int i = 0;  i < target.size();  i++)\n            pos[target[i]] = i; \n        \n        \n        vector<int> a; \n        for (auto x : arr) {\n            if (pos.count(x)) \n        }\n\n        int len = 0; \n        vector<int> q(a.size() + 1); \n        for (int i = 0;  i < a.size();  ) {\n            \n            \n            \n            \n        }\n        cout << endl; \n\n        return target.size() - len; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [2], \"target_element0\": [\"-910392195\"], \"target_element1\": [\"1723485342\"], \"arr\": [1], \"arr_element0\": [\"-2109207132\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfRounds. /*FC*/class Solution {\n/*FM*/int numberOfRounds(string startTime, string finishTime) {\n        Time s(startTime), f(finishTime); \n        Time a(23, 59), b(0, 0); \n        if (!cmp(f, s)) {\n            \n        } else {\n            f.h += 24; \n            return cnt(s, f); \n        }\n    };/*F*//*C*//*M*/bool cmp(Time s, Time f) {\n    if (s.h < f.h) return true; \n    if (s.h > f.h) return false; \n    if (s.m < f.m) return true; \n    return false; \n} int cnt(Time s, Time f) {\n    int ans = 0; \n    for (int h = s.h;  h <= f.h;  h++) {\n        for (int m = 0;  m <= 45;  m += 15) {\n            Time tmp(h, m); \n            if (\n                !cmp(tmp, s) && !cmp(f, tmp)) {\n                \n                ans++; \n            }\n        }\n    }\n    return max(ans - 1, 0); \n} Time(int h, int m) : h(h), m(m) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"startTime\": [\"3\"], \"finishTime\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfRounds. /*FC*/class Solution {\n/*FM*/int numberOfRounds(string startTime, string finishTime) {\n        Time s(startTime), f(finishTime); \n        Time a(23, 59), b(0, 0); \n        if (!cmp(f, s)) {\n            return cnt(s, f); \n        } else {\n            \n            \n        }\n    };/*F*//*C*//*M*/bool cmp(Time s, Time f) {\n    if (s.h < f.h) return true; \n    if (s.h > f.h) return false; \n    if (s.m < f.m) return true; \n    return false; \n} int cnt(Time s, Time f) {\n    int ans = 0; \n    for (int h = s.h;  h <= f.h;  h++) {\n        for (int m = 0;  m <= 45;  m += 15) {\n            Time tmp(h, m); \n            if (\n                !cmp(tmp, s) && !cmp(f, tmp)) {\n                \n                ans++; \n            }\n        }\n    }\n    return max(ans - 1, 0); \n} Time(int h, int m) : h(h), m(m) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"startTime\": [\"3\"], \"finishTime\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSubIslands. /*FC*/class Solution {\n/*FM*/int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\n        g1 = grid1, g2 = grid2; \n        m = g1.size(), n = g1[0].size(); \n        c1 = vector<vector<int>>(m, vector<int>(n, -1)); \n        c2 = vector<vector<int>>(m, vector<int>(n, -1)); \n        int color = 0; \n        for (int i = 0;  i < m;  i++) {\n            for (int j = 0;  j < n;  j++) {\n                if (c1[i][j] == -1 && g1[i][j] == 1) {\n                    \n                    \n                }\n            }\n        }\n        for (int i = 0;  i < m;  i++) {\n            for (int j = 0;  j < n;  j++) {\n                if (c2[i][j] == -1 && c1[i][j] != -1 && g2[i][j] == 1) {\n                    \n                }\n            }\n        }\n        return ans; \n    };/*F*/vector<vector<int>> g1;  vector<vector<int>> g2;  vector<vector<int>> c1;  vector<vector<int>> c2;  int m;  int n;  int ans = 0;  int dx[4] = {0, 0, 1, -1};  int dy[4] = {1, -1, 0, 0};/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->dx\": [4], \"AKA_INSTANCE___Solution->dy\": [4], \"grid1\": [1], \"grid1_element0\": [3], \"grid1_element0_element0\": [\"180289902\"], \"grid1_element0_element1\": [\"2069479392\"], \"grid1_element0_element2\": [\"-772649131\"], \"grid2\": [3], \"grid2_element0\": [3], \"grid2_element0_element0\": [\"1988637282\"], \"grid2_element0_element1\": [\"-909634024\"], \"grid2_element0_element2\": [\"-973660758\"], \"grid2_element1\": [1], \"grid2_element1_element0\": [\"-884017202\"], \"grid2_element2\": [3], \"grid2_element2_element0\": [\"-712073858\"], \"grid2_element2_element1\": [\"-477521535\"], \"grid2_element2_element2\": [\"929277583\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> rotateGrid. /*FC*/class Solution {\n/*FM*/vector<vector<int>> rotateGrid(vector<vector<int>>& grid, int k) {\n        int m = grid.size(), n = grid[0].size(); \n        for (int l = 0;  l < min(m, n) / 2;  ) {\n            \n            \n            \n            \n        }\n        return grid; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [1], \"grid_element0_element0\": [\"740972485\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"-1248325105\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int eliminateMaximum. /*FC*/class Solution {\n/*FM*/int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\n        int n = dist.size(); \n        vector<double> t; \n        for (int i = 0;  i < n;  i++) {\n            t.push_back((double)dist[i] / speed[i]); \n        }\n        sort(t.begin(), t.end()); \n        for (int i = 0;  i < n;  ) {\n            if (t[i] <= i) return i; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dist\": [1], \"dist_element0\": [\"744749875\"], \"speed\": [1], \"speed_element0\": [\"-242462472\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int eliminateMaximum. /*FC*/class Solution {\n/*FM*/int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\n        int n = dist.size(); \n        vector<double> t; \n        for (int i = 0;  i < n;  i++) {\n            t.push_back((double)dist[i] / speed[i]); \n        }\n        sort(t.begin(), t.end()); \n        for (int i = 0;  i < n;  i++) {\n            if (t[i] <= i) \n        }\n        return n; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dist\": [1], \"dist_element0\": [\"134198802\"], \"speed\": [1], \"speed_element0\": [\"1257533282\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string mergeAlternately. /*FC*/class Solution {\n/*FM*/string mergeAlternately(string w1, string w2) {\n        int n = w1.length(), m = w2.length(); \n        string ans; \n        for (int i = 0;  i < min(m, n);  i++) {\n            ans += w1[i]; \n            ans += w2[i]; \n        }\n        \n        if (m > n)\n            \n        else {\n            ans += w1.substr(m); \n            \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"w1\": [\"2\"], \"w2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getVal. /*FC*/class Solution {\n/*FM*/int getVal(string s) {\n        int ans = 0; \n        for (auto ch : s) {\n            ans = ans * 10 + ch - 'a'; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string maxValue. /*FC*/class Solution {\n/*FM*/string maxValue(string n, int x) {\n        int i = 0; \n        if (n[0] == '-') {\n            \n                 } else {\n            while (i < n.length() && n[i] - '0' >= x) i++; \n        }\n        \n        n.insert(i, to_string(x)); \n        return n; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1\"], \"x\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSkips. /*FC*/class Solution {\n/*FM*/int minSkips(vector<int>& dist, int speed, int hoursBefore) {\n        int n = dist.size(); \n        vector<vector<double>> f(n + 1, vector<double>(n + 1, 1e10)); \n        f[0][0] = 0; \n        for (int i = 1;  i <= n;  i++) {\n            for (int j = 0;  j <= i;  j++) {\n                double t = (double)dist[i - 1] / speed; \n                f[i][j] = ceil(f[i - 1][j] + t - eps); \n                if (j > 0)\n                    f[i][j] = min(\n                        f[i][j],\n                        f[i - 1][j - 1] + t); \n            }\n        }\n        for (int j = 0;  j <= n;  j++) {\n            if (f[n][j] <= hoursBefore) \n        }\n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dist\": [2], \"dist_element0\": [\"828703940\"], \"dist_element1\": [\"-2116252741\"], \"speed\": [\"-1398828732\"], \"hoursBefore\": [\"-937765334\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSkips. /*FC*/class Solution {\n/*FM*/int minSkips(vector<int>& dist, int speed, int hoursBefore) {\n        int n = dist.size(); \n        vector<vector<double>> f(n + 1, vector<double>(n + 1, 1e10)); \n        f[0][0] = 0; \n        for (int i = 1;  i <= n;  i++) {\n            for (int j = 0;  j <= i;  j++) {\n                double t = (double)dist[i - 1] / speed; \n                f[i][j] = ceil(f[i - 1][j] + t - eps); \n                if (j > 0)\n                    f[i][j] = min(\n                        f[i][j],\n                        f[i - 1][j - 1] + t); \n            }\n        }\n        for (int j = 0;  j <= n;  ) {\n            if (f[n][j] <= hoursBefore) return j; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dist\": [1], \"dist_element0\": [\"-69640122\"], \"speed\": [\"1781465904\"], \"hoursBefore\": [\"705466422\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reductionOperations. /*FC*/class Solution {\n/*FM*/int reductionOperations(vector<int>& nums) {\n        sort(nums.begin(), nums.end()); \n        int ans = 0; \n        for (int i = 0, j, g = 0;  i < nums.size();  g++) {\n            j = i; \n            while (j < nums.size() && nums[i] == nums[j]) j++; \n            ans += g * (j - i); \n            i = j; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1058941907\"], \"nums_element1\": [\"274781155\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int makeKey. /*FC*/class Solution {\n/*FM*/int makeKey(vector<int>&count)\n    {\n        int key=0; \n        for (int i=0;  i<10;  i++)\n        {\n            if (count[i]%2==0)\n                key+=(0<<i); \n            else\n                key+=(1<<i); \n        }\n        return key; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"count\": [2], \"count_element0\": [\"-2070939257\"], \"count_element1\": [\"-1117916065\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numWays. /*FC*/class Solution {\n/*FM*/int numWays(string s) \n    {\n        long ret = 0; \n        long M = 1e9+7; \n\n        unordered_map<int,int>Map;      \n        int count = 0;    \n        for (int i=0;  i<s.size();  i++)\n        {\n            if (s[i]=='1') \n            {\n                \n                \n            }\n        }            \n        if (count%3!=0) \n        long n = s.size(); \n        if (count==0) return (n-1)*(n-2)/2%M; \n\n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minOperations. /*FC*/class Solution {\n/*FM*/int minOperations(vector<int>& nums, int x) \n    {\n        int n = nums.size(); \n        unordered_map<int,int>Map; \n        int presum = 0; \n        Map[0] = -1; \n        for (int i=0;  i<n;  i++)\n        {\n            presum += nums[i]; \n            if (Map.find(presum)==Map.end())\n                Map[presum] = i; \n        }\n        \n        int ret = INT_MAX; \n        if (Map.find(x)!=Map.end())\n            \n        \n        int sufsum = 0; \n        for (int b = n-1;  b>=0;  b--)\n        {\n            sufsum += nums[b]; \n            int pre = x - sufsum; \n            if (Map.find(pre)!=Map.end())\n            {\n                \n                \n            }\n        }\n        \n        return ret==INT_MAX ? -1: ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1430994999\"], \"nums_element1\": [\"-514069398\"], \"x\": [\"1078685337\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestPalindrome. /*FC*/class Solution {\n/*FM*/int longestPalindrome(vector<string>& words) \n    {\n        unordered_map<string,int>count1; \n        unordered_map<string,int>count2; \n        unordered_map<string,int>count3; \n                \n        for (auto str: words)\n        {\n            string str2 = str; \n            reverse(str2.begin(), str2.end()); \n            \n            if (str2==str)\n                count3[str]++; \n            else\n            {\n                \n                \n            }\n        }\n        \n        int ret = 0; \n        for (auto& [key, val]: count1)\n        {            \n            \n            \n            \n        }\n        int flag = 0; \n        for (auto& [key, val]: count3)\n        {\n            ret += val/2*2*2; \n            if (val%2==1)\n                flag = 1; \n        }\n        \n        return ret+flag*2; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [2], \"words_element0\": [\"1\"], \"words_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long beautifulSubarrays. /*FC*/class Solution {\n/*FM*/long long beautifulSubarrays(vector<int>& nums) \n    {\n        unordered_map<int,long long>Map; \n        Map[0] = 1; \n        int state = 0; \n        long long ret = 0; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            int x = nums[i]; \n            for (int k=0;  k<31;  k++)\n            {\n                int t = ((x>>k)&1) + ((state>>k)&1);  \n                t = t%2; \n                state = state - (((state>>k)&1)<<k) + (t<<k); \n            }\n            ret += Map[state]; \n            Map[state] += 1;             \n        }\n        \n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"2100960835\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long beautifulSubarrays. /*FC*/class Solution {\n/*FM*/long long beautifulSubarrays(vector<int>& nums) \n    {\n        unordered_map<int, LL>Map;  \n        \n        Map[0] = 1; \n\n        int state = 0; \n        LL ret = 0; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            state = state ^ nums[i]; \n            ret += Map[state]; \n            Map[state] += 1; \n        }\n\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1619627154\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstMissingPositive. /*FC*/class Solution {\n/*FM*/int firstMissingPositive(vector<int>& nums) \n    {\n        nums.insert(nums.begin(),0); \n        for (int i=0;  i<nums.size();  i++)\n        {\n            while (nums[i]!=i && nums[i]<nums.size() && nums[i]!=nums[nums[i]])\n                \n        }\n        for (int i=1;  i<nums.size();  )\n            if (nums[i]!=i) return i;      \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1078621711\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/class Solution {\n/*FM*/int jump(vector<int>& nums) \n    {\n        int start = 0, end = 0; \n        int step = 0; \n        if (nums.size()==1) \n\n        while (end >= start)\n        {\n            int start_old = start; \n            int end_old = end;             \n            for (int i=start_old;  i<=end_old;  )            \n            {\n                end = max(end, i+nums[i]); \n                if (end >= nums.size()-1)\n                    return step+1; \n            }\n            \n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1997966187\"], \"nums_element1\": [\"999930425\"], \"nums_element2\": [\"139591304\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/class Solution {\n/*FM*/int jump(vector<int>& nums) \n    {\n        int start = 0, end = 0; \n        int step = 0; \n        if (nums.size()==1) return 0; \n\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"792823217\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/class Solution {\n/*FM*/int jump(vector<int>& nums) \n    {\n        int start = 0, end = 0; \n        int step = 0; \n        if (nums.size()==1) \n\n        while (end >= start)\n        {\n            int start_old = start; \n            int end_old = end;             \n            for (int i=start_old;  i<=end_old;  i++)            \n            {\n                end = max(end, i+nums[i]); \n                if (end >= nums.size()-1)\n                    \n            }\n            step++; \n            start = end_old+1; \n        }\n        return 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1692308298\"], \"nums_element1\": [\"1705009442\"], \"nums_element2\": [\"-1354149658\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int>& nums) {\n        \n        int far = 0;  \n        for(int i = 0;  i<nums.size()-1;  i++)\n        {\n            if (far < i) return false; \n            far = max(far,i+nums[i]);             \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-744968198\"], \"nums_element1\": [\"746550404\"], \"nums_element2\": [\"660786180\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int>& nums) {\n        \n        int far = 0;  \n        for(int i = 0;  i<nums.size()-1;  )\n        {\n            \n                        \n        }\n        \n        return far>=nums.size()-1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1883508310\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int canCompleteCircuit. /*FC*/class Solution {\n/*FM*/int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \n    {\n        int sum = 0; \n        for (int i=0;  i<gas.size();  i++)\n            sum+= gas[i]-cost[i]; \n        if (sum<0) \n        \n        sum = 0; \n        int result=0; \n        for (int i=0;  i<gas.size();  i++)\n        {\n            sum+= gas[i]-cost[i]; \n            if (sum<0)\n            {\n                sum = 0; \n                result = i+1; \n            }                \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"gas\": [3], \"gas_element0\": [\"-1830128558\"], \"gas_element1\": [\"1918252758\"], \"gas_element2\": [\"224956788\"], \"cost\": [1], \"cost_element0\": [\"-1197579162\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int canCompleteCircuit. /*FC*/class Solution {\n/*FM*/int canCompleteCircuit(vector<int>& gas, vector<int>& cost) \n    {\n        int sum = 0; \n        for (int i=0;  i<gas.size();  i++)\n            sum+= gas[i]-cost[i]; \n        if (sum<0) return -1; \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"gas\": [2], \"gas_element0\": [\"1247575302\"], \"gas_element1\": [\"1608540558\"], \"cost\": [3], \"cost_element0\": [\"141029556\"], \"cost_element1\": [\"-452605134\"], \"cost_element2\": [\"-1033104548\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int candy. /*FC*/class Solution {\n/*FM*/int candy(vector<int>& ratings) \n    {\n        int n = ratings.size(); \n        vector<int>rets(n, 1); \n        for (int i=1;  i<n;  i++)\n        {\n            if (ratings[i]>ratings[i-1])\n                rets[i] = max(rets[i], rets[i-1]+1); \n        }\n        for (int i=n-2;  i>=0;  i--)\n        {\n            if (ratings[i]>ratings[i+1])\n                rets[i] = max(rets[i], rets[i+1]+1); \n        }\n        int sum = accumulate(rets.begin(), rets.end(), 0); \n        return sum; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ratings\": [3], \"ratings_element0\": [\"1849041910\"], \"ratings_element1\": [\"-1768898753\"], \"ratings_element2\": [\"741894341\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumGap. /*FC*/class Solution {\n/*FM*/int maximumGap(vector<int>& nums) \n    {\n        int N=nums.size(); \n        if (N<2) return 0; \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1168515805\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumGap. /*FC*/class Solution {\n/*FM*/int maximumGap(vector<int>& nums) \n    {\n        int N=nums.size(); \n        if (N<2) \n        \n        int MIN=INT_MAX; \n        int MAX=INT_MIN; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            MIN=min(MIN,nums[i]); \n            MAX=max(MAX,nums[i]); \n        }\n        \n        int bucket_size = max(1,(MAX-MIN)/(N-1)); \n        int bucket_nums = (MAX-MIN)/bucket_size+1; \n        vector<int>bucket_min(bucket_nums,INT_MAX); \n        vector<int>bucket_max(bucket_nums,INT_MIN); \n        \n        unordered_set<int>Set; \n        for (int i=0;  i<N;  i++)\n        {\n            int idx=(nums[i]-MIN)/bucket_size; \n            bucket_min[idx]=min(nums[i],bucket_min[idx]); \n            bucket_max[idx]=max(nums[i],bucket_max[idx]); \n            Set.insert(idx); \n            \n        }\n        \n        int result=INT_MIN; \n        int pre=0; \n        for (int i=0;  i<bucket_nums;  i++)\n        {\n            if (Set.count(i)==0) \n            result=max(result,bucket_min[i]-bucket_max[pre]); \n            pre = i; \n        }\n        \n        return result;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"753702278\"], \"nums_element1\": [\"1944843587\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string largestNumber. /*FC*/class Solution {\n/*FM*/string largestNumber(vector<int>& nums) \n    {\n        vector<string>strs; \n        for (int i=0;  i<nums.size();  i++)\n            strs.push_back(to_string(nums[i])); \n\n        sort(strs.begin(), strs.end(), cmp); \n\n        string result; \n        for (int i=0;  i<strs.size();  i++)\n            result+=strs[i]; \n\n        int i=0; \n        while (result[i]=='0') \n        if (i==result.size())\n            \n        else\n            return result.substr(i); \n            \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1470905542\"], \"nums_element1\": [\"-1885045784\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> majorityElement. /*FC*/class Solution {\n/*FM*/vector<int> majorityElement(vector<int>& nums) \n    {\n        int x1,x2; \n        int count1=0,count2=0; \n        \n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (count1>0 && nums[i]==x1)\n            {\n                \n            }\n            else if (count2>0 && nums[i]==x2)\n            {\n                \n            }\n            else if (count1==0)\n            {\n                x1=nums[i]; \n                count1=1; \n            }\n            else if (count2==0)\n            {\n                x2=nums[i]; \n                count2=1; \n            }\n            else if (nums[i]!=x1 && nums[i]!=x2)\n            {\n                count1--; \n                count2--; \n            }            \n        }\n                \n        vector<int>results; \n        count1=0; \n        count2=0; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (nums[i]==x1) count1++; \n            if (nums[i]==x2) count2++; \n        }  \n        if (count1>nums.size()/3) \n        if (x1!=x2 && count2>nums.size()/3) \n        \n        return results; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-24566677\"], \"nums_element1\": [\"-82971593\"], \"nums_element2\": [\"-1677778491\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> majorityElement. /*FC*/class Solution {\n/*FM*/vector<int> majorityElement(vector<int>& nums) \n    {\n        int x1,x2; \n        int count1=0,count2=0; \n        \n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (count1>0 && nums[i]==x1)\n            {\n                \n            }\n            else if (count2>0 && nums[i]==x2)\n            {\n                \n            }\n            else if (count1==0)\n            {\n                x1=nums[i]; \n                count1=1; \n            }\n            else if (count2==0)\n            {\n                x2=nums[i]; \n                count2=1; \n            }\n            else if (nums[i]!=x1 && nums[i]!=x2)\n            {\n                \n                \n            }            \n        }\n                \n        vector<int>results; \n        count1=0; \n        count2=0; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (nums[i]==x1) count1++; \n            if (nums[i]==x2) count2++; \n        }  \n        if (count1>nums.size()/3) results.push_back(x1); \n        if (x1!=x2 && count2>nums.size()/3) results.push_back(x2); \n        \n        return results; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1300232815\"], \"nums_element1\": [\"200001220\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int missingNumber. /*FC*/class Solution {\n/*FM*/int missingNumber(vector<int>& nums) \n    {\n        int k=0; \n        for (int i=0;  i<=nums.size();  i++)\n            k = k^i; \n        for (int i=0;  i<nums.size();  i++)\n            k = k^nums[i]; \n        return k; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1039531795\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLIS. /*FC*/class Solution {\n/*FM*/int lengthOfLIS(vector<int>& nums) \n    {\n        int n = nums.size(); \n        vector<int>dp(n,1); \n        for (int i=0;  i<n;  i++)\n        {\n            for (int j=0;  j<i;  j++)\n            {\n                if (nums[j]<nums[i])\n                    dp[i] = max(dp[i], dp[j]+1); \n            }\n        }\n        \n        int ret = 0; \n        for (int i=0;  i<n;  i++)\n            ret = max(ret, dp[i]); \n        \n        return ret; \n\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-271067560\"], \"nums_element1\": [\"-1002477367\"], \"nums_element2\": [\"-595568330\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLIS. /*FC*/class Solution {\n/*FM*/int lengthOfLIS(vector<int>& nums) \n    {\n        int n = nums.size();               \n        vector<int>q(n, INT_MAX); \n        for (int i=0;  i<n;  i++)\n        {\n            auto iter = lower_bound(q.begin(),q.end(),nums[i]); \n            *iter = nums[i]; \n        }\n        for (int i = n - 1;  i >= 0;  i--)\n        {\n            if (q[i] != INT_MAX)\n                return i + 1;   \n        }\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-174741974\"], \"nums_element1\": [\"-212413808\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPatches. /*FC*/class Solution {\n/*FM*/int minPatches(vector<int>& nums, int n) \n    {\n        int count=0; \n        long miss=1; \n        int i=0; \n        \n        while (miss<=n)\n        {\n            if (i>=nums.size() || miss<nums[i])\n            {\n                count++; \n                miss+=miss; \n            }\n            else\n            {\n                \n                \n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1610561446\"], \"nums_element1\": [\"-1168031203\"], \"n\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPatches. /*FC*/class Solution {\n/*FM*/int minPatches(vector<int>& nums, int n) \n    {\n        int count=0; \n        long miss=1; \n        int i=0; \n        \n        while (miss<=n)\n        {\n            if (i>=nums.size() || miss<nums[i])\n            {\n                count++; \n                miss+=miss; \n            }\n            else\n            {\n                miss+=nums[i]; \n                i++; \n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1117276629\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool increasingTriplet. /*FC*/class Solution {\n/*FM*/bool increasingTriplet(vector<int>& nums) \n    {\n        int N = nums.size(); \n        if (N==0) \n        \n        vector<int>LeftMin(N,0); \n        LeftMin[0] = INT_MAX; \n        for (int i=1;  i<N;  i++)\n            LeftMin[i] = min(LeftMin[i-1],nums[i-1]); \n        \n        vector<int>RightMax(N,0); \n        RightMax[N-1] = INT_MIN; \n        for (int i=N-2;  i>=0;  i--)\n            RightMax[i] = max(RightMax[i+1],nums[i+1]); \n        \n        for (int i=1;  i<N-1;  )\n        {\n                   return false; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1047621250\"], \"nums_element1\": [\"735450085\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool increasingTriplet. /*FC*/class Solution {\n/*FM*/bool increasingTriplet(vector<int>& nums) \n    {\n        vector<int>q; \n        for (auto x: nums)\n        {\n            if (q.empty() || q.back()<x)\n                q.push_back(x); \n            else\n            {\n                auto iter = lower_bound(q.begin(), q.end(), x); \n                *iter = x; \n            }\n            if (q.size()==3)\n                \n        }\n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-271860172\"], \"nums_element1\": [\"-408393896\"], \"nums_element2\": [\"1807359189\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool increasingTriplet. /*FC*/class Solution {\n/*FM*/bool increasingTriplet(vector<int>& nums) \n    {\n        vector<int>q; \n        for (auto x: nums)\n        {\n            if (q.empty() || q.back()<x)\n                q.push_back(x); \n            else\n            {\n                \n                \n            }\n            if (q.size()==3)\n                return true; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1489746783\"], \"nums_element1\": [\"1717751036\"], \"nums_element2\": [\"2125754424\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxEnvelopes. /*FC*/class Solution {\n/*FM*/int maxEnvelopes(vector<vector<int>>& envelopes) \n    {\n        int n = envelopes.size(); \n        sort(envelopes.begin(), envelopes.end()); \n        vector<int>dp(n,0); \n        for (int i=0;  i<n;  i++)\n        {\n            dp[i] = 1; \n            for (int j=0;  j<i;  j++)\n            {\n                if (envelopes[j][0]<envelopes[i][0] && envelopes[j][1]<envelopes[i][1])\n                    \n            }\n        }\n        \n        int ret = 0; \n        for (int i=0;  i<n;  i++)\n            ret = max(ret, dp[i]); \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"envelopes\": [2], \"envelopes_element0\": [2], \"envelopes_element0_element0\": [\"742242000\"], \"envelopes_element0_element1\": [\"-1730252937\"], \"envelopes_element1\": [1], \"envelopes_element1_element0\": [\"-1816053061\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxEnvelopes. /*FC*/class Solution {\n/*FM*/int maxEnvelopes(vector<vector<int>>& envelopes) \n    {\n        int n = envelopes.size(); \n        sort(envelopes.begin(), envelopes.end()); \n        vector<int>dp(n,0); \n        for (int i=0;  i<n;  i++)\n        {\n            dp[i] = 1; \n            for (int j=0;  j<i;  j++)\n            {\n                if (envelopes[j][0]<envelopes[i][0] && envelopes[j][1]<envelopes[i][1])\n                    dp[i] = max(dp[i], dp[j]+1); \n            }\n        }\n        \n        int ret = 0; \n        for (int i=0;  i<n;  i++)\n            ret = max(ret, dp[i]); \n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"envelopes\": [2], \"envelopes_element0\": [2], \"envelopes_element0_element0\": [\"-525608387\"], \"envelopes_element0_element1\": [\"-1574125504\"], \"envelopes_element1\": [2], \"envelopes_element1_element0\": [\"1255277612\"], \"envelopes_element1_element1\": [\"155792566\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method static bool cmp. /*FC*/class Solution {\n/*FM*/static bool cmp(vector<int>&a, vector<int>&b)\n    {\n        if (a[0]==b[0])\n            \n        else\n            return a[0]<b[0]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [3], \"a_element0\": [\"631984379\"], \"a_element1\": [\"156722964\"], \"a_element2\": [\"192522880\"], \"b\": [2], \"b_element0\": [\"-1396449051\"], \"b_element1\": [\"-1280576528\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxEnvelopes. /*FC*/class Solution {\n/*FM*/int maxEnvelopes(vector<vector<int>>& envelopes) \n    {\n        sort(envelopes.begin(), envelopes.end(), cmp); \n        vector<int>q; \n        for (auto x: envelopes)\n        {\n            if (q.empty() || x[1]>q.back())\n                q.push_back(x[1]); \n            else\n            {\n                auto iter = lower_bound(q.begin(), q.end(), x[1]); \n                *iter = x[1]; \n            }\n        }\n        return q.size(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"envelopes\": [3], \"envelopes_element0\": [3], \"envelopes_element0_element0\": [\"-906000689\"], \"envelopes_element0_element1\": [\"-427722391\"], \"envelopes_element0_element2\": [\"1186540124\"], \"envelopes_element1\": [2], \"envelopes_element1_element0\": [\"188504384\"], \"envelopes_element1_element1\": [\"-1875854209\"], \"envelopes_element2\": [2], \"envelopes_element2_element0\": [\"2145310508\"], \"envelopes_element2_element1\": [\"493508080\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method static bool cmp. /*FC*/class Solution {\n/*FM*/static bool cmp(pair<int,int>a,  pair<int,int>b)\n    {\n        if (a.first==b.first)\n            \n        else\n            return a.first>b.first; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a.first\": [\"-679036732\"], \"a.second\": [\"1151733963\"], \"b.first\": [\"-1167943443\"], \"b.second\": [\"1057108369\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int eraseOverlapIntervals. /*FC*/class Solution {\n/*FM*/int eraseOverlapIntervals(vector<vector<int>>& intervals) \n    {\n        sort(intervals.begin(), intervals.end(), cmp); \n        int i = 0; \n        int count = 0; \n        while (i<intervals.size())\n        {\n            count++; \n            int j = i+1; \n            while (j<intervals.size() && intervals[j][0] < intervals[i][1])\n                \n            i = j; \n        }\n        return intervals.size()-count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [1], \"intervals_element0_element0\": [\"846028098\"], \"intervals_element1\": [3], \"intervals_element1_element0\": [\"1408823916\"], \"intervals_element1_element1\": [\"-1179361603\"], \"intervals_element1_element2\": [\"1209067218\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int eraseOverlapIntervals. /*FC*/class Solution {\n/*FM*/int eraseOverlapIntervals(vector<vector<int>>& intervals) \n    {\n        sort(intervals.begin(), intervals.end(), cmp); \n        int i = 0; \n        int count = 0; \n        while (i<intervals.size())\n        {\n            count++; \n            int j = i+1; \n            while (j<intervals.size() && intervals[j][0] < intervals[i][1])\n                j++; \n            i = j; \n        }\n        return intervals.size()-count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [3], \"intervals_element0_element0\": [\"-1721006436\"], \"intervals_element0_element1\": [\"-86841765\"], \"intervals_element0_element2\": [\"-182025126\"], \"intervals_element1\": [1], \"intervals_element1_element0\": [\"-132252507\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMinArrowShots. /*FC*/class Solution {\n/*FM*/int findMinArrowShots(vector<vector<int>>& points) \n    {\n        sort(points.begin(), points.end(), cmp); \n        int i = 0; \n        int count = 0; \n        while (i<points.size())\n        {\n            count++; \n            int j = i+1; \n            while (j<points.size() && points[j][0]<=points[i][1])\n                j++; \n            i = j; \n        }\n        return count;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"points\": [2], \"points_element0\": [2], \"points_element0_element0\": [\"453973187\"], \"points_element0_element1\": [\"-383379633\"], \"points_element1\": [2], \"points_element1_element0\": [\"-1354448575\"], \"points_element1_element1\": [\"1900155998\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string findLongestWord. /*FC*/class Solution {\n/*FM*/string findLongestWord(string S, vector<string>& dictionary) \n    {\n        int m = S.size(); \n        S = \"#\"+S; \n        int next[m+1][26]; \n        \n        for (int k=0;  k<26;  k++)\n            next[m][k] = -1; \n        for (int i=m;  i>=1;  i--)\n        {\n            for (int k=0;  k<26;  k++)\n                next[i-1][k] = next[i][k]; \n            next[i-1][S[i]-'a'] = i; \n        }\n        \n        string ret = \"\"; \n        for (auto word: dictionary)\n        {\n            int flag = 1; \n            int i = 0; \n            for (auto ch: word)\n            {\n                i = next[i][ch-'a']; \n                if (i==-1)\n                {\n                    \n                    \n                }                \n            }\n            if (flag)\n            {\n                if (word.size() > ret.size() || (word.size() == ret.size() && word < ret))\n                    ret = word; \n            }\n        }\n        return ret;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"], \"dictionary\": [2], \"dictionary_element0\": [\"1\"], \"dictionary_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nextGreaterElement. /*FC*/class Solution {\n/*FM*/int nextGreaterElement(int n) \n    {\n        vector<int>digits;         \n        while(n>0)\n        {\n            digits.push_back(n%10); \n            n=n/10; \n        }\n        int m = digits.size(); \n\n        reverse(digits.begin(), digits.end()); \n\n        int i = m-1; \n        while (i>=1 && digits[i-1] >= digits[i])\n            \n        if (i==0) return -1; \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int>& nums) \n    {\n        int curMax=INT_MIN; \n        int right_bound=0; \n        for (int i=0;  i<nums.size();  i++)\n        {\n            if (nums[i]<curMax)\n                right_bound=i; \n            curMax=max(curMax,nums[i]); \n        }\n        \n        int curMin=INT_MAX; \n        int left_bound=nums.size()-1; \n        for (int i=nums.size()-1;  i>=0;  i--)\n        {\n            if (nums[i]>curMin)\n                left_bound=i; \n            curMin=min(curMin,nums[i]); \n        }        \n        \n        cout<<left_bound<<\" \"<<right_bound<<endl; \n        \n        return left_bound>=right_bound?0:right_bound-left_bound+1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-79027960\"], \"nums_element1\": [\"-517077235\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDistance. /*FC*/class Solution {\n/*FM*/int maxDistance(vector<vector<int>>& arrays) \n    {\n        vector<int>Mins; \n        vector<int>Maxs; \n        for (int i=0;  i<arrays.size();  i++)\n        {\n            Mins.push_back(arrays[i][0]); \n            Maxs.push_back(arrays[i].back()); \n        }\n        \n        sort(Mins.begin(),Mins.end()); \n        sort(Maxs.begin(),Maxs.end()); \n        \n        int N=arrays.size(); \n        int flag=0; \n        for (int i=0;  i<arrays.size();  i++)\n        {\n            if (arrays[i][0]==Mins[0] && arrays[i].back()==Maxs.back() )\n            {\n                \n                                    \n            }            \n        }\n        \n        if (flag==0)\n            return Maxs.back()-Mins[0]; \n        else\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arrays\": [2], \"arrays_element0\": [1], \"arrays_element0_element0\": [\"-1192157257\"], \"arrays_element1\": [1], \"arrays_element1_element0\": [\"1150713284\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDistance. /*FC*/class Solution {\n/*FM*/int maxDistance(vector<vector<int>>& arrays) \n    {\n        vector<int>Mins; \n        vector<int>Maxs; \n        for (int i=0;  i<arrays.size();  i++)\n        {\n            Mins.push_back(arrays[i][0]); \n            Maxs.push_back(arrays[i].back()); \n        }\n        \n        sort(Mins.begin(),Mins.end()); \n        sort(Maxs.begin(),Maxs.end()); \n        \n        int N=arrays.size(); \n        int flag=0; \n        for (int i=0;  i<arrays.size();  )\n        {\n            if (arrays[i][0]==Mins[0] && arrays[i].back()==Maxs.back() )\n            {\n                flag=1; \n                break;                     \n            }            \n        }\n        \n        if (flag==0)\n            \n        else\n            return max(Maxs.back()-Mins[1],Maxs[N-2]-Mins[0]); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arrays\": [1], \"arrays_element0\": [2], \"arrays_element0_element0\": [\"699150285\"], \"arrays_element0_element1\": [\"986277783\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string predictPartyVictory. /*FC*/class Solution {\n/*FM*/string predictPartyVictory(string senate) \n    {\n        string str=senate; \n        int len=0; \n        int count=0; \n        while (senate.size()!=len)\n        {\n            len=senate.size(); \n            string s; \n            for (int i=0;  i<senate.size();  i++)\n            {\n                if (senate[i]=='R')\n                {                    \n                    \n                    \n                }\n                else\n                {                    \n                    if (count<=0) s.push_back('D'); \n                    count--; \n                }\n            }\n            senate = s; \n        }\n        \n        if (senate[0]=='R')\n            \n        else\n            return \"Dire\"; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"senate\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkPossibility. /*FC*/class Solution {\n/*FM*/bool checkPossibility(vector<int>& nums) \n    {\n        int count=0; \n        for (int i=1;  i<nums.size();  i++)\n        {            \n            if (nums[i-1]>nums[i])\n            {\n                count++; \n                \n                if (count==2) \n                \n                if (i>=2 && nums[i-2]>nums[i])\n                    \n                else\n                    nums[i-1]=nums[i]; \n            }\n        }\n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1956470955\"], \"nums_element1\": [\"-1549592398\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkPossibility. /*FC*/class Solution {\n/*FM*/bool checkPossibility(vector<int>& nums) \n    {\n        int count=0; \n        for (int i=1;  i<nums.size();  i++)\n        {            \n            if (nums[i-1]>nums[i])\n            {\n                \n                \n                \n                \n                if (i>=2 && nums[i-2]>nums[i])\n                    \n                else\n                    \n            }\n        }\n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1352476242\"], \"nums_element1\": [\"1883059917\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkPossibility. /*FC*/class Solution {\n/*FM*/bool checkPossibility(vector<int>& nums) \n    {\n        int a = -1, b = -1; \n        for (int i=1;  i<nums.size();  i++)\n        {\n            if (nums[i-1]>nums[i])\n            {\n                \n                \n            }\n        }\n        if (a==-1) return true; \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-733283261\"], \"nums_element1\": [\"1794949239\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> constructArray. /*FC*/class Solution {\n/*FM*/vector<int> constructArray(int n, int k) \n    {\n        vector<int>ret({k+1}); \n        int count = 1; \n        for (int d=k;  d>=1;  d--)\n        {\n            if (count%2==1)\n                ret.push_back(ret.back()-d); \n            else\n                ret.push_back(ret.back()+d); \n            count++; \n        }\n        reverse(ret.begin(), ret.end()); \n        for (int i=k+2;  i<=n;  i++)\n            ret.push_back(i); \n        \n        return ret; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"], \"k\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumSwap. /*FC*/class Solution {\n/*FM*/int maximumSwap(int num) \n    {\n        int MAX=0; \n        int pos; \n        string str=to_string(num); \n        \n        string str2=str; \n        sort(str2.begin(),str2.end()); \n        reverse(str2.begin(),str2.end()); \n        \n        int j=0; \n        while (j<str.size() && str[j]==str2[j])\n            \n        \n        if (j==str.size()) \n                \n        for (int i=j;  i<str.size();  i++)\n        {\n            if (str[i]-'0'>=MAX)\n            {\n                MAX=str[i]-'0'; \n                pos=i; \n            }\n        }\n        \n        for (int i=j;  i<pos;  )\n        {\n            if (str[i]-'0'>=MAX)\n                \n            swap(str[i],str[pos]);          \n            break; \n        }\n        \n        return stoi(str); \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"-2117597814\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkValidString. /*FC*/class Solution {\n/*FM*/bool checkValidString(string s) \n    {\n        int lower=0; \n        int upper=0; \n        \n        for (int i=0;  i<s.size();  i++)\n        {\n            if (s[i]=='(')\n            {\n                \n                \n            }\n            else if (s[i]=='*')\n            {\n                \n                \n            }\n            else if (s[i]==')')\n            {\n                \n                \n            }\n            \n            if (lower<0) \n            \n            if (upper<0)                         \n        }\n        \n        return (lower==0); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char next. /*FC*/class StringIterator {\n/*FM*/char next() {\n        if (hasNext()) {\n            \n            \n            \n            \n            \n        }\n        else {\n            return ' '; \n        }\n    };/*F*//*C*/StringIterator(string compressedString) { };/*M*/bool hasNext() {\n        return count != 0;         \n    };\n}",
        "target": "{\"AKA_INSTANCE___StringIterator\": [\"StringIterator\", \"StringIterator(string)\"], \"AKA_INSTANCE___StringIterator_compressedString\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPlaceFlowers. /*FC*/class Solution {\n/*FM*/bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        for (int i = 0;  i < flowerbed.size() && n;  ++i) {\n            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {\n                \n                \n            }\n        }\n        \n        return n == 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"flowerbed\": [2], \"flowerbed_element0\": [\"-24323605\"], \"flowerbed_element1\": [\"229340452\"], \"n\": [\"-1542686834\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string tree2str. /*FC*/class Solution {\n/*FM*/string tree2str(TreeNode* t) {\n        string result; \n        if (t == nullptr) {\n            \n        }\n        \n        result += to_string(t->val); \n        if (t->right) {\n            result += '(' + tree2str(t->left) + ')'; \n            result += '(' + tree2str(t->right) + ')'; \n        }\n        else if (t->left) {\n            \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/string tree2str(TreeNode* t) {\n        string result; \n        if (t == nullptr) {\n            return \"\"; \n        }\n        \n        result += to_string(t->val); \n        if (t->right) {\n            result += '(' + tree2str(t->left) + ')'; \n            result += '(' + tree2str(t->right) + ')'; \n        }\n        else if (t->left) {\n            result += '(' + tree2str(t->left) + ')'; \n        }\n        \n        return result; \n    } string tree2str(TreeNode* t) {\n        string result; \n        if (t == nullptr) {\n            return \"\"; \n        }\n        \n        result += to_string(t->val); \n        if (t->right) {\n            result += '(' + tree2str(t->left) + ')'; \n            result += '(' + tree2str(t->right) + ')'; \n        }\n        else if (t->left) {\n            result += '(' + tree2str(t->left) + ')'; \n        }\n        \n        return result; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"t\": [1], \"t[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"t0_x\": [\"-822008820\"], \"t[0].val\": [\"-833476875\"], \"t[0].left\": [1], \"t[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"t0_left0_x\": [\"11814013\"], \"t[0].left[0].val\": [\"1739299091\"], \"t[0].right\": [1], \"t[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"t0_right0_x\": [\"1947620728\"], \"t[0].right[0].val\": [\"-1308576078\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int triangleNumber. /*FC*/class Solution {\n/*FM*/int triangleNumber(vector<int>& nums) {\n        int n = nums.size(); \n        if (n < 3) {\n            return 0; \n        }\n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1480788462\"], \"nums_element1\": [\"-556553556\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int leastInterval. /*FC*/class Solution {\n/*FM*/int leastInterval(vector<char>& tasks, int n) {\n        int m = tasks.size(); \n        vector<int> table(26); \n        for (char c : tasks) {\n            ++table[c - 'A']; \n        }\n        \n        sort(table.begin(), table.end()); \n        int maxNum = table[25] - 1; \n        int numIdle = maxNum * n; \n        for (int i = 24;  i >= 0 && table[i];  ) {\n            \n        }\n        \n        return (numIdle > 0) ? numIdle + m : m; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tasks\": [1], \"tasks_element0\": [\"-77\"], \"n\": [\"1310069405\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool enQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool enQueue(int value) {\n        if (isFull()) {\n            \n        }\n        if (head == -1) {\n            head = 0; \n        }\n        tail = (tail + 1) % data.size(); \n        data[tail] = value; \n        ++len; \n        return true;         \n    };/*F*/int head;  int tail;  int len;  vector<int> data;/*C*/MyCircularQueue(int k) { };/*M*/bool isFull() {\n        return len == data.size(); \n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"863369774\"], \"value\": [\"-1103241228\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool deQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool deQueue() {\n        if (isEmpty()) {\n            return false; \n        }\n        \n        if (head == tail) {\n            \n            \n        }\n        else {\n            \n        }\n        \n        \n    };/*F*/int head;  int tail;/*C*/MyCircularQueue(int k) { };/*M*/bool isEmpty() {\n        return len == 0; \n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"1029915214\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* addOneRow. /*FC*/class Solution {\n/*FM*/TreeNode* addOneRow(TreeNode* root, int v, int d) {\n        if (d == 1) {\n            \n            \n            \n        }\n        \n        helper(root, v, d); \n        return root; \n    };/*F*//*C*//*M*/void helper(TreeNode* root, int v, int d) {\n        if (root == nullptr) {\n            return; \n        }\n        if (d == 2) {\n            TreeNode* nleft = new TreeNode(v); \n            TreeNode* nright = new TreeNode(v); \n            nleft->left = root->left; \n            nright->right = root->right; \n            root->left = nleft; \n            root->right = nright; \n        }\n        else {\n            helper(root->left, v, d - 1); \n            helper(root->right, v, d - 1); \n        }\n    } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"113904899\"], \"root[0].val\": [\"-335389923\"], \"v\": [\"1044386999\"], \"d\": [\"-198888145\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDistance. /*FC*/class Solution {\n/*FM*/int maxDistance(vector<vector<int>>& arrays) {\n        int maxDist = 0; \n        int m = arrays.size(); \n        int minNum = arrays[0].front(); \n        int maxNum = arrays[0].back(); \n        for (int i = 1;  i < m;  ++i) {\n            maxDist = max({maxDist, abs(arrays[i].back() - minNum), abs(arrays[i].front() - maxNum)}); \n            minNum = min(minNum, arrays[i].front()); \n            maxNum = max(maxNum, arrays[i].back()); \n        }\n        \n        return maxDist; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arrays\": [2], \"arrays_element0\": [1], \"arrays_element0_element0\": [\"-1704093739\"], \"arrays_element1\": [2], \"arrays_element1_element0\": [\"-1524797196\"], \"arrays_element1_element1\": [\"1148854454\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestFactorization. /*FC*/class Solution {\n/*FM*/int smallestFactorization(int a) {\n        if (a < 2) {\n            return a; \n        }\n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestFactorization. /*FC*/class Solution {\n/*FM*/int smallestFactorization(int a) {\n        if (a < 2) {\n            \n        }\n        long result = 0, base = 1; \n        for (int i = 9;  i >= 2;  --i) {\n            while (a % i == 0) {\n                result += i * base; \n                base *= 10; \n                a /= i; \n            }\n        }\n        \n        return (a == 1 && result <= INT_MAX) ? result : 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* insertIntoBST. /*FC*/class Solution {\n/*FM*/TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if (root == nullptr) {\n            \n        }\n        \n        TreeNode *node = root, *prev = nullptr; \n        while (node) {\n            prev = node; \n            if (node->val < val) {\n                \n            }\n            else if (node->val > val) {\n                node = node->left; \n            }\n            else {\n                \n            }\n        }\n        \n        if (prev->val < val) {\n            \n        }\n        else {\n            prev->left = new TreeNode(val); \n        }\n        return root; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1754679658\"], \"root[0].val\": [\"709927356\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"809743279\"], \"root[1].val\": [\"24103287\"], \"val\": [\"-1659719799\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* insertIntoBST. /*FC*/class Solution {\n/*FM*/TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if (root == nullptr) {\n            \n        }\n        \n        TreeNode *node = root, *prev = nullptr; \n        while (node) {\n            prev = node; \n            if (node->val < val) {\n                node = node->right; \n            }\n            else if (node->val > val) {\n                \n            }\n            else {\n                \n            }\n        }\n        \n        if (prev->val < val) {\n            prev->right = new TreeNode(val); \n        }\n        else {\n            \n        }\n        return root; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1364974390\"], \"root[0].val\": [\"1356233894\"], \"val\": [\"1938444503\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int add. /*FC*/class KthLargest {\n/*FM*/int add(int val) {\n        pq.push(val); \n        if (pq.size() > k) {\n            \n        }\n        return pq.top(); \n    };/*F*/int k;  priority_queue<int, vector<int>, greater<int>> pq;/*C*/KthLargest(int k, vector<int> nums) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___KthLargest\": [\"KthLargest\", \"KthLargest(int,vector<int>)\"], \"AKA_INSTANCE___KthLargest_k\": [\"683106829\"], \"AKA_INSTANCE___KthLargest_nums\": [1], \"AKA_INSTANCE___KthLargest_nums_element0\": [\"1830980231\"], \"AKA_INSTANCE___KthLargest->k\": [\"683106829\"], \"val\": [\"1788347454\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& nums, int target) {\n        int start = 0, end = nums.size() - 1; \n        while (start <= end) {\n            int mid = start + (end - start) / 2; \n            if (nums[mid] < target) {\n                start = mid + 1; \n            }\n            else if (nums[mid] > target) {\n                end = mid - 1; \n            }\n            else {\n                \n            }\n        }\n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1526533835\"], \"nums_element1\": [\"1549464447\"], \"target\": [\"-1302230190\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method Node* insert. /*FC*/class Solution {\n/*FM*/Node* insert(Node* head, int insertVal) {\n        if (head == nullptr) {\n            Node *node = new Node(insertVal, nullptr); \n            node->next = node; \n            return node; \n        }\n        \n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"insertVal\": [\"2062061468\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method Node* insert. /*FC*/class Solution {\n/*FM*/Node* insert(Node* head, int insertVal) {\n        if (head == nullptr) {\n            \n            \n            \n        }\n        \n        Node *prev = head, *curr = head->next; \n        bool insert = false; \n        while (curr != head) {\n            if ((prev->val <= insertVal && insertVal <= curr->val) ||\n                (prev->val > curr->val && (insertVal <= curr->val || insertVal >= prev->val))) {\n                prev->next = new Node(insertVal, curr); \n                insert = true; \n                break; \n            }\n                \n            \n            \n        }\n        \n        if (!insert) {\n            \n        }\n        \n        return head; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"Node\", \"Node()\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"Node\", \"Node(int,Node*)\", \"Node\"], \"head0_next0__val\": [\"532894719\"], \"head[0].next[1]\": [\"Node\", \"Node()\"], \"insertVal\": [\"-797612698\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string toLowerCase. /*FC*/class Solution {\n/*FM*/string toLowerCase(string str) {\n        string result; \n        for (char c : str) {\n            if (c >= 'A' && c <= 'Z') {\n                \n            }\n            else {\n                result += c; \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarrayProductLessThanK. /*FC*/class Solution {\n/*FM*/int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        if (k <= 1) {\n            \n        }\n        int count = 0; \n        int start = 0; \n        int product = 1; \n        for (int end = 0;  end < nums.size();  ++end) {\n            product *= nums[end]; \n            while (product >= k) {\n                product /= nums[start++]; \n            }\n            \n            count += end - start + 1; \n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1344431932\"], \"nums_element1\": [\"-1610473698\"], \"nums_element2\": [\"1276977037\"], \"k\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarrayProductLessThanK. /*FC*/class Solution {\n/*FM*/int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        if (k <= 1) {\n            return 0; \n        }\n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1662298850\"], \"nums_element1\": [\"-511493484\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/class Solution {\n/*FM*/int maxProfit(vector<int>& prices, int fee) {\n        int n = prices.size(); \n        vector<int> buy(n); \n        buy[0] = -prices[0]; \n        vector<int> sell(n); \n        for (int i = 1;  i < n;  ++i) {\n            buy[i] = max(buy[i - 1], sell[i - 1] - prices[i]); \n            sell[i] = max(sell[i - 1], buy[i] + prices[i] - fee); \n        }\n        \n        return sell[n - 1]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [3], \"prices_element0\": [\"-1221679907\"], \"prices_element1\": [\"-916564143\"], \"prices_element2\": [\"-776887740\"], \"fee\": [\"416654696\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit2. /*FC*/class Solution {\n/*FM*/int maxProfit2(vector<int>& prices, int fee) {\n        int n = prices.size(); \n        int buy = -prices[0], sell = 0; \n        for (int i = 1;  i < n;  ++i) {\n            buy = max(buy, sell - prices[i]); \n            sell = max(sell, buy + prices[i] - fee); \n        }\n        \n        return sell; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"prices\": [3], \"prices_element0\": [\"2020468652\"], \"prices_element1\": [\"773448998\"], \"prices_element2\": [\"-887440249\"], \"fee\": [\"917869001\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void addRange. /*FC*/class RangeModule {\n/*FM*/void addRange(int left, int right) {\n        auto l = table.lower_bound(left); \n        if (l != table.begin()) {\n            \n            \n        }\n        auto r = table.upper_bound(right); \n        if (l != r) {\n            \n            \n            \n        }\n        table[left] = right; \n    };/*F*/map<int, int> table;/*C*/RangeModule() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RangeModule\": [\"RangeModule\", \"RangeModule()\"], \"left\": [\"262638466\"], \"right\": [\"-1301456986\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void removeRange. /*FC*/class RangeModule {\n/*FM*/void removeRange(int left, int right) {\n        auto l = table.lower_bound(left); \n        if (l != table.begin()) {\n            \n            \n        }\n        auto r = table.upper_bound(right); \n        if (l != r) {\n            \n            \n            \n            \n            \n        }\n    };/*F*/map<int, int> table;/*C*/RangeModule() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RangeModule\": [\"RangeModule\", \"RangeModule()\"], \"left\": [\"965947666\"], \"right\": [\"974034859\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void push. /*FC*/class MaxStack {\n/*FM*/void push(int x) {\n        St.push(x); \n        if (maxSt.empty() || x >= maxSt.top()) {\n            maxSt.push(x); \n        }\n    };/*F*/stack<int> St;  stack<int> maxSt;/*C*/MaxStack() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MaxStack\": [\"MaxStack\", \"MaxStack()\"], \"x\": [\"26978886\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isOneBitCharacter. /*FC*/class Solution {\n/*FM*/bool isOneBitCharacter(vector<int>& bits) {\n        int n = bits.size(); \n        if (n == 1 || bits[n - 2] == 0) {\n            \n        }\n        vector<bool> dp(n); \n        dp[0] = true; \n        for (int i = 1;  i < dp.size();  ++i) {\n            if (bits[i - 1] == 0 && (dp[i - 1] || (i > 1 && dp[i - 2]))) {\n                \n            }\n            else if (bits[i - 1] == 1 && i > 1 && bits[i - 2] == 1 && dp[i - 2]){\n                \n            }\n        }\n                \n        return dp[n - 1] && !dp[n - 2]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"bits\": [2], \"bits_element0\": [\"-1766973210\"], \"bits_element1\": [\"534353651\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isOneBitCharacter2. /*FC*/class Solution {\n/*FM*/bool isOneBitCharacter2(vector<int>& bits) {\n        int n = bits.size(); \n        int i = 0; \n        while (i < n - 1) {\n            if (bits[i] == 0) {\n                \n            }\n            else {\n                i += 2; \n            }\n        }\n        \n        return i == n - 1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"bits\": [3], \"bits_element0\": [\"490109737\"], \"bits_element1\": [\"422182174\"], \"bits_element2\": [\"-1108805052\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLength. /*FC*/class Solution {\n/*FM*/int findLength(vector<int>& A, vector<int>& B) {\n        int m = A.size(); \n        int n = B.size(); \n        vector<vector<int>> dp(1 + m, vector<int>(1 + n)); \n        int maxLen = 0; \n        for (int i = 1;  i <= m;  ++i) {\n            for (int j = 1;  j <= n;  ++j) {\n                if (A[i - 1] == B[j - 1]) {\n                    \n                    \n                }               \n            }\n        }\n        \n        return maxLen; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"1024693333\"], \"A_element1\": [\"-1613786126\"], \"A_element2\": [\"2036480285\"], \"B\": [2], \"B_element0\": [\"77293152\"], \"B_element1\": [\"-160194331\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestDistancePair. /*FC*/class Solution {\n/*FM*/int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end()); \n        int low = 0, high = nums.back() - nums.front(); \n\n        while (low < high) {\n            int mid = low + (high - low) / 2; \n            int count = 0, left = 0; \n            for (int right = 1;  right < nums.size();  ++right) {\n                while (nums[right] - nums[left] > mid) {\n                    ++left; \n                }\n                count += right - left; \n            }\n            \n            if (count >= k) {\n                \n            }\n            else {\n                low = mid + 1; \n            }\n        }\n        return low; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"606091529\"], \"nums_element1\": [\"-722823377\"], \"k\": [\"463092502\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestDistancePair. /*FC*/class Solution {\n/*FM*/int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end()); \n        int low = 0, high = nums.back() - nums.front(); \n\n        while (low < high) {\n            int mid = low + (high - low) / 2; \n            int count = 0, left = 0; \n            for (int right = 1;  right < nums.size();  ++right) {\n                while (nums[right] - nums[left] > mid) {\n                    ++left; \n                }\n                count += right - left; \n            }\n            \n            if (count >= k) {\n                high = mid; \n            }\n            else {\n                \n            }\n        }\n        return low; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"944679955\"], \"nums_element1\": [\"670153085\"], \"nums_element2\": [\"1638088166\"], \"k\": [\"-1200943948\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestWord. /*FC*/class Solution {\n/*FM*/string longestWord(vector<string>& words) {\n        TrieNode* root = new TrieNode; \n        for (int i = 0;  i < words.size();  ++i) {\n            insert(root, words[i], i); \n        }\n        \n        string result = search(root, words); \n        delete root; \n        return result; \n    };/*F*//*C*//*M*/void insert(TrieNode* root, string word, int index) {\n        TrieNode* node = root; \n        for (char c : word) {\n            int i = c - 'a'; \n            if (node->next[i] == NULL) {\n                node->next[i] = new TrieNode(); \n            }\n            node = node->next[i]; \n        }\n        node->index = index; \n    } string search(TrieNode* root, vector<string>& words) {\n        stack<TrieNode*> St; \n        St.push(root); \n        string result; \n        while (!St.empty()) {\n            TrieNode* node = St.top(); \n            St.pop(); \n            if (node->index != -1 || node == root) {\n                if (node != root) {\n                    string word = words[node->index]; \n                    if (word.size() > result.size() || (word.size() == result.size() && word < result)) {\n                        result = word; \n                    }\n                }\n                \n                for (int i = 0;  i < 26;  ++i) {\n                    if (node->next[i]) {\n                        St.push(node->next[i]); \n                    }                    \n                }\n            }\n        }\n        \n        return result; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/class Solution {\n/*FM*/void insert(TrieNode* root, string word, int index) {\n        TrieNode* node = root; \n        for (char c : word) {\n            int i = c - 'a'; \n            if (node->next[i] == NULL) {\n                node->next[i] = new TrieNode(); \n            }\n            node = node->next[i]; \n        }\n        node->index = index; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TrieNode\", \"TrieNode()\"], \"root[0].next\": [26], \"root[0].index\": [\"96806171\"], \"word\": [\"1\"], \"index\": [\"-2020595809\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/class Solution {\n/*FM*/void insert(TrieNode* root, string word, int index) {\n        TrieNode* node = root; \n        for (char c : word) {\n            int i = c - 'a'; \n            if (node->next[i] == NULL) {\n                \n            }\n            node = node->next[i]; \n        }\n        node->index = index; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TrieNode\", \"TrieNode()\"], \"root[0].next\": [26], \"root[0].index\": [\"-1789395512\"], \"root[1]\": [\"TrieNode\", \"TrieNode()\"], \"root[1].next\": [26], \"root[1].index\": [\"-1172373976\"], \"word\": [\"1\"], \"index\": [\"-426064515\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> removeComments. /*FC*/class Solution {\n/*FM*/vector<string> removeComments(vector<string>& source) {\n        vector<string> result; \n        bool inBlock = false; \n        string newLine; \n        for (string s : source) {\n            if (!inBlock) {\n                newLine = \"\"; \n            }\n            int i = 0; \n            while (i < s.size()) {\n                if (!inBlock) {\n                    if (s.substr(i, 2) == \"\") {\n                    \n                    \n                }\n                else {\n                    \n                }\n            } \n            \n            if (newLine != \"\" && !inBlock) {\n                result.push_back(newLine); \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"source\": [2], \"source_element0\": [\"2\"], \"source_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pivotIndex. /*FC*/class Solution {\n/*FM*/int pivotIndex(vector<int>& nums) {\n        int n = nums.size(); \n        int sum = accumulate(nums.begin(), nums.end(), 0); \n        int leftSum = 0; \n        \n        for (int i = 0;  i < n;  ++i) {\n            if (leftSum == sum - leftSum - nums[i]) {\n                \n            }\n            leftSum += nums[i]; \n        }\n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1185419442\"], \"nums_element1\": [\"-1850760989\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pivotIndex. /*FC*/class Solution {\n/*FM*/int pivotIndex(vector<int>& nums) {\n        int n = nums.size(); \n        int sum = accumulate(nums.begin(), nums.end(), 0); \n        int leftSum = 0; \n        \n        for (int i = 0;  i < n;  ) {\n            if (leftSum == sum - leftSum - nums[i]) {\n                return i; \n            }\n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"2095209672\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<ListNode*> splitListToParts. /*FC*/class Solution {\n/*FM*/vector<ListNode*> splitListToParts(ListNode* root, int k) {\n        int len = 0; \n        ListNode* head = root; \n        while (head) {\n            ++len; \n            head = head->next; \n        }\n        \n        int count = len / k, remain = len % k; \n        vector<ListNode*> result(k); \n        head = root; \n        for (int i = 0;  i < k && head;  ++i) {\n            result[i] = head; \n            ListNode* prev = nullptr; \n            for (int j = 0;  j < count;  ) {\n                \n                \n            }\n            if (remain > 0) {\n                prev = head; \n                head = head->next; \n                --remain; \n            }\n            prev->next = nullptr; \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"ListNode\", \"ListNode(int)\"], \"root0_x\": [\"41482273\"], \"k\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string countOfAtoms. /*FC*/class Solution {\n/*FM*/string countOfAtoms(string formula) {\n        int n = formula.size(); \n        int i = 0; \n        map<string, int> table = helper(formula, i); \n        string result; \n        for (auto t : table) {\n            \n            \n        }\n        return result; \n    };/*F*//*C*//*M*/map<string, int> helper(string& s, int& i) {\n        map<string, int> table; \n        while (i < s.size() && s[i] != ')') {\n            if (s[i] == '(') {\n                ++i; \n                map<string, int> next = helper(s, i); \n                for (auto n : next) {\n                    table[n.first] += n.second; \n                }\n            }\n            else {\n                int start = i++; \n                while (i < s.size() && islower(s[i])) {\n                    ++i; \n                }\n                \n                string name = s.substr(start, i - start); \n                int num = 0; \n                while (i < s.size() && isdigit(s[i])) {\n                    num = num * 10 + (s[i] - '0'); \n                    ++i; \n                }\n                if (num == 0) {\n                    num = 1; \n                }\n                table[name] += num; \n            }\n        }\n\n        if (i < s.size()) {\n            ++i; \n            int num = 0; \n            while (i < s.size() && isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0'); \n                ++i; \n            }\n\n            if (num != 0) {\n                for (auto& t : table) {\n                    t.second *= num; \n                }\n            }\n        }        \n        \n        return table; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"formula\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string countOfAtoms. /*FC*/class Solution {\n/*FM*/string countOfAtoms(string formula) {\n        int n = formula.size(); \n        int i = 0; \n        map<string, int> table = helper(formula, i); \n        string result; \n        for (auto t : table) {\n            result += t.first; \n            if (t.second != 1) {\n                \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/map<string, int> helper(string& s, int& i) {\n        map<string, int> table; \n        while (i < s.size() && s[i] != ')') {\n            if (s[i] == '(') {\n                ++i; \n                map<string, int> next = helper(s, i); \n                for (auto n : next) {\n                    table[n.first] += n.second; \n                }\n            }\n            else {\n                int start = i++; \n                while (i < s.size() && islower(s[i])) {\n                    ++i; \n                }\n                \n                string name = s.substr(start, i - start); \n                int num = 0; \n                while (i < s.size() && isdigit(s[i])) {\n                    num = num * 10 + (s[i] - '0'); \n                    ++i; \n                }\n                if (num == 0) {\n                    num = 1; \n                }\n                table[name] += num; \n            }\n        }\n\n        if (i < s.size()) {\n            ++i; \n            int num = 0; \n            while (i < s.size() && isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0'); \n                ++i; \n            }\n\n            if (num != 0) {\n                for (auto& t : table) {\n                    t.second *= num; \n                }\n            }\n        }        \n        \n        return table; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"formula\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class Solution {\n/*FM*/string minWindow(string S, string T) {\n        int m = S.size(), n = T.size(); \n        if (m < n) {\n            \n        }\n        vector<vector<int>> start(1 + m, vector<int>(1 + n, -1)); \n        int minLen = m + 1, minStart = -1; \n        \n        for (int i = 0;  i <= m;  ++i) {\n            start[i][0] = i; \n        }\n        \n        for (int i = 1;  i <= m;  ++i) {\n            for (int j = 1;  j <= min(i, n);  ++j) {\n                if (S[i - 1] == T[j - 1]) {\n                    \n                }\n                else {\n                    start[i][j] = start[i - 1][j]; \n                }\n            }\n            \n            if (start[i][n] != -1 && i - start[i][n] < minLen) {\n                \n                \n            }\n        }        \n        \n        return minStart != -1 ? S.substr(minStart, minLen) : \"\"; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class Solution2 {\n/*FM*/string minWindow(string S, string T) {\n        int m = S.size(), n = T.size(); \n        if (m < n) {\n            \n        }\n        vector<int> start(1 + n, -1); \n        int minLen = m + 1, minStart = -1;         \n        start[0] = 0; \n        for (int i = 1;  i <= m;  ++i) {\n            for (int j = min(i, n);  j >= 1;  --j) {\n                if (S[i - 1] == T[j - 1]) {\n                    \n                }\n            }\n            start[0] = i; \n            if (start[n] != -1 && i - start[n] < minLen) {\n                \n                \n            }\n        }        \n        \n        return minStart != -1 ? S.substr(minStart, minLen) : \"\"; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"S\": [\"1\"], \"T\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> selfDividingNumbers. /*FC*/class Solution {\n/*FM*/vector<int> selfDividingNumbers(int left, int right) {\n        vector<int> result; \n        for (int i = left;  i <= right;  ++i) {\n            int num = i; \n            bool valid = true; \n            while (num) {\n                int temp = num % 10; \n                if (temp == 0 || i % temp) {\n                    valid = false; \n                    break; \n                }\n                num /= 10; \n            }\n            if (valid) {\n                result.push_back(i); \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"left\": [\"0\"], \"right\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool book. /*FC*/class MyCalendar {\n/*FM*/bool book(int start, int end) {\n        auto it = table.lower_bound(start); \n        \n        if (it != table.begin()) {\n            \n            \n            \n        }\n        \n        if (it != table.end() && it->first < end) {\n            \n        }\n        \n        table[start] = end; \n        return true; \n    };/*F*/map<int, int> table;/*C*/MyCalendar() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyCalendar\": [\"MyCalendar\", \"MyCalendar()\"], \"start\": [\"1821171000\"], \"end\": [\"901441736\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool book. /*FC*/class MyCalendarTwo {\n/*FM*/bool book(int start, int end) {\n        ++table[start]; \n        --table[end]; \n        int sum = 0; \n        for (auto t : table) {\n            sum += t.second; \n            if (sum >= 3) {\n                \n                \n                \n            }\n        }\n        return true; \n    };/*F*/map<int, int> table;/*C*/MyCalendarTwo() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyCalendarTwo\": [\"MyCalendarTwo\", \"MyCalendarTwo()\"], \"start\": [\"-477043349\"], \"end\": [\"-1175958833\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int book. /*FC*/class MyCalendarThree {\n/*FM*/int book(int start, int end) {\n        ++table[start]; \n        --table[end]; \n        int sum = 0; \n        int maxCount = 0; \n        for (auto t : table) {\n            sum += t.second; \n            maxCount = max(maxCount, sum); \n        }\n        return maxCount; \n    };/*F*/map<int, int> table;/*C*/MyCalendarThree() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyCalendarThree\": [\"MyCalendarThree\", \"MyCalendarThree()\"], \"start\": [\"561747148\"], \"end\": [\"814451097\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool areSentencesSimilar. /*FC*/class Solution {\n/*FM*/bool areSentencesSimilar(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> pairs) {\n        if (words1.size() != words2.size()) {\n            return false; \n        }\n        \n        \n        for ( : pairs) {\n            \n        }\n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words1\": [2], \"words1_element0\": [\"1\"], \"words1_element1\": [\"2\"], \"words2\": [1], \"words2_element0\": [\"2\"], \"pairs\": [2]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool areSentencesSimilar. /*FC*/class Solution {\n/*FM*/bool areSentencesSimilar(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> pairs) {\n        if (words1.size() != words2.size()) {\n            \n        }\n        \n        unordered_set<string> table; \n        for (auto& p : pairs) {\n            table.insert(p.first + \"#\" + p.second); \n        }\n        \n        for (int i = 0;  i < words1.size();  ) {\n            if (words1[i] == words2[i]) {\n                \n            }\n            \n            string s1 = words1[i] + \"#\" + words2[i]; \n            string s2 = words2[i] + \"#\" + words1[i]; \n            if (table.find(s1) == table.end() && table.find(s2) == table.end()) {\n                return false; \n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words1\": [2], \"words1_element0\": [\"1\"], \"words1_element1\": [\"1\"], \"words2\": [2], \"words2_element0\": [\"1\"], \"words2_element1\": [\"2\"], \"pairs\": [2]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> asteroidCollision. /*FC*/class Solution {\n/*FM*/vector<int> asteroidCollision(vector<int>& asteroids) {\n        vector<int> St; \n        for (int a : asteroids) {\n            while (!St.empty() && St.back() > 0 && St.back() < -a) {\n                \n            }\n            \n            if (St.empty() || St.back() < 0 || a > 0) {\n                St.push_back(a); \n            }\n            else if (St.back() == -a) {\n                \n            }\n        }\n        \n        return St; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"asteroids\": [2], \"asteroids_element0\": [\"1526920105\"], \"asteroids_element1\": [\"789079841\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool areSentencesSimilarTwo. /*FC*/class Solution {\n/*FM*/bool areSentencesSimilarTwo(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> pairs) {\n        if (words1.size() != words2.size()) {\n            \n        }\n        \n        for (auto& p : pairs) {\n            if (parent.find(p.first) == parent.end()) {\n                parent[p.first] = p.first; \n            }\n            if (parent.find(p.second) == parent.end()) {\n                \n            }\n            \n            string p1 = findParent(p.first); \n            string p2 = findParent(p.second); \n            if (p1 != p2) {\n                \n            }            \n        }\n        \n        for (int i = 0;  i < words1.size();  ) {\n            if (words1[i] == words2[i]) {\n                \n            }\n            \n            if (!parent.count(words1[i]) || !parent.count(words2[i]) || findParent(words1[i]) != findParent(words2[i])) {\n                return false; \n            }\n        }\n        \n        \n    };/*F*/unordered_map<string, string> parent;/*C*//*M*/string findParent(string& s) {\n        while (parent[s] != s) {\n            parent[s] = parent[parent[s]] ; \n            s = parent[s]; \n        }\n        \n        return s; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words1\": [2], \"words1_element0\": [\"1\"], \"words1_element1\": [\"2\"], \"words2\": [2], \"words2_element0\": [\"2\"], \"words2_element1\": [\"2\"], \"pairs\": [2]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool areSentencesSimilarTwo. /*FC*/class Solution {\n/*FM*/bool areSentencesSimilarTwo(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> pairs) {\n        if (words1.size() != words2.size()) {\n            return false; \n        }\n        \n        for ( : pairs) {\n            \n            \n            \n            \n            \n                        \n        }\n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words1\": [2], \"words1_element0\": [\"2\"], \"words1_element1\": [\"1\"], \"words2\": [1], \"words2_element0\": [\"1\"], \"pairs\": [1]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string findParent. /*FC*/class Solution {\n/*FM*/string findParent(string& s) {\n        while (parent[s] != s) {\n            parent[s] = parent[parent[s]] ; \n            s = parent[s]; \n        }\n        \n        return s; \n    };/*F*/unordered_map<string, string> parent;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> dailyTemperatures. /*FC*/class Solution {\n/*FM*/vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int n = temperatures.size(); \n        vector<int> result(n); \n        stack<int> St; \n        for (int i = n - 1;  i >= 0;  --i) {\n            while (!St.empty() && temperatures[St.top()] <= temperatures[i]) {\n                St.pop(); \n            }\n            if (!St.empty()) {\n                \n            }\n            St.push(i);             \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"temperatures\": [2], \"temperatures_element0\": [\"635766731\"], \"temperatures_element1\": [\"-1883396827\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findClosestLeaf. /*FC*/class Solution {\n/*FM*/int findClosestLeaf(TreeNode* root, int k) {\n        dfs(root, nullptr); \n        if (graph[k].size() == 0) {\n            return k; \n        }\n        \n        \n        \n              \n        \n        \n        \n        \n    };/*F*/unordered_map<int, unordered_set<int>> graph;/*C*//*M*/void dfs(TreeNode* node, TreeNode* parent) {\n        if (node) {\n            if (parent) {\n                graph[node->val].insert(parent->val); \n                graph[parent->val].insert(node->val); \n            }\n            dfs(node->left, node); \n            dfs(node->right, node); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"262890883\"], \"root[0].val\": [\"1885086451\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"523812574\"], \"root[1].val\": [\"-1412144455\"], \"k\": [\"-308948129\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(TreeNode* node, TreeNode* parent) {\n        if (node) {\n            if (parent) {\n                graph[node->val].insert(parent->val); \n                graph[parent->val].insert(node->val); \n            }\n            dfs(node->left, node); \n            dfs(node->right, node); \n        }\n    };/*F*/unordered_map<int, unordered_set<int>> graph;/*C*//*M*/void dfs(TreeNode* node, TreeNode* parent) {\n        if (node) {\n            if (parent) {\n                graph[node->val].insert(parent->val); \n                graph[parent->val].insert(node->val); \n            }\n            dfs(node->left, node); \n            dfs(node->right, node); \n        }\n    } void dfs(TreeNode* node, TreeNode* parent) {\n        if (node) {\n            if (parent) {\n                graph[node->val].insert(parent->val); \n                graph[parent->val].insert(node->val); \n            }\n            dfs(node->left, node); \n            dfs(node->right, node); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"node\": [1], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"694761473\"], \"node[0].val\": [\"1378424091\"], \"node[0].left\": [2], \"node[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_left0_x\": [\"1609129345\"], \"node[0].left[0].val\": [\"-725298659\"], \"node[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_left1_x\": [\"-98832104\"], \"node[0].left[1].val\": [\"-72960052\"], \"node[0].right\": [1], \"node[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_right0_x\": [\"1034583809\"], \"node[0].right[0].val\": [\"-609673974\"], \"parent\": [2], \"parent[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"parent0_x\": [\"2118488606\"], \"parent[0].val\": [\"-288006149\"], \"parent[0].left\": [2], \"parent[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"parent0_left0_x\": [\"-1235590508\"], \"parent[0].left[0].val\": [\"1063006802\"], \"parent[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"parent0_left1_x\": [\"-804847946\"], \"parent[0].left[1].val\": [\"2090422299\"], \"parent[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"parent1_x\": [\"-1730916277\"], \"parent[1].val\": [\"-113126579\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char nextGreatestLetter. /*FC*/class Solution {\n/*FM*/char nextGreatestLetter(vector<char>& letters, char target) {\n        auto it = upper_bound(letters.begin(), letters.end(), target); \n        if (it == letters.end()) {\n            \n        }\n        else {\n            return *it; \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"letters\": [3], \"letters_element0\": [\"-116\"], \"letters_element1\": [\"116\"], \"letters_element2\": [\"-106\"], \"target\": [\"81\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char nextGreatestLetter. /*FC*/class Solution {\n/*FM*/char nextGreatestLetter(vector<char>& letters, char target) {\n        auto it = upper_bound(letters.begin(), letters.end(), target); \n        if (it == letters.end()) {\n            return letters[0]; \n        }\n        else {\n            \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"letters\": [3], \"letters_element0\": [\"-9\"], \"letters_element1\": [\"73\"], \"letters_element2\": [\"-29\"], \"target\": [\"85\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCostClimbingStairs. /*FC*/class Solution {\n/*FM*/int minCostClimbingStairs(vector<int>& cost) {        \n        int dp0 = cost[0], dp1 = cost[1]; \n        for (int i = 2;  i < cost.size();  ) {\n            \n            \n            \n        }\n        \n        return min(dp0, dp1);         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"cost\": [1], \"cost_element0\": [\"-2089235606\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dominantIndex. /*FC*/class Solution {\n/*FM*/int dominantIndex(vector<int>& nums) {\n        int n = nums.size(); \n        if (n == 1) {\n            \n        }\n        \n        int max1 = 0, max2 = 1; \n        if (nums[1] > nums[0]) {\n            \n            \n        }\n        \n        for (int i = 2;  i < n;  ) {\n            \n        }\n        \n        return nums[max1] >= nums[max2] * 2 ? max1 : -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"907732469\"], \"nums_element1\": [\"-1564871276\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dominantIndex. /*FC*/class Solution {\n/*FM*/int dominantIndex(vector<int>& nums) {\n        int n = nums.size(); \n        if (n == 1) {\n            return 0; \n        }\n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1362103155\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string shortestCompletingWord. /*FC*/class Solution {\n/*FM*/string shortestCompletingWord(string licensePlate, vector<string>& words) {\n        vector<int> table(26); \n        int count = 0; \n        for (char c : licensePlate) {\n            if (c == ' ' || isdigit(c)) {\n                \n            }\n            else {\n                ++table[tolower(c) - 'a']; \n                ++count; \n            }\n        }\n        \n        int minLen = INT_MAX; \n        int minIndex = -1; \n        for (int i = 0;  i < words.size();  ++i) {\n            int num = count; \n            vector<int> need(table.begin(), table.end()); \n            for (char c : words[i]) {\n                if (--need[c - 'a'] >= 0) {\n                    --num; \n                    if (num == 0) {\n                        if (words[i].size() < minLen) {\n                            minIndex = i; \n                            minLen = words[i].size(); \n                        }\n                        break; \n                    }\n                }\n            }\n        }\n        \n        return words[minIndex]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"licensePlate\": [\"1\"], \"words\": [2], \"words_element0\": [\"2\"], \"words_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int intersectionSizeTwo. /*FC*/class Solution {\n/*FM*/int intersectionSizeTwo(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), cmp()); \n        int end1 = intervals[0][1] - 1, end2 = intervals[0][1]; \n        int count = 2; \n        for (int i = 1;  i < intervals.size();  ++i) {\n            if (intervals[i][0] > end2) {                \n                count += 2;                 \n                end1 = intervals[i][1] - 1; \n                end2 = intervals[i][1]; \n            }\n            else if (intervals[i][0] > end1) {\n                                \n                \n                \n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [1], \"intervals_element0_element0\": [\"562129107\"], \"intervals_element1\": [1], \"intervals_element1_element0\": [\"-1422288651\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int intersectionSizeTwo. /*FC*/class Solution {\n/*FM*/int intersectionSizeTwo(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), cmp()); \n        int end1 = intervals[0][1] - 1, end2 = intervals[0][1]; \n        int count = 2; \n        for (int i = 1;  i < intervals.size();  ++i) {\n            if (intervals[i][0] > end2) {                \n                                \n                \n                \n            }\n            else if (intervals[i][0] > end1) {\n                                \n                \n                \n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [1], \"intervals_element0_element0\": [\"-399622767\"], \"intervals_element1\": [1], \"intervals_element1_element0\": [\"-98103123\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> employeeFreeTime. /*FC*/class Solution {\n/*FM*/vector<Interval> employeeFreeTime(vector<vector<Interval>> schedule) {\n        vector<Interval> intervals; \n        for (auto s : schedule) {\n            for (Interval i : s) {\n                intervals.push_back(i); \n            }\n        }\n        \n        sort(intervals.begin(), intervals.end(), cmp()); \n        int prevEnd = intervals[0].end;         \n        vector<Interval> result; \n        for (int i = 1;  i < intervals.size();  ++i) {\n            if (intervals[i].start > prevEnd) {\n                \n            }\n                        \n            if (intervals[i].end > prevEnd) {\n                \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"schedule\": [1], \"schedule_element0\": [2], \"schedule_element0_element0\": [\"Interval\", \"Interval()\"], \"schedule_element0_element1\": [\"Interval\", \"Interval(int,int)\"], \"schedule_element0_element1__start\": [\"-795240\"], \"schedule_element0_element1__end\": [\"2123557673\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> employeeFreeTime. /*FC*/class Solution {\n/*FM*/vector<Interval> employeeFreeTime(vector<vector<Interval>> schedule) {\n        vector<Interval> intervals; \n        for (auto s : schedule) {\n            for (Interval i : s) {\n                intervals.push_back(i); \n            }\n        }\n        \n        sort(intervals.begin(), intervals.end(), cmp()); \n        int prevEnd = intervals[0].end;         \n        vector<Interval> result; \n        for (int i = 1;  i < intervals.size();  ++i) {\n            if (intervals[i].start > prevEnd) {\n                result.push_back({prevEnd, intervals[i].start}); \n            }\n                        \n            if (intervals[i].end > prevEnd) {\n                prevEnd = intervals[i].end; \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"schedule\": [2], \"schedule_element0\": [1], \"schedule_element0_element0\": [\"Interval\", \"Interval(int,int)\"], \"schedule_element0_element0__start\": [\"1849126434\"], \"schedule_element0_element0__end\": [\"179506466\"], \"schedule_element1\": [2], \"schedule_element1_element0\": [\"Interval\", \"Interval(int,int)\"], \"schedule_element1_element0__start\": [\"-81309055\"], \"schedule_element1_element0__end\": [\"-962238352\"], \"schedule_element1_element1\": [\"Interval\", \"Interval()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPrimeSetBits. /*FC*/class Solution {\n/*FM*/int countPrimeSetBits(int L, int R) {\n        int count = 0; \n        vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}; \n        for (int i = L;  i <= R;  ++i) {\n            int num = i; \n            int sum = 0; \n            while (num) {\n                ++sum; \n                num &= (num - 1); \n            }\n            if (find(primes.begin(), primes.end(), sum) != primes.end()) ++count; \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"L\": [\"0\"], \"R\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> partitionLabels. /*FC*/class Solution {\n/*FM*/vector<int> partitionLabels(string S) {\n        vector<int> last(26); \n        for (int i = 0;  i < S.size();  ++i) {\n            last[S[i] - 'a'] = i; \n        }\n        \n        vector<int> result; \n        int start = 0, j = 0; \n        for (int i = 0;  i < S.size();  ++i) {\n            j = max(j, last[S[i] - 'a']); \n            if (j == i) {\n                result.push_back(i - start + 1); \n                start = i + 1; \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSwapsCouples. /*FC*/class Solution {\n/*FM*/int minSwapsCouples(vector<int>& row) {\n        int count = 0; \n        int n = row.size(); \n        \n        unordered_map<int, int> table; \n        for (int i = 0;  i < n;  ++i) {\n            table[row[i]] = i; \n        }\n                \n        for (int i = 0;  i < n;  i += 2) {\n            int curr = row[i]; \n            int couple = curr ^ 1; \n            if (table[couple] == i + 1) {\n                \n            }\n            \n            ++count; \n            table[row[i + 1]] = table[couple]; \n            swap(row[i + 1], row[table[couple]]); \n            table[couple] = i + 1; \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"row\": [1], \"row_element0\": [\"-813501378\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isToeplitzMatrix. /*FC*/class Solution {\n/*FM*/bool isToeplitzMatrix(vector<vector<int>>& matrix) {\n        for (int i = 1;  i < matrix.size();  ) {\n            \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"-1620159207\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxChunksToSorted. /*FC*/class Solution {\n/*FM*/int maxChunksToSorted(vector<int>& arr) {\n        int maxNum = 0, count = 0; \n        for (int i = 0;  i < arr.size();  ++i) {\n            maxNum = max(maxNum, arr[i]); \n            if (maxNum == i) ++count; \n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [2], \"arr_element0\": [\"-343526147\"], \"arr_element1\": [\"1351753142\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numJewelsInStones. /*FC*/class Solution {\n/*FM*/int numJewelsInStones(string J, string S) {\n        unordered_set<char> jewels(J.begin(), J.end()); \n        int count = 0; \n        for (char c : S) {\n            if (jewels.count(c)) {\n                \n            }\n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"J\": [\"1\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int calculate. /*FC*/class Solution {\n/*FM*/int calculate(string s) {\n        stack<int> vals; \n        stack<char> ops; \n        int sign = 1; \n        for (int i = 0;  i < s.size();  ++i) {\n            if (s[i] == ' ') {\n                \n            }\n            if (isdigit(s[i])) {\n                int num = 0; \n                while (i < s.size() && isdigit(s[i])) {\n                    num = num * 10 + (s[i++] - '0'); \n                }\n                --i; \n                vals.push(sign * num); \n                sign = 1; \n            }\n            else if (s[i] == '(') {\n                \n            }\n            else if (s[i] == ')') {\n                \n                \n            }\n            else {\n                                \n            }\n        }\n        \n        while (!ops.empty()) {\n            \n            \n            \n            \n            \n            \n            \n        }\n        \n        return vals.top(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int apply. /*FC*/class Solution {\n/*FM*/int apply(int a, int b, char op) {\n        if (op == '+')\n            \n        else if (op == '-')\n            \n        else if (op == '*')\n            \n        else\n            return a / b; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"1666107940\"], \"b\": [\"-1375272168\"], \"op\": [\"-102\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int precedence. /*FC*/class Solution {\n/*FM*/int precedence(char op) {\n        if (op == '+' || op == '-')\n            \n        else\n            return 2; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"op\": [\"18\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/class Solution {\n/*FM*/string convert(vector<vector<int>>& board) {\n        string str; \n        for (int i = 0;  i < 2;  ++i)\n            for (int j = 0;  j < 3;  ++j)\n                str += '0' + board[i][j]; \n        return str; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"board\": [2], \"board_element0\": [1], \"board_element0_element0\": [\"-1237854703\"], \"board_element1\": [1], \"board_element1_element0\": [\"686979525\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isIdealPermutation. /*FC*/class Solution {\n/*FM*/bool isIdealPermutation(vector<int>& A) {\n        int n = A.size(); \n        int maxNum = A[0]; \n        for (int i = 0;  i < n - 2;  ) {\n            \n            \n        }\n\n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"1321654526\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool reachingPoints. /*FC*/class Solution {\n/*FM*/bool reachingPoints(int sx, int sy, int tx, int ty) {\n        while (tx >= sx && ty >= sy) {\n            if (tx > ty) {\n                \n            }\n            else {\n                if (tx == sx) {\n                    return (ty - sy) % tx == 0; \n                }\n                else {\n                    \n                }              \n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"sx\": [\"5\"], \"sy\": [\"2\"], \"tx\": [\"5\"], \"ty\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool reachingPoints. /*FC*/class Solution {\n/*FM*/bool reachingPoints(int sx, int sy, int tx, int ty) {\n        while (tx >= sx && ty >= sy) {\n            if (tx > ty) {\n                if (ty == sy) {\n                    \n                }\n                else {\n                    tx %= ty; \n                }\n            }\n            else {\n                              \n            }\n        }\n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"sx\": [\"5\"], \"sy\": [\"0\"], \"tx\": [\"9\"], \"ty\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numRabbits. /*FC*/class Solution {\n/*FM*/int numRabbits(vector<int>& answers) {\n        unordered_map<int, int> table; \n        for (int a : answers) {\n            ++table[a]; \n        }\n        int count = 0; \n        for (auto t : table) {\n            \n            count += (t.second + t.first) / (t.first + 1) * (t.first + 1); \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"answers\": [2], \"answers_element0\": [\"1599584862\"], \"answers_element1\": [\"-1629166238\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDiffInBST. /*FC*/class Solution {\n/*FM*/int minDiffInBST(TreeNode* root) {\n        int minDiff = INT_MAX; \n        TreeNode* prev = nullptr; \n        dfs(root, prev, minDiff); \n        return minDiff; \n    };/*F*//*C*//*M*/void dfs(TreeNode* root, TreeNode* &prev, int& minDiff) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        dfs(root->left, prev, minDiff); \n        if (prev != nullptr) {\n            minDiff = min(minDiff, root->val - prev->val); \n        }\n        prev = root; \n        dfs(root->right, prev, minDiff); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1370393611\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1557782241\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(TreeNode* root, TreeNode* &prev, int& minDiff) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        dfs(root->left, prev, minDiff); \n        if (prev != nullptr) {\n            minDiff = min(minDiff, root->val - prev->val); \n        }\n        prev = root; \n        dfs(root->right, prev, minDiff); \n    };/*F*//*C*//*M*/void dfs(TreeNode* root, TreeNode* &prev, int& minDiff) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        dfs(root->left, prev, minDiff); \n        if (prev != nullptr) {\n            minDiff = min(minDiff, root->val - prev->val); \n        }\n        prev = root; \n        dfs(root->right, prev, minDiff); \n    } void dfs(TreeNode* root, TreeNode* &prev, int& minDiff) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        dfs(root->left, prev, minDiff); \n        if (prev != nullptr) {\n            minDiff = min(minDiff, root->val - prev->val); \n        }\n        prev = root; \n        dfs(root->right, prev, minDiff); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"739328343\"], \"root[0].val\": [\"352505837\"], \"minDiff\": [\"-1666659276\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(int num) {\n        int n = num, base = 1; \n        int result = 0; \n        while (n) {\n            int temp = n % 10; \n            if (temp == 2 || temp == 5) {\n                temp = 7 - temp; \n            }\n            else if (temp == 6 || temp == 9) {\n                \n            }\n            else if (temp != 0 && temp != 1 && temp != 8) {\n                return false; \n            }\n            result += base * temp; \n            base *= 10; \n            n /= 10; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1271373518\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(int num) {\n        int n = num, base = 1; \n        int result = 0; \n        while (n) {\n            int temp = n % 10; \n            if (temp == 2 || temp == 5) {\n                \n            }\n            else if (temp == 6 || temp == 9) {\n                temp = 15 - temp; \n            }\n            else if (temp != 0 && temp != 1 && temp != 8) {\n                return false; \n            }\n            result += base * temp; \n            base *= 10; \n            n /= 10; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"379739019\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool escapeGhosts. /*FC*/class Solution {\n/*FM*/bool escapeGhosts(vector<vector<int>>& ghosts, vector<int>& target) {\n        int dist = abs(target[0]) + abs(target[1]); \n        for (auto ghost : ghosts) {\n            if (abs(target[0] - ghost[0]) + abs(target[1] - ghost[1]) <= dist) {\n                return false; \n            }\n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ghosts\": [1], \"ghosts_element0\": [1], \"ghosts_element0_element0\": [\"1226821910\"], \"target\": [2], \"target_element0\": [\"1374195949\"], \"target_element1\": [\"-397827164\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool escapeGhosts. /*FC*/class Solution {\n/*FM*/bool escapeGhosts(vector<vector<int>>& ghosts, vector<int>& target) {\n        int dist = abs(target[0]) + abs(target[1]); \n        for (auto ghost : ghosts) {\n            if (abs(target[0] - ghost[0]) + abs(target[1] - ghost[1]) <= dist) {\n                \n            }\n        }\n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ghosts\": [2], \"ghosts_element0\": [1], \"ghosts_element0_element0\": [\"942492518\"], \"ghosts_element1\": [1], \"ghosts_element1_element0\": [\"-1354726843\"], \"target\": [2], \"target_element0\": [\"-944855683\"], \"target_element1\": [\"1518208130\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numTilings. /*FC*/class Solution {\n/*FM*/int numTilings(int N) {\n        int MOD = 1000000007; \n        int dp[1001]; \n        dp[0] = 1; \n        dp[1] = 1; \n        dp[2] = 2; \n        if (N <= 2) \n        for (int i = 3;  i <= N;  ++i) {\n            dp[i] = ((dp[i - 1] + dp[i - 1]) % MOD + dp[i - 3]) % MOD; \n        }\n        return dp[N]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numTilings. /*FC*/class Solution {\n/*FM*/int numTilings(int N) {\n        int MOD = 1000000007; \n        int dp[1001]; \n        dp[0] = 1; \n        dp[1] = 1; \n        dp[2] = 2; \n        if (N <= 2) return dp[N]; \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string customSortString. /*FC*/class Solution {\n/*FM*/string customSortString(string S, string T) {\n        string result; \n        vector<int> table(26); \n        for (char c : T) {\n            ++table[c - 'a']; \n        }\n        \n        for (char c : S) {\n            if (table[c - 'a'] > 0) {\n                result += string(table[c - 'a'], c); \n                table[c - 'a'] = 0; \n            }\n        }\n        \n        for (int i = 0;  i < 26;  ++i) {\n            if (table[i] > 0) {\n                \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string customSortString. /*FC*/class Solution {\n/*FM*/string customSortString(string S, string T) {\n        string result; \n        vector<int> table(26); \n        for (char c : T) {\n            ++table[c - 'a']; \n        }\n        \n        for (char c : S) {\n            if (table[c - 'a'] > 0) {\n                \n                \n            }\n        }\n        \n        for (int i = 0;  i < 26;  ++i) {\n            if (table[i] > 0) {\n                \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"T\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numMatchingSubseq. /*FC*/class Solution {\n/*FM*/int numMatchingSubseq(string S, vector<string>& words) {\n        vector<vector<int>> table(26); \n        for (int i = 0;  i < S.size();  ++i) {\n            table[S[i] - 'a'].push_back(i); \n        }\n        \n        int count = 0; \n        for (string word : words) {\n            int index = -1; \n            bool flag = true; \n            for (char c : word) {\n                auto it = upper_bound(table[c - 'a'].begin(), table[c - 'a'].end(), index); \n                if (it == table[c - 'a'].end()) {\n                    flag = false; \n                    break; \n                }\n                else {\n                    \n                }                \n            }\n            if (flag) {\n                \n            }\n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"words\": [1], \"words_element0\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int preimageSizeFZF. /*FC*/class Solution {\n/*FM*/int preimageSizeFZF(int K) {\n        long long start = 1, end = ((long long)K + 1) * 5; \n        while (start <= end) {\n            long long mid = start + (end - start) / 2; \n            long long count = trailingZeroes(mid); \n            \n            if (count > K) {\n                end = mid - 1; \n            }\n            else if (count < K) {\n                start = mid + 1; \n            }\n            else{\n                return 5; \n            }\n        }\n        \n                \n    };/*F*//*C*//*M*/long long trailingZeroes(long long n) {\n        long long count = 0; \n        while (n >= 5) {\n            n /= 5; \n            count += n; \n        }\n        \n        return count; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"K\": [\"1883584732\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int preimageSizeFZF. /*FC*/class Solution {\n/*FM*/int preimageSizeFZF(int K) {\n        long long start = 1, end = ((long long)K + 1) * 5; \n        while (start <= end) {\n            long long mid = start + (end - start) / 2; \n            long long count = trailingZeroes(mid); \n            \n            if (count > K) {\n                end = mid - 1; \n            }\n            else if (count < K) {\n                start = mid + 1; \n            }\n            else{\n                \n            }\n        }\n        \n        return 0;         \n    };/*F*//*C*//*M*/long long trailingZeroes(long long n) {\n        long long count = 0; \n        while (n >= 5) {\n            n /= 5; \n            count += n; \n        }\n        \n        return count; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"K\": [\"930272930\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long trailingZeroes. /*FC*/class Solution {\n/*FM*/long long trailingZeroes(long long n) {\n        long long count = 0; \n        while (n >= 5) {\n            n /= 5; \n            count += n; \n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarrayBoundedMax. /*FC*/class Solution {\n/*FM*/int numSubarrayBoundedMax(vector<int>& A, int L, int R) {\n        int count = 0; \n        int maxIndex = -1, minIndex = -1; \n        for (int i = 0;  i < A.size();  ++i) {\n            if (A[i] >= L) {\n                minIndex = i; \n            }\n            if (A[i] > R) {\n                maxIndex = i; \n            }\n            count += minIndex - maxIndex; \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-2122108992\"], \"A_element1\": [\"1974063302\"], \"L\": [\"-1716100780\"], \"R\": [\"-1509750670\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool rotateString. /*FC*/class Solution {\n/*FM*/bool rotateString(string A, string B) {\n        if (A.size() != B.size()) {\n            \n        }\n        string s = A + A; \n        return s.find(B) != -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"1\"], \"B\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int bestRotation. /*FC*/class Solution {\n/*FM*/int bestRotation(vector<int>& A) {\n        int n = A.size(); \n        int change[n] = {0}; \n        for (int i = 0;  i < n;  ++i) {\n            change[(i - A[i] + 1 + n) % n] -= 1; \n        }\n        int K = 0; \n        for (int i = 1;  i < n;  ++i) {\n            change[i] += change[i - 1] + 1; \n            if (change[i] > change[K]) {\n                \n            }\n        }\n\n        return K; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-70290971\"], \"A_element1\": [\"-1792785301\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int bestRotation. /*FC*/class Solution {\n/*FM*/int bestRotation(vector<int>& A) {\n        int n = A.size(); \n        int change[n] = {0}; \n        for (int i = 0;  i < n;  ++i) {\n            change[(i - A[i] + 1 + n) % n] -= 1; \n        }\n        int K = 0; \n        for (int i = 1;  i < n;  ++i) {\n            change[i] += change[i - 1] + 1; \n            if (change[i] > change[K]) {\n                K = i; \n            }\n        }\n\n        return K; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"700515683\"], \"A_element1\": [\"1237123807\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumProduct. /*FC*/class Solution {\n/*FM*/int maximumProduct(vector<int>& nums) {\n        int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN; \n        int min1 = INT_MAX, min2 = INT_MAX; \n        for (int num : nums) {\n            if (num > max1) {\n                max3 = max2; \n                max2 = max1; \n                max1 = num; \n            }\n            else if (num > max2) {\n                \n                \n            }\n            else if (num > max3) {\n                \n            }            \n            \n            if (num < min1) {\n                min2 = min1; \n                min1 = num; \n            }\n            else if (num < min2) {\n                min2 = num; \n            }\n        }\n        \n        return max(max1 * max2 * max3, max1 * min1 * min2); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1450664893\"], \"nums_element1\": [\"1531638551\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> smallestRange. /*FC*/class Solution {\n/*FM*/vector<int> smallestRange(vector<vector<int>>& nums) {\n        priority_queue<Node> pq; \n        int minNum = INT_MAX, maxNum = INT_MIN; \n        int k = nums.size(); \n        for (int i = 0;  i < k;  ++i) {\n            pq.emplace(nums[i][0], i, 0); \n            minNum = min(minNum, nums[i][0]); \n            maxNum = max(maxNum, nums[i][0]); \n        }\n        \n        vector<int> minRange = {minNum, maxNum}; \n        while (true) {\n            Node node = pq.top(); \n            pq.pop(); \n            int row = node.row; \n            int col = node.col; \n            int val = node.val; \n            if (maxNum - val < minRange[1] - minRange[0] || (maxNum - val == minRange[1] - minRange[0] && val < minRange[0])) {\n                minRange[0] = val; \n                minRange[1] = maxNum; \n            }\n            \n            if (col < nums[row].size() - 1) {\n                ++col; \n                maxNum = max(maxNum, nums[row][col]); \n                pq.emplace(nums[row][col], row, col); \n            }\n            else {\n                break; \n            }            \n        }\n     \n        return minRange; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [1], \"nums_element0_element0\": [\"1547269880\"], \"nums_element1\": [2], \"nums_element1_element0\": [\"780642648\"], \"nums_element1_element1\": [\"1274365048\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> smallestRange. /*FC*/class Solution {\n/*FM*/vector<int> smallestRange(vector<vector<int>>& nums) {\n        priority_queue<Node> pq; \n        int minNum = INT_MAX, maxNum = INT_MIN; \n        int k = nums.size(); \n        for (int i = 0;  i < k;  ++i) {\n            pq.emplace(nums[i][0], i, 0); \n            minNum = min(minNum, nums[i][0]); \n            maxNum = max(maxNum, nums[i][0]); \n        }\n        \n        vector<int> minRange = {minNum, maxNum}; \n        while (true) {\n            Node node = pq.top(); \n            pq.pop(); \n            int row = node.row; \n            int col = node.col; \n            int val = node.val; \n            if (maxNum - val < minRange[1] - minRange[0] || (maxNum - val == minRange[1] - minRange[0] && val < minRange[0])) {\n                \n                \n            }\n            \n            if (col < nums[row].size() - 1) {\n                ++col; \n                maxNum = max(maxNum, nums[row][col]); \n                pq.emplace(nums[row][col], row, col); \n            }\n            else {\n                break; \n            }            \n        }\n     \n        return minRange; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [2], \"nums_element0_element0\": [\"1505808768\"], \"nums_element0_element1\": [\"-951252951\"], \"nums_element1\": [2], \"nums_element1_element0\": [\"815987837\"], \"nums_element1_element1\": [\"-419964790\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool judgeSquareSum. /*FC*/class Solution {\n/*FM*/bool judgeSquareSum(int c) {\n        for (long a = 0;  a * a <= c;  ++a) {\n            int b2 = c - a * a; \n            int root = sqrt(b2); \n            if (root * root == b2) {\n                return true; \n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"c\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool judgeSquareSum. /*FC*/class Solution {\n/*FM*/bool judgeSquareSum(int c) {\n        for (long a = 0;  a * a <= c;  ++a) {\n            int b2 = c - a * a; \n            int root = sqrt(b2); \n            if (root * root == b2) {\n                \n            }\n        }\n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"c\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findDerangement. /*FC*/class Solution {\n/*FM*/int findDerangement(int n) {\n        int MOD = 1e9 + 7; \n        if (n == 1) {\n            return 0; \n        }\n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findDerangement. /*FC*/class Solution {\n/*FM*/int findDerangement(int n) {\n        int MOD = 1e9 + 7; \n        if (n == 1) {\n            \n        }\n        \n        int dp1 = 0, dp2 = 1; \n        for (int i = 3;  i <= n;  ++i) {\n            int dp3 = ((i - 1L) * (dp1 + dp2)) % MOD; \n            dp1 = dp2; \n            dp2 = dp3; \n        }\n        \n        return dp2; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<double> averageOfLevels. /*FC*/class Solution {\n/*FM*/vector<double> averageOfLevels(TreeNode* root) {\n        queue<TreeNode*> Q; \n        Q.push(root); \n        vector<double> result; \n        while (!Q.empty()) {\n            int qs = Q.size(); \n            double sum = 0; \n            for (int i = 0;  i < qs;  ++i) {\n                TreeNode* node = Q.front(); \n                Q.pop(); \n                sum += node->val; \n                if (node->left) {\n                    \n                }\n                if (node->right) {\n                    \n                }\n            }\n            result.push_back(sum / qs); \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-8287472\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMinMoves. /*FC*/class Solution {\n/*FM*/int findMinMoves(vector<int>& machines) {\n        int n = machines.size(); \n        int sum = accumulate(machines.begin(), machines.end(), 0); \n        if (sum % n) {\n            \n        }\n        \n        int avg = sum / n; \n        int count = 0; \n        int curr = 0; \n        for (int i = 0;  i < n;  ++i) {\n            int diff = machines[i] - avg; \n            curr += diff; \n            count = max(count, max(abs(curr), diff)); \n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"machines\": [1], \"machines_element0\": [\"-38313540\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMinMoves. /*FC*/class Solution {\n/*FM*/int findMinMoves(vector<int>& machines) {\n        int n = machines.size(); \n        int sum = accumulate(machines.begin(), machines.end(), 0); \n        if (sum % n) {\n            return -1; \n        }\n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"machines\": [3], \"machines_element0\": [\"-1830501170\"], \"machines_element1\": [\"240627650\"], \"machines_element2\": [\"-1000756056\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int change. /*FC*/class Solution {\n/*FM*/int change(int amount, vector<int>& coins) {\n        vector<int> dp(1 + amount); \n        dp[0] = 1; \n        for (int i = 0;  i < coins.size();  ++i) {\n            for (int j = coins[i];  j <= amount;  ) {\n                \n            }\n        }\n\n        return dp[amount]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"amount\": [\"4\"], \"coins\": [2], \"coins_element0\": [\"697829844\"], \"coins_element1\": [\"113426315\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool detectCapitalUse. /*FC*/class Solution {\n/*FM*/bool detectCapitalUse(string word) {\n        bool allUpper = false; \n        bool allLower = false; \n        if (islower(word[0])) {\n            \n        }\n        \n        for (int i = 1;  i < word.size();  ) {\n            \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool detectCapitalUse. /*FC*/class Solution {\n/*FM*/bool detectCapitalUse(string word) {\n        bool allUpper = false; \n        bool allLower = false; \n        if (islower(word[0])) {\n            allLower = true; \n        }\n        \n        for (int i = 1;  i < word.size();  ) {\n            \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLUSlength. /*FC*/class Solution {\n/*FM*/int findLUSlength(string a, string b) {\n        if (a == b) {\n            \n        }\n        else {\n            return max(a.size(), b.size()); \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"3\"], \"b\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLUSlength. /*FC*/class Solution {\n/*FM*/int findLUSlength(vector<string>& strs) {\n        map<int, vector<string>> table; \n        unordered_map<string, int> count; \n        for (string str : strs) {\n            ++count[str]; \n            table[str.size()].push_back(str); \n        }\n        \n        unordered_set<string> substring; \n        \n        for (auto it = table.rbegin();  it != table.rend();  ) {\n            int n = it->second.size(); \n            for (int i = 0;  i < n;  ) {\n                string str = it->second[i]; \n                if (count[str] == 1 && !isSubstring(str, substring)) {\n                    return it->first; \n                }\n                \n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [1], \"strs_element0\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubstring. /*FC*/class Solution {\n/*FM*/bool isSubstring(string& a, string& b) {\n        int i = 0, j = 0; \n        while (i < a.size() && j < b.size()) {\n            \n            \n        }\n        \n        return i == a.size(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"1\"], \"b\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubstring. /*FC*/class Solution {\n/*FM*/bool isSubstring(string& a, string& b) {\n        int i = 0, j = 0; \n        while (i < a.size() && j < b.size()) {\n            if (a[i] == b[j]) {\n                \n            }\n            ++j; \n        }\n        \n        return i == a.size(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"2\"], \"b\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubstring. /*FC*/class Solution {\n/*FM*/bool isSubstring(string& a, unordered_set<string>& prev) {\n        for (string str : prev) {\n            \n        }\n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkSubarraySum. /*FC*/class Solution {\n/*FM*/bool checkSubarraySum(vector<int>& nums, int k) {\n        int presum = 0; \n        unordered_map<int, int> table; \n        table[0] = -1; \n        for (int i = 0;  i < nums.size();  ++i) {\n            presum += nums[i]; \n            if (k != 0) {\n                presum %= k; \n            }\n            if (table.find(presum) != table.end()) {\n                \n            }\n            else {\n                table[presum] = i; \n            }\n        }\n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-961378462\"], \"nums_element1\": [\"-1984646837\"], \"nums_element2\": [\"221629358\"], \"k\": [\"1053598604\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string findLongestWord. /*FC*/class Solution {\n/*FM*/string findLongestWord(string s, vector<string>& d) {\n        string result; \n        for (string str : d) {\n            if (isSubstring(str, s) && (str.size() > result.size() || str.size() == result.size() && str < result)) {\n                \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/bool isSubstring(string& a, string& b) {\n        int i = 0, j = 0; \n        while (i < a.size() && j < b.size()) {\n            if (a[i] == b[j]) {\n                ++i; \n            }\n            ++j; \n        }\n        \n        return i == a.size(); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"d\": [1], \"d_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeBoxes. /*FC*/class Solution {\n/*FM*/int removeBoxes(vector<int>& boxes) {\n        int n = boxes.size(); \n        if (n == 0) {\n            \n        }\n        \n        memset(dp, 0, sizeof(dp)); \n\n        return dfs(boxes, dp, 0, n - 1, 0); \n    };/*F*//*C*//*M*/int dfs(vector<int>& boxes, int dp[][maxn][maxn], int i, int j, int k) {\n        if (i > j) {\n            return 0; \n        }\n        \n        if (dp[i][j][k]) {\n            return dp[i][j][k]; \n        }        \n\n        while (i < j && boxes[i] == boxes[i + 1]) {\n            ++i; \n            ++k; \n        }\n\n        int maxVal = dfs(boxes, dp, i + 1, j, 0) + (k + 1) * (k + 1); \n        for (int m = i + 2;  m <= j;  ++m) {\n            if (boxes[i] == boxes[m]) {\n                maxVal = max(maxVal, dfs(boxes, dp, i + 1, m - 1, 0) + dfs(boxes, dp, m, j, k + 1)); \n            }\n        }\n        return dp[i][j][k] = maxVal; \n    };\n}",
        "target": "{\"dp\": [3], \"dp[1][0][0]\": [\"100\"], \"dp[7][0][0]\": [\"100\"], \"dp[8][0][0]\": [\"100\"], \"dp[9][0][0]\": [\"1457902287\"], \"dp[68][0][0]\": [\"-2139058785\"], \"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"boxes\": [3], \"boxes_element0\": [\"-395203699\"], \"boxes_element1\": [\"2091996774\"], \"boxes_element2\": [\"-442361971\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findCircleNum. /*FC*/class Solution {\n/*FM*/int findCircleNum(vector<vector<int>>& M) {\n        int count = M.size(); \n        vector<int> parent(count); \n        for (int i = 0;  i < parent.size();  ++i) {\n            parent[i] = i; \n        }\n        for (int i = 0;  i < M.size();  ++i) {\n            for (int j = i + 1;  j < M[i].size();  ++j) {\n                if (M[i][j] == 1) {\n                    \n                    \n                    \n                }\n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"M\": [2], \"M_element0\": [2], \"M_element0_element0\": [\"2069058326\"], \"M_element0_element1\": [\"-959171466\"], \"M_element1\": [2], \"M_element1_element0\": [\"1307069111\"], \"M_element1_element1\": [\"-2016440523\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool splitArray. /*FC*/class Solution {\n/*FM*/bool splitArray(vector<int>& nums) {\n        int n = nums.size(); \n        if (n < 7) {\n            return false; \n        }\n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1260483414\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkRecord. /*FC*/class Solution {\n/*FM*/bool checkRecord(string s) {\n        int countA = 0, countL = 0; \n        for (char c : s) {\n            if (c == 'A') {\n                \n                \n            }\n            else if (c == 'L') {\n                \n            }\n            else { \n                countL = 0; \n            }\n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string optimalDivision. /*FC*/class Solution {\n/*FM*/string optimalDivision(vector<int>& nums) {\n        int n = nums.size(); \n        if (n == 1) {\n            \n        }\n        else if (n == 2) {\n            return to_string(nums[0]) + '/' + to_string(nums[1]); \n        }\n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1601774113\"], \"nums_element1\": [\"1630453212\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string optimalDivision. /*FC*/class Solution {\n/*FM*/string optimalDivision(vector<int>& nums) {\n        int n = nums.size(); \n        if (n == 1) {\n            return to_string(nums[0]); \n        }\n        else if (n == 2) {\n            \n        }\n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1130365408\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nextGreaterElement. /*FC*/class Solution {\n/*FM*/int nextGreaterElement(int n) {\n        string str = to_string(n); \n        if (str.size() == 1) {\n            \n        }\n        int i = str.size() - 2; \n        while (i >= 0 && str[i] >= str[i + 1]) {\n            --i; \n        }\n        if (i == -1) {\n            \n        }\n        \n        int j = str.size() - 1; \n        while (j >= i && str[i] >= str[j]) {\n            --j; \n        }\n        \n        swap(str[i], str[j]); \n        reverse(str.begin() + i + 1, str.end()); \n        long long result = stol(str); \n        if (result > INT_MAX) {\n            \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1734132490\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseWords. /*FC*/class Solution {\n/*FM*/string reverseWords(string& s) {\n        int start = 0; \n        for (int i = 0;  i < s.size();  ++i) {\n            if (s[i] == ' ') {\n                \n                \n            }\n        }\n        \n        reverse(s.begin() + start, s.end()); \n        return s; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(Node* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        \n        for ( : root->children) {\n            \n        }\n        \n    };/*F*//*C*//*M*/int maxDepth(Node* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int len = 0; \n        for (Node* child : root->children) {\n            len = max(len, maxDepth(child)); \n        }\n        return 1 + len; \n    } int maxDepth(Node* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int len = 0; \n        for (Node* child : root->children) {\n            len = max(len, maxDepth(child)); \n        }\n        return 1 + len; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int subarraySum. /*FC*/class Solution {\n/*FM*/int subarraySum(vector<int>& nums, int k) {\n        int n = nums.size(); \n        unordered_map<int, int> table; \n        int sum = 0; \n        table[0] = 1; \n        int count = 0; \n        for (int num : nums) {\n            sum += num; \n            count += table[sum - k]; \n            ++table[sum]; \n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1561588688\"], \"k\": [\"713322277\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int arrayPairSum. /*FC*/class Solution {\n/*FM*/int arrayPairSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end()); \n        int sum = 0; \n        for (int i = 0;  i < nums.size();  i += 2) {\n            sum += nums[i]; \n        }\n        \n        return sum; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-727073821\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findSum. /*FC*/class Solution {\n/*FM*/int findSum(TreeNode* root, int& sum) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int leftSum = findSum(root->left, sum); \n        int rightSum = findSum(root->right, sum); \n        sum += abs(leftSum - rightSum); \n        return leftSum + root->val + rightSum; \n    };/*F*//*C*//*M*/int findSum(TreeNode* root, int& sum) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int leftSum = findSum(root->left, sum); \n        int rightSum = findSum(root->right, sum); \n        sum += abs(leftSum - rightSum); \n        return leftSum + root->val + rightSum; \n    } int findSum(TreeNode* root, int& sum) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int leftSum = findSum(root->left, sum); \n        int rightSum = findSum(root->right, sum); \n        sum += abs(leftSum - rightSum); \n        return leftSum + root->val + rightSum; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"929554185\"], \"root[0].val\": [\"1258608122\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-885302527\"], \"root[0].right[0].val\": [\"1274610807\"], \"sum\": [\"885925132\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> matrixReshape. /*FC*/class Solution {\n/*FM*/vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\n        int m = nums.size(); \n        int n = nums[0].size(); \n        if (m * n != r * c) {\n            return nums; \n        }\n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [2], \"nums_element0_element0\": [\"1247169353\"], \"nums_element0_element1\": [\"474522427\"], \"nums_element1\": [1], \"nums_element1_element0\": [\"1569824441\"], \"r\": [\"1183464580\"], \"c\": [\"1068397487\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkInclusion. /*FC*/class Solution2 {\n/*FM*/bool checkInclusion(string s1, string s2) {\n        if (s2.size() < s1.size()) {\n            \n        }\n        vector<int> table(26); \n        int count = s1.size(); \n        for (char c : s1) {\n            ++table[c - 'a']; \n        }\n        \n        int start = 0; \n        for (int i = 0;  i < s2.size();  ++i) {\n            if (--table[s2[i] - 'a'] >= 0) {\n                \n                \n            }\n            \n            if (i - start + 1 == s1.size()) {\n                if (++table[s2[start++] - 'a'] > 0) {\n                    \n                }\n            }\n        }   \n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s1\": [\"1\"], \"s2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkInclusion. /*FC*/class Solution2 {\n/*FM*/bool checkInclusion(string s1, string s2) {\n        if (s2.size() < s1.size()) {\n            \n        }\n        vector<int> table(26); \n        int count = s1.size(); \n        for (char c : s1) {\n            ++table[c - 'a']; \n        }\n        \n        int start = 0; \n        for (int i = 0;  i < s2.size();  ) {\n            if (--table[s2[i] - 'a'] >= 0) {\n                --count; \n                if (count == 0) {\n                    return true; \n                }\n            }\n            \n            \n        }   \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s1\": [\"2\"], \"s2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkInclusion. /*FC*/class Solution {\n/*FM*/bool checkInclusion(string s1, string s2) {\n        if (s2.size() < s1.size()) {\n            \n        }\n        vector<int> table(26); \n        int count = 0; \n        for (char c : s1) {\n            if (++table[c - 'a'] == 1) {\n                \n            }\n        }\n        \n        int start = 0; \n        for (int i = 0;  i < s2.size();  ++i) {\n            if (--table[s2[i] - 'a'] == 0) {\n                \n                \n                \n                \n            }\n        }   \n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s1\": [\"1\"], \"s2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkInclusion. /*FC*/class Solution {\n/*FM*/bool checkInclusion(string s1, string s2) {\n        if (s2.size() < s1.size()) {\n            \n        }\n        vector<int> table(26); \n        int count = 0; \n        for (char c : s1) {\n            if (++table[c - 'a'] == 1) {\n                ++count; \n            }\n        }\n        \n        int start = 0; \n        for (int i = 0;  i < s2.size();  ++i) {\n            if (--table[s2[i] - 'a'] == 0) {\n                \n                \n                \n                \n            }\n        }   \n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s1\": [\"1\"], \"s2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSubtree. /*FC*/class Solution {\n/*FM*/bool isSubtree(TreeNode* s, TreeNode* t) {\n        if (s == nullptr || t == nullptr) {\n            return s == t; \n        }\n        \n        return isSameTree(s, t) || isSubtree(s->left, t) || isSubtree(s->right, t); \n    };/*F*//*C*//*M*/bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr || q == nullptr) {\n            return p == q; \n        }\n        \n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right); \n    } bool isSubtree(TreeNode* s, TreeNode* t) {\n        if (s == nullptr || t == nullptr) {\n            return s == t; \n        }\n        \n        return isSameTree(s, t) || isSubtree(s->left, t) || isSubtree(s->right, t); \n    } bool isSubtree(TreeNode* s, TreeNode* t) {\n        if (s == nullptr || t == nullptr) {\n            return s == t; \n        }\n        \n        return isSameTree(s, t) || isSubtree(s->left, t) || isSubtree(s->right, t); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [1], \"s[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"s0_x\": [\"-1677120770\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSameTree. /*FC*/class Solution {\n/*FM*/bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr || q == nullptr) {\n            return p == q; \n        }\n        \n        \n    };/*F*//*C*//*M*/bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr || q == nullptr) {\n            return p == q; \n        }\n        \n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right); \n    } bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr || q == nullptr) {\n            return p == q; \n        }\n        \n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/class Solution {\n/*FM*/int minDistance(int height, int width, vector<int>& tree, vector<int>& squirrel, vector<vector<int>>& nuts) {\n        int sum = 0; \n        int maxDiff = INT_MIN; \n        for (auto nut : nuts) {\n            int nutTreeDist = abs(tree[0] - nut[0]) + abs(tree[1] - nut[1]); \n            sum += nutTreeDist * 2; \n            int nutSquirrelDist = abs(squirrel[0] - nut[0]) + abs(squirrel[1] - nut[1]); \n            maxDiff = max(maxDiff, nutTreeDist - nutSquirrelDist); \n        }\n        \n        return sum - maxDiff; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [\"-1481863188\"], \"width\": [\"-547401371\"], \"tree\": [1], \"tree_element0\": [\"1001449041\"], \"squirrel\": [2], \"squirrel_element0\": [\"850856245\"], \"squirrel_element1\": [\"717756567\"], \"nuts\": [2], \"nuts_element0\": [1], \"nuts_element0_element0\": [\"1895834111\"], \"nuts_element1\": [2], \"nuts_element1_element0\": [\"-1516574266\"], \"nuts_element1_element1\": [\"1169015688\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int distributeCandies. /*FC*/class Solution {\n/*FM*/int distributeCandies(vector<int>& candies) {\n        unordered_set<int> table; \n        for (int i : candies) {\n            table.insert(i); \n        }\n        \n        return min(table.size(), candies.size() / 2); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"candies\": [2], \"candies_element0\": [\"758675864\"], \"candies_element1\": [\"1707074433\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int>& nums) {\n        int n = nums.size(); \n        stack<int> St1; \n        int first = n, last = -1; \n        for (int i = 0;  i < n;  ++i) {\n            while (!St1.empty() && nums[St1.top()] > nums[i]) {\n                \n                \n            }\n            St1.push(i); \n        }\n        \n        if (first == n) {\n            return 0; \n        }\n        \n        \n        \n\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1190152093\"], \"nums_element1\": [\"-390774731\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int>& nums) {\n        int n = nums.size(); \n        stack<int> St1; \n        int first = n, last = -1; \n        for (int i = 0;  i < n;  ++i) {\n            while (!St1.empty() && nums[St1.top()] > nums[i]) {\n                first = min(first, St1.top()); \n                St1.pop(); \n            }\n            St1.push(i); \n        }\n        \n        if (first == n) {\n            \n        }\n        \n        stack<int> St2; \n        for (int i = n - 1;  i >= 0;  --i) {\n            while (!St2.empty() && nums[St2.top()] < nums[i]) {\n                last = max(last, St2.top()); \n                St2.pop(); \n            }\n            St2.push(i); \n        }\n\n        return last - first + 1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1662049591\"], \"nums_element1\": [\"929286809\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/class Solution {\n/*FM*/int minDistance(string word1, string word2) {\n        int m = word1.size(); \n        int n = word2.size(); \n        vector<vector<int>> dp(1 + m, vector<int>(1 + n)); \n        \n        for (int i = 0;  i <= m;  ++i) {\n            for (int j = 0;  j <= n;  ++j) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = i + j; \n                }\n                else if (word1[i - 1] == word2[j - 1]) {\n                    \n                }\n                else {\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j]); \n                }\n            }\n        }\n        \n        return dp[m][n]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word1\": [\"1\"], \"word2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string code) {\n        stack<string> St; \n        int i = 0; \n        while (i < code.size()) {\n            if (i > 0 && St.empty()) {\n                \n            }\n            \n            if (code.substr(i, 9) == \"<![CDATA[\") {\n                \n                \n                \n                \n            }\n            else if (code.substr(i, 2) == \"</\") {\n                \n                \n                \n                \n                \n                \n                \n            }\n            else if (code.substr(i, 1) == \"<\") {\n                \n                \n                \n                \n                \n                \n                \n            }\n            else {\n                ++i; \n            }\n        }\n        \n        return St.empty(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"code\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int GCD. /*FC*/class Solution {\n/*FM*/int GCD(int a, int b) {\n        a = abs(a); \n        b = abs(b); \n        while (b) {\n            int temp = a; \n            a = b; \n            b = temp % b; \n        }\n        \n        return a; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"208689009\"], \"b\": [\"-2067979392\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLHS. /*FC*/class Solution {\n/*FM*/int findLHS(vector<int>& nums) {\n        int maxCount = 0; \n        unordered_map<int, int> table; \n        for (int num : nums) {\n            int count = ++table[num]; \n            if (table.find(num - 1) != table.end()) {\n                \n            }\n            if (table.find(num + 1) != table.end()) {\n                \n            }\n        }\n        \n        return maxCount;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1265429772\"], \"nums_element1\": [\"874060317\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxCount. /*FC*/class Solution {\n/*FM*/int maxCount(int m, int n, vector<vector<int>>& ops) {\n        for (auto& op : ops) {\n            m = min(m, op[0]); \n            n = min(n, op[1]); \n        }\n        \n        return m * n; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"1782817096\"], \"n\": [\"-1416042055\"], \"ops\": [2], \"ops_element0\": [1], \"ops_element0_element0\": [\"-1080809711\"], \"ops_element1\": [1], \"ops_element1_element0\": [\"-349996283\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDecodings. /*FC*/class Solution {\n/*FM*/int numDecodings(string s) {\n        int n = s.size(); \n        int MOD = 1000000007; \n        vector<long> dp(1 + n); \n        dp[0] = 1; \n        for (int i = 1;  i <= n;  ++i) {\n            if (s[i - 1] == '*') {\n                \n            }\n            else if (s[i - 1] != '0') {\n                dp[i] = dp[i - 1]; \n            }\n            \n            if (i >= 2) {\n                                    \n            }\n        }\n        \n        return dp[n]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string solveEquation. /*FC*/class Solution {\n/*FM*/string solveEquation(string equation) {\n        int n = equation.size(); \n        int i = 0; \n        int leftx = 0, rightx = 0; \n        int leftsum = 0, rightsum = 0; \n        int num = 0; \n        bool prenum = false; \n        int sign = 1; \n        while (equation[i] != '=') {\n            if (isdigit(equation[i])) {\n                num = num * 10 + (equation[i] - '0'); \n                prenum = true; \n            }\n            else if (equation[i] == 'x') {\n                \n                \n            }\n            else {\n                leftsum += sign * num; \n                sign = (equation[i] == '+') ? 1 : -1; \n                num = 0; \n                prenum = false; \n            }\n            \n            ++i; \n        }\n        \n        leftsum += sign * num; \n        ++i; \n        num = 0; \n        sign = 1; \n        prenum = false; \n        \n        while (i < n) {\n            \n            \n            \n        }\n        rightsum += sign * num; \n        \n        int xnum = leftx - rightx; \n        int val = rightsum - leftsum; \n        \n        if (xnum == 0) {\n            if (val == 0) {\n                \n            }\n            else {\n                return \"No solution\"; \n            }\n        }\n        else {\n            \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"equation\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string solveEquation. /*FC*/class Solution {\n/*FM*/string solveEquation(string equation) {\n        int n = equation.size(); \n        int i = 0; \n        int leftx = 0, rightx = 0; \n        int leftsum = 0, rightsum = 0; \n        int num = 0; \n        bool prenum = false; \n        int sign = 1; \n        while (equation[i] != '=') {\n            if (isdigit(equation[i])) {\n                num = num * 10 + (equation[i] - '0'); \n                prenum = true; \n            }\n            else if (equation[i] == 'x') {\n                if (prenum) {\n                    \n                }\n                else {\n                    leftx += sign; \n                }\n                num = 0; \n            }\n            else {\n                leftsum += sign * num; \n                sign = (equation[i] == '+') ? 1 : -1; \n                num = 0; \n                prenum = false; \n            }\n            \n            ++i; \n        }\n        \n        leftsum += sign * num; \n        ++i; \n        num = 0; \n        sign = 1; \n        prenum = false; \n        \n        while (i < n) {\n            \n            \n            \n        }\n        rightsum += sign * num; \n        \n        int xnum = leftx - rightx; \n        int val = rightsum - leftsum; \n        \n        if (xnum == 0) {\n            \n        }\n        else {\n            return \"x=\" + to_string(val / xnum); \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"equation\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMaxAverage. /*FC*/class Solution {\n/*FM*/double findMaxAverage(vector<int>& nums, int k) {\n        int n = nums.size(); \n        int i = 0; \n        int sum = 0; \n        while (i < k) {\n            sum += nums[i++]; \n        }\n        \n        int maxSum = sum; \n        while (i < n) {\n            \n            \n            \n        }\n        \n        return (double)maxSum / k; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1851013074\"], \"nums_element1\": [\"-1255678656\"], \"k\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMaxAverage. /*FC*/class Solution {\n/*FM*/double findMaxAverage(vector<int>& nums, int k) {\n        int n = nums.size(); \n        int minNum = INT_MAX, maxNum = INT_MIN; \n        for (int num : nums) {\n            minNum = min(minNum, num); \n            maxNum = max(maxNum, num); \n        }\n        double low = minNum, high = maxNum; \n        while (high - low > 10e-6) {\n            double mid = (low + high) / 2; \n            if (available(nums, k, mid)) {\n                low = mid; \n            }\n            else {\n                \n            }\n        }\n        \n        return low; \n    };/*F*//*C*//*M*/bool available(vector<int>& nums, int k, double target) {\n        int n = nums.size(); \n        double sum = 0; \n        for (int i = 0;  i < k;  ++i) {\n            sum += nums[i] - target; \n        }\n        if (sum >= 0) {\n            return true; \n        }\n        double premin = 0; \n        double presum = 0; \n        for (int i = k;  i < n;  ++i) {\n            sum += nums[i] - target; \n            presum += nums[i - k] - target; \n            premin = min(premin, presum); \n            if (sum - premin >= 0) {\n                return true; \n            }\n        }\n        \n        return false; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1728431751\"], \"nums_element1\": [\"-1973438397\"], \"k\": [\"-1054810181\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool available. /*FC*/class Solution {\n/*FM*/bool available(vector<int>& nums, int k, double target) {\n        int n = nums.size(); \n        double sum = 0; \n        for (int i = 0;  i < k;  ++i) {\n            sum += nums[i] - target; \n        }\n        if (sum >= 0) {\n            \n        }\n        double premin = 0; \n        double presum = 0; \n        for (int i = k;  i < n;  ) {\n            \n            \n            \n            \n        }\n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-2039425488\"], \"nums_element1\": [\"-2001965477\"], \"k\": [\"3\"], \"target\": [\"0.98\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool available. /*FC*/class Solution {\n/*FM*/bool available(vector<int>& nums, int k, double target) {\n        int n = nums.size(); \n        double sum = 0; \n        for (int i = 0;  i < k;  ++i) {\n            sum += nums[i] - target; \n        }\n        if (sum >= 0) {\n            return true; \n        }\n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1299997279\"], \"nums_element1\": [\"-571417406\"], \"k\": [\"3\"], \"target\": [\"0.18\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLongestChain. /*FC*/class Solution {\n/*FM*/int findLongestChain(vector<vector<int>>& pairs) {\n        sort(pairs.begin(), pairs.end()); \n        int maxLen = 1; \n        int n = pairs.size(); \n        vector<int> dp(n, 1); \n        for (int i = 0;  i < n;  ++i) {\n            for (int j = 0;  j < i;  ++j) {\n                if (pairs[j][1] < pairs[i][0]) {\n                    \n                }\n            }\n            maxLen = max(maxLen, dp[i]); \n        }\n        \n        return maxLen; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pairs\": [2], \"pairs_element0\": [1], \"pairs_element0_element0\": [\"29110436\"], \"pairs_element1\": [1], \"pairs_element1_element0\": [\"267533113\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSubstrings. /*FC*/class Solution {\n/*FM*/int countSubstrings(string s) {\n        int n = s.size(); \n        if (n == 0) {\n            \n        }\n        \n        vector<vector<bool>> dp(n, vector<bool>(n)); \n        int count = 0; \n        for (int j = 0;  j < n;  ++j) {\n            for (int i = j;  i >= 0;  --i) {\n                if (s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1])) {\n                    dp[i][j] = true; \n                    ++count; \n                }\n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string findRoot. /*FC*/class Solution {\n/*FM*/string findRoot(TrieNode* root, string word) {\n        TrieNode* node = root; \n        for (char c : word) {\n            if (node->next[c - 'a'] == nullptr) {\n                return word; \n            }\n            \n            \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TrieNode\", \"TrieNode()\"], \"root[0].next\": [26], \"root[1]\": [\"TrieNode\", \"TrieNode()\"], \"root[1].next\": [26], \"word\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPossible. /*FC*/class Solution {\n/*FM*/bool isPossible(vector<int>& nums) {\n        unordered_map<int, int> freq, append; \n        for (int& num : nums) {\n            ++freq[num]; \n        }\n        \n        for (int& num : nums) {\n            if (freq[num] == 0) {\n                \n            }\n            else if (append[num] > 0) {\n                \n                \n            }\n            else if (freq[num + 1] > 0 && freq[num + 2] > 0) {\n                \n                \n                \n            }\n            else {\n                return false; \n            }\n            \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-2116106970\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int newInteger. /*FC*/class Solution {\n/*FM*/int newInteger(int n) {\n        int result = 0; \n        int base = 1; \n        while (n) {\n            result += (n % 9) * base; \n            n /= 9; \n            base *= 10; \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2024393860\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> imageSmoother. /*FC*/class Solution {\n/*FM*/vector<vector<int>> imageSmoother(vector<vector<int>>& M) {\n        int m = M.size(); \n        int n = M[0].size(); \n        vector<int> dx = {-1, -1, -1, 0, 0, 0, 1, 1, 1}; \n        vector<int> dy = {1, 0, -1, 1, 0, -1, 1, 0, -1}; \n        vector<vector<int>> result(m, vector<int>(n)); \n        for (int i = 0;  i < m;  ++i) {\n            for (int j = 0;  j < n;  ++j) {\n                int sum = 0; \n                int count = 0; \n                for (int k = 0;  k < dx.size();  ++k) {\n                    int ni = i + dx[k]; \n                    int nj = j + dy[k]; \n                    if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\n                        ++count; \n                        sum += M[ni][nj]; \n                    }\n                }\n                int val = sum / count; \n                result[i][j] = val; \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"M\": [1], \"M_element0\": [1], \"M_element0_element0\": [\"1415562732\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkEqualTree. /*FC*/class Solution {\n/*FM*/bool checkEqualTree(TreeNode* root) {\n        int sum = getSum(root); \n        if (sum == 0) {\n            \n        }\n        return sum % 2 == 0 && table[sum / 2] > 0; \n    };/*F*/unordered_map<int, int> table;/*C*//*M*/int getSum(TreeNode* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int sum = root->val + getSum(root->left) + getSum(root->right); \n        ++table[sum]; \n        return sum; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1802788315\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getSum. /*FC*/class Solution {\n/*FM*/int getSum(TreeNode* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int sum = root->val + getSum(root->left) + getSum(root->right); \n        ++table[sum]; \n        return sum; \n    };/*F*/unordered_map<int, int> table;/*C*//*M*/int getSum(TreeNode* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int sum = root->val + getSum(root->left) + getSum(root->right); \n        ++table[sum]; \n        return sum; \n    } int getSum(TreeNode* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int sum = root->val + getSum(root->left) + getSum(root->right); \n        ++table[sum]; \n        return sum; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"449806940\"], \"root[0].val\": [\"701868522\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"379305700\"], \"root[0].left[0].val\": [\"323149854\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"-2136575165\"], \"root[0].left[1].val\": [\"353761051\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-1365156564\"], \"root[0].right[0].val\": [\"681650486\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"770203929\"], \"root[0].right[1].val\": [\"-1866696104\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dfs. /*FC*/class Solution {\n/*FM*/int dfs(string& s, int l, int r, vector<vector<int>>& table) {\n        if (l > r) {\n            \n        }\n        if (table[l][r]) {\n            return table[l][r]; \n        }\n        \n        \n        \n        \n    };/*F*//*C*//*M*/int dfs(string& s, int l, int r, vector<vector<int>>& table) {\n        if (l > r) {\n            return 0; \n        }\n        if (table[l][r]) {\n            return table[l][r]; \n        }\n        \n        int count = dfs(s, l + 1, r, table) + 1; \n        for (int i = l + 1;  i <= r;  ++i) {\n            if (s[i] == s[l]) {\n                count = min(count, dfs(s, l + 1, i - 1, table) + dfs(s, i, r, table)); \n            }\n        }\n        return table[l][r] = count; \n    } int dfs(string& s, int l, int r, vector<vector<int>>& table) {\n        if (l > r) {\n            return 0; \n        }\n        if (table[l][r]) {\n            return table[l][r]; \n        }\n        \n        int count = dfs(s, l + 1, r, table) + 1; \n        for (int i = l + 1;  i <= r;  ++i) {\n            if (s[i] == s[l]) {\n                count = min(count, dfs(s, l + 1, i - 1, table) + dfs(s, i, r, table)); \n            }\n        }\n        return table[l][r] = count; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"l\": [\"0\"], \"r\": [\"8\"], \"table\": [1], \"table_element0\": [2], \"table_element0_element0\": [\"1919963122\"], \"table_element0_element1\": [\"-1228473040\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dfs. /*FC*/class Solution {\n/*FM*/int dfs(string& s, int l, int r, vector<vector<int>>& table) {\n        if (l > r) {\n            return 0; \n        }\n        if (table[l][r]) {\n            \n        }\n        \n        \n        \n        \n    };/*F*//*C*//*M*/int dfs(string& s, int l, int r, vector<vector<int>>& table) {\n        if (l > r) {\n            return 0; \n        }\n        if (table[l][r]) {\n            return table[l][r]; \n        }\n        \n        int count = dfs(s, l + 1, r, table) + 1; \n        for (int i = l + 1;  i <= r;  ++i) {\n            if (s[i] == s[l]) {\n                count = min(count, dfs(s, l + 1, i - 1, table) + dfs(s, i, r, table)); \n            }\n        }\n        return table[l][r] = count; \n    } int dfs(string& s, int l, int r, vector<vector<int>>& table) {\n        if (l > r) {\n            return 0; \n        }\n        if (table[l][r]) {\n            return table[l][r]; \n        }\n        \n        int count = dfs(s, l + 1, r, table) + 1; \n        for (int i = l + 1;  i <= r;  ++i) {\n            if (s[i] == s[l]) {\n                count = min(count, dfs(s, l + 1, i - 1, table) + dfs(s, i, r, table)); \n            }\n        }\n        return table[l][r] = count; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"l\": [\"10\"], \"r\": [\"5\"], \"table\": [2], \"table_element0\": [1], \"table_element0_element0\": [\"-1871307993\"], \"table_element1\": [1], \"table_element1_element0\": [\"-345939400\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkPossibility. /*FC*/class Solution {\n/*FM*/bool checkPossibility(vector<int>& nums) {\n        int n = nums.size(); \n        int count = 0; \n        for (int i = 1;  i < n;  ++i) {\n            if (nums[i] < nums[i - 1]) {\n                ++count; \n                if (count > 1) {\n                    \n                }\n                if (i > 1 && nums[i - 2] > nums[i] && i < n - 1 && nums[i + 1] < nums[i - 1] ) {\n                    \n                }\n            }\n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1662417363\"], \"nums_element1\": [\"1076863547\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pathSum. /*FC*/class Solution {\n/*FM*/int pathSum(vector<int>& nums) {\n        if (nums.size() == 0) {\n            \n        }\n        for (int num : nums) {\n            table[num / 10] = num % 10;  \n        }\n        \n        int sum = 0; \n        traverse(nums[0] / 10, 0, sum); \n        return sum; \n    };/*F*/unordered_map<int, int> table;/*C*//*M*/void traverse(int root, int preSum, int& sum) {\n        int level = root / 10; \n        int index = root % 10; \n        int curSum = preSum + table[root]; \n        \n        int left = (level + 1) * 10 + 2 * index - 1; \n        int right = (level + 1) * 10 + 2 * index; \n        if (table.find(left) == table.end() && table.find(right) == table.end()) {\n            sum += curSum; \n        }\n        \n        if (table.find(left) != table.end()) {\n            traverse(left, curSum, sum); \n        }\n        if (table.find(right) != table.end()) {\n            traverse(right, curSum, sum); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"732525560\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> constructArray. /*FC*/class Solution {\n/*FM*/vector<int> constructArray(int n, int k) {\n        vector<int> result(n); \n        int start = 1, end = n; \n        int i = 0; \n        while (start <= end) {\n            if (k > 1) {\n                \n            }\n            else {\n                result[i] = end--; \n            }\n            ++i; \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"4\"], \"k\": [\"-91577538\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> constructArray. /*FC*/class Solution {\n/*FM*/vector<int> constructArray(int n, int k) {\n        vector<int> result(n); \n        int start = 1, end = n; \n        int i = 0; \n        while (start <= end) {\n            if (k > 1) {\n                result[i] = (k-- % 2 == 0) ? start++ : end--; \n            }\n            else {\n                \n            }\n            ++i; \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"], \"k\": [\"1737831842\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findKthNumber. /*FC*/class Solution {\n/*FM*/int findKthNumber(int m, int n, int k) {\n        if (m > n) {\n            swap(m, n); \n        }\n        int start = 1, end = m * n; \n        while (start < end) {\n            int mid = start + (end - start) / 2; \n            int count = 0; \n            for (int i = 1;  i <= m;  ++i) {\n                count += min(mid / i, n); \n            }\n            \n            if (count < k) {\n                \n            }\n            else {\n                end = mid; \n            }\n        }\n        \n        return start; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"6\"], \"n\": [\"2\"], \"k\": [\"-1000941693\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findKthNumber. /*FC*/class Solution {\n/*FM*/int findKthNumber(int m, int n, int k) {\n        if (m > n) {\n            \n        }\n        int start = 1, end = m * n; \n        while (start < end) {\n            int mid = start + (end - start) / 2; \n            int count = 0; \n            for (int i = 1;  i <= m;  ++i) {\n                count += min(mid / i, n); \n            }\n            \n            if (count < k) {\n                start = mid + 1; \n            }\n            else {\n                \n            }\n        }\n        \n        return start; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"10\"], \"n\": [\"10\"], \"k\": [\"2097754794\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* trimBST. /*FC*/class Solution {\n/*FM*/TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if (root == nullptr) {\n            return nullptr; \n        }        \n        \n        if (root->val < L) {\n            return trimBST(root->right, L, R); \n        }\n        else if (root->val > R)\n        {\n            \n        }\n        else {\n            \n            \n            \n        }\n    };/*F*//*C*//*M*/TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if (root == nullptr) {\n            return nullptr; \n        }        \n        \n        if (root->val < L) {\n            return trimBST(root->right, L, R); \n        }\n        else if (root->val > R)\n        {\n            return trimBST(root->left, L, R); \n        }\n        else {\n            root->left = trimBST(root->left, L, R); \n            root->right = trimBST(root->right, L, R); \n            return root; \n        }\n    } TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if (root == nullptr) {\n            return nullptr; \n        }        \n        \n        if (root->val < L) {\n            return trimBST(root->right, L, R); \n        }\n        else if (root->val > R)\n        {\n            return trimBST(root->left, L, R); \n        }\n        else {\n            root->left = trimBST(root->left, L, R); \n            root->right = trimBST(root->right, L, R); \n            return root; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"562887800\"], \"root[0].val\": [\"-1972817517\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-576133366\"], \"root[0].left[0].val\": [\"2048203224\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"-1715176676\"], \"root[0].left[1].val\": [\"894749378\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"1579596440\"], \"root[0].left[2].val\": [\"1316901902\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-69445297\"], \"root[0].right[0].val\": [\"-1130121355\"], \"L\": [\"-182354354\"], \"R\": [\"-246786350\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* trimBST. /*FC*/class Solution {\n/*FM*/TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if (root == nullptr) {\n            return nullptr; \n        }        \n        \n        if (root->val < L) {\n            \n        }\n        else if (root->val > R)\n        {\n            \n        }\n        else {\n            root->left = trimBST(root->left, L, R); \n            root->right = trimBST(root->right, L, R); \n            return root; \n        }\n    };/*F*//*C*//*M*/TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if (root == nullptr) {\n            return nullptr; \n        }        \n        \n        if (root->val < L) {\n            return trimBST(root->right, L, R); \n        }\n        else if (root->val > R)\n        {\n            return trimBST(root->left, L, R); \n        }\n        else {\n            root->left = trimBST(root->left, L, R); \n            root->right = trimBST(root->right, L, R); \n            return root; \n        }\n    } TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if (root == nullptr) {\n            return nullptr; \n        }        \n        \n        if (root->val < L) {\n            return trimBST(root->right, L, R); \n        }\n        else if (root->val > R)\n        {\n            return trimBST(root->left, L, R); \n        }\n        else {\n            root->left = trimBST(root->left, L, R); \n            root->right = trimBST(root->right, L, R); \n            return root; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-424277987\"], \"root[0].val\": [\"-576627620\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-1074973369\"], \"root[0].left[0].val\": [\"400039749\"], \"L\": [\"-909310795\"], \"R\": [\"879080665\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumSwap. /*FC*/class Solution {\n/*FM*/int maximumSwap(int num) {\n        string str = to_string(num); \n        int n = str.size(); \n        vector<int> last(10); \n        for (int i = 0;  i < n;  ++i) {\n            last[str[i] - '0'] = i; \n        }\n        \n        for (int i = 0;  i < n;  ) {\n            for (int d = 9;  d > str[i] - '0';  --d) {\n                if (last[d] > i) {\n                    swap(str[i], str[last[d]]); \n                    return stoi(str); \n                }\n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"-1512648065\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int helper. /*FC*/class Solution {\n/*FM*/int helper(TreeNode* root, int smallest) {\n        if (root == nullptr) {\n            return -1; \n        }\n        \n        int left = helper(root->left, smallest); \n        int right = helper(root->right, smallest); \n        if (left == -1) {\n            if (right == -1) {\n                return root->val > smallest ? root->val : -1; \n            }\n            else {\n                return right; \n            }\n        }\n        else if (right == -1) {\n            \n        }\n        else {\n            \n        }\n    };/*F*//*C*//*M*/int helper(TreeNode* root, int smallest) {\n        if (root == nullptr) {\n            return -1; \n        }\n        \n        int left = helper(root->left, smallest); \n        int right = helper(root->right, smallest); \n        if (left == -1) {\n            if (right == -1) {\n                return root->val > smallest ? root->val : -1; \n            }\n            else {\n                return right; \n            }\n        }\n        else if (right == -1) {\n            return left; \n        }\n        else {\n            return min(left, right); \n        }\n    } int helper(TreeNode* root, int smallest) {\n        if (root == nullptr) {\n            return -1; \n        }\n        \n        int left = helper(root->left, smallest); \n        int right = helper(root->right, smallest); \n        if (left == -1) {\n            if (right == -1) {\n                return root->val > smallest ? root->val : -1; \n            }\n            else {\n                return right; \n            }\n        }\n        else if (right == -1) {\n            return left; \n        }\n        else {\n            return min(left, right); \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1693083667\"], \"root[0].val\": [\"1797469772\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"820919138\"], \"root[0].left[0].val\": [\"-2115433829\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"-1199460255\"], \"root[0].left[1].val\": [\"-1115806293\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"645407013\"], \"root[0].left[2].val\": [\"789085846\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"776090114\"], \"root[0].right[0].val\": [\"1546058390\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1165900974\"], \"root[1].val\": [\"423793298\"], \"root[1].right\": [1], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_right0_x\": [\"-640049114\"], \"root[1].right[0].val\": [\"843676613\"], \"smallest\": [\"-1155302493\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int flipLights. /*FC*/class Solution {\n/*FM*/int flipLights(int n, int m) {\n        if (n == 0 || m == 0) {\n            \n        }\n        if (n == 1) {\n            \n        }\n        if (n == 2) {\n            \n        }\n        if (m == 1) {\n            \n        }\n        if (m == 2) {\n            \n        }\n        return 8; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1185634625\"], \"m\": [\"1440923745\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findNumberOfLIS. /*FC*/class Solution {\n/*FM*/int findNumberOfLIS(vector<int>& nums) {\n        int n = nums.size(); \n        if (n <= 1) {\n            \n        }\n        \n        vector<int> dp(n, 1); \n        vector<int> count(n, 1); \n        int maxLen = 1; \n        int totalCount = 1;  \n        for (int j = 1;  j < n;  ++j) {\n            for (int i = 0;  i < j;  ++i) {\n                if (nums[j] > nums[i]) {\n                    if (1 + dp[i] > dp[j]) {\n                        dp[j] = 1 + dp[i]; \n                        count[j] = count[i]; \n                    }\n                    else if (1 + dp[i] == dp[j]) {\n                        \n                    }                    \n                }\n            }\n            \n            if (dp[j] > maxLen) {\n                maxLen = dp[j]; \n                totalCount = count[j];                 \n            }\n            else if (dp[j] == maxLen) {\n                totalCount += count[j]; \n            }\n        }\n\n        return totalCount; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1985559513\"], \"nums_element1\": [\"2136874529\"], \"nums_element2\": [\"1742056533\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findNumberOfLIS. /*FC*/class Solution {\n/*FM*/int findNumberOfLIS(vector<int>& nums) {\n        int n = nums.size(); \n        if (n <= 1) {\n            return n; \n        }\n        \n        \n        \n        \n         \n        \n\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1119921705\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLengthOfLCIS. /*FC*/class Solution {\n/*FM*/int findLengthOfLCIS(vector<int>& nums) {\n        if (nums.size() <= 1) {\n            \n        }\n        int maxLen = 1; \n        int curr = 1; \n        for (int i = 1;  i < nums.size();  ++i) {\n            if (nums[i] > nums[i - 1]) {\n                ++curr; \n                maxLen = max(maxLen, curr); \n            }\n            else {\n                curr = 1; \n            }            \n        }\n        \n        return maxLen; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1516313824\"], \"nums_element1\": [\"-962337904\"], \"nums_element2\": [\"1028575098\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLengthOfLCIS. /*FC*/class Solution {\n/*FM*/int findLengthOfLCIS(vector<int>& nums) {\n        if (nums.size() <= 1) {\n            return nums.size(); \n        }\n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-554373562\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void buildDict. /*FC*/class MagicDictionary {\n/*FM*/void buildDict(vector<string> dict) {\n        for (string s : dict) {\n            words.insert(s); \n            for (int i = 0;  i < s.size();  ++i) {\n                string sub = s.substr(0, i) + '*' + s.substr(i + 1); \n                ++table[sub]; \n            }\n        }\n        \n    };/*F*/unordered_set<string> words;  unordered_map<string, int> table;/*C*/MagicDictionary() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MagicDictionary\": [\"MagicDictionary\", \"MagicDictionary()\"], \"dict\": [2], \"dict_element0\": [\"2\"], \"dict_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool search. /*FC*/class MagicDictionary {\n/*FM*/bool search(string word) {\n        bool found = (words.find(word) != words.end()); \n        for (int i = 0;  i < word.size();  ++i) {\n            string sub = word.substr(0, i) + '*' + word.substr(i + 1);             \n            if ((found && table[sub] > 1) || (!found && table[sub] >= 1)) {\n                \n            }\n        }\n        \n        return false; \n    };/*F*/unordered_set<string> words;  unordered_map<string, int> table;/*C*/MagicDictionary() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MagicDictionary\": [\"MagicDictionary\", \"MagicDictionary()\"], \"word\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/class MapSum {\n/*FM*/void insert(string key, int val) {\n        int orig = 0; \n        if (table.find(key) != table.end()) {\n            \n        }\n        table[key] = val; \n        int diff = val - orig; \n        if (diff == 0) {\n            \n        }\n        \n        TrieNode* node = root; \n        for (char c : key) {\n            if (node->next.find(c) == node->next.end()) {\n                node->next[c] = new TrieNode(); \n            }\n            node = node->next[c]; \n            node->sum += diff; \n        }\n    };/*F*/unordered_map<string, int> table;  TrieNode * root;/*C*/MapSum() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MapSum\": [\"MapSum\", \"MapSum()\"], \"key\": [\"2\"], \"val\": [\"372543583\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sum. /*FC*/class MapSum {\n/*FM*/int sum(string prefix) {\n        TrieNode* node = root; \n        for (char c : prefix) {\n            if (node->next.find(c) == node->next.end()) {\n                return 0; \n            }\n            \n        }\n        \n    };/*F*/TrieNode * root;/*C*/MapSum() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MapSum\": [\"MapSum\", \"MapSum()\"], \"prefix\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkValidString. /*FC*/class Solution {\n/*FM*/bool checkValidString(string s) {\n        int low = 0, high = 0; \n        for (char c : s) {\n            low += (c == '(') ? 1 : -1; \n            high += (c == ')') ? -1 : 1; \n            if (high < 0) {\n                \n            }\n            low = max(low, 0); \n        }\n        return low == 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool judgePoint24. /*FC*/class Solution {\n/*FM*/bool judgePoint24(vector<int>& nums) {\n        int used = 0; \n        for (int bit = 0;  bit < 4;  ) {\n            if (dfs(nums, 1 << bit, nums[bit], 24)) {\n                return true; \n            }\n        }\n        \n    };/*F*//*C*//*M*/bool dfs(vector<int>& nums, int used, double curr, double target) {\n        if (used == 15) {\n            return abs(curr - target) < 0.001; \n        }\n\n        for (int bit = 0;  bit < 4;  ++bit) {\n            int mask = 1 << bit; \n            if ((used & mask) == 0) {\n                used |= mask; \n                if (dfs(nums, used, curr + nums[bit], target) || dfs(nums, used, curr - nums[bit], target) ||\n                    dfs(nums, used, nums[bit] - curr, target) || dfs(nums, used, curr * nums[bit], target) ||\n                    dfs(nums, used, curr / nums[bit], target)) {\n                    return true; \n                }\n                                \n                if (dfs(nums, used, nums[bit], target - curr) || dfs(nums, used, nums[bit], curr - target) ||\n                    dfs(nums, used, nums[bit], target + curr)) {\n                    return true; \n                }\n                \n                if (curr != 0 && (dfs(nums, used, nums[bit], target / curr) ||\n                                  dfs(nums, used, nums[bit], target * curr))) {\n                    return true; \n                }\n                \n                if (target != 0 && curr != 0 && dfs(nums, used, nums[bit], curr / target)) {\n                    return true; \n                }\n\n                used &= ~mask; \n            }\n        }\n        return false; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1641707497\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validPalindrome. /*FC*/class Solution {\n/*FM*/bool validPalindrome(string s) {\n        if (s.size() == 0) {\n            \n        }\n        \n        int start = 0, end = s.size() - 1; \n        while (start < end) {\n            \n            \n            \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string s) {\n        if (s.size() == 0) {\n            \n        }\n        \n        int start = 0, end = s.size() - 1; \n        while (start < end) {\n            \n            \n            \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int repeatedStringMatch. /*FC*/class Solution {\n/*FM*/int repeatedStringMatch(string A, string B) {\n        int n = A.size(); \n        if (n == 0) {\n            \n        }\n        int m = B.size(); \n        vector<int> lps(m); \n        int i = 1; \n        int len = 0; \n        while (i < m) {\n            \n        }\n        \n        i = 0; \n        int j = 0; \n        while (i < n) {\n            if (A[(i + j) % n] == B[j]) {\n                \n                \n            }\n            else if (j != 0) {\n                \n                \n            }\n            else {\n                ++i; \n            }\n        }\n        \n        return -1;    \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"1\"], \"B\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSumOfThreeSubarrays. /*FC*/class Solution {\n/*FM*/vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {\n        int n = nums.size(); \n        vector<int> windows(n - k + 1); \n        int sum = 0; \n        for (int i = 0;  i < n;  ++i) {\n            sum += nums[i]; \n            if (i >= k) {\n                sum -= nums[i - k]; \n            }\n            if (i >= k - 1) {\n                windows[i - k + 1] = sum; \n            }\n        }\n        \n        vector<int> left(n - k + 1); \n        int maxIndex = 0; \n        for (int i = 0;  i < left.size();  ++i) {\n            if (windows[i] > windows[maxIndex]) {\n                \n            }\n            left[i] = maxIndex; \n        }\n        \n        vector<int> right(n - k + 1); \n        maxIndex = n - k; \n        for (int i = n - k;  i >= 0;  --i) {\n            if (windows[i] > windows[maxIndex]) {\n                \n            }\n            right[i] = maxIndex; \n        }\n        \n        vector<int> index(3); \n        int maxSum = INT_MIN; \n        for (int i = k;  i < n - 2 * k + 1;  ++i) {\n            int curr = windows[left[i - k]] + windows[i] + windows[right[i + k]]; \n            if (curr > maxSum) {\n                index[0] = left[i - k]; \n                index[1] = i; \n                index[2] = right[i + k]; \n                maxSum = curr; \n            }\n        }\n        \n        return index; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"633547581\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSumOfThreeSubarrays. /*FC*/class Solution {\n/*FM*/vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {\n        int n = nums.size(); \n        vector<int> windows(n - k + 1); \n        int sum = 0; \n        for (int i = 0;  i < n;  ++i) {\n            sum += nums[i]; \n            if (i >= k) {\n                \n            }\n            if (i >= k - 1) {\n                windows[i - k + 1] = sum; \n            }\n        }\n        \n        vector<int> left(n - k + 1); \n        int maxIndex = 0; \n        for (int i = 0;  i < left.size();  ++i) {\n            if (windows[i] > windows[maxIndex]) {\n                \n            }\n            left[i] = maxIndex; \n        }\n        \n        vector<int> right(n - k + 1); \n        maxIndex = n - k; \n        for (int i = n - k;  i >= 0;  --i) {\n            if (windows[i] > windows[maxIndex]) {\n                \n            }\n            right[i] = maxIndex; \n        }\n        \n        vector<int> index(3); \n        int maxSum = INT_MIN; \n        for (int i = k;  i < n - 2 * k + 1;  ) {\n            \n            \n        }\n        \n        return index; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-145083332\"], \"nums_element1\": [\"1655099506\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getImportance. /*FC*/class Solution {\n/*FM*/int getImportance(vector<Employee*> employees, int id) {\n        unordered_map<int, Employee*> table; \n        for (auto e : employees) {\n            table[e->id] = e; \n        }\n        \n        if (table.find(id) == table.end()) {\n            return 0; \n        }\n        \n        \n        \n        \n        \n                \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"employees\": [1], \"employees_element0\": [2], \"employees_element0[0]\": [\"Employee\", \"Employee()\"], \"employees_element0[0].id\": [\"1222581482\"], \"employees_element0[1]\": [\"Employee\", \"Employee()\"], \"employees_element0[1].id\": [\"1202489600\"], \"id\": [\"2068905348\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> topKFrequent. /*FC*/class Solution {\n/*FM*/vector<string> topKFrequent(vector<string>& words, int k) {\n        unordered_map<string, int> table; \n        for (string& word : words) {\n            ++table[word]; \n        }\n        \n        priority_queue<Node> pq; \n        for (auto t : table) {\n            pq.emplace(t.first, t.second); \n            if (pq.size() > k) {\n                \n            }\n        }\n        \n        vector<string> result(k); \n        for (int i = k - 1;  i >= 0;  --i) {\n            result[i] = pq.top().s; \n            pq.pop(); \n        }\n        \n        return result;         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [2], \"words_element0\": [\"2\"], \"words_element1\": [\"1\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasAlternatingBits. /*FC*/class Solution {\n/*FM*/bool hasAlternatingBits(int n) {\n        int prev = n & 1; \n        n >>= 1; \n        while (n) {\n            int curr = n & 1; \n            if (curr == prev) {\n                return false; \n            }\n            prev = curr; \n            n >>= 1; \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"13330185\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxAreaOfIsland. /*FC*/class Solution {\n/*FM*/int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int m = grid.size(); \n        if (m == 0) {\n            \n        }\n        int n = grid[0].size(); \n        int dr[4] = {-1, 1, 0, 0}; \n        int dc[4] = {0, 0, -1, 1}; \n        int maxCount = 0; \n        for (int i = 0;  i < m;  ++i) {\n            for (int j = 0;  j < n;  ++j) {\n                if (grid[i][j] == 1) {\n                    \n                    \n                    \n                    \n                    \n                    \n                }\n            }\n        }\n        \n        return maxCount; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [1], \"grid_element0\": [1], \"grid_element0_element0\": [\"473963857\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countBinarySubstrings. /*FC*/class Solution {\n/*FM*/int countBinarySubstrings(string s) {\n        int n = s.size(); \n        int i = 0; \n        int prev = 0; \n        int count = 0; \n        while (i < n) {\n            int curr = 0; \n            char target = s[i]; \n            while (i < n && s[i] == target) {\n                ++curr; \n                ++i; \n            }\n            count += min(prev, curr); \n            prev = curr; \n        }\n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countBinarySubstrings2. /*FC*/class Solution {\n/*FM*/int countBinarySubstrings2(string s) {\n        int prev = 0, curr = 1; \n        int count = 0; \n        for (int i = 1;  i < s.size();  ) {\n            \n        }\n        return count + min(prev, curr); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findShortestSubArray. /*FC*/class Solution {\n/*FM*/int findShortestSubArray(vector<int>& nums) {\n        int freq = 0; \n        unordered_map<int, int> start; \n        unordered_map<int, int> count; \n        int len = nums.size(); \n        for (int i = 0;  i < nums.size();  ++i) {\n            if (start.find(nums[i]) == start.end()) {\n                start[nums[i]] = i; \n            }\n            ++count[nums[i]]; \n            if (count[nums[i]] > freq) {\n                freq = count[nums[i]]; \n                len = i - start[nums[i]] + 1; \n            }\n            else if (count[nums[i]] == freq) {\n                len = min(len, i - start[nums[i]] + 1); \n            }            \n        }\n        \n        return len; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-284220022\"], \"nums_element1\": [\"-25854803\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPartitionKSubsets. /*FC*/class Solution {\n/*FM*/bool canPartitionKSubsets(vector<int>& nums, int k) {\n        int n = nums.size(); \n        int sum = 0; \n        int maxNum = INT_MIN; \n        for (int num : nums) {\n            sum += num; \n            maxNum = max(maxNum, num); \n        }\n        if (sum % k) {\n            return false; \n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1882968818\"], \"k\": [\"664601751\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getHeight. /*FC*/class Solution {\n/*FM*/int getHeight(vector<Interval>& intervals, int left, int right) {\n        int h = 0; \n        for (Interval& interval : intervals) {\n            if (interval.right < left || interval.left > right) {\n                continue; \n            }\n            \n        }\n        return h; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [\"Interval\", \"Interval(int,int,int)\"], \"intervals_element0_l\": [\"437101044\"], \"intervals_element0_r\": [\"-250325103\"], \"intervals_element0_h\": [\"-197697386\"], \"intervals_element0.left\": [\"-298501499\"], \"intervals_element0.right\": [\"-1804133054\"], \"intervals_element1\": [\"Interval\", \"Interval(int,int,int)\"], \"intervals_element1_l\": [\"-1613845437\"], \"intervals_element1_r\": [\"1959062378\"], \"intervals_element1_h\": [\"903961999\"], \"intervals_element1.left\": [\"-1329197988\"], \"intervals_element1.right\": [\"-1005957794\"], \"left\": [\"221227000\"], \"right\": [\"462095788\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* searchBST. /*FC*/class Solution {\n/*FM*/TreeNode* searchBST(TreeNode* root, int val) {\n        while (root) {\n            if (root->val < val) {\n                root = root->right; \n            }\n            else if (root->val > val) {\n                root = root->left; \n            }\n            else {\n                \n            }\n        }\n        \n        return root; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-695687525\"], \"root[0].val\": [\"1049202403\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1223175408\"], \"root[0].left[0].val\": [\"-857613400\"], \"val\": [\"-389839731\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double soupServings. /*FC*/class Solution {\n/*FM*/double soupServings(int N) {\n        if (N >= 5000) {\n            \n        }\n        table = vector<vector<double>>(200, vector<double>(200)); \n        return soupServings((N + 24) / 25, (N + 24) / 25); \n    };/*F*/vector<vector<double>> table;/*C*//*M*/double soupServings(int a, int b) {\n        if (a <= 0 && b <= 0) {\n            return 0.5; \n        }\n        \n        if (a <= 0) {\n            return 1; \n        }\n        \n        if (b <= 0) {\n            return 0; \n        }\n        \n        if (table[a][b] > 0) {\n            return table[a][b]; \n        } \n        \n        return table[a][b] = 0.25 * (soupServings(a - 4, b) + soupServings(a - 3, b - 1) +\n                                     soupServings(a - 2, b - 2) + soupServings(a - 1, b - 3)); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"-677227902\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double soupServings. /*FC*/class Solution {\n/*FM*/double soupServings(int N) {\n        if (N >= 5000) {\n            return 1; \n        }\n        \n        \n    };/*F*//*C*//*M*/double soupServings(int a, int b) {\n        if (a <= 0 && b <= 0) {\n            return 0.5; \n        }\n        \n        if (a <= 0) {\n            return 1; \n        }\n        \n        if (b <= 0) {\n            return 0; \n        }\n        \n        if (table[a][b] > 0) {\n            return table[a][b]; \n        } \n        \n        return table[a][b] = 0.25 * (soupServings(a - 4, b) + soupServings(a - 3, b - 1) +\n                                     soupServings(a - 2, b - 2) + soupServings(a - 1, b - 3)); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"704171962\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double soupServings. /*FC*/class Solution {\n/*FM*/double soupServings(int a, int b) {\n        if (a <= 0 && b <= 0) {\n            \n        }\n        \n        if (a <= 0) {\n            \n        }\n        \n        if (b <= 0) {\n            return 0; \n        }\n        \n        if (table[a][b] > 0) {\n            \n        } \n        \n        \n    };/*F*/vector<vector<double>> table;/*C*//*M*/double soupServings(int a, int b) {\n        if (a <= 0 && b <= 0) {\n            return 0.5; \n        }\n        \n        if (a <= 0) {\n            return 1; \n        }\n        \n        if (b <= 0) {\n            return 0; \n        }\n        \n        if (table[a][b] > 0) {\n            return table[a][b]; \n        } \n        \n        return table[a][b] = 0.25 * (soupServings(a - 4, b) + soupServings(a - 3, b - 1) +\n                                     soupServings(a - 2, b - 2) + soupServings(a - 1, b - 3)); \n    } double soupServings(int a, int b) {\n        if (a <= 0 && b <= 0) {\n            return 0.5; \n        }\n        \n        if (a <= 0) {\n            return 1; \n        }\n        \n        if (b <= 0) {\n            return 0; \n        }\n        \n        if (table[a][b] > 0) {\n            return table[a][b]; \n        } \n        \n        return table[a][b] = 0.25 * (soupServings(a - 4, b) + soupServings(a - 3, b - 1) +\n                                     soupServings(a - 2, b - 2) + soupServings(a - 1, b - 3)); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->table\": [1], \"AKA_INSTANCE___Solution_table_element0\": [1], \"AKA_INSTANCE___Solution_table_element0_element0\": [\"1\"], \"a\": [\"2\"], \"b\": [\"-2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double soupServings. /*FC*/class Solution {\n/*FM*/double soupServings(int a, int b) {\n        if (a <= 0 && b <= 0) {\n            \n        }\n        \n        if (a <= 0) {\n            \n        }\n        \n        if (b <= 0) {\n            \n        }\n        \n        if (table[a][b] > 0) {\n            return table[a][b]; \n        } \n        \n        \n    };/*F*/vector<vector<double>> table;/*C*//*M*/double soupServings(int a, int b) {\n        if (a <= 0 && b <= 0) {\n            return 0.5; \n        }\n        \n        if (a <= 0) {\n            return 1; \n        }\n        \n        if (b <= 0) {\n            return 0; \n        }\n        \n        if (table[a][b] > 0) {\n            return table[a][b]; \n        } \n        \n        return table[a][b] = 0.25 * (soupServings(a - 4, b) + soupServings(a - 3, b - 1) +\n                                     soupServings(a - 2, b - 2) + soupServings(a - 1, b - 3)); \n    } double soupServings(int a, int b) {\n        if (a <= 0 && b <= 0) {\n            return 0.5; \n        }\n        \n        if (a <= 0) {\n            return 1; \n        }\n        \n        if (b <= 0) {\n            return 0; \n        }\n        \n        if (table[a][b] > 0) {\n            return table[a][b]; \n        } \n        \n        return table[a][b] = 0.25 * (soupServings(a - 4, b) + soupServings(a - 3, b - 1) +\n                                     soupServings(a - 2, b - 2) + soupServings(a - 1, b - 3)); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->table\": [2], \"AKA_INSTANCE___Solution_table_element0\": [1], \"AKA_INSTANCE___Solution_table_element0_element0\": [\"1\"], \"AKA_INSTANCE___Solution_table_element1\": [2], \"AKA_INSTANCE___Solution_table_element1_element0\": [\"1\"], \"AKA_INSTANCE___Solution_table_element1_element1\": [\"1\"], \"a\": [\"1\"], \"b\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int gcd. /*FC*/class Solution {\n/*FM*/int gcd(int a, int b) {\n        while (b) {\n            int temp = a; \n            a = b; \n            b = temp % b; \n        }\n        return a; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"-324415646\"], \"b\": [\"1181420584\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool enQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool enQueue(int value) {\n        if (isFull()) {\n            \n        }\n        if (head == -1) {\n            \n        }\n        tail = (tail + 1) % data.size(); \n        data[tail] = value; \n        ++len; \n        return true;         \n    };/*F*/int head;  int tail;  int len;  vector<int> data;/*C*/MyCircularQueue(int k) { };/*M*/bool isFull() {\n        return len == data.size(); \n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"1\"], \"AKA_INSTANCE___MyCircularQueue->head\": [\"0\"], \"AKA_INSTANCE___MyCircularQueue->tail\": [\"0\"], \"AKA_INSTANCE___MyCircularQueue->len\": [\"1\"], \"AKA_INSTANCE___MyCircularQueue->data\": [1], \"AKA_INSTANCE___MyCircularQueue_data_element0\": [\"0\"], \"value\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool enQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool enQueue(int value) {\n        if (isFull()) {\n            return false; \n        }\n        if (head == -1) {\n            \n        }\n        \n        \n        \n                \n    };/*F*/int head;/*C*/MyCircularQueue(int k) { };/*M*/bool isFull() {\n        return len == data.size(); \n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"0\"], \"AKA_INSTANCE___MyCircularQueue->head\": [\"-1\"], \"AKA_INSTANCE___MyCircularQueue->tail\": [\"-1\"], \"AKA_INSTANCE___MyCircularQueue->len\": [\"0\"], \"AKA_INSTANCE___MyCircularQueue->data\": [0], \"value\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool deQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool deQueue() {\n        if (isEmpty()) {\n            \n        }\n        \n        if (head == tail) {\n            head = -1; \n            tail = -1; \n        }\n        else {\n            \n        }\n        --len; \n        return true; \n    };/*F*/int head;  int tail;  int len;/*C*/MyCircularQueue(int k) { };/*M*/bool isEmpty() {\n        return len == 0; \n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"1\"], \"AKA_INSTANCE___MyCircularQueue->head\": [\"0\"], \"AKA_INSTANCE___MyCircularQueue->tail\": [\"0\"], \"AKA_INSTANCE___MyCircularQueue->len\": [\"1\"], \"AKA_INSTANCE___MyCircularQueue->data\": [1], \"AKA_INSTANCE___MyCircularQueue_data_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool deQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool deQueue() {\n        if (isEmpty()) {\n            \n        }\n        \n        if (head == tail) {\n            \n            \n        }\n        else {\n            head = (head + 1) % data.size(); \n        }\n        --len; \n        return true; \n    };/*F*/int head;  int tail;  int len;  vector<int> data;/*C*/MyCircularQueue(int k) { };/*M*/bool isEmpty() {\n        return len == 0; \n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"2\"], \"AKA_INSTANCE___MyCircularQueue->head\": [\"0\"], \"AKA_INSTANCE___MyCircularQueue->tail\": [\"1\"], \"AKA_INSTANCE___MyCircularQueue->len\": [\"2\"], \"AKA_INSTANCE___MyCircularQueue->data\": [2], \"AKA_INSTANCE___MyCircularQueue_data_element0\": [\"-1\"], \"AKA_INSTANCE___MyCircularQueue_data_element1\": [\"-1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int ping. /*FC*/class RecentCounter {\n/*FM*/int ping(int t) {\n        Q.push(t); \n        while (Q.front() < t - 3000) {\n            Q.pop(); \n        }\n        return Q.size(); \n    };/*F*/queue<int> Q;/*C*/RecentCounter() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RecentCounter\": [\"RecentCounter\", \"RecentCounter()\"], \"AKA_INSTANCE___RecentCounter->Q\": [1], \"AKA_INSTANCE___RecentCounter_Q_element0\": [\"-5000\"], \"t\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rangeBitwiseAnd. /*FC*/class Solution {\n/*FM*/int rangeBitwiseAnd(int m, int n) {\n        while (n > m) {\n            n &= n - 1; \n        }\n        \n        return n; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"6\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isHappy. /*FC*/class Solution {\n/*FM*/bool isHappy(int n) {\n        unordered_set<int> visited{n}; \n        while (n != 1) {\n            int temp = n; \n            n = 0; \n            while (temp) {\n                int i = temp % 10; \n                n += i * i; \n                temp /= 10; \n            }\n            if (visited.count(n)) {\n                \n            }\n            visited.insert(n); \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isHappy. /*FC*/class Solution {\n/*FM*/bool isHappy(int n) {\n        unordered_set<int> visited{n}; \n        while (n != 1) {\n            int temp = n; \n            n = 0; \n            while (temp) {\n                \n                \n                \n            }\n            if (visited.count(n)) {\n                return false; \n            }\n            \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* removeElements. /*FC*/class Solution {\n/*FM*/ListNode* removeElements(ListNode* head, int val) {\n        ListNode dummy(-1); \n        ListNode* p = &dummy; \n        while (head) {\n            if (head->val != val) {\n                p->next = head; \n                p = p->next; \n            }\n            head = head->next; \n        }\n        \n        p->next = nullptr;         \n        return dummy.next; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"484857163\"], \"head[0].val\": [\"-234675035\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-459723206\"], \"head[0].next[0].val\": [\"-27859204\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"-1310930067\"], \"head[0].next[1].val\": [\"-399381450\"], \"val\": [\"-625744130\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPrimes. /*FC*/class Solution {\n/*FM*/int countPrimes(int n) {\n        if (n <= 2) {\n            \n        }\n        vector<int> prime(n, true); \n        int count = 1; \n        int upper = sqrt(n); \n        for (int i = 3;  i < n;  i += 2) {\n            if (prime[i]) {\n                ++count; \n                if (i > upper) {\n                    continue; \n                }\n                \n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPrimes. /*FC*/class Solution {\n/*FM*/int countPrimes(int n) {\n        if (n <= 2) {\n            return 0; \n        }\n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isIsomorphic. /*FC*/class Solution {\n/*FM*/bool isIsomorphic(string s, string t) {\n        if (s.size() != t.size()) {\n            \n        }\n        vector<int> table1(256); \n        vector<int> table2(256); \n        for (int i = 0;  i < s.size();  ) {\n            if (table1[s[i]] == 0 && table2[t[i]] == 0) {\n                \n                \n            }\n            else if (table1[s[i]] != t[i]) {\n                return false; \n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isIsomorphic. /*FC*/class Solution {\n/*FM*/bool isIsomorphic(string s, string t) {\n        if (s.size() != t.size()) {\n            \n        }\n        vector<int> table1(256); \n        vector<int> table2(256); \n        for (int i = 0;  i < s.size();  ++i) {\n            if (table1[s[i]] == 0 && table2[t[i]] == 0) {\n                table1[s[i]] = t[i]; \n                table2[t[i]] = s[i]; \n            }\n            else if (table1[s[i]] != t[i]) {\n                \n            }\n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList. /*FC*/class Solution {\n/*FM*/ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr; \n        ListNode* curr = head; \n        while (curr) {\n            ListNode* next = curr->next; \n            curr->next = prev; \n            prev = curr; \n            curr = next; \n        }\n        \n        return prev; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"125837778\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-710328244\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList2. /*FC*/class Solution {\n/*FM*/ListNode* reverseList2(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head; \n        }\n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr; \n        ListNode* curr = head; \n        while (curr) {\n            ListNode* next = curr->next; \n            curr->next = prev; \n            prev = curr; \n            curr = next; \n        }\n        \n        return prev; \n    } ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1226590461\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1282620111\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList2. /*FC*/class Solution {\n/*FM*/ListNode* reverseList2(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            \n        }\n        \n        ListNode* node = reverseList(head->next); \n        head->next->next = head; \n        head->next = nullptr; \n        return node; \n    };/*F*//*C*//*M*/ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr; \n        ListNode* curr = head; \n        while (curr) {\n            ListNode* next = curr->next; \n            curr->next = prev; \n            prev = curr; \n            curr = next; \n        }\n        \n        return prev; \n    } ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1208170507\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"1235138705\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1962361814\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/class Trie {\n/*FM*/void insert(string word) {\n        TrieNode* node = root; \n        for (char c : word) {\n            int i = c - 'a'; \n            if (node->next[i] == nullptr) {\n                node->next[i] = new TrieNode(); \n            }\n            node = node->next[i]; \n        }\n        \n        node->isEnd = true; \n    };/*F*/TrieNode * root;/*C*/Trie() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Trie\": [\"Trie\", \"Trie()\"], \"word\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool search. /*FC*/class Trie {\n/*FM*/bool search(string word) {\n        TrieNode* node = root; \n        for (char c : word) {\n            int i = c - 'a'; \n            if (node->next[i] == nullptr) {\n                \n            }\n            node = node->next[i]; \n        }\n        \n        return node->isEnd; \n    };/*F*/TrieNode * root;/*C*/Trie() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Trie\": [\"Trie\", \"Trie()\"], \"word\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool search. /*FC*/class Trie {\n/*FM*/bool search(string word) {\n        TrieNode* node = root; \n        for (char c : word) {\n            int i = c - 'a'; \n            if (node->next[i] == nullptr) {\n                return false; \n            }\n            \n        }\n        \n        \n    };/*F*/TrieNode * root;/*C*/Trie() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Trie\": [\"Trie\", \"Trie()\"], \"word\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool startsWith. /*FC*/class Trie {\n/*FM*/bool startsWith(string prefix) {\n        TrieNode* node = root; \n        for (char c : prefix) {\n            int i = c - 'a'; \n            if (node->next[i] == nullptr) {\n                \n            }\n            node = node->next[i]; \n        }\n        \n        return true; \n    };/*F*/TrieNode * root;/*C*/Trie() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Trie\": [\"Trie\", \"Trie()\"], \"prefix\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool startsWith. /*FC*/class Trie {\n/*FM*/bool startsWith(string prefix) {\n        TrieNode* node = root; \n        for (char c : prefix) {\n            int i = c - 'a'; \n            if (node->next[i] == nullptr) {\n                return false; \n            }\n            \n        }\n        \n        \n    };/*F*/TrieNode * root;/*C*/Trie() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Trie\": [\"Trie\", \"Trie()\"], \"prefix\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSubArrayLen. /*FC*/class Solution {\n/*FM*/int minSubArrayLen(int s, vector<int>& nums) {\n        int minLen = nums.size() + 1; \n        int start = 0, sum = 0;         \n        for (int i = 0;  i < nums.size();  ++i) {\n            sum += nums[i]; \n            while (sum >= s) {\n                minLen = min(minLen, i - start + 1); \n                sum -= nums[start++]; \n            }\n        }\n        \n        return minLen == nums.size() + 1 ? 0 : minLen; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"nums\": [2], \"nums_element0\": [\"670231513\"], \"nums_element1\": [\"1509250683\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/ {\n/*FM*/int lengthOfLastWord(const char* s) {\n        int len = 0; \n        while (*s) {\n            if (*s++ != ' ')\n                ++len; \n            else if (*s && *s != ' ')\n                len = 0; \n    \n        }\n        return len; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [4], \"s_constantPointer[0]\": [\"49\"], \"s_constantPointer[1]\": [\"32\"], \"s_constantPointer[2]\": [\"49\"], \"s_constantPointer[3]\": [\"32\"], \"s_constantPointer[4]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void addWord. /*FC*/class WordDictionary {\n/*FM*/void addWord(string word) {\n        TrieNode* node = root; \n        for (char c : word) {\n            int i = c - 'a'; \n            if (node->next[i] == nullptr) {\n                node->next[i] = new TrieNode(); \n            }\n            node = node->next[i]; \n        }\n        node->isEnd = true; \n    };/*F*/TrieNode * root;/*C*/WordDictionary() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___WordDictionary\": [\"WordDictionary\", \"WordDictionary()\"], \"word\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void addWord. /*FC*/class WordDictionary {\n/*FM*/void addWord(string word) {\n        TrieNode* node = root; \n        for (char c : word) {\n            int i = c - 'a'; \n            if (node->next[i] == nullptr) {\n                \n            }\n            node = node->next[i]; \n        }\n        node->isEnd = true; \n    };/*F*/TrieNode * root;/*C*/WordDictionary() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___WordDictionary\": [\"WordDictionary\", \"WordDictionary()\"], \"word\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int>& nums) {\n        int n = nums.size(); \n        if (n == 0) {\n            \n        }\n        else if (n == 1) {\n            \n        }\n\n        return max(rob(nums, 0, n - 2), rob(nums, 1, n - 1)); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-183397737\"], \"nums_element1\": [\"-1340668316\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int>& nums) {\n        int n = nums.size(); \n        if (n == 0) {\n            \n        }\n        else if (n == 1) {\n            return nums[0]; \n        }\n\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"486479013\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> combinationSum3. /*FC*/class Solution {\n/*FM*/vector<vector<int>> combinationSum3(int k, int n) {\n        vector<vector<int>> result; \n        if (n <= 0 || n > 45 || k <= 0) {\n            return result; \n        }\n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"-1787753995\"], \"n\": [\"-2010871845\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsDuplicate. /*FC*/class Solution {\n/*FM*/bool containsDuplicate(vector<int>& nums) {\n        unordered_set<int> table; \n        for (int num : nums) {\n            if (table.count(num)) {\n                \n            }\n            table.insert(num); \n        }\n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1460190616\"], \"nums_element1\": [\"400119029\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_map<int, int> table; \n        for (int i = 0;  i < nums.size();  ++i) {\n            if (table.find(nums[i]) != table.end() && i - table[nums[i]] <= k) {\n                \n            }\n            else {\n                table[nums[i]] = i; \n            }\n        }\n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1529613700\"], \"k\": [\"1976513308\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyAlmostDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        if (k < 0 || t < 0) {\n            \n        }\n        unordered_map<long, long> table; \n        long w = t + 1LL; \n        for (int i = 0;  i < nums.size();  ++i) {\n            long m = getID(nums[i], w); \n            if (table.find(m) != table.end()) {\n                \n            }\n            if (table.find(m - 1) != table.end() && abs(nums[i] - table[m - 1]) < w) {\n                \n            }\n            if (table.find(m + 1) != table.end() && abs(nums[i] - table[m + 1]) < w) {\n                return true; \n            }\n            table[m] = nums[i]; \n            if (i >= k) {\n                \n            }\n        }\n        \n    };/*F*//*C*//*M*/long getID(long x, long w) {\n        return x < 0 ? (x + 1) / w - 1 : x / w; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1696913338\"], \"nums_element1\": [\"1691573747\"], \"k\": [\"67068131\"], \"t\": [\"14018090\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyAlmostDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        if (k < 0 || t < 0) {\n            return false; \n        }\n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"515612484\"], \"nums_element1\": [\"871996526\"], \"k\": [\"-1468238980\"], \"t\": [\"-2036635289\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalSquare. /*FC*/class Solution {\n/*FM*/int maximalSquare(vector<vector<char>>& matrix) {\n        int m = matrix.size(); \n        if (m == 0) {\n            \n        }\n        int n = matrix[0].size(); \n        if (n == 0) {\n            \n        }\n        vector<vector<int>> dp(1 + m, vector<int>(1 + n)); \n        \n        int maxArea = 0; \n        for (int i = 1;  i <= m;  ++i) {\n            for (int j = 1;  j <= n;  ++j) {\n                if (matrix[i - 1][j - 1] == '1') {\n                    \n                    \n                }\n            }\n        }\n        \n        return maxArea; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"-68\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int height. /*FC*/class Solution {\n/*FM*/int height(TreeNode* root) {\n        int h = -1; \n        while (root) {\n            ++h; \n            root = root->left; \n        }\n        return h; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1477917879\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int calculate. /*FC*/class Solution {\n/*FM*/int calculate(string s) {\n        stack<int> St; \n        int result = 0, num = 0, i = 0; \n        int sign = 1; \n        while (i < s.size()) {\n            if (isdigit(s[i])) {\n                while (i < s.size() && isdigit(s[i])) {\n                    num = num * 10 + (s[i++] - '0'); \n                }\n                result += sign * num; \n                num = 0; \n            }\n            else {\n                \n                \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int calculate. /*FC*/class Solution {\n/*FM*/int calculate(string s) {\n        stack<int> St; \n        int result = 0, num = 0, i = 0; \n        int sign = 1; \n        while (i < s.size()) {\n            if (isdigit(s[i])) {\n                \n                \n                \n            }\n            else {\n                if (s[i] == '+') {\n                    \n                }\n                else if (s[i] == '-') {\n                    \n                }\n                else if (s[i] == '(') {\n                    \n                    \n                    \n                    \n                }\n                else if (s[i] == ')') {\n                    \n                    \n                    \n                    \n                    \n                }\n                ++i; \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void push. /*FC*/class MyStack {\n/*FM*/void push(int x) {\n        Q.push(x); \n        int qs = Q.size(); \n        while (qs > 1) {\n            \n            \n            \n        }\n    };/*F*/queue<int> Q;/*C*/MyStack() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyStack\": [\"MyStack\", \"MyStack()\"], \"x\": [\"910601620\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* invertTree. /*FC*/class Solution {\n/*FM*/TreeNode* invertTree(TreeNode* root) {\n        if (root == nullptr) {\n            return nullptr; \n        }\n        \n        TreeNode* left = invertTree(root->left); \n        TreeNode* right = invertTree(root->right); \n        root->left = right; \n        root->right = left; \n        return root; \n    };/*F*//*C*//*M*/TreeNode* invertTree(TreeNode* root) {\n        if (root == nullptr) {\n            return nullptr; \n        }\n        \n        TreeNode* left = invertTree(root->left); \n        TreeNode* right = invertTree(root->right); \n        root->left = right; \n        root->right = left; \n        return root; \n    } TreeNode* invertTree(TreeNode* root) {\n        if (root == nullptr) {\n            return nullptr; \n        }\n        \n        TreeNode* left = invertTree(root->left); \n        TreeNode* right = invertTree(root->right); \n        root->left = right; \n        root->right = left; \n        return root; \n    } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1181584880\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-898491054\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int calculate. /*FC*/class Solution {\n/*FM*/int calculate(string s) {\n        int n = s.size(); \n        stack<int> St; \n        int num = 0; \n        char preop = '+'; \n        for (int i = 0;  i < n;  ++i) {\n            char c = s[i]; \n            if (isdigit(c)) {\n                \n            }\n            if (i == n - 1 || (!isdigit(c) && c != ' ')) {\n                if (preop == '+') {\n                    St.push(num); \n                }\n                else if (preop == '-') {\n                    \n                }\n                else if (preop == '*') {\n                    \n                    \n                    \n                }\n                else {\n                    \n                    \n                    \n                }\n                \n                preop = c; \n                num = 0; \n            }\n        }\n        \n        int result = 0; \n        while (!St.empty()) {\n            result += St.top(); \n            St.pop(); \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> summaryRanges. /*FC*/class Solution {\n/*FM*/vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> result; \n        int i = 0; \n        for (int j = 0;  j < nums.size();  ++j) {\n            if (j + 1 < nums.size() && nums[j + 1] == nums[j] + 1) {\n                \n            }\n            \n            if (i == j) {\n                result.push_back(to_string(nums[i])); \n            }\n            else {\n                \n            }\n            i = j + 1; \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"519965510\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> majorityElement. /*FC*/class Solution {\n/*FM*/vector<int> majorityElement(vector<int>& nums) {\n        vector<int> result; \n        int n = nums.size(); \n        if (n == 0) {\n            \n        }\n        int num1 = 1, num2 = 2; \n        int count1 = 0, count2 = 0; \n        for (int num : nums) {\n            if (num == num1) {\n                \n            }\n            else if (num == num2) {\n                \n            }\n            else if (count1 == 0) {\n                num1 = num; \n                count1 = 1; \n            }\n            else if (count2 == 0) {\n                \n                \n            }\n            else {\n                \n                \n            }\n        }\n        \n        count1 = count2 = 0; \n        for (int num : nums) {\n            if (num == num1) {\n                ++count1; \n            }\n            if (num == num2) {\n                \n            }\n        }\n        \n        if (count1 > n / 3) {\n            result.push_back(num1); \n        }\n        \n        if (count2 > n / 3) {\n            \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1290080688\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int kthSmallest. /*FC*/class Solution {\n/*FM*/int kthSmallest(TreeNode* root, int k) {\n        stack<TreeNode*> St; \n        TreeNode* p = root; \n        while (!St.empty() || p) {\n            if (p) {\n                St.push(p); \n                p = p->left; \n            }\n            else {\n                p = St.top(); \n                St.pop(); \n                if (--k == 0) {\n                    \n                }\n                p = p->right; \n            }\n        }\n        \n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1071045371\"], \"k\": [\"-2147467703\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countDigitOne. /*FC*/class Solution {\n/*FM*/int countDigitOne(int n) {\n        int count = 0; \n        for (long base = 1;  base <= n;  base *= 10) {\n            int curr = n / base % 10; \n            int low = n % base; \n            int high = n / (base * 10); \n            if (curr < 1) {\n                \n            }\n            else if (curr == 1) {\n                \n            }\n            else {\n                count += (high + 1) * base; \n            }\n        }\n        \n        return count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return true; \n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1687012497\"], \"head[0].val\": [\"-1811140987\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList. /*FC*/class Solution {\n/*FM*/ListNode* reverseList(ListNode* head) {        \n        ListNode *curr = head; \n        ListNode *prev = nullptr; \n        while (curr) {\n            ListNode* next = curr->next; \n            curr->next = prev; \n            prev = curr; \n            curr = next; \n        }\n        \n        return prev; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1066579564\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* lowestCommonAncestor. /*FC*/class Solution {\n/*FM*/TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        while (root) {\n            if (root->val < p->val && root->val < q->val) {\n                \n            }\n            else if (root->val > p->val && root->val > q->val) {\n                root = root->left; \n            }\n            else {\n                \n            }\n        }\n        \n        return root; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1776709133\"], \"root[0].val\": [\"2049707460\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-1724374119\"], \"root[0].right[0].val\": [\"-1110952807\"], \"p\": [1], \"p[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_x\": [\"1449356015\"], \"p[0].val\": [\"797788319\"], \"p[0].left\": [1], \"p[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_left0_x\": [\"981492854\"], \"p[0].left[0].val\": [\"-1814028389\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* lowestCommonAncestor. /*FC*/class Solution {\n/*FM*/TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        while (root) {\n            if (root->val < p->val && root->val < q->val) {\n                \n            }\n            else if (root->val > p->val && root->val > q->val) {\n                \n            }\n            else {\n                break; \n            }\n        }\n        \n        return root; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"839768836\"], \"root[0].val\": [\"-525039149\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-879636620\"], \"root[0].left[0].val\": [\"1148878415\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"829002347\"], \"root[0].right[0].val\": [\"-443638437\"], \"p\": [1], \"p[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_x\": [\"178593637\"], \"p[0].val\": [\"242838265\"], \"p[0].left\": [1], \"p[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_left0_x\": [\"-357296699\"], \"p[0].left[0].val\": [\"1857664020\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* lowestCommonAncestor. /*FC*/class Solution {\n/*FM*/TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root; \n        }\n        \n        TreeNode* left = lowestCommonAncestor(root->left, p, q); \n        TreeNode* right = lowestCommonAncestor(root->right, p, q); \n        if (left && right) {\n            \n        }\n        else {\n            return left ? left : right; \n        }\n    };/*F*//*C*//*M*/TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root; \n        }\n        \n        TreeNode* left = lowestCommonAncestor(root->left, p, q); \n        TreeNode* right = lowestCommonAncestor(root->right, p, q); \n        if (left && right) {\n            return root; \n        }\n        else {\n            return left ? left : right; \n        }\n    } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root; \n        }\n        \n        TreeNode* left = lowestCommonAncestor(root->left, p, q); \n        TreeNode* right = lowestCommonAncestor(root->right, p, q); \n        if (left && right) {\n            return root; \n        }\n        else {\n            return left ? left : right; \n        }\n    } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"549571801\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1377612067\"], \"p\": [1], \"p[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_x\": [\"-2008972998\"], \"q\": [1], \"q[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"q0_x\": [\"-1641118704\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> productExceptSelf. /*FC*/class Solution {\n/*FM*/vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size(); \n        vector<int> product(n, 1); \n        for (int i = 1;  i < n;  ) {\n            \n        }\n        \n        int right = 1; \n        for (int i = n - 2;  i >= 0;  ) {\n            \n            \n        }\n        \n        return product; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-75070617\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSlidingWindow. /*FC*/class Solution {\n/*FM*/vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size(); \n        vector<int> result; \n        deque<int> dq; \n        for (int i = 0;  i < n;  ++i) {\n            while (!dq.empty() && dq.front() <= i - k) {\n                \n            }\n            \n            while (!dq.empty() && nums[dq.back()] <= nums[i]) {\n                \n            }\n            \n            dq.push_back(i); \n            \n            if (i >= k - 1) {\n                \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"928926464\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSlidingWindow. /*FC*/class Solution {\n/*FM*/vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size(); \n        vector<int> result; \n        deque<int> dq; \n        for (int i = 0;  i < n;  ++i) {\n            while (!dq.empty() && dq.front() <= i - k) {\n                \n            }\n            \n            while (!dq.empty() && nums[dq.back()] <= nums[i]) {\n                \n            }\n            \n            dq.push_back(i); \n            \n            if (i >= k - 1) {\n                result.push_back(nums[dq.front()]); \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"309779703\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(); \n        if (m == 0) {\n            \n        }\n        int n = matrix[0].size(); \n        if (n == 0) {\n            \n        }\n        \n        \n        int row = m - 1, col = 0; \n        while (row >= 0 && col < n) {\n            if (matrix[row][col] == target) {\n                \n            }\n            \n            if (matrix[row][col] < target) {\n                ++col; \n            }\n            else {\n                \n            }\n        }\n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"-2010945128\"], \"target\": [\"-1210304145\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(); \n        if (m == 0) {\n            \n        }\n        int n = matrix[0].size(); \n        if (n == 0) {\n            \n        }\n        \n        \n        int row = m - 1, col = 0; \n        while (row >= 0 && col < n) {\n            if (matrix[row][col] == target) {\n                \n            }\n            \n            if (matrix[row][col] < target) {\n                \n            }\n            else {\n                --row; \n            }\n        }\n        \n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"-411333305\"], \"target\": [\"-420363940\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution {\n/*FM*/bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) {\n            \n        }\n        vector<int> table(26); \n        for (char c : s) {\n            ++table[c - 'a']; \n        }\n        \n        for (char c : t) {\n            if (--table[c - 'a'] < 0) {\n                return false; \n            }\n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortest. /*FC*/class WordDistance {\n/*FM*/int shortest(string word1, string word2) {\n        int minDist = INT_MAX; \n        vector<int>& index1 = table[word1]; \n        vector<int>& index2 = table[word2]; \n        int p1 = 0, p2 = 0; \n        while (p1 < index1.size() && p2 < index2.size()) {\n            \n            \n        }\n        \n        return minDist; \n    };/*F*/unordered_map<string, vector<int>> table;/*C*/WordDistance(vector<string> words) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___WordDistance\": [\"WordDistance\", \"WordDistance(vector<string>)\"], \"AKA_INSTANCE___WordDistance_words\": [1], \"AKA_INSTANCE___WordDistance_words_element0\": [\"1\"], \"word1\": [\"1\"], \"word2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isStrobogrammatic. /*FC*/class Solution {\n/*FM*/bool isStrobogrammatic(string num) {\n        int n = num.size(); \n        if (n == 0) {\n            \n        }\n        \n        int start = 0, end = n - 1; \n        while (start <= end) {\n            if (convert(num[start]) != num[end]) {\n                return false; \n            }\n            \n            \n        }\n        \n        \n    };/*F*//*C*//*M*/char convert(char ch) {\n        if (ch == '0' || ch == '1' || ch == '8') {\n            return ch; \n        }\n        else if (ch == '6') {\n            return '9'; \n        }\n        else if (ch == '9') {\n            return '6'; \n        }\n        else {\n            return ' '; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char convert. /*FC*/class Solution {\n/*FM*/char convert(char ch) {\n        if (ch == '0' || ch == '1' || ch == '8') {\n            \n        }\n        else if (ch == '6') {\n            \n        }\n        else if (ch == '9') {\n            \n        }\n        else {\n            return ' '; \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ch\": [\"-72\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strobogrammaticInRange. /*FC*/class Solution {\n/*FM*/int strobogrammaticInRange(string low, string high) {\n        int count = 0; \n        for (int i = low.size();  i <= high.size();  ++i) {\n            findStrobogrammatic(i, low, high, count); \n        }\n        \n        return count; \n    };/*F*//*C*//*M*/void findStrobogrammatic(int n, string low, string high, int& count) {\n        vector<string> result; \n        if (n % 2) {\n            --n; \n            result = {\"0\", \"1\", \"8\"}; \n        }\n        else {\n            result = {\"\"}; \n        }\n        \n        while (n) {\n            vector<string> temp; \n            for (string s : result) {\n                if (n != 2) {\n                    temp.push_back(\"0\" + s + \"0\"); \n                }\n                temp.push_back(\"1\" + s + \"1\");                 \n                temp.push_back(\"6\" + s + \"9\"); \n                temp.push_back(\"8\" + s + \"8\"); \n                temp.push_back(\"9\" + s + \"6\"); \n            }\n            \n            n -= 2; \n            result = temp; \n        }\n        \n        for (string s : result) {\n            if (!((s.size() == low.size() && s < low) || (s.size() == high.size() && s > high))) {\n                ++count; \n            }\n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"low\": [\"1\"], \"high\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int next. /*FC*/class Vector2D {\n/*FM*/int next() {\n        int result = *(begin->begin() + curr); \n        ++curr; \n        while (begin != end && curr == begin->size()) {\n            ++begin; \n            curr = 0; \n        }\n        return result; \n    };/*F*/vector<vector<int>>::iterator begin;  vector<vector<int>>::iterator end;  int curr;/*C*/Vector2D(vector<vector<int>>& vec2d) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Vector2D\": [\"Vector2D\", \"Vector2D(vector<vector<int>>&)\"], \"AKA_INSTANCE___Vector2D_vec2d\": [1], \"AKA_INSTANCE___Vector2D_vec2d_element0\": [1], \"AKA_INSTANCE___Vector2D_vec2d_element0_element0\": [\"51291275\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canAttendMeetings. /*FC*/class Solution {\n/*FM*/bool canAttendMeetings(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end()); \n        for (int i = 1;  i < intervals.size();  ) {\n            \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [1], \"intervals_element0\": [1], \"intervals_element0_element0\": [\"-367327882\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(int start, int n, vector<int>& path, vector<vector<int>>& result) {\n        for (int i = start;  i * i <=  n;  ++i) {\n            if (n % i == 0) {\n                path.push_back(i); \n                dfs(i, n / i, path, result); \n                path.push_back(n / i); \n                result.push_back(path); \n                path.pop_back(); \n                path.pop_back(); \n            }\n        }\n    };/*F*//*C*//*M*/void dfs(int start, int n, vector<int>& path, vector<vector<int>>& result) {\n        for (int i = start;  i * i <=  n;  ++i) {\n            if (n % i == 0) {\n                path.push_back(i); \n                dfs(i, n / i, path, result); \n                path.push_back(n / i); \n                result.push_back(path); \n                path.pop_back(); \n                path.pop_back(); \n            }\n        }\n    } void dfs(int start, int n, vector<int>& path, vector<vector<int>>& result) {\n        for (int i = start;  i * i <=  n;  ++i) {\n            if (n % i == 0) {\n                path.push_back(i); \n                dfs(i, n / i, path, result); \n                path.push_back(n / i); \n                result.push_back(path); \n                path.pop_back(); \n                path.pop_back(); \n            }\n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"start\": [\"2\"], \"n\": [\"6\"], \"path\": [1], \"path_element0\": [\"1786723303\"], \"result\": [1], \"result_element0\": [1], \"result_element0_element0\": [\"1661945100\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(int start, int n, vector<int>& path, vector<vector<int>>& result) {\n        for (int i = start;  i * i <=  n;  ) {\n            if (n % i == 0) {\n                \n                \n                \n                \n                \n                \n            }\n        }\n    };/*F*//*C*//*M*/void dfs(int start, int n, vector<int>& path, vector<vector<int>>& result) {\n        for (int i = start;  i * i <=  n;  ++i) {\n            if (n % i == 0) {\n                path.push_back(i); \n                dfs(i, n / i, path, result); \n                path.push_back(n / i); \n                result.push_back(path); \n                path.pop_back(); \n                path.pop_back(); \n            }\n        }\n    } void dfs(int start, int n, vector<int>& path, vector<vector<int>>& result) {\n        for (int i = start;  i * i <=  n;  ++i) {\n            if (n % i == 0) {\n                path.push_back(i); \n                dfs(i, n / i, path, result); \n                path.push_back(n / i); \n                result.push_back(path); \n                path.pop_back(); \n                path.pop_back(); \n            }\n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"start\": [\"0\"], \"n\": [\"6\"], \"path\": [1], \"path_element0\": [\"1239804135\"], \"result\": [1], \"result_element0\": [1], \"result_element0_element0\": [\"-2099794462\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool verifyPreorder. /*FC*/class Solution {\n/*FM*/bool verifyPreorder(vector<int>& preorder) {\n        int root = INT_MIN; \n        stack<int> St; \n        for (int num : preorder) {\n            if (num < root) {\n                \n            }\n            while (!St.empty() && St.top() < num) {\n                \n                \n            }\n            \n            St.push(num); \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"preorder\": [1], \"preorder_element0\": [\"-653191288\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool verifyPreorder2. /*FC*/class Solution {\n/*FM*/bool verifyPreorder2(vector<int>& preorder) {\n        int root = INT_MIN; \n        int i = 0; \n        for (int num : preorder) {\n            if (num < root) {\n                \n            }\n            while (i && preorder[i - 1] < num) {\n                \n            }\n            \n            preorder[i++] = num; \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"preorder\": [1], \"preorder_element0\": [\"-946365856\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCost. /*FC*/class Solution {\n/*FM*/int minCost(vector<vector<int>>& costs) {\n        int n = costs.size(); \n        if (n == 0) {\n            \n        }\n        for (int i = 1;  i < n;  ) {\n            \n            \n            \n        }\n        \n        return min({costs[n - 1][0], costs[n - 1][1], costs[n - 1][2]}); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"costs\": [1], \"costs_element0\": [1], \"costs_element0_element0\": [\"618237014\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/class Solution {\n/*FM*/void dfs(TreeNode* root, string path, vector<string>& result) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        path += (path.size() ? \"->\" : \"\") + to_string(root->val); \n        if (root->left == nullptr && root->right == nullptr) {\n            result.push_back(path); \n            return; \n        }\n        \n        dfs(root->left, path, result); \n        dfs(root->right, path, result); \n    };/*F*//*C*//*M*/void dfs(TreeNode* root, string path, vector<string>& result) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        path += (path.size() ? \"->\" : \"\") + to_string(root->val); \n        if (root->left == nullptr && root->right == nullptr) {\n            result.push_back(path); \n            return; \n        }\n        \n        dfs(root->left, path, result); \n        dfs(root->right, path, result); \n    } void dfs(TreeNode* root, string path, vector<string>& result) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        path += (path.size() ? \"->\" : \"\") + to_string(root->val); \n        if (root->left == nullptr && root->right == nullptr) {\n            result.push_back(path); \n            return; \n        }\n        \n        dfs(root->left, path, result); \n        dfs(root->right, path, result); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-837034946\"], \"root[0].val\": [\"-1988776037\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1901675400\"], \"root[0].left[0].val\": [\"-1393914097\"], \"path\": [\"1\"], \"result\": [1], \"result_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int threeSumSmaller. /*FC*/class Solution {\n/*FM*/int threeSumSmaller(vector<int>& nums, int target) {\n        if (nums.size() <= 2) {\n            return 0; \n        }\n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-929738591\"], \"target\": [\"1767013866\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> singleNumber. /*FC*/class Solution {\n/*FM*/vector<int> singleNumber(vector<int>& nums) {\n        vector<int> result(2); \n        int diff = 0; \n        for (int num : nums) {\n            diff ^= num; \n        }\n        \n        int lastBitMask = (-diff) & diff; \n        for (int num : nums) {\n            if (num & lastBitMask) {\n                result[0] ^= num; \n            }\n            else {\n                \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1849579488\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void addNum. /*FC*/class MedianFinder {\n/*FM*/void addNum(int num) {\n      if(s.empty()||num<=s.top())\n        \n      else\n        l.push(num); \n      \n      if(s.size()==l.size()+2){\n        \n        \n        \n      }\n      else if(s.size()+1==l.size()){\n        \n        \n        \n      }\n    };/*F*/priority_queue<int> s;  priority_queue<int,vector<int>,greater<int>> l;/*C*/MedianFinder() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MedianFinder\": [\"MedianFinder\", \"MedianFinder()\"], \"AKA_INSTANCE___MedianFinder->s\": [2], \"AKA_INSTANCE___MedianFinder_s_element0\": [\"1\"], \"AKA_INSTANCE___MedianFinder_s_element1\": [\"1\"], \"AKA_INSTANCE___MedianFinder->l\": [0], \"num\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void addNum. /*FC*/class MedianFinder {\n/*FM*/void addNum(int num) {\n      if(s.empty()||num<=s.top())\n        \n      else\n        l.push(num); \n      \n      if(s.size()==l.size()+2){\n        \n        \n        \n      }\n      else if(s.size()+1==l.size()){\n        int t=l.top(); \n        l.pop(); \n        s.push(t); \n      }\n    };/*F*/priority_queue<int> s;  priority_queue<int,vector<int>,greater<int>> l;/*C*/MedianFinder() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MedianFinder\": [\"MedianFinder\", \"MedianFinder()\"], \"AKA_INSTANCE___MedianFinder->s\": [2], \"AKA_INSTANCE___MedianFinder_s_element0\": [\"1\"], \"AKA_INSTANCE___MedianFinder_s_element1\": [\"1\"], \"AKA_INSTANCE___MedianFinder->l\": [2], \"AKA_INSTANCE___MedianFinder_l_element0\": [\"1\"], \"AKA_INSTANCE___MedianFinder_l_element1\": [\"1\"], \"num\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void addNum. /*FC*/class MedianFinder {\n/*FM*/void addNum(int num) {\n      if(s.empty()||num<=s.top())\n        s.push(num); \n      else\n        \n      \n      if(s.size()==l.size()+2){\n        \n        \n        \n      }\n      else if(s.size()+1==l.size()){\n        \n        \n        \n      }\n    };/*F*/priority_queue<int> s;  priority_queue<int,vector<int>,greater<int>> l;/*C*/MedianFinder() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MedianFinder\": [\"MedianFinder\", \"MedianFinder()\"], \"AKA_INSTANCE___MedianFinder->s\": [-1], \"AKA_INSTANCE___MedianFinder->l\": [0], \"num\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void addNum. /*FC*/class MedianFinder {\n/*FM*/void addNum(int num) {\n      if(s.empty()||num<=s.top())\n        s.push(num); \n      else\n        \n      \n      if(s.size()==l.size()+2){\n        int t=s.top(); \n        s.pop(); \n        l.push(t); \n      }\n      else if(s.size()+1==l.size()){\n        \n        \n        \n      }\n    };/*F*/priority_queue<int> s;  priority_queue<int,vector<int>,greater<int>> l;/*C*/MedianFinder() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MedianFinder\": [\"MedianFinder\", \"MedianFinder()\"], \"AKA_INSTANCE___MedianFinder->s\": [1], \"AKA_INSTANCE___MedianFinder_s_element0\": [\"1\"], \"AKA_INSTANCE___MedianFinder->l\": [0], \"num\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMedian. /*FC*/class MedianFinder {\n/*FM*/double findMedian() {\n      if(s.size()==l.size()) return (s.top()+l.top())/2.0; \n      \n    };/*F*/priority_queue<int> s;  priority_queue<int,vector<int>,greater<int>> l;/*C*/MedianFinder() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MedianFinder\": [\"MedianFinder\", \"MedianFinder()\"], \"AKA_INSTANCE___MedianFinder->s\": [1], \"AKA_INSTANCE___MedianFinder_s_element0\": [\"1\"], \"AKA_INSTANCE___MedianFinder->l\": [1], \"AKA_INSTANCE___MedianFinder_l_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMedian. /*FC*/class MedianFinder {\n/*FM*/double findMedian() {\n      if(s.size()==l.size()) \n      return s.top(); \n    };/*F*/priority_queue<int> s;  priority_queue<int,vector<int>,greater<int>> l;/*C*/MedianFinder() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MedianFinder\": [\"MedianFinder\", \"MedianFinder()\"], \"AKA_INSTANCE___MedianFinder->s\": [1], \"AKA_INSTANCE___MedianFinder_s_element0\": [\"1\"], \"AKA_INSTANCE___MedianFinder->l\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validTree. /*FC*/class Solution {\n/*FM*/bool validTree(int n, vector<pair<int, int>>& edges) {\n        if (edges.size() != n - 1) {\n            return false; \n        }\n        \n        \n        \n        for ( : edges) {\n            \n            \n            \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"5\"], \"edges\": [1], \"edges_element0.first\": [\"-1758683197\"], \"edges_element0.second\": [\"-466446670\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUgly. /*FC*/class Solution {\n/*FM*/bool isUgly(int num) {\n        if (num <= 0) {\n            \n        }\n        \n        for (int p : vector<int>{2, 3, 5}) {\n            while (num % p == 0) {\n                num /= p; \n            } \n        }\n        \n        return num == 1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUgly. /*FC*/class Solution {\n/*FM*/bool isUgly(int num) {\n        if (num <= 0) {\n            return false; \n        }\n        \n        for ( : vector<int>{2, 3, 5}) {\n             \n        }\n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthUglyNumber. /*FC*/class Solution {\n/*FM*/int nthUglyNumber(int n) {\n        int p2 = 0, p3 = 0, p5 = 0; \n        vector<int> ugly(n, 1); \n        for (int i = 1;  i < n;  ++i) {\n            ugly[i] = min({ugly[p2] * 2, ugly[p3] * 3, ugly[p5] * 5}); \n            if (ugly[p2] * 2 == ugly[i]) {\n                ++p2; \n            }\n            \n            if (ugly[p3] * 3 == ugly[i]) {\n                ++p3; \n            }\n            \n            if (ugly[p5] * 5 == ugly[i]) {\n                ++p5; \n            }\n        }\n        \n        return ugly[n - 1];         \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPermutePalindrome. /*FC*/class Solution {\n/*FM*/bool canPermutePalindrome(string s) {\n        vector<int> table(128); \n        for (char c : s) {\n            ++table[c]; \n        }\n        \n        int odd = 0; \n        for (int i : table) {\n            if (i % 2) {\n                ++odd; \n                if (odd > 1) {\n                    \n                }\n            }\n        }\n        \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int missingNumber. /*FC*/class Solution {\n/*FM*/int missingNumber(vector<int>& nums) {\n        int result = nums.size(); \n        for (int i = 0;  i < nums.size();  ++i) {\n            result ^= i ^ nums[i]; \n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1347308448\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string encode. /*FC*/class Codec {\n/*FM*/string encode(vector<string>& strs) {\n        string result; \n        for (string& str : strs) {\n            result += to_string(str.size()) + '@' + str; \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Codec\": [\"Codec\", \"Codec()\"], \"strs\": [1], \"strs_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string numberToWords. /*FC*/class Solution {\n/*FM*/string numberToWords(int num) {\n        if (num == 0) {\n            \n        }\n        else {\n            return numberToString(num).substr(1); \n        }\n    };/*F*//*C*//*M*/string numberToString(int num) {\n        if (num >= 1000000000) {\n            return numberToString(num / 1000000000) + \" Billion\" + numberToString(num % 1000000000); \n        }\n        else if (num >= 1000000) {\n            return numberToString(num / 1000000) + \" Million\" + numberToString(num % 1000000); \n        }\n        else if (num >= 1000) {\n            return numberToString(num / 1000) + \" Thousand\" + numberToString(num % 1000); \n        }\n        else if (num >= 100) {\n            return numberToString(num / 100) + \" Hundred\" + numberToString(num % 100); \n        }\n        else if (num >= 20) {\n            return \" \" + below_100[num / 10 - 2] + numberToString(num % 10); \n        }\n        else if (num >= 1) {\n            return \" \" + below_20[num - 1]; \n        }\n        else {\n            return \"\"; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"-1321602438\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\n        sort(citations.begin(), citations.end(), greater<int>()); \n        int result = 0; \n        for (int i = citations.size() - 1;  i >= 0;  ) {\n            if (citations[i] >= i + 1) {\n                result = i + 1; \n                break; \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [1], \"citations_element0\": [\"1493463832\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\n        sort(citations.begin(), citations.end(), greater<int>()); \n        int result = 0; \n        for (int i = citations.size() - 1;  i >= 0;  --i) {\n            if (citations[i] >= i + 1) {\n                \n                \n            }\n        }\n        \n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [1], \"citations_element0\": [\"-365985250\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\n        int n = citations.size(); \n        int low = 0, high = n - 1; \n        while (low <= high) {\n            int mid = low + (high - low) / 2; \n            if (citations[mid] == n - mid) {\n                \n            }\n            else if (citations[mid] > n - mid) {\n                \n            }\n            else {\n                low = mid + 1; \n            }\n        }\n        \n        return n - low; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [1], \"citations_element0\": [\"-2115485691\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\n        int n = citations.size(); \n        int low = 0, high = n - 1; \n        while (low <= high) {\n            int mid = low + (high - low) / 2; \n            if (citations[mid] == n - mid) {\n                \n            }\n            else if (citations[mid] > n - mid) {\n                high = mid - 1; \n            }\n            else {\n                \n            }\n        }\n        \n        return n - low; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [1], \"citations_element0\": [\"1696449767\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numWays. /*FC*/class Solution {\n/*FM*/int numWays(int n, int k) {\n        if (n == 0) {\n            \n        }\n        else if (n == 1) {\n            \n        }\n        \n        int sameColor = k; \n        int diffColor = k * (k - 1); \n        for (int i = 3;  i <= n;  ++i) {\n            int temp = diffColor; \n            diffColor = sameColor * (k - 1) + diffColor * (k - 1); \n            sameColor = temp; \n        }\n        \n        return sameColor + diffColor; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"], \"k\": [\"399426494\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numWays. /*FC*/class Solution {\n/*FM*/int numWays(int n, int k) {\n        if (n == 0) {\n            return 0; \n        }\n        else if (n == 1) {\n            \n        }\n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"], \"k\": [\"-1476749083\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numWays. /*FC*/class Solution {\n/*FM*/int numWays(int n, int k) {\n        if (n == 0) {\n            \n        }\n        else if (n == 1) {\n            return k; \n        }\n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1\"], \"k\": [\"-1624333953\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSquares. /*FC*/class Solution {\n/*FM*/int numSquares(int n) {\n        vector<int> dp(1 + n); \n        for (int i = 0;  i <= n;  ++i) {\n            dp[i] = i; \n        }\n        \n        for (int i = 1;  i <= n;  ++i) {\n            for (int j = 1;  j * j <= i;  ++j) {\n                dp[i] = min(dp[i], 1 + dp[i - j * j]); \n            }\n        }\n        \n        return dp[n]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void wiggleSort. /*FC*/class Solution {\n/*FM*/void wiggleSort(vector<int>& nums) {\n        if (nums.size() == 0) {\n            \n        }\n        bool down = false; \n        for (int i = 0;  i < nums.size() - 1;  ) {\n            \n            \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"2012701638\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void push. /*FC*/class MyStack {\n/*FM*/void push(int x) {\n        Q.push(x); \n        int qs = Q.size(); \n        while (qs > 1) {\n            Q.push(Q.front()); \n            Q.pop(); \n            --qs; \n        }\n    };/*F*/queue<int> Q;/*C*/MyStack() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyStack\": [\"MyStack\", \"MyStack()\"], \"AKA_INSTANCE___MyStack->Q\": [1], \"AKA_INSTANCE___MyStack_Q_element0\": [\"1\"], \"x\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int peek. /*FC*/class MyQueue {\n/*FM*/int peek() {\n        if (S2.empty()) {\n            while (!S1.empty()) {\n                S2.push(S1.top()); \n                S1.pop(); \n            }\n        }\n        return S2.top(); \n    };/*F*/stack<int> S1;  stack<int> S2;/*C*/MyQueue() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyQueue\": [\"MyQueue\", \"MyQueue()\"], \"AKA_INSTANCE___MyQueue->S1\": [2], \"AKA_INSTANCE___MyQueue_S1_element0\": [\"1\"], \"AKA_INSTANCE___MyQueue_S1_element1\": [\"2\"], \"AKA_INSTANCE___MyQueue->S2\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int peek. /*FC*/class MyQueue {\n/*FM*/int peek() {\n        if (S2.empty()) {\n            while (!S1.empty()) {\n                \n                \n            }\n        }\n        return S2.top(); \n    };/*F*/stack<int> S1;  stack<int> S2;/*C*/MyQueue() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyQueue\": [\"MyQueue\", \"MyQueue()\"], \"AKA_INSTANCE___MyQueue->S1\": [0], \"AKA_INSTANCE___MyQueue->S2\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int peek. /*FC*/class MyQueue {\n/*FM*/int peek() {\n        if (S2.empty()) {\n            \n        }\n        return S2.top(); \n    };/*F*/stack<int> S2;/*C*/MyQueue() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MyQueue\": [\"MyQueue\", \"MyQueue()\"], \"AKA_INSTANCE___MyQueue->S1\": [2], \"AKA_INSTANCE___MyQueue_S1_element0\": [\"1\"], \"AKA_INSTANCE___MyQueue_S1_element1\": [\"2\"], \"AKA_INSTANCE___MyQueue->S2\": [2], \"AKA_INSTANCE___MyQueue_S2_element0\": [\"1\"], \"AKA_INSTANCE___MyQueue_S2_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void inorder. /*FC*/class Solution {\n/*FM*/void inorder(TreeNode* root, vector<int>& result) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        inorder(root->left, result); \n        handleVal(root->val, result); \n        inorder(root->right, result); \n    };/*F*//*C*//*M*/void inorder(TreeNode* root, vector<int>& result) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        inorder(root->left, result); \n        handleVal(root->val, result); \n        inorder(root->right, result); \n    } void inorder(TreeNode* root, vector<int>& result) {\n        if (root == nullptr) {\n            return; \n        }\n        \n        inorder(root->left, result); \n        handleVal(root->val, result); \n        inorder(root->right, result); \n    } void handleVal(int val, vector<int>& result) {\n        if (val != currVal) {\n            currVal = val; \n            currCount = 0; \n        }\n        \n        ++currCount; \n        if (currCount > maxCount) {\n            maxCount = currCount; \n            modeCount = 1; \n        }\n        else if (currCount == maxCount) {\n            ++modeCount; \n            if (result.size()) {\n                result[modeCount - 1] = val; \n            }\n        }        \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root[0].val\": [\"8\"], \"root[0].left\": [-1], \"root[0].right\": [-1], \"result\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void handleVal. /*FC*/class Solution {\n/*FM*/void handleVal(int val, vector<int>& result) {\n        if (val != currVal) {\n            \n            \n        }\n        \n        ++currCount; \n        if (currCount > maxCount) {\n            \n            \n        }\n        else if (currCount == maxCount) {\n            \n            \n        }        \n    };/*F*/int maxCount;  int currVal;  int currCount;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->maxCount\": [\"10\"], \"AKA_INSTANCE___Solution->modeCount\": [\"1\"], \"AKA_INSTANCE___Solution->currVal\": [\"1\"], \"AKA_INSTANCE___Solution->currCount\": [\"1\"], \"val\": [\"1\"], \"result\": [1], \"result_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void handleVal. /*FC*/class Solution {\n/*FM*/void handleVal(int val, vector<int>& result) {\n        if (val != currVal) {\n            currVal = val; \n            currCount = 0; \n        }\n        \n        ++currCount; \n        if (currCount > maxCount) {\n            \n            \n        }\n        else if (currCount == maxCount) {\n            \n            \n        }        \n    };/*F*/int maxCount;  int currVal;  int currCount;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->maxCount\": [\"10\"], \"AKA_INSTANCE___Solution->modeCount\": [\"1\"], \"AKA_INSTANCE___Solution->currVal\": [\"1\"], \"AKA_INSTANCE___Solution->currCount\": [\"1\"], \"val\": [\"2\"], \"result\": [1], \"result_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void handleVal. /*FC*/class Solution {\n/*FM*/void handleVal(int val, vector<int>& result) {\n        if (val != currVal) {\n            currVal = val; \n            currCount = 0; \n        }\n        \n        ++currCount; \n        if (currCount > maxCount) {\n            maxCount = currCount; \n            modeCount = 1; \n        }\n        else if (currCount == maxCount) {\n            \n            \n        }        \n    };/*F*/int maxCount;  int modeCount;  int currVal;  int currCount;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->maxCount\": [\"0\"], \"AKA_INSTANCE___Solution->modeCount\": [\"1\"], \"AKA_INSTANCE___Solution->currVal\": [\"10\"], \"AKA_INSTANCE___Solution->currCount\": [\"10\"], \"val\": [\"1\"], \"result\": [1], \"result_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void handleVal. /*FC*/class Solution {\n/*FM*/void handleVal(int val, vector<int>& result) {\n        if (val != currVal) {\n            \n            \n        }\n        \n        ++currCount; \n        if (currCount > maxCount) {\n            \n            \n        }\n        else if (currCount == maxCount) {\n            ++modeCount; \n            if (result.size()) {\n                result[modeCount - 1] = val; \n            }\n        }        \n    };/*F*/int maxCount;  int modeCount;  int currVal;  int currCount;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->maxCount\": [\"3\"], \"AKA_INSTANCE___Solution->modeCount\": [\"1\"], \"AKA_INSTANCE___Solution->currVal\": [\"1\"], \"AKA_INSTANCE___Solution->currCount\": [\"2\"], \"val\": [\"1\"], \"result\": [1], \"result_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void handleVal. /*FC*/class Solution {\n/*FM*/void handleVal(int val, vector<int>& result) {\n        if (val != currVal) {\n            \n            \n        }\n        \n        ++currCount; \n        if (currCount > maxCount) {\n            \n            \n        }\n        else if (currCount == maxCount) {\n            ++modeCount; \n            if (result.size()) {\n                \n            }\n        }        \n    };/*F*/int maxCount;  int modeCount;  int currVal;  int currCount;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->maxCount\": [\"3\"], \"AKA_INSTANCE___Solution->modeCount\": [\"1\"], \"AKA_INSTANCE___Solution->currVal\": [\"1\"], \"AKA_INSTANCE___Solution->currCount\": [\"2\"], \"val\": [\"1\"], \"result\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution2 {\n/*FM*/bool isNumber(string s) {\n        \n        map<string, int> dfa[8] = {\n            {{\"digit\", 1}, {\"sign\", 2}, {\"dot\", 3}},\n            {{\"digit\", 1}, {\"dot\", 4}, {\"exponent\", 5}},\n            {{\"digit\", 1}, {\"dot\", 3}},\n            {{\"digit\", 4}},\n            {{\"digit\", 4}, {\"exponent\", 5}},\n            {{\"sign\", 6}, {\"digit\", 7}},\n            {{\"digit\", 7}},\n            {{\"digit\", 7}}\n        }; \n        int current_state = 0; \n        string group; \n        for (char c : s) {\n            if (isdigit(c)) {\n                \n            } else if (c == '+' || c == '-') {\n                \n            } else if (c == 'e' || c == 'E') {\n                \n            } else if (c == '.') {\n                \n            } else {\n                return false; \n            }\n            \n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution2 {\n/*FM*/bool isNumber(string s) {\n        \n        map<string, int> dfa[8] = {\n            {{\"digit\", 1}, {\"sign\", 2}, {\"dot\", 3}},\n            {{\"digit\", 1}, {\"dot\", 4}, {\"exponent\", 5}},\n            {{\"digit\", 1}, {\"dot\", 3}},\n            {{\"digit\", 4}},\n            {{\"digit\", 4}, {\"exponent\", 5}},\n            {{\"sign\", 6}, {\"digit\", 7}},\n            {{\"digit\", 7}},\n            {{\"digit\", 7}}\n        }; \n        int current_state = 0; \n        string group; \n        for (char c : s) {\n            if (isdigit(c)) {\n                group = \"digit\"; \n            } else if (c == '+' || c == '-') {\n                \n            } else if (c == 'e' || c == 'E') {\n                \n            } else if (c == '.') {\n                \n            } else {\n                \n            }\n            if (dfa[current_state].find(group) == dfa[current_state].end()) {\n                \n            }\n            current_state = dfa[current_state][group]; \n        }\n        return current_state == 1 || current_state == 4 || current_state == 7; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(string s) {\n        bool seenDigit = false;  \n        bool seenExponent = false; \n        bool seenDot = false; \n        for(int i = 0;  i < s.size();  ){\n            char c = s[i]; \n            if (c >= '0' && c <= '9')\n                \n            else if (c == '+' || c == '-'){\n                } else if (c == 'e' || c == 'E'){\n                    \n                 \n            } else if (c == '.'){ \n                    \n            } else \n                return false; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strStr. /*FC*/class Solution {\n/*FM*/int strStr(string haystack, string needle) {\n        if(needle.empty()){\n            \n        }\n        return kmp(haystack, needle); \n    };/*F*//*C*//*M*/int kmp(const string &text, const string & pattern){\n        vector<int>prefix = computePrefix(pattern); \n        int j = 0;  \n        for(int i = 0;  i<text.size();  i++){\n            while(j>0 && pattern[j]!=text[i])\n                j = prefix[j-1]; \n            if(pattern[j] == text[i])\n                j++; \n            \n            if(j == pattern.size())\n                return i - j + 1; \n        }\n        return -1; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [\"1\"], \"needle\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int kmp. /*FC*/class Solution {\n/*FM*/int kmp(const string &text, const string & pattern){\n        vector<int>prefix = computePrefix(pattern); \n        int j = 0;  \n        for(int i = 0;  i<text.size();  i++){\n            while(j>0 && pattern[j]!=text[i])\n                \n            if(pattern[j] == text[i])\n                \n            \n            if(j == pattern.size())\n                \n        }\n        return -1; \n    };/*F*//*C*//*M*/vector<int>computePrefix(const string& pattern){\n        vector<int>p(pattern.size()); \n        int j = 0; \n        for(int i = 1;  i<pattern.size();  i++){\n            while(j>0 && pattern[j]!= pattern[i]){\n                j = p[j-1]; \n            }\n            if(pattern[j] ==pattern[i])\n                j++; \n            \n           p[i] = j; \n        }\n        return p; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"text\": [\"2\"], \"pattern\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int>computePrefix. /*FC*/class Solution {\n/*FM*/vector<int>computePrefix(const string& pattern){\n        vector<int>p(pattern.size()); \n        int j = 0; \n        for(int i = 1;  i<pattern.size();  ){\n            \n            if(pattern[j] ==pattern[i])\n                \n            \n           \n        }\n        return p; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pattern\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strStr. /*FC*/class Solution2 {\n/*FM*/int strStr(string haystack, string needle) {\n        for (int i = 0;  i + needle.length() < haystack.length() + 1;  ++i) {\n            if (haystack.substr(i, needle.length()) == needle) {\n                \n            }\n        }\n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"haystack\": [\"2\"], \"needle\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution {\n/*FM*/string longestCommonPrefix(vector<string>& strs) {\n        if(strs.empty()) \n        string res = strs[0]; \n        for(int i = 1;  i<strs.size() && !res.empty();  ){\n            \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [1], \"strs_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution2 {\n/*FM*/string longestCommonPrefix(vector<string>& strs) {\n        if(strs.empty()) \n        for(int i = 0;  i<strs[0].size();  i++){\n            for(auto str: strs){\n                if(i>=str.size() || str[i] != strs[0][i]){\n                    \n                }\n            }\n        }\n        return strs[0]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"strs\": [1], \"strs_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution3 {\n/*FM*/string longestCommonPrefix(vector<string>& strs) {\n        string prefix = \"\"; \n        for(int idx=0;  strs.size()>0;  prefix+=strs[0][idx], idx++)\n            for(int i=0;  i<strs.size();  i++)\n                if(idx >= strs[i].size() ||(i > 0 && strs[i][idx] != strs[i-1][idx]))\n                    return prefix; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"strs\": [1], \"strs_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string s) {\n        int i = 0, j = s.size()-1; \n        while(i < j )\n        {\n                              if(i>=j) \n            if(tolower(s[i]) != tolower(s[j])) \n                \n\n             \n        }\n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void cleanString. /*FC*/class Solution2 {\n/*FM*/void cleanString(string& s) {\n        s.erase(remove_if(s.begin(), s.end(), [] (char &c) {\n            return !(isalpha(c) || isdigit(c)); \n        }), s.end()); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution2 {\n/*FM*/bool isPalindrome(string s) {\n        cleanString(s); \n        \n        int n = s.size(); \n        for (int i = 0;  i < n / 2;  ) {\n            \n        }\n        \n        return true; \n    };/*F*//*C*//*M*/void cleanString(string& s) {\n        s.erase(remove_if(s.begin(), s.end(), [] (char &c) {\n            return !(isalpha(c) || isdigit(c)); \n        }), s.end()); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reverseWords. /*FC*/class Solution {\n/*FM*/void reverseWords(string &s) {\n        reverse(s.begin(), s.end()); \n        size_t begin = 0, end = 0, len = 0; \n        while((begin = s.find_first_not_of(' ', end)) != string::npos){\n            if( (end = s.find_first_of(' ', begin)) == string::npos)\n                end =  s.size(); \n            reverse(s.begin()+begin, s.begin() +end ); \n            move(s.begin() +begin, s.begin()+end, s.begin()+len); \n            len += end - begin; \n            s[len++] = ' '; \n        }\n        if(len > 0)\n            s = s.substr(0,len-1); \n        else\n            \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\n        int i = a.size() - 1, j = b.size() -1, carry = 0; \n        vector<int>vec; \n        while (i >= 0 || j >= 0 || carry >0){\n            if(i>=0)  carry += ( a[i] - '0'); \n            if(j>= 0) carry += (b[j] - '0'); \n            vec.push_back(carry%2); \n            carry >>=1 ; \n            i--;  j--; \n        }\n        string res; \n        transform(vec.rbegin(), vec.rend(), back_inserter(res), [](const int & i){return i+'0'; }); \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"3\"], \"b\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution2 {\n/*FM*/string addBinary(string a, string b) {\n        int i = a.size() - 1, j = b.size() -1, carry = 0; \n        string res; \n        vector<int>vec; \n        while (i >= 0 || j >= 0 || carry >0){\n            if(i>=0)  carry += ( a[i] - '0'); \n            if(j>= 0) carry += (b[j] - '0'); \n            res+=to_string(carry%2); \n            carry >>=1 ; \n            i--;  j--; \n        }\n        reverse(res.begin(),res.end()); \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"a\": [\"1\"], \"b\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAdditiveNumber. /*FC*/class Solution {\n/*FM*/bool isAdditiveNumber(string num) {\n        for(int i = 1;  i<=num.size()/2; ){\n            \n        }\n        return false; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> fullJustify. /*FC*/class Solution {\n/*FM*/vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        vector<string>res; \n        for(int i = 0, j = 0;  i<words.size();  i = j){\n            int width = 0; \n            for(;  j<words.size() && width+words[j].size()+j - i<=maxWidth;  j++)\n                width += words[j].size(); \n            int space = 1, extra = 0; \n            if(j-i> 1 && j!= words.size()){\n                \n                \n            }\n            string cur = words[i++]; \n            for(; i<j;  ){\n                \n                \n                \n            }\n            cur += string(maxWidth - cur.size(), ' '); \n            res.push_back(cur); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"3\"], \"maxWidth\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(string s) {\n        int count = 0; \n        int i = s.size()-1; \n        while(i>=0 && s[i]==' ') \n        int start = i; \n        for(;  i>=0 && s[i]!=' ';  i--); \n        return start - i; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution2 {\n/*FM*/int lengthOfLastWord(string s) { \n        int len = 0, tail = s.length() - 1; \n        while (tail >= 0 && s[tail] == ' ') \n        while (tail >= 0 && s[tail] != ' ') {\n            len++; \n            tail--; \n        }\n        return len; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution3 {\n/*FM*/int lengthOfLastWord(string s) {\n        size_t start = s.find_last_not_of(' '); \n        if (start == string::npos) \n        if(start == 0) return 1; \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/ {\n/*FM*/int lengthOfLastWord(const char* s) {\n        int len = 0; \n        while (*s) {\n            if (*s++ != ' ')\n                ++len; \n            else if (*s && *s != ' ')\n                \n    \n        }\n        return len; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [1], \"s_constantPointer[0]\": [\"92\"], \"s_constantPointer[1]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getIndex. /*FC*/class MKAverage {\n/*FM*/int getIndex(int need){\n        int l = 1, r = 100000; \n        while(l < r){\n            int mid = (l + r) / 2; \n            if(index.getSum(mid) < need)\n                \n            else r = mid; \n        }\n        return l; \n    };/*F*/BITtree index;/*C*/MKAverage(int m, int k): m(m), k(k), value(100001), index(100001) { };/*M*/long getSum(int index){\n                long tot = 0; \n                while(index){\n                    tot += sums[index]; \n                    index &= index - 1; \n                }\n                return tot; \n            };\n}",
        "target": "{\"AKA_INSTANCE___MKAverage\": [\"MKAverage\", \"MKAverage(int,int)\"], \"AKA_INSTANCE___MKAverage_m\": [\"320606426\"], \"AKA_INSTANCE___MKAverage_k\": [\"-46082116\"], \"AKA_INSTANCE___MKAverage->index\": [\"BITtree\", \"BITtree(int)\"], \"AKA_INSTANCE___MKAverage_index_n_\": [\"568827045\"], \"AKA_INSTANCE___MKAverage->m\": [\"320606426\"], \"AKA_INSTANCE___MKAverage->k\": [\"-46082116\"], \"need\": [\"-1004225945\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getIndex. /*FC*/class MKAverage {\n/*FM*/int getIndex(int need){\n        int l = 1, r = 100000; \n        while(l < r){\n            int mid = (l + r) / 2; \n            if(index.getSum(mid) < need)\n                l = mid + 1; \n            else \n        }\n        return l; \n    };/*F*/BITtree index;/*C*/MKAverage(int m, int k): m(m), k(k), value(100001), index(100001) { };/*M*/long getSum(int index){\n                long tot = 0; \n                while(index){\n                    tot += sums[index]; \n                    index &= index - 1; \n                }\n                return tot; \n            };\n}",
        "target": "{\"AKA_INSTANCE___MKAverage\": [\"MKAverage\", \"MKAverage(int,int)\"], \"AKA_INSTANCE___MKAverage_m\": [\"900456024\"], \"AKA_INSTANCE___MKAverage_k\": [\"-1998442724\"], \"AKA_INSTANCE___MKAverage->index\": [\"BITtree\", \"BITtree(int)\"], \"AKA_INSTANCE___MKAverage_index_n_\": [\"1514290720\"], \"AKA_INSTANCE___MKAverage->m\": [\"900456024\"], \"AKA_INSTANCE___MKAverage->k\": [\"-1998442724\"], \"need\": [\"906473276\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxFrequency. /*FC*/class Solution2 {\n/*FM*/int maxFrequency(vector<int>& nums, int k) {\n        int i = 0, j; \n        sort(nums.begin(), nums.end()); \n        for (j = 0;  j < nums.size();  ++j) {\n            k += nums[j]; \n            if (k < (long)nums[j] * (j - i + 1))\n                k -= nums[i++]; \n        }\n        return j - i; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"nums\": [2], \"nums_element0\": [\"1565197777\"], \"nums_element1\": [\"-1041629402\"], \"k\": [\"1569604895\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxFrequency. /*FC*/class Solution {\n/*FM*/int maxFrequency(vector<int>& nums, int k) {\n        int res = 1, start = 0; \n        long cur = 0; \n        sort(nums.begin(), nums.end()); \n        for(int i = 1;  i<nums.size();  ++i){\n            cur += static_cast<long>( (nums[i] - nums[i-1])) * (i-start);  \n            while(cur > k && start <= i){\n                cur -= (nums[i] - nums[start++]); \n            }\n            res = max(res, i - start + 1); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"2147134386\"], \"nums_element1\": [\"1359893456\"], \"k\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxFrequency. /*FC*/class Solution3 {\n/*FM*/int maxFrequency(vector<int>& A, int k) {\n        sort(begin(A), end(A)); \n        long i = 0, N = A.size(), ans = 1, sum = 0; \n        for (int j = 0;  j < N;  ++j) {\n            sum += A[j]; \n            while ((j - i + 1) * A[j] - sum > k) sum -= A[i++]; \n            ans = max(ans, j - i + 1); \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"A\": [2], \"A_element0\": [\"1343215691\"], \"A_element1\": [\"-1787185528\"], \"k\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sumBase. /*FC*/class Solution {\n/*FM*/int sumBase(int n, int k) {\n        int res = 0; \n        for (;  n > 0;  n /= k)\n            res += n % k; \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"3\"], \"k\": [\"-1594678998\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minAbsoluteSumDiff. /*FC*/class Solution {\n/*FM*/int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {\n        set<int>st(nums1.begin(), nums1.end()); \n        long res = 0; \n        long mod = pow(10, 9) + 7; \n        long gain = 0; \n        for(int i = 0;  i<nums1.size();  ++i){\n            long cur = abs(nums1[i] - nums2[i]); \n            auto it = st.upper_bound(nums2[i]); \n            if(it!= st.end())\n                \n            if(it != st.begin())\n                gain = max(gain, cur - abs(nums2[i] - *prev(it))); \n            res = (res + cur) % mod; \n        }\n        return (res - gain)% mod; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [1], \"nums1_element0\": [\"-643729556\"], \"nums2\": [1], \"nums2_element0\": [\"1828588850\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minAbsoluteSumDiff. /*FC*/class Solution {\n/*FM*/int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {\n        set<int>st(nums1.begin(), nums1.end()); \n        long res = 0; \n        long mod = pow(10, 9) + 7; \n        long gain = 0; \n        for(int i = 0;  i<nums1.size();  ++i){\n            long cur = abs(nums1[i] - nums2[i]); \n            auto it = st.upper_bound(nums2[i]); \n            if(it!= st.end())\n                gain = max(gain, cur - abs(nums2[i] - *it)); \n            if(it != st.begin())\n                gain = max(gain, cur - abs(nums2[i] - *prev(it))); \n            res = (res + cur) % mod; \n        }\n        return (res - gain)% mod; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"1420192064\"], \"nums1_element1\": [\"-1269557933\"], \"nums2\": [2], \"nums2_element0\": [\"685671952\"], \"nums2_element1\": [\"623604833\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxIceCream. /*FC*/class Solution {\n/*FM*/int maxIceCream(vector<int>& costs, int coins) {\n        sort(costs.begin(), costs.end()); \n        for (int i = 0;  i < costs.size();  )\n            if ((coins -= costs[i]) < 0)\n                return i; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"costs\": [2], \"costs_element0\": [\"145766228\"], \"costs_element1\": [\"-1616610523\"], \"coins\": [\"-1625376875\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxIceCream. /*FC*/class Solution {\n/*FM*/int maxIceCream(vector<int>& costs, int coins) {\n        sort(costs.begin(), costs.end()); \n        for (int i = 0;  i < costs.size();  ++i)\n            if ((coins -= costs[i]) < 0)\n                \n        return costs.size(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"costs\": [1], \"costs_element0\": [\"-260419723\"], \"coins\": [\"-24972905\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxIceCream. /*FC*/class Solution2 {\n/*FM*/int maxIceCream(vector<int>& costs, int coins) {\n        sort(begin(costs), end(costs)); \n        for (int i = 0;  i < costs.size();  ++i)\n            if (coins >= costs[i])\n                coins -= costs[i]; \n            else\n                return i; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"costs\": [2], \"costs_element0\": [\"-1728838204\"], \"costs_element1\": [\"1033452027\"], \"coins\": [\"1436390072\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxIceCream. /*FC*/class Solution2 {\n/*FM*/int maxIceCream(vector<int>& costs, int coins) {\n        sort(begin(costs), end(costs)); \n        for (int i = 0;  i < costs.size();  ++i)\n            if (coins >= costs[i])\n                coins -= costs[i]; \n            else\n                \n        return costs.size(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"costs\": [1], \"costs_element0\": [\"-1225484998\"], \"coins\": [\"1623876260\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheWinner. /*FC*/class Solution {\n/*FM*/int findTheWinner(int n, int k) {\n        int a = 0;  \n        for(int i = 1;  i<=n;  ++i){\n            a = (a + k) % i; \n        }\n        return a + 1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"6\"], \"k\": [\"341858845\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheWinner. /*FC*/class Solution2 {\n/*FM*/int findTheWinner(int n, int k) {\n        int a = 0;  \n        for(int i = 1;  i<=n;  ++i){\n            a = (a + k - 1) % i; \n            ++a; \n        }\n        return a; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"n\": [\"6\"], \"k\": [\"-1755719313\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheWinner. /*FC*/class Solution4 {\n/*FM*/int findTheWinner(int n, int k) {\n        queue<int> q; \n        for(int i=1; i<=n; i++){\n            q.push(i); \n        }\n        while(q.size()!=1){\n            int x=k; \n            while(x>1){\n                int r=q.front(); \n                q.pop(); \n                q.push(r); \n                x--; \n            }\n            q.pop(); \n        }\n        return q.front(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"n\": [\"8\"], \"k\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheWinner. /*FC*/class Solution5 {\n/*FM*/int findTheWinner(int n, int k) {\n        vector<bool> f(n, true); \n        int i = 0, cnt = n; \n        while (cnt > 1) {\n            for (int j = 0;  j < k;  ++j, ++i) {\n                while(!f[i % n])\n                    ++i; \n            }\n            f[(i - 1) % n] = false; \n            --cnt; \n        }\n        for (i = 0;  !f[i];  ++i); \n        return i  + 1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"n\": [\"3\"], \"k\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numOfMinutes. /*FC*/class Solution {\n/*FM*/int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int res = 0; \n        for (int i = 0;  i < n;  )\n            \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"], \"headID\": [\"1807619090\"], \"manager\": [2], \"manager_element0\": [\"-1729840349\"], \"manager_element1\": [\"1836562898\"], \"informTime\": [2], \"informTime_element0\": [\"-1856776988\"], \"informTime_element1\": [\"-2010364484\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxNumberOfFamilies. /*FC*/class Solution2 {\n/*FM*/int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats) {\n        sort(begin(reservedSeats), end(reservedSeats)); \n        int result = 2 * n; \n        for (int i = 0;  i < reservedSeats.size(); ) {\n            unordered_map<int, bool> reserved; \n            int curr = reservedSeats[i][0]; \n            while (i < reservedSeats.size() && reservedSeats[i][0] == curr) {\n                if (2 <= reservedSeats[i][1] && reservedSeats[i][1] <= 5) {\n                    \n                }\n                if (4 <= reservedSeats[i][1] && reservedSeats[i][1] <= 7) {\n                    \n                }\n                if (6 <= reservedSeats[i][1] && reservedSeats[i][1] <= 9) {\n                    \n                }\n                ++i; \n            }\n            if (!reserved[0] && !reserved[2]) {\n                continue; \n            }\n            if (!reserved[0] || !reserved[1] || !reserved[2]) {\n                \n                \n            }\n            \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"n\": [\"-581763422\"], \"reservedSeats\": [2], \"reservedSeats_element0\": [1], \"reservedSeats_element0_element0\": [\"-623790428\"], \"reservedSeats_element1\": [1], \"reservedSeats_element1_element0\": [\"2123081913\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxNumberOfFamilies. /*FC*/class Solution {\n/*FM*/int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats) {\n        unordered_map<int, unordered_map<int, bool>> lookup; \n        for (const auto& seat : reservedSeats) {\n            if (2 <= seat[1] && seat[1] <= 5) {\n                \n            }\n            if (4 <= seat[1] && seat[1] <= 7) {\n                \n            }\n            if (6 <= seat[1] && seat[1] <= 9) {\n                \n            }\n        }\n        int result = 2 * n; \n        for (auto& [_, reserved] : lookup) {\n            \n            if (!reserved[0] || !reserved[1] || !reserved[2]) {\n                \n                \n            }\n            \n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"438092724\"], \"reservedSeats\": [2], \"reservedSeats_element0\": [1], \"reservedSeats_element0_element0\": [\"-760383699\"], \"reservedSeats_element1\": [1], \"reservedSeats_element1_element0\": [\"1343460730\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void push. /*FC*/class CustomStack {\n/*FM*/void push(int x) {\n        if (stack.size() == n) \n        stack.push_back(x); \n        inc.push_back(0); \n    };/*F*/vector<int> stack;  vector<int> inc;  int n;/*C*/CustomStack(int maxSize) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___CustomStack\": [\"CustomStack\", \"CustomStack(int)\"], \"AKA_INSTANCE___CustomStack_maxSize\": [\"1073011761\"], \"AKA_INSTANCE___CustomStack->stack\": [2], \"AKA_INSTANCE___CustomStack_stack_element0\": [\"-448813042\"], \"AKA_INSTANCE___CustomStack_stack_element1\": [\"-1616203194\"], \"AKA_INSTANCE___CustomStack->inc\": [2], \"AKA_INSTANCE___CustomStack_inc_element0\": [\"1464894781\"], \"AKA_INSTANCE___CustomStack_inc_element1\": [\"652040738\"], \"AKA_INSTANCE___CustomStack->n\": [\"1096707685\"], \"x\": [\"925743335\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void increment. /*FC*/class CustomStack {\n/*FM*/void increment(int k, int val) {\n        int i = min(k, (int)stack.size()) - 1; \n        if (i >= 0) \n    };/*F*/vector<int> stack;/*C*/CustomStack(int maxSize) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___CustomStack\": [\"CustomStack\", \"CustomStack(int)\"], \"AKA_INSTANCE___CustomStack_maxSize\": [\"-448942777\"], \"AKA_INSTANCE___CustomStack->stack\": [1], \"AKA_INSTANCE___CustomStack_stack_element0\": [\"-1087266861\"], \"AKA_INSTANCE___CustomStack->inc\": [2], \"AKA_INSTANCE___CustomStack_inc_element0\": [\"1528156159\"], \"AKA_INSTANCE___CustomStack_inc_element1\": [\"1854664171\"], \"k\": [\"-4462443\"], \"val\": [\"-1107476496\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void increment. /*FC*/class CustomStack {\n/*FM*/void increment(int k, int val) {\n        int i = min(k, (int)stack.size()) - 1; \n        if (i >= 0) inc[i] += val; \n    };/*F*/vector<int> stack;  vector<int> inc;/*C*/CustomStack(int maxSize) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___CustomStack\": [\"CustomStack\", \"CustomStack(int)\"], \"AKA_INSTANCE___CustomStack_maxSize\": [\"-1740998725\"], \"AKA_INSTANCE___CustomStack->stack\": [1], \"AKA_INSTANCE___CustomStack_stack_element0\": [\"-381413401\"], \"AKA_INSTANCE___CustomStack->inc\": [2], \"AKA_INSTANCE___CustomStack_inc_element0\": [\"2102835610\"], \"AKA_INSTANCE___CustomStack_inc_element1\": [\"-1591306128\"], \"k\": [\"999906128\"], \"val\": [\"-1795472225\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheDistanceValue. /*FC*/class Solution {\n/*FM*/int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\n        sort(arr2.begin(), arr2.end()); \n        int cnt = 0; \n        for(auto i: arr1){\n            int l = distance(arr2.begin(), lower_bound(arr2.begin(), arr2.end(), i)); \n            int left = l != 0 ? arr2[l-1] : numeric_limits<int>::min(); \n            int right = l != arr2.size() ? arr2[l] : numeric_limits<int>::max(); \n            \n            cnt += left + d < i && right - d > i; \n        }\n        return cnt; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr1\": [2], \"arr1_element0\": [\"1788370693\"], \"arr1_element1\": [\"-1670950207\"], \"arr2\": [1], \"arr2_element0\": [\"37738743\"], \"d\": [\"332792864\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheDistanceValue. /*FC*/class Solution2 {\n/*FM*/int findTheDistanceValue(vector<int>& a1, vector<int>& a2, int d) {\n        sort(a2.begin(), a2.end()); \n        int ans = 0; \n        for (int i : a1) {\n            auto lb = lower_bound(a2.begin(), a2.end(), i - d); \n            auto ub = upper_bound(a2.begin(), a2.end(), i + d); \n            if (lb == ub)\n                \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"a1\": [2], \"a1_element0\": [\"-1762900260\"], \"a1_element1\": [\"1150838977\"], \"a2\": [2], \"a2_element0\": [\"-43283392\"], \"a2_element1\": [\"-411552475\"], \"d\": [\"1020109938\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheDistanceValue. /*FC*/class Solution2 {\n/*FM*/int findTheDistanceValue(vector<int>& a1, vector<int>& a2, int d) {\n        sort(a2.begin(), a2.end()); \n        int ans = 0; \n        for (int i : a1) {\n            auto lb = lower_bound(a2.begin(), a2.end(), i - d); \n            auto ub = upper_bound(a2.begin(), a2.end(), i + d); \n            if (lb == ub)\n                ans++; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"a1\": [1], \"a1_element0\": [\"-1647173968\"], \"a2\": [1], \"a2_element0\": [\"-958275671\"], \"d\": [\"-1877261158\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheDistanceValue. /*FC*/class Solution3 {\n/*FM*/int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\n        sort(arr1.begin(), arr1.end()); \n        sort(arr2.begin(), arr2.end()); \n        int cnt = 0, i = 0; \n        for(int j = 0;  i<arr1.size() && j < arr2.size(); ){\n            if (arr1[i] - d > arr2[j]) ++j; \n            else \n                cnt += arr1[i++] + d < arr2[j]; \n        }\n        return cnt + arr1.size() - i; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"arr1\": [2], \"arr1_element0\": [\"67124575\"], \"arr1_element1\": [\"-475025335\"], \"arr2\": [2], \"arr2_element0\": [\"-1761689739\"], \"arr2_element1\": [\"1812169224\"], \"d\": [\"-721468431\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheDistanceValue. /*FC*/class Solution4 {\n/*FM*/int findTheDistanceValue(vector<int>& a1, vector<int>& a2, int d) {\n        sort(a2.begin(), a2.end()); \n        int ans = 0; \n        for (int i : a1) {\n            auto lb = lower_bound(a2.begin(), a2.end(), i - d); \n            auto ub = upper_bound(a2.begin(), a2.end(), i + d); \n            if (lb == ub)\n                ans++; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"a1\": [2], \"a1_element0\": [\"264697387\"], \"a1_element1\": [\"-1328603833\"], \"a2\": [1], \"a2_element0\": [\"-984608558\"], \"d\": [\"1715271001\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findTheDistanceValue. /*FC*/class Solution5 {\n/*FM*/int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\n        sort(arr1.begin(), arr1.end()); \n        sort(arr2.begin(), arr2.end()); \n        int idx=0, res=0; \n        for(int i=0; i<arr1.size(); i++) {\n            if(idx>=arr2.size()||arr1[i]<arr2[idx]-d) res++; \n            else if(arr1[i]>arr2[idx]+d) idx++, i--; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"arr1\": [2], \"arr1_element0\": [\"-1285493402\"], \"arr1_element1\": [\"-175809469\"], \"arr2\": [1], \"arr2_element0\": [\"-343601672\"], \"d\": [\"-93289386\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxPerformance. /*FC*/class Solution {\n/*FM*/int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {\n        multiset<vector<int>>pq; \n        for(int i = 0;  i<n;  ++i)\n            pq.insert({-efficiency[i], speed[i]}); \n        long long cur = 0, res = 0, mod = pow(10,9)+7; \n        multiset<int>topSpeed; \n        for(auto it: pq){\n            cur += it[1];  \n            topSpeed.insert(it[1]); \n            if(topSpeed.size() > k){\n                \n                \n            }\n            res = max(cur*(-it[0]), res); \n        }\n        return res % (mod); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"7\"], \"speed\": [2], \"speed_element0\": [\"986637837\"], \"speed_element1\": [\"-2018360939\"], \"efficiency\": [2], \"efficiency_element0\": [\"-198674835\"], \"efficiency_element1\": [\"-304131315\"], \"k\": [\"736267444\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxPerformance. /*FC*/class Solution2 {\n/*FM*/int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {\n        priority_queue<vector<int>>pq; \n        for(int i = 0;  i<n;  ++i)\n            pq.push({efficiency[i], speed[i]}); \n\t\t\t\n        long long cur = 0, res = 0, mod = pow(10,9)+7; \n        priority_queue<int>topSpeed; \n        for(int i = 0;  i<n;  ++i){\n            auto top = pq.top(); \n            cur += top[1];  pq.pop(); \n            topSpeed.push(-top[1]); \n\t\t\t\n            if(topSpeed.size() > k){\n                \n                \n            }\n            res = max(cur*top[0], res); \n        }\n        return res % (mod); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"n\": [\"4\"], \"speed\": [2], \"speed_element0\": [\"1851641423\"], \"speed_element1\": [\"2143260133\"], \"efficiency\": [1], \"efficiency_element0\": [\"-1943757227\"], \"k\": [\"-1566503500\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxPerformance. /*FC*/class Solution3 {\n/*FM*/int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {\n        vector<pair<int, int>> ess; \n        for (int i = 0;  i < n;  ++i)\n            ess.push_back({efficiency[i], speed[i]}); \n        sort(begin(ess), end(ess)); \n\n        long sumS = 0, res = 0; \n        priority_queue <int, vector<int>, greater<int> > pq; \n        for (int i = n - 1;  i >= 0;  --i) {\n            pq.push(ess[i].second); \n            sumS += ess[i].second; \n            if (pq.size() > k) {\n                \n                \n            }\n            res = max(res, sumS * ess[i].first); \n        }\n        return res % (int)(1e9+7); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"n\": [\"4\"], \"speed\": [1], \"speed_element0\": [\"-115903362\"], \"efficiency\": [1], \"efficiency_element0\": [\"894320943\"], \"k\": [\"-1534464283\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void inorderTraverse. /*FC*/class Solution {\n/*FM*/void inorderTraverse(TreeNode* root) {\n        if (root == NULL) return; \n        inorderTraverse(root->left); \n        sortedArr.push_back(root->val); \n        inorderTraverse(root->right); \n    };/*F*/vector<int> sortedArr;/*C*//*M*/void inorderTraverse(TreeNode* root) {\n        if (root == NULL) return; \n        inorderTraverse(root->left); \n        sortedArr.push_back(root->val); \n        inorderTraverse(root->right); \n    } void inorderTraverse(TreeNode* root) {\n        if (root == NULL) return; \n        inorderTraverse(root->left); \n        sortedArr.push_back(root->val); \n        inorderTraverse(root->right); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->sortedArr\": [2], \"AKA_INSTANCE___Solution_sortedArr_element0\": [\"-788656866\"], \"AKA_INSTANCE___Solution_sortedArr_element1\": [\"125120156\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_val\": [\"385869611\"], \"root[0].val\": [\"385869611\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_val\": [\"-1195057152\"], \"root[0].left[0].val\": [\"-1195057152\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_val\": [\"210537065\"], \"root[1].val\": [\"210537065\"], \"root[1].left\": [3], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_val\": [\"-566668226\"], \"root[1].left[0].val\": [\"-566668226\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left1_val\": [\"-1873173784\"], \"root[1].left[1].val\": [\"-1873173784\"], \"root[1].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left2_val\": [\"-1298566916\"], \"root[1].left[2].val\": [\"-1298566916\"], \"root[1].right\": [1], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_right0_val\": [\"1935967202\"], \"root[1].right[0].val\": [\"1935967202\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numTimesAllBlue. /*FC*/class Solution {\n/*FM*/int numTimesAllBlue(vector<int>& A) {\n        int right = 0, res = 0, n = A.size(); \n        for (int i = 0;  i < n;  ++i)\n            res += (right = max(right, A[i])) == i + 1; \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"-1817981959\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> luckyNumbers . /*FC*/class Solution {\n/*FM*/vector<int> luckyNumbers (vector<vector<int>>& matrix) {\n        \n        \n        int m(matrix.size()), n(matrix[0].size()); \n\t\t\n        vector<int> mins(m, 100001), maxs(n); \n        vector<int> lucky; \n        for (int i = 0;  i < m;  ++i)\n            for (int j = 0;  j < n;  ++j)\n                mins[i] = min(mins[i], matrix[i][j]); \n        for (int j = 0;  j < n;  ++j)\n            for (int i = 0;  i < m;  ++i)\n                maxs[j] = max(maxs[j], matrix[i][j]); \n        for (int i = 0;  i < m;  ++i)\n            for (int j = 0;  j < n;  ++j)\n                if (maxs[j] == matrix[i][j] && mins[i] == matrix[i][j])\n                    \n        return lucky; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"36138369\"], \"matrix_element0_element1\": [\"1124393139\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"1549072131\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> luckyNumbers . /*FC*/class Solution2 {\n/*FM*/vector<int> luckyNumbers (vector<vector<int>>& matrix) {\n        \n        \n        int m(matrix.size()), n(matrix[0].size()); \n        unordered_set<int> extrema; \n        vector<int> lucky; \n        if (m < n) {\n            \n            \n        } else {\n            for (int j = 0;  j < n;  ++j) {\n                int c(0); \n                for (int i = 0;  i < m;  ++i)\n                    c = max(c, matrix[i][j]); \n                extrema.insert(c); \n            }\n            for (int i = 0;  i < m;  ++i) {\n                int r(100001); \n                for (int j = 0;  j < n;  ++j)\n                    r = min(r, matrix[i][j]); \n                if (extrema.count(r)) \n            }\n        }\n        \n        return lucky; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"1269641881\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"1246793315\"], \"matrix_element1_element1\": [\"149187352\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> luckyNumbers . /*FC*/class Solution2 {\n/*FM*/vector<int> luckyNumbers (vector<vector<int>>& matrix) {\n        \n        \n        int m(matrix.size()), n(matrix[0].size()); \n        unordered_set<int> extrema; \n        vector<int> lucky; \n        if (m < n) {\n            for (int i = 0;  i < m;  ++i) {\n                int r(100001); \n                for (int j = 0;  j < n;  ++j)\n                    r = min(r, matrix[i][j]); \n                extrema.insert(r); \n            }\n            for (int j = 0;  j < n;  ++j) {\n                int c(0); \n                for (int i = 0;  i < m;  ++i)\n                    c = max(c, matrix[i][j]); \n                if (extrema.count(c)) \n            }\n        } else {\n            \n            \n        }\n        \n        return lucky; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"matrix\": [1], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-1573716628\"], \"matrix_element0_element1\": [\"-2059617419\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestCommonSubsequence. /*FC*/class Solution {\n/*FM*/int longestCommonSubsequence(string text1, string text2) {\n        int n  = text1.size(), m = text2.size(); \n        vector<vector<int>>dp(n+1, vector<int>(m+1)); \n        for(int i = 0;  i<n;  ++i){\n            for(int j = 0;  j < m ;  ++j){\n                dp[i+1][j+1] = (text1[i] == text2[j]? dp[i][j] + 1: max(dp[i+1][j], dp[i][j+1])); \n            }\n        }\n        return dp[n][m]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"text1\": [\"1\"], \"text2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestCommonSubsequence. /*FC*/class Solution2 {\n/*FM*/int longestCommonSubsequence(string s1, string s2) {\n      int n=s1.length(),m=s2.length(); \n      vector<int> prev(m+1,0); \n      vector<int> curr(m+1,0); \n      for(int i=1; i<=n; i++)\n      {\n        for(int j=1; j<=m; j++)\n        {\n            if(s1[i-1]==s2[j-1])\n            \n            else\n            curr[j]=max(prev[j],curr[j-1]); \n        }\n        prev=curr; \n      }\n      return curr[m]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s1\": [\"1\"], \"s2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minTaps. /*FC*/class Solution {\n/*FM*/int minTaps(int n, vector<int>& ranges) {\n        vector<int>dist(n+1); \n        for(int i = 0;  i<ranges.size();  ++i){\n            int left = max(0, i - ranges[i]); \n            dist[left] = max(dist[left], i + ranges[i]); \n        }\n        int end = 0, next = 0,  count = 0; \n        for(int i = 0;  i<=n && next <n;  ){\n            ++count; \n            while(i <= end){\n                next = max(next, dist[i++]); \n            }\n            if (end == next) return -1;  \n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"], \"ranges\": [2], \"ranges_element0\": [\"-75\"], \"ranges_element1\": [\"-98\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minTaps. /*FC*/class Solution {\n/*FM*/int minTaps(int n, vector<int>& ranges) {\n        vector<int>dist(n+1); \n        for(int i = 0;  i<ranges.size();  ++i){\n            int left = max(0, i - ranges[i]); \n            dist[left] = max(dist[left], i + ranges[i]); \n        }\n        int end = 0, next = 0,  count = 0; \n        for(int i = 0;  i<=n && next <n;  end = next){\n            ++count; \n            while(i <= end){\n                next = max(next, dist[i++]); \n            }\n            if (end == next)  \n            \n        }\n        return next >= n? count: -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"], \"ranges\": [1], \"ranges_element0\": [\"90\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minTaps. /*FC*/class Solution2 {\n/*FM*/int minTaps(int n, vector<int>& ranges) {\n        vector<int>dist(n+1); \n        for(int i = 0;  i<ranges.size();  ++i){\n            int left = max(0, i - ranges[i]); \n            dist[left] = max(dist[left], i + ranges[i]); \n        }\n        int end = 0, count = 0, next = 0; \n        for(int i = 0;  i<=n && end < n;  i++){\n            if ( i > end){\n                if ( i > next)  \n                \n                ++count; \n                end = next; \n            }\n            next = max(next, dist[i]); \n        }\n        return end >=n ? count: -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"n\": [\"5\"], \"ranges\": [1], \"ranges_element0\": [\"66\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minTaps. /*FC*/class Solution2 {\n/*FM*/int minTaps(int n, vector<int>& ranges) {\n        vector<int>dist(n+1); \n        for(int i = 0;  i<ranges.size();  ++i){\n            int left = max(0, i - ranges[i]); \n            dist[left] = max(dist[left], i + ranges[i]); \n        }\n        int end = 0, count = 0, next = 0; \n        for(int i = 0;  i<=n && end < n;  i++){\n            if ( i > end){\n                if ( i > next) return -1;  \n                \n                \n                \n            }\n            next = max(next, dist[i]); \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"n\": [\"1\"], \"ranges\": [1], \"ranges_element0\": [\"-60\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minTaps. /*FC*/class Solution3 {\n/*FM*/int minTaps(int n, vector<int>& ranges) {\n        vector<int>dist(n+1); \n        for(int i = 0;  i<ranges.size();  ++i){\n            int left = max(0, i - ranges[i]); \n            dist[left] = max(dist[left], i + ranges[i]); \n        }\n        int end = 0, count = 0, next = 0; \n        for(int i = 0;  i<=n && end < n;  i++){\n            next = max(next, dist[i]);  \n            \n            if ( i == end){\n                cout<<i<<\" end \"<<end<<endl; \n                \n                ++count; \n                end = next; \n            }\n        }\n        return end >=n ? count: -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"n\": [\"4\"], \"ranges\": [1], \"ranges_element0\": [\"-68\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minTaps. /*FC*/class Solution4 {\n/*FM*/int minTaps(int n, vector<int>& ranges) {\n        vector<int>dp(n+1, n+2); \n        dp[0] = 0; \n        for(int i = 0;  i<=n;  ++i){\n            for(int j = max(0, i-ranges[i] + 1);  j<=min(n, i+ranges[i]);  ++j){\n                \n                dp[j] = min(dp[j], dp[max(0, i-ranges[i])]+1); \n            }\n        }\n        return dp.back() < n+2 ? dp.back(): -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"n\": [\"3\"], \"ranges\": [2], \"ranges_element0\": [\"25\"], \"ranges_element1\": [\"28\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minRemoveToMakeValid. /*FC*/class Solution {\n/*FM*/string minRemoveToMakeValid(string s) {\n        stack<int>left_remaining; \n        stack<int>right_remaining; \n        for(int i = 0;  i < s.size();  ++i){\n            if(s[i] == '(') \n            else if (s[i] == ')'){\n                \n            }\n        }\n        string res = \"\"; \n        for(int i = s.size()-1;  i>=0;  --i){\n            if(!left_remaining.empty() && left_remaining.top() == i){\n                \n            } else if(!right_remaining.empty() && right_remaining.top() == i){\n                \n            } else {\n                res += s[i]; \n            }\n        }\n        return string(res.rbegin(), res.rend()); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minRemoveToMakeValid. /*FC*/class Solution2 {\n/*FM*/string minRemoveToMakeValid(string s) {\n        vector<int>left(s.size()); \n        vector<int>right(s.size()); \n        stack<int>cur; \n        for(int i = 0;  i<s.size();  i++){    \n            if(s[i]!='(' && s[i] !=')') continue;  \n            if(s[i] == '(') \n            else if(!cur.empty()){\n                \n                \n                \n            }\n        }\n        string res; \n        for(int i = 0;  i<s.size();  i++)\n            if(s[i]!='(' && s[i] !=')' || left[i] ||right[i])\n                res += s[i]; \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minRemoveToMakeValid. /*FC*/class Solution3 {\n/*FM*/string minRemoveToMakeValid(string s) {\n        stack<int>cur, bad; \n        for(int i = 0;  i<s.size();  i++){    \n            if(s[i]!='(' && s[i] !=')') continue;  \n            if(s[i] == '(') \n                \n            else if(!cur.empty()) \n            else \n        }\n        string res; \n        for(int i = s.size()-1;  i>=0;  i--){\n            if(!cur.empty() && i == cur.top()){\n                \n                \n            }\n            if(!bad.empty() && i == bad.top()){\n                \n                \n            }\n            res += s[i]; \n        }\n        reverse(res.begin(), res.end()); \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minRemoveToMakeValid. /*FC*/class Solution4 {\n/*FM*/string minRemoveToMakeValid(string s) {\n        stack<int> sk;  \n        for(int i = 0;  i < s.size();  ++i) {\n            if(s[i] == '(') {\n                \n            } else if(s[i] == ')') {\n                \n            }\n        }\n        \n        while(!sk.empty()) {\n            \n            \n        }\n        \n        s.erase(remove(s.begin(), s.end(), '*'), s.end()); \n        return s; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minRemoveToMakeValid. /*FC*/class Solution5 {\n/*FM*/string minRemoveToMakeValid(string s) {\n        stack<int> mstack; \n        unordered_set<int> mset; \n        for (int i=0;  i<s.size();  i++) {\n            if (s[i] == '(')\n                \n            else if (s[i] == ')') {\n                \n            }\n        }\n        while (!mstack.empty()) {\n            \n            \n        }\n        string ans; \n        for (int i=0;  i<s.size();  i++) {\n            if (mset.find(i) == mset.end())\n                ans.push_back(s[i]); \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSquares. /*FC*/class Solution {\n/*FM*/int countSquares(vector<vector<int>>& matrix) {\n        int res = 0; \n        for (int i = 0;  i < matrix.size();  ++i)\n            for (int j = 0;  j < matrix[0].size();  res += matrix[i][j++])\n                if (matrix[i][j] && i && j)\n                    matrix[i][j] += min({matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1]}); \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"43\"], \"matrix_element0_element1\": [\"-29\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"-92\"], \"matrix_element1_element1\": [\"30\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSquares. /*FC*/class Solution {\n/*FM*/int countSquares(vector<vector<int>>& matrix) {\n        int res = 0; \n        for (int i = 0;  i < matrix.size();  ++i)\n            for (int j = 0;  j < matrix[0].size();  res += matrix[i][j++])\n                if (matrix[i][j] && i && j)\n                    \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"83\"], \"matrix_element0_element1\": [\"-87\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"31\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string shortestCommonSupersequence. /*FC*/class Solution {\n/*FM*/string shortestCommonSupersequence(string str1, string str2) {\n        string lcs = get_lcs(str1, str2); \n        int i = 0, j = 0; \n        string res(\"\"); \n        for(auto c: lcs){\n             \n            \n               \n        }\n        return res + str1.substr(i) + str2.substr(j); \n    };/*F*//*C*//*M*/string get_lcs(const string& str1, const string& str2){\n        int n = str1.size(), m = str2.size(); \n        vector<vector<string>>dp(2, vector<string>(m+1, \"\")); \n        for(int i = 0;  i < n;  ++i){\n            for(int j = 0;  j < m;  ++j){\n                if (str1[i] == str2[j]){\n                    dp[(i + 1)%2][j+1] = dp[i%2][j] + str1[i]; \n                } else {\n                    dp[(i + 1)%2][j+1] = dp[(i + 1)%2][j].size() > dp[i%2][j+1].size()? dp[(i + 1)%2][j] : dp[i%2][j+1]; \n                }\n            }\n        }\n        return dp[n%2][m]; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str1\": [\"2\"], \"str2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string shortestCommonSupersequence. /*FC*/class Solution3 {\n/*FM*/string shortestCommonSupersequence(string a, string b) {\n        int dp[1001][1001] = {}, m = a.size(), n = b.size(); \n        for (int i = 0;  i < m;  ++i) \n            for (int j = 0;  j < n;  ++j)\n                dp[i + 1][j + 1] = a[i] == b[j] ? \n                    dp[i][j] + 1 : max(dp[i][j + 1], dp[i + 1][j]); \n        string res; \n        while (m && n) \n            if (dp[m][n] == dp[m - 1][n])\n                res += a[--m];  \n            else if (dp[m][n] == dp[m][n - 1])\n                 \n            else\n                 \n        return a.substr(0, m) + b.substr(0, n) + string(rbegin(res), rend(res)); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"a\": [\"2\"], \"b\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string shortestCommonSupersequence. /*FC*/class Solution2 {\n/*FM*/string shortestCommonSupersequence(string str1, string str2) {\n        int n = str1.size(), m = str2.size(); \n        vector<vector<int>>dp (n + 1, vector<int>(m+1)); \n        for(int i = 0;  i < n;  ++i){\n            for(int j = 0;  j < m;  ++j){\n                dp[i+1][j+1] = str1[i] == str2[j] ? dp[i][j] +1: max(dp[i+1][j], dp[i][j+1]); \n            }\n        }\n        string res = \"\"; \n        while(n && m ){\n            if (dp[n][m] == dp[n-1][m]){\n                res += str1[--n]; \n            } else if (dp[n][m] == dp[n][m-1]){\n                \n            } else {\n                  \n            }\n        }\n        return str1.substr(0, n) + str2.substr(0, m) + string(rbegin(res), rend(res)); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"str1\": [\"1\"], \"str2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int validSubarrays. /*FC*/class Solution {\n/*FM*/int validSubarrays(vector<int>& nums) {\n        int n = nums.size();  \n        stack<int>stk; \n        vector<int>right(n, n); \n        for(int i = 0;  i < n; ++i){\n            while(!stk.empty() && nums[stk.top()] > nums[i]){\n                right[stk.top()] = i; \n                stk.pop(); \n            }\n            stk.push(i); \n        }\n        int res = 0; \n        for(int i = 0;  i < n;  ++i){\n            res += right[i] - i; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"513140951\"], \"nums_element1\": [\"1952034693\"], \"nums_element2\": [\"1643605356\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int validSubarrays. /*FC*/class Solution2 {\n/*FM*/int validSubarrays(vector<int>& nums) {\n        int ans = 0; \n        \n        stack<int> st; \n        for (int i = 0;  i < nums.size();  i++) {\n            \n            \n            while (!st.empty() && nums[i] < nums[st.top()]) {\n                \n                \n                ans += (i - st.top()); \n                st.pop(); \n            }\n            st.push(i); \n        }\n        \n        \n        while (!st.empty()) {\n            ans += (nums.size() - st.top()); \n            st.pop(); \n        }\n        \n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"nums\": [3], \"nums_element0\": [\"1769643952\"], \"nums_element1\": [\"-2116431595\"], \"nums_element2\": [\"-1018958341\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int validSubarrays. /*FC*/class Solution3 {\n/*FM*/int validSubarrays(vector<int>& nums, int res = 0) {\n    vector<int> s; \n    for (auto n : nums) {\n        while (!s.empty() && n < s.back()) \n        s.push_back(n); \n        res += s.size(); \n    }\n    return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"nums\": [2], \"nums_element0\": [\"-867922836\"], \"nums_element1\": [\"1577082647\"], \"res\": [\"-1726317530\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int validSubarrays. /*FC*/class Solution3 {\n/*FM*/int validSubarrays(vector<int>& nums, int res = 0) {\n    vector<int> s; \n    for (auto n : nums) {\n        while (!s.empty() && n < s.back()) s.pop_back(); \n        s.push_back(n); \n        res += s.size(); \n    }\n    return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"nums\": [2], \"nums_element0\": [\"1752942010\"], \"nums_element1\": [\"357275359\"], \"res\": [\"459201796\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestPathBinaryMatrix. /*FC*/class Solution {\n/*FM*/int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\n        int n = grid.size(); \n        if(grid[0][0] == 1 || grid[n-1][n-1] == 1) \n        static vector<vector<int>> dirs = {{-1,-1}, {-1,0}, {-1,1}, {0, -1}, {0,1}, {1,-1}, {1,0}, {1,1}}; \n        queue<pair<int,int>>q;  q.push({0,0}); \n        vector<vector<int>> visited(n, vector<int>(n)); \n        visited[0][0] = 1; \n        int distance = 1;  \n        while(!q.empty()){\n            int size =  q.size(); \n            for(int a = 0;  a < size;  ++a){\n                auto [i, j] = q.front();  q.pop(); \n                if (i == n-1 && j == n -1)\n                    return distance; \n                \n                for(auto & dir: dirs){\n                    int x = i + dir[0];  \n                    int y = j + dir[1]; \n                    if( x < 0 || y < 0 || x >= n || y >= n || visited[x][y] || grid[x][y] == 1) continue; \n                    \n                    visited[x][y] = 1; \n                    q.push({x, y}); \n                }\n            }\n            ++distance; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [3], \"grid_element0\": [3], \"grid_element0_element0\": [\"-1303650215\"], \"grid_element0_element1\": [\"-1759375011\"], \"grid_element0_element2\": [\"1911912360\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"1737027797\"], \"grid_element1_element1\": [\"-2100891848\"], \"grid_element2\": [3], \"grid_element2_element0\": [\"1983901641\"], \"grid_element2_element1\": [\"-864593028\"], \"grid_element2_element2\": [\"555590569\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int missingElement. /*FC*/class Solution {\n/*FM*/int missingElement(vector<int>& nums, int k) {\n        int l = 0, h = nums.size(); \n        while(l < h) {\n            int m = l + (h - l) / 2; \n            nums[m] - m - k >= nums[0] ? h = m : l = m + 1;  \n        }\n        \n        return nums[0] + l-1 + k; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1591791253\"], \"k\": [\"-780658092\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lastStoneWeight. /*FC*/class Solution {\n/*FM*/int lastStoneWeight(vector<int>& stones) {\n        priority_queue<int>pq(stones.begin(), stones.end()); \n        while(pq.size()>1){\n            int y = pq.top();  pq.pop(); \n            int x = pq.top();  pq.pop(); \n            if(y - x)\n                pq.push(y-x); \n        }\n        return pq.size() ? pq.top(): 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"stones\": [2], \"stones_element0\": [\"-1651408536\"], \"stones_element1\": [\"1116077384\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lastStoneWeight. /*FC*/class Solution2 {\n/*FM*/int lastStoneWeight(vector<int>& stones) {\n        multiset<int>pq(stones.begin(), stones.end()); \n        while(pq.size()>1){\n            int y = *pq.rbegin();  pq.erase(prev(pq.end()));  \n            int x = *pq.rbegin();  pq.erase(prev(pq.end())); \n            if(y - x)\n                pq.insert(y-x); \n        }\n        return pq.size() ? *pq.begin(): 0; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"stones\": [3], \"stones_element0\": [\"1857117563\"], \"stones_element1\": [\"-1688393954\"], \"stones_element2\": [\"610990923\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<TreeNode*> delNodes. /*FC*/class Solution {\n/*FM*/vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\n        unordered_set<int>st(to_delete.begin(), to_delete.end()); \n        vector<TreeNode*>res; \n        root = helper(root, res, st); \n        if(root)\n            res.push_back(root); \n        return res; \n    };/*F*//*C*//*M*/TreeNode* helper(TreeNode* root, vector<TreeNode*>& res, unordered_set<int>& to_delete){\n        if (!root){\n            return root; \n        }\n        root->left  = helper(root->left, res, to_delete); \n        root->right  = helper(root->right, res, to_delete); \n        if(to_delete.count(root->val)){\n            if(root->left) res.push_back(root->left); \n            if(root->right) res.push_back(root->right); \n            return nullptr; \n        }\n        return root; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_val\": [\"1751766064\"], \"root[0].val\": [\"1751766064\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_val\": [\"406382703\"], \"root[1].val\": [\"406382703\"], \"to_delete\": [2], \"to_delete_element0\": [\"-911392115\"], \"to_delete_element1\": [\"-1128568436\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isRobotBounded. /*FC*/class Solution {\n/*FM*/bool isRobotBounded(string instructions) {\n        vector<vector<int>>direction = {{0,1},{-1,0}, {0,-1},{1,0}}; \n        int x = 0, y = 0, idx = 0; \n        for(auto i: instructions){\n            if(i == 'L' )\n                \n            else if(i == 'R')\n                \n            else{\n                x += direction[idx][0]; \n                y += direction[idx][1]; \n            }\n        }\n        return (x == 0 && y == 0) || idx != 0;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"instructions\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minKBitFlips. /*FC*/class Solution2 {\n/*FM*/int minKBitFlips(vector<int>& A, int K) {\n        int n = A.size(), flipped = 0, res = 0; \n        vector<int>isFlipped(n); \n        for (int i = 0;  i < A.size();  ++i) {\n            if (i >= K)\n                \n            if (flipped == A[i]) { \n                \n                \n                \n                \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"A\": [1], \"A_element0\": [\"-59\"], \"K\": [\"1702099818\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minKBitFlips. /*FC*/class Solution {\n/*FM*/int minKBitFlips(vector<int>& A, int K) {\n        queue<int>q;  \n        int need = 0, cnt = 0; \n        for(int i = 0;  i< A.size();  ++i){\n            int cur = cnt & 1 ? 1 ^ A[i] : A[i]; \n            if(cur == 0){\n                 \n                \n            }\n            if(q.size() && q.front() == i){\n                \n                \n            }\n        }\n        return q.empty() ? need: -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"5\"], \"A_element1\": [\"83\"], \"K\": [\"-854379720\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minKBitFlips. /*FC*/class Solution3 {\n/*FM*/int minKBitFlips(vector<int>& A, int K) {\n        int cur = 0, res = 0, n = A.size(); \n        for (int i = 0;  i < n;  ++i) {\n            if (i >= K && A[i - K] > 1) {\n                cur--; \n                A[i - K] -= 2; \n            }\n            if (cur % 2 == A[i]) {\n                \n                \n                \n                \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"A\": [1], \"A_element0\": [\"-35\"], \"K\": [\"-21\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minKBitFlips. /*FC*/class Solution3 {\n/*FM*/int minKBitFlips(vector<int>& A, int K) {\n        int cur = 0, res = 0, n = A.size(); \n        for (int i = 0;  i < n;  ++i) {\n            if (i >= K && A[i - K] > 1) {\n                \n                \n            }\n            if (cur % 2 == A[i]) {\n                \n                \n                \n                \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"A\": [1], \"A_element0\": [\"-86\"], \"K\": [\"59\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int time) {\n        sort(clips.begin(), clips.end()); \n        if(clips.front()[0]!=0) return -1; \n         \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"clips\": [1], \"clips_element0\": [1], \"clips_element0_element0\": [\"32\"], \"time\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution2 {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int time) {\n        int n = clips.size();  \n        vector<int>dp(time, 0); \n        for(auto c: clips){\n            if (c[0] >= time) continue; \n            dp[c[0]] = max(dp[c[0]], min(time, c[1])); \n        }\n        int count = 0, next = 0, end = 0; \n        for(int i = 0;  i<time && end < time;  ){\n            ++count; \n            while(i <= end){\n                next = max(next, dp[i++]); \n            }\n            if (end == next) return -1; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"clips\": [2], \"clips_element0\": [2], \"clips_element0_element0\": [\"-17\"], \"clips_element0_element1\": [\"63\"], \"clips_element1\": [1], \"clips_element1_element0\": [\"77\"], \"time\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution3 {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int time) {\n        int n = clips.size();  \n        vector<int>dp(time, 0); \n        for(auto c: clips){\n            if (c[0] >= time) continue; \n            \n        }\n        int count = 0, next = 0, end = 0; \n        for(int i = 0;  i<time && end < time;  ++i){\n            next = max(next, dp[i]); \n            if ( i == end){\n                ++count;  \n                end = next; \n            }\n        }\n        return end < time ? -1: count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"clips\": [2], \"clips_element0\": [2], \"clips_element0_element0\": [\"29\"], \"clips_element0_element1\": [\"-1\"], \"clips_element1\": [1], \"clips_element1_element0\": [\"97\"], \"time\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution3 {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int time) {\n        int n = clips.size();  \n        vector<int>dp(time, 0); \n        for(auto c: clips){\n            if (c[0] >= time) \n            dp[c[0]] = max(dp[c[0]], min(time, c[1])); \n        }\n        int count = 0, next = 0, end = 0; \n        for(int i = 0;  i<time && end < time;  ++i){\n            next = max(next, dp[i]); \n            if ( i == end){\n                ++count;  \n                end = next; \n            }\n        }\n        return end < time ? -1: count; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"clips\": [2], \"clips_element0\": [2], \"clips_element0_element0\": [\"-21\"], \"clips_element0_element1\": [\"-6\"], \"clips_element1\": [1], \"clips_element1_element0\": [\"-67\"], \"time\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution4 {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int time) {\n        int n = clips.size();  \n        vector<int>dp(time+1, 0); \n        for(auto c: clips){\n            if (c[0] >= time) continue; \n            dp[c[0]] = max(dp[c[0]], min(time, c[1])); \n        }\n        int count = 0, next = 0, end = 0; \n        for(int i = 0;  i<=time && end < time;  ++i){\n        \n        \n\n            \n            if ( i > end){\n                if (i > next) return -1; \n                 \n                \n            }\n            next = max(next, dp[i]); \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"clips\": [2], \"clips_element0\": [1], \"clips_element0_element0\": [\"80\"], \"clips_element1\": [2], \"clips_element1_element0\": [\"-30\"], \"clips_element1_element1\": [\"-13\"], \"time\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution5 {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int time) {\n        int n = clips.size();  \n        vector<int>right(time+1, 0); \n        for(auto c: clips){\n            if (c[0] >= time) continue; \n            \n        }\n        vector<int>cnt(time+1, time+2); \n        cnt[0] = 0; \n        for(int i = 0;  i<time;  ++i){\n            for(int j = i;  j <= right[i] && j <= time;  ++j){\n                cnt[j] = min(cnt[j], cnt[i]+1); \n            }\n        }\n        return cnt.back() > time ? -1: cnt.back(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"clips\": [1], \"clips_element0\": [2], \"clips_element0_element0\": [\"71\"], \"clips_element0_element1\": [\"4\"], \"time\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution5 {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int time) {\n        int n = clips.size();  \n        vector<int>right(time+1, 0); \n        for(auto c: clips){\n            if (c[0] >= time) \n            right[c[0]] = max(right[c[0]], min(time, c[1])); \n        }\n        vector<int>cnt(time+1, time+2); \n        cnt[0] = 0; \n        for(int i = 0;  i<time;  ++i){\n            for(int j = i;  j <= right[i] && j <= time;  ++j){\n                cnt[j] = min(cnt[j], cnt[i]+1); \n            }\n        }\n        return cnt.back() > time ? -1: cnt.back(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"clips\": [2], \"clips_element0\": [2], \"clips_element0_element0\": [\"-17\"], \"clips_element0_element1\": [\"80\"], \"clips_element1\": [1], \"clips_element1_element0\": [\"-57\"], \"time\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int twoCitySchedCost. /*FC*/class Solution {\n/*FM*/int twoCitySchedCost(vector<vector<int>>& costs) {\n        sort(costs.begin(),costs.end(),[](vector<int>&a, vector<int>&b){return abs(a[0]-a[1]) > abs(b[0]-b[1]); }); \n        \n        int res = 0; \n        for(int i = 0, n1 = costs.size()/2, n2 = costs.size()/2;  i<costs.size();  ++i){\n            if(n1 && costs[i][0] < costs[i][1] || n2 <= 0){\n                res += costs[i][0]; \n                n1 -- ; \n            }else {\n                res += costs[i][1]; \n                n2--; \n            }\n        }\n        \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"costs\": [2], \"costs_element0\": [1], \"costs_element0_element0\": [\"2\"], \"costs_element1\": [2], \"costs_element1_element0\": [\"91\"], \"costs_element1_element1\": [\"-91\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int twoCitySchedCost. /*FC*/class Solution2 {\n/*FM*/int twoCitySchedCost(vector<vector<int>>& cs, int res = 0) {\n        sort(begin(cs), end(cs), [](vector<int> &v1, vector<int> &v2) {\n            return (v1[0] - v1[1] < v2[0] - v2[1]); \n        }); \n        for (auto i = 0;  i < cs.size() / 2;  ++i) {\n            res += cs[i][0] + cs[i + cs.size() / 2][1]; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"cs\": [2], \"cs_element0\": [2], \"cs_element0_element0\": [\"94\"], \"cs_element0_element1\": [\"4\"], \"cs_element1\": [1], \"cs_element1_element0\": [\"-93\"], \"res\": [\"50\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int twoCitySchedCost. /*FC*/class Solution3 {\n/*FM*/int twoCitySchedCost(vector<vector<int>>& cs, int res = 0) {\n        nth_element(begin(cs), begin(cs) + cs.size() / 2, end(cs), [](vector<int> &a, vector<int> &b) {\n            return (a[0] - a[1] < b[0] - b[1]); \n        }); \n        for (auto i = 0;  i < cs.size() / 2;  ++i) {\n            res += cs[i][0] + cs[i + cs.size() / 2][1]; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"cs\": [2], \"cs_element0\": [1], \"cs_element0_element0\": [\"-15\"], \"cs_element1\": [2], \"cs_element1_element0\": [\"-70\"], \"cs_element1_element1\": [\"-32\"], \"res\": [\"93\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int twoCitySchedCost. /*FC*/class Solution4 {\n/*FM*/int twoCitySchedCost(vector<vector<int>>& costs) {\n        int N = costs.size() / 2; \n        vector<vector<int>>dp(N+1, vector<int>(N+1)); \n        for (int i = 1;  i <= N;  i++) {\n            dp[i][0] = dp[i - 1][0] + costs[i - 1][0]; \n        }\n        for (int j = 1;  j <= N;  j++) {\n            dp[0][j] = dp[0][j - 1] + costs[j - 1][1]; \n        }\n        for (int i = 1;  i <= N;  i++) {\n            for (int j = 1;  j <= N;  j++) {\n                dp[i][j] = min(dp[i - 1][j] + costs[i + j - 1][0], dp[i][j - 1] + costs[i + j - 1][1]); \n            }\n        }\n        return dp[N][N]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"costs\": [2], \"costs_element0\": [2], \"costs_element0_element0\": [\"9\"], \"costs_element0_element1\": [\"9\"], \"costs_element1\": [2], \"costs_element1_element0\": [\"42\"], \"costs_element1_element1\": [\"-99\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numPairsDivisibleBy60. /*FC*/class Solution {\n/*FM*/int numPairsDivisibleBy60(vector<int>& time) {\n        unordered_map<int, int>mp; \n        for(auto t: time){\n            mp[t%60]++; \n        }\n        long cnt = 0; \n        for(auto &it: mp){\n            if (it.first > 30){\n                \n            }\n            if (it.first == 0 || it.first == 30){\n                \n            }\n            else if (mp.count(60 - it.first)){\n                \n            }\n        }\n        return cnt; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"time\": [1], \"time_element0\": [\"-44\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numPairsDivisibleBy60. /*FC*/class Solution2 {\n/*FM*/int numPairsDivisibleBy60(vector<int>& time) {\n        vector<int> c(60); \n        int res = 0; \n        for (int t : time) {\n            res += c[(540 - t) % 60];  \n            c[t % 60] += 1; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"time\": [1], \"time_element0\": [\"-93\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* bstFromPreorder. /*FC*/class Solution {\n/*FM*/TreeNode* bstFromPreorder(vector<int>& preorder) {\n        if(preorder.empty())\n            \n        vector<TreeNode*>stk; \n        TreeNode *res = new TreeNode(preorder[0]);  \n        stk.push_back(res); \n        for(int i = 1;  i<preorder.size();  ++i){\n            TreeNode* tree = new TreeNode(preorder[i]); \n            if(preorder[i] > stk.back()->val){\n                TreeNode* cur; \n                while(stk.size() && preorder[i] > stk.back()->val){\n                    cur = stk.back(); \n                    stk.pop_back(); \n                }\n                cur->right = tree; \n            }\n            else\n                \n            stk.push_back(tree); \n        }\n        return res; \n    };/*F*//*C*//*M*/TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"preorder\": [2], \"preorder_element0\": [\"-50\"], \"preorder_element1\": [\"24\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* bstFromPreorder. /*FC*/class Solution {\n/*FM*/TreeNode* bstFromPreorder(vector<int>& preorder) {\n        if(preorder.empty())\n            \n        vector<TreeNode*>stk; \n        TreeNode *res = new TreeNode(preorder[0]);  \n        stk.push_back(res); \n        for(int i = 1;  i<preorder.size();  ++i){\n            TreeNode* tree = new TreeNode(preorder[i]); \n            if(preorder[i] > stk.back()->val){\n                \n                \n                \n            }\n            else\n                stk.back()->left = tree; \n            stk.push_back(tree); \n        }\n        return res; \n    };/*F*//*C*//*M*/TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"preorder\": [2], \"preorder_element0\": [\"24\"], \"preorder_element1\": [\"24\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* bstFromPreorder. /*FC*/class Solution2 {\n/*FM*/TreeNode* bstFromPreorder(vector<int>& preorder) {\n        if(preorder.empty())\n            \n        TreeNode* res = new TreeNode(preorder[0]); \n        stack<TreeNode*>stk;  stk.push(res); \n        for(int i = 1;  i < preorder.size();  ++i){\n            TreeNode* cur = new TreeNode(preorder[i]); \n            if(cur->val < stk.top()->val )\n                stk.top()->left = cur; \n            else{\n                \n                \n                \n            }\n            stk.push(cur); \n        }\n        return res; \n    };/*F*//*C*//*M*/TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"preorder\": [2], \"preorder_element0\": [\"23\"], \"preorder_element1\": [\"-73\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* bstFromPreorder. /*FC*/class Solution3 {\n/*FM*/TreeNode* bstFromPreorder(vector<int>& preorder) {\n        if(preorder.empty())\n            \n        int i = 0; \n        return helper(preorder, i, numeric_limits<int>::max()); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"preorder\": [1], \"preorder_element0\": [\"17\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* helper. /*FC*/class Solution3 {\n/*FM*/TreeNode* helper(const vector<int>&preorder, int& index, int parent){   \n        if(index == preorder.size())                                                    \n                                                                        \n        TreeNode *cur = new TreeNode(preorder[index++]);                               \n        if (index < preorder.size() && preorder[index] < cur->val) \n                                      \n        if (index < preorder.size() && preorder[index] < parent) \n            \n        return cur; \n    };/*F*//*C*//*M*/TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"preorder\": [1], \"preorder_element0\": [\"-56\"], \"index\": [\"78\"], \"parent\": [\"68\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* bstFromPreorder. /*FC*/class Solution4 {\n/*FM*/TreeNode* bstFromPreorder(vector<int>& preorder) {\n        if(preorder.empty())\n            \n        int i = 0; \n        return helper(preorder, i, numeric_limits<int>::max()); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"preorder\": [2], \"preorder_element0\": [\"67\"], \"preorder_element1\": [\"94\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* helper. /*FC*/class Solution4 {\n/*FM*/TreeNode* helper(const vector<int>&preorder, int& index, int parent){\n        if(index == preorder.size() || preorder[index] > parent)\n            return nullptr; \n        TreeNode *cur = new TreeNode(preorder[index++]); \n        cur->left = helper(preorder, index, cur->val); \n        cur->right = helper(preorder, index, parent); \n        return cur; \n    };/*F*//*C*//*M*/TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"preorder\": [1], \"preorder_element0\": [\"95\"], \"index\": [\"-55\"], \"parent\": [\"79\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* bstFromPreorder. /*FC*/class Solution5 {\n/*FM*/TreeNode* bstFromPreorder(vector<int>& preorder) {\n        if(preorder.empty())\n            \n        TreeNode* root = new TreeNode(preorder[0]);  \n        TreeNode *node = root; \n        for(int i = 1;  i<preorder.size();  ++i)\n        {\n            TreeNode* cur = new TreeNode(preorder[i]); \n            if(node->val > preorder[i]){\n                \n                \n            }\n            else{\n                while(node->right && node->right->val < preorder[i]){\n                    \n                    \n                    \n                }\n                cur->right = node->right; \n                node = node->right = cur; \n            }\n        }    \n            \n        \n        while(node->right)\n        {\n            \n            \n            \n        }\n        \n        return root; \n    };/*F*//*C*//*M*/TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"preorder\": [2], \"preorder_element0\": [\"-85\"], \"preorder_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* bstFromPreorder. /*FC*/class Solution5 {\n/*FM*/TreeNode* bstFromPreorder(vector<int>& preorder) {\n        if(preorder.empty())\n            \n        TreeNode* root = new TreeNode(preorder[0]);  \n        TreeNode *node = root; \n        for(int i = 1;  i<preorder.size();  ++i)\n        {\n            TreeNode* cur = new TreeNode(preorder[i]); \n            if(node->val > preorder[i]){\n                cur->right = node; \n                node = node->left = cur; \n            }\n            else{\n                \n                \n                \n            }\n        }    \n            \n        \n        while(node->right)\n        {\n            auto tmp = node->right; \n            node->right = nullptr; \n            node = tmp; \n        }\n        \n        return root; \n    };/*F*//*C*//*M*/TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"preorder\": [2], \"preorder_element0\": [\"88\"], \"preorder_element1\": [\"19\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findJudge. /*FC*/class Solution {\n/*FM*/int findJudge(int N, vector<vector<int>>& trust) {\n        unordered_set<int>judge; \n        for(int i = 1;  i<=N;  i++)\n            judge.insert(i); \n        unordered_map<int,unordered_set<int>>mp; \n        for(auto t: trust){\n            judge.erase(t[0]); \n            mp[t[1]].insert(t[0]); \n        }\n        if(judge.size() != 1 || mp[*judge.begin()].size() != N-1)\n            return -1; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"3\"], \"trust\": [2], \"trust_element0\": [2], \"trust_element0_element0\": [\"92\"], \"trust_element0_element1\": [\"-12\"], \"trust_element1\": [1], \"trust_element1_element0\": [\"-67\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* recoverFromPreorder. /*FC*/class Solution {\n/*FM*/TreeNode* recoverFromPreorder(string S) {\n        vector<TreeNode*>stk; \n        int index = 0; \n        while(index < S.length()){\n            int level = 0, val = 0; \n            while (index < S.length() && S[index]=='-') \n            while(index < S.length() && S[index] !='-') val = val*10 + S[index]-'0',index ++;  \n            \n            TreeNode* curNode = new TreeNode(val); \n            while(level < stk.size()) \n            if (!stk.empty() && !stk.back()->left)\n                \n            else if (!stk.empty())\n                \n            stk.push_back(curNode); \n        }\n        return stk[0]; \n    };/*F*//*C*//*M*/TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* recoverFromPreorder. /*FC*/class Solution5 {\n/*FM*/TreeNode* recoverFromPreorder(string S) {\n        unordered_map<int, TreeNode*> tbl; \n        TreeNode* res = NULL; \n        \n        queue<pair<int, int>> q; \n        \n        for (int i = 0;  i < S.size();  ) {\n            int c = 0; \n            int n = 0; \n            \n            while (i < S.size() && S[i] == '-') {   }\n            \n            while (i < S.size() && S[i] != '-') { n *= 10;  n += (S[i] - '0');  i++;  }\n                        \n            q.push(make_pair(c, n)); \n        }\n        \n        while (!q.empty()) {\n            auto i = q.front();  q.pop(); \n            \n            TreeNode* cur = new TreeNode(i.second); \n            \n            tbl[i.first] = cur; \n            \n            if (!i.first) res = cur; \n            else {\n                \n                \n                \n            }\n        }\n        \n        return res; \n    };/*F*//*C*//*M*/TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* dfs. /*FC*/class Solution4 {\n/*FM*/TreeNode* dfs(const string& S, int& i, int depth) {\n        if (i == S.length()) return nullptr; \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    };/*F*//*C*//*M*/TreeNode* dfs(const string& S, int& i, int depth) {\n        if (i == S.length()) return nullptr; \n        for (int j = 0;  j < depth;  j++) {\n            if (S[i + j] != '-') return nullptr; \n        }\n        i += depth; \n        int j = i; \n        while (j < S.length() && isdigit(S[j])) {\n            j++; \n        }\n        int val = stoi(S.substr(i, j - i)); \n        i = j; \n        TreeNode* root = new TreeNode(val); \n        root->left = dfs(S, i, depth + 1); \n        root->right = dfs(S, i, depth + 1); \n        return root; \n    } TreeNode* dfs(const string& S, int& i, int depth) {\n        if (i == S.length()) return nullptr; \n        for (int j = 0;  j < depth;  j++) {\n            if (S[i + j] != '-') return nullptr; \n        }\n        i += depth; \n        int j = i; \n        while (j < S.length() && isdigit(S[j])) {\n            j++; \n        }\n        int val = stoi(S.substr(i, j - i)); \n        i = j; \n        TreeNode* root = new TreeNode(val); \n        root->left = dfs(S, i, depth + 1); \n        root->right = dfs(S, i, depth + 1); \n        return root; \n    } TreeNode(int val) {\n        this->val = val; \n        this->left = nullptr; \n        this->right = nullptr; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"S\": [\"2\"], \"i\": [\"1\"], \"depth\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxUncrossedLines. /*FC*/class Solution {\n/*FM*/int maxUncrossedLines(vector<int>& A, vector<int>& B) {\n        unordered_map<int,vector<int>>mp; \n        for(int i = 0;  i<B.size();  ++i)\n            mp[B[i]].push_back(i); \n        unordered_map<int,unordered_map<int,int>>dp; \n        return helper(mp,dp, A, 0, 0); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-54\"], \"A_element1\": [\"-99\"], \"B\": [2], \"B_element0\": [\"-99\"], \"B_element1\": [\"99\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxUncrossedLines. /*FC*/class Solution3 {\n/*FM*/int maxUncrossedLines(vector<int>& A, vector<int>& B) {\n        vector<vector<int>>dp(A.size()+1, vector<int>(B.size()+1)); \n        for(int i = 0;  i<A.size();  ++i){\n            for(int j = 0;  j<B.size();  ++j){\n                dp[i+1][j+1] = max(dp[i][j] + static_cast<int>(A[i] == B[j]), max(dp[i+1][j], dp[i][j+1])); \n            }\n        }\n        return dp[A.size()][B.size()]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"A\": [2], \"A_element0\": [\"-16\"], \"A_element1\": [\"82\"], \"B\": [1], \"B_element0\": [\"56\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxUncrossedLines. /*FC*/class Solution5 {\n/*FM*/int maxUncrossedLines(vector<int>& A, vector<int>& B) {\n        if (A.size() < B.size()) {\n            return maxUncrossedLines(B, A); \n        }\n        vector<vector<int>> dp(2, vector<int>(B.size() + 1)); \n        for (int i = 0;  i < A.size();  ++i) {\n            for (int j = 0;  j < B.size();  ++j) {\n                dp[(i + 1) % 2][j + 1] = max(dp[i % 2][j] + static_cast<int>(A[i] == B[j]),\n                                             max(dp[i % 2][j + 1], dp[(i + 1) % 2][j])); \n            }\n        }\n        return dp[(A.size()) % 2][B.size()]; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"A\": [1], \"A_element0\": [\"-39\"], \"B\": [2], \"B_element0\": [\"-60\"], \"B_element1\": [\"-4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int helper. /*FC*/class Solution4 {\n/*FM*/int helper(vector<vector<int>>&dp, const vector<int>& A, const vector<int>& B, int i, int j){\n        if(i >= A.size() || j>=B.size())\n            return 0; \n        if(dp[i][j] >= 0)\n            \n        if(A[i] == B[j])\n             \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"dp\": [2], \"dp_element0\": [2], \"dp_element0_element0\": [\"-6\"], \"dp_element0_element1\": [\"-47\"], \"dp_element1\": [1], \"dp_element1_element0\": [\"21\"], \"A\": [1], \"A_element0\": [\"-49\"], \"B\": [1], \"B_element0\": [\"-95\"], \"i\": [\"-34\"], \"j\": [\"59\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dfs. /*FC*/class Solution6 {\n/*FM*/int dfs(vector<int>& A, vector<int>& B, int i, int j, vector<vector<int>> &dp) {\n      if (i >= A.size() || j >= B.size()) return 0; \n        \n      if (dp[i][j] != -1) \n      \n        \n    };/*F*//*C*//*M*/int dfs(vector<int>& A, vector<int>& B, int i, int j, vector<vector<int>> &dp) {\n      if (i >= A.size() || j >= B.size()) return 0; \n        \n      if (dp[i][j] != -1) return dp[i][j]; \n      auto nj = j; \n      while (nj < B.size() && B[nj] != A[i]) ++nj; \n      return dp[i][j] = max(dfs(A, B, i + 1, j, dp), (nj < B.size() ? 1 : 0) + dfs(A, B, i + 1, nj + 1, dp)); \n    } int dfs(vector<int>& A, vector<int>& B, int i, int j, vector<vector<int>> &dp) {\n      if (i >= A.size() || j >= B.size()) return 0; \n        \n      if (dp[i][j] != -1) return dp[i][j]; \n      auto nj = j; \n      while (nj < B.size() && B[nj] != A[i]) ++nj; \n      return dp[i][j] = max(dfs(A, B, i + 1, j, dp), (nj < B.size() ? 1 : 0) + dfs(A, B, i + 1, nj + 1, dp)); \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution6\": [\"Solution6\", \"Solution6()\"], \"A\": [1], \"A_element0\": [\"17\"], \"B\": [1], \"B_element0\": [\"5\"], \"i\": [\"21\"], \"j\": [\"10\"], \"dp\": [2], \"dp_element0\": [2], \"dp_element0_element0\": [\"33\"], \"dp_element0_element1\": [\"66\"], \"dp_element1\": [1], \"dp_element1_element0\": [\"-57\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int check. /*FC*/class Solution {\n/*FM*/int check(int x, vector<int>& A, vector<int>& B, int n) {\n    \n    \n    \n    int rotations_a = 0, rotations_b = 0; \n    for (int i = 0;  i < n;  ) {\n      \n      min number of rotations to have all\n    \n    return min(rotations_a, rotations_b); \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"51\"], \"A\": [2], \"A_element0\": [\"72\"], \"A_element1\": [\"96\"], \"B\": [2], \"B_element0\": [\"94\"], \"B_element1\": [\"-58\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int check. /*FC*/class Solution {\n/*FM*/int check(int x, vector<int>& A, vector<int>& B, int n) {\n    \n    \n    \n    int rotations_a = 0, rotations_b = 0; \n    for (int i = 0;  i < n;  ) {\n      \n      if (A[i] != x && B[i] != x) return -1; \n      \n      else if (A[i] != x) \n      \n      else if (B[i] != x) \n    }\n    \n    \n    \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"-65\"], \"A\": [2], \"A_element0\": [\"68\"], \"A_element1\": [\"-9\"], \"B\": [2], \"B_element0\": [\"-70\"], \"B_element1\": [\"14\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDominoRotations. /*FC*/class Solution {\n/*FM*/int minDominoRotations(vector<int>& A, vector<int>& B) {\n    int n = A.size(); \n    int rotations = check(A[0], A, B, n); \n    \n    if (rotations != -1 || A[0] == B[0]) return rotations; \n    \n    else \n  };/*F*//*C*//*M*/int check(int x, vector<int>& A, vector<int>& B, int n) {\n    \n    \n    \n    int rotations_a = 0, rotations_b = 0; \n    for (int i = 0;  i < n;  i++) {\n      \n      if (A[i] != x && B[i] != x) return -1; \n      \n      else if (A[i] != x) rotations_a++; \n      \n      else if (B[i] != x) rotations_b++; \n    }\n    \n    \n    return min(rotations_a, rotations_b); \n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"15\"], \"B\": [1], \"B_element0\": [\"96\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDominoRotations. /*FC*/class Solution {\n/*FM*/int minDominoRotations(vector<int>& A, vector<int>& B) {\n    int n = A.size(); \n    int rotations = check(A[0], A, B, n); \n    \n    if (rotations != -1 || A[0] == B[0]) \n    \n    else return check(B[0], A, B, n); \n  };/*F*//*C*//*M*/int check(int x, vector<int>& A, vector<int>& B, int n) {\n    \n    \n    \n    int rotations_a = 0, rotations_b = 0; \n    for (int i = 0;  i < n;  i++) {\n      \n      if (A[i] != x && B[i] != x) return -1; \n      \n      else if (A[i] != x) rotations_a++; \n      \n      else if (B[i] != x) rotations_b++; \n    }\n    \n    \n    return min(rotations_a, rotations_b); \n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-44\"], \"A_element1\": [\"-10\"], \"B\": [2], \"B_element0\": [\"58\"], \"B_element1\": [\"-73\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDominoRotations. /*FC*/class Solution2 {\n/*FM*/int minDominoRotations(vector<int>& A, vector<int>& B) {\n        vector<int>cnt(7);  \n        vector<int>flipA(7); \n        vector<int>flipB(7); \n        for(int i =0;  i<A.size();  ++i){\n            ++cnt[A[i]];   \n            if(A[i]!=B[i]){\n                ++cnt[B[i]]; \n                ++flipA[B[i]]; \n                ++flipB[A[i]];    \n            }\n        }\n        \n        int res = A.size()+1; \n        for(int i = 1;  i<7; ++i){\n            if(cnt[i] == A.size())\n                \n        }\n        \n        return res > A.size() ? -1: res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"A\": [2], \"A_element0\": [\"13\"], \"A_element1\": [\"60\"], \"B\": [2], \"B_element0\": [\"-9\"], \"B_element1\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDominoRotations. /*FC*/class Solution3 {\n/*FM*/int minDominoRotations(vector<int>& A, vector<int>& B) {\n        vector<int> countA(7), countB(7), same(7); \n        int n = A.size(); \n        for (int i = 0;  i < n;  ++i) {\n            countA[A[i]]++; \n            countB[B[i]]++; \n            if (A[i] == B[i])\n                \n        }\n        for (int i  = 1;  i < 7;  ++i)\n            if (countA[i] + countB[i] - same[i] == n)\n                return n - max(countA[i], countB[i]); \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"A\": [1], \"A_element0\": [\"78\"], \"B\": [1], \"B_element0\": [\"-6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDominoRotations. /*FC*/class Solution3 {\n/*FM*/int minDominoRotations(vector<int>& A, vector<int>& B) {\n        vector<int> countA(7), countB(7), same(7); \n        int n = A.size(); \n        for (int i = 0;  i < n;  ++i) {\n            countA[A[i]]++; \n            countB[B[i]]++; \n            if (A[i] == B[i])\n                \n        }\n        for (int i  = 1;  i < 7;  ++i)\n            if (countA[i] + countB[i] - same[i] == n)\n                \n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"A\": [2], \"A_element0\": [\"55\"], \"A_element1\": [\"-23\"], \"B\": [2], \"B_element0\": [\"82\"], \"B_element1\": [\"100\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDominoRotations. /*FC*/class Solution4 {\n/*FM*/int minDominoRotations(vector<int>& A, vector<int>& B) {\n          auto top = A[0], bot = B[0], top1 = 0, bot1 = 0, top2 = 0, bot2 = 0; \n          for (auto i = 0;  i < A.size();  ++i) {\n            if (A[i] != top && B[i] != top) top = 0; \n            if (A[i] != bot && B[i] != bot) bot = 0; \n            top1 += A[i] == top; \n            bot1 += B[i] == top; \n            top2 += A[i] == bot; \n            bot2 += B[i] == bot; \n          }\n          return top || bot ? min(A.size() - max(top1, bot1), A.size() - max(top2, bot2)) : -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"A\": [2], \"A_element0\": [\"-29\"], \"A_element1\": [\"-24\"], \"B\": [1], \"B_element0\": [\"-4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> intervalIntersection. /*FC*/class Solution2 {\n/*FM*/vector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {\n        if(A.size() > B.size()){\n            return intervalIntersection(B,A); \n        }\n        vector<vector<int>>res; \n        int j = 0; \n        for(int i = 0;  i<A.size() && j <B.size();  ){\n            int pos = findPosition(B, j, A[i][0]); \n            if(pos==B.size())\n                     \n            int start  = max(A[i][0], B[pos][0]); \n            int end = min(A[i][1], B[pos][1]); \n            if(start <= end)\n                res.push_back({start, end}); \n            if(A[i][1] <= B[pos][1])\n                ++i; \n            else \n                j = pos + 1; \n        }\n        return res; \n    };/*F*//*C*//*M*/int findPosition(const vector<vector<int>>&B, int l, int target){\n        int r = B.size(); \n        while (l < r){\n            int mid = l + (r-l)/2; \n            if(B[mid][1] >= target)\n                r = mid; \n            else\n                l = mid + 1; \n        }\n        return l; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"A\": [2], \"A_element0\": [2], \"A_element0_element0\": [\"-43\"], \"A_element0_element1\": [\"-11\"], \"A_element1\": [1], \"A_element1_element0\": [\"-15\"], \"B\": [1], \"B_element0\": [1], \"B_element0_element0\": [\"-32\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> intervalIntersection. /*FC*/class Solution2 {\n/*FM*/vector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {\n        if(A.size() > B.size()){\n            \n        }\n        vector<vector<int>>res; \n        int j = 0; \n        for(int i = 0;  i<A.size() && j <B.size();  ){\n            int pos = findPosition(B, j, A[i][0]); \n            if(pos==B.size())\n                     \n            int start  = max(A[i][0], B[pos][0]); \n            int end = min(A[i][1], B[pos][1]); \n            if(start <= end)\n                res.push_back({start, end}); \n            if(A[i][1] <= B[pos][1])\n                \n            else \n                j = pos + 1; \n        }\n        return res; \n    };/*F*//*C*//*M*/int findPosition(const vector<vector<int>>&B, int l, int target){\n        int r = B.size(); \n        while (l < r){\n            int mid = l + (r-l)/2; \n            if(B[mid][1] >= target)\n                r = mid; \n            else\n                l = mid + 1; \n        }\n        return l; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"A\": [1], \"A_element0\": [1], \"A_element0_element0\": [\"-46\"], \"B\": [2], \"B_element0\": [1], \"B_element0_element0\": [\"-17\"], \"B_element1\": [1], \"B_element1_element0\": [\"38\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> intervalIntersection. /*FC*/class Solution2 {\n/*FM*/vector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {\n        if(A.size() > B.size()){\n            \n        }\n        vector<vector<int>>res; \n        int j = 0; \n        for(int i = 0;  i<A.size() && j <B.size();  ){\n            int pos = findPosition(B, j, A[i][0]); \n            if(pos==B.size())\n                break;      \n            \n            \n            \n            \n        }\n        return res; \n    };/*F*//*C*//*M*/int findPosition(const vector<vector<int>>&B, int l, int target){\n        int r = B.size(); \n        while (l < r){\n            int mid = l + (r-l)/2; \n            if(B[mid][1] >= target)\n                r = mid; \n            else\n                l = mid + 1; \n        }\n        return l; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"A\": [1], \"A_element0\": [1], \"A_element0_element0\": [\"6\"], \"B\": [2], \"B_element0\": [2], \"B_element0_element0\": [\"49\"], \"B_element0_element1\": [\"35\"], \"B_element1\": [2], \"B_element1_element0\": [\"26\"], \"B_element1_element1\": [\"-25\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPosition. /*FC*/class Solution2 {\n/*FM*/int findPosition(const vector<vector<int>>&B, int l, int target){\n        int r = B.size(); \n        while (l < r){\n            \n            \n        }\n        return l; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"B\": [1], \"B_element0\": [1], \"B_element0_element0\": [\"48\"], \"l\": [\"7\"], \"target\": [\"1648872184\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> intervalIntersection. /*FC*/class Solution {\n/*FM*/vector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {\n        vector<vector<int>>res; \n        int i = 0, j = 0; \n        while(i<A.size() && j < B.size()){\n            int start  = max(A[i][0], B[j][0]); \n            int end = min(A[i][1], B[j][1]); \n            if(start <= end)\n                \n            \n            if(A[i][1] < B[j][1]) \n            else ++j; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [2], \"A_element0_element0\": [\"28\"], \"A_element0_element1\": [\"34\"], \"A_element1\": [1], \"A_element1_element0\": [\"-48\"], \"B\": [1], \"B_element0\": [2], \"B_element0_element0\": [\"3\"], \"B_element0_element1\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> intervalIntersection. /*FC*/class Solution {\n/*FM*/vector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {\n        vector<vector<int>>res; \n        int i = 0, j = 0; \n        while(i<A.size() && j < B.size()){\n            int start  = max(A[i][0], B[j][0]); \n            int end = min(A[i][1], B[j][1]); \n            if(start <= end)\n                \n            \n            if(A[i][1] < B[j][1]) ++i; \n            else ++j; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [2], \"A_element0_element0\": [\"25\"], \"A_element0_element1\": [\"-24\"], \"A_element1\": [2], \"A_element1_element0\": [\"17\"], \"A_element1_element1\": [\"-20\"], \"B\": [2], \"B_element0\": [2], \"B_element0_element0\": [\"-25\"], \"B_element0_element1\": [\"-27\"], \"B_element1\": [2], \"B_element1_element0\": [\"7\"], \"B_element1_element1\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long maximumBooks. /*FC*/class Solution {\n/*FM*/long long maximumBooks(vector<int>& books) {\n        \n        auto calculate = [&](int l, int r) -> long long{\n            int min_cnt = min(books[r], r-l); \n            return (long long)(books[r] + (books[r] - min_cnt))*(min_cnt+1)/2; \n        }; \n        int n = books.size(); \n        vector<long long>dp(n); \n        stack<int>stk; \n        for(int i = 0;  i<n;  ++i){\n            while(!stk.empty() && books[stk.top()] >= books[i] - (i - stk.top())){\n                \n            }\n            if(stk.empty()){\n                dp[i] = calculate(0, i); \n            } else {\n                dp[i] = dp[stk.top()] + calculate(stk.top()+1, i); \n            }\n            stk.push(i); \n        }\n        return *max_element(dp.begin(), dp.end()); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"books\": [2], \"books_element0\": [\"1456535702\"], \"books_element1\": [\"1882954662\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long maximumBooks. /*FC*/class Solution {\n/*FM*/long long maximumBooks(vector<int>& books) {\n        \n        auto calculate = [&](int l, int r) -> long long{\n            int min_cnt = min(books[r], r-l); \n            return (long long)(books[r] + (books[r] - min_cnt))*(min_cnt+1)/2; \n        }; \n        int n = books.size(); \n        vector<long long>dp(n); \n        stack<int>stk; \n        for(int i = 0;  i<n;  ++i){\n            while(!stk.empty() && books[stk.top()] >= books[i] - (i - stk.top())){\n                stk.pop(); \n            }\n            if(stk.empty()){\n                dp[i] = calculate(0, i); \n            } else {\n                \n            }\n            stk.push(i); \n        }\n        return *max_element(dp.begin(), dp.end()); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"books\": [2], \"books_element0\": [\"1681173078\"], \"books_element1\": [\"1402503455\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumGroups. /*FC*/class Solution {\n/*FM*/int maximumGroups(vector<int>& grades) {\n        int total = 0, k = 0, n = grades.size(); \n        while (total + k + 1 <= n) \n            total += ++k; \n        return k; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grades\": [1], \"grades_element0\": [\"-842331301\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumGroups. /*FC*/class Solution2 {\n/*FM*/int maximumGroups(vector<int>& grades) {\n        if (grades.empty()) \n        int l = 1, r = grades.size(), n = grades.size(); \n        while (l < r){\n            long mid = l + (r-l + 1)/2; \n            if ( mid *(mid+1)/2 <= n) \n                \n            else \n                r = mid -1; \n        }\n        return l; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"grades\": [2], \"grades_element0\": [\"-219487182\"], \"grades_element1\": [\"-1271422749\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMedianSortedArrays. /*FC*/class Solution9 {\n/*FM*/double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int N1 = nums1.size(); \n        int N2 = nums2.size(); \n        if (N1 < N2) \t\n\n        int lo = 0, hi = N2 * 2; \n        while (lo <= hi) {\n            int mid2 = (lo + hi) / 2;    \n            int mid1 = N1 + N2 - mid2;   \n\n            double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2]; \t\n            double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2]; \n            double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2]; \n            double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2]; \n\n            if (L1 > R2) lo = mid2 + 1; \t\t\n            else if (L2 > R1) \t\n            else return (max(L1,L2) + min(R1, R2)) / 2; \t\n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution9\": [\"Solution9\", \"Solution9()\"], \"nums1\": [2], \"nums1_element0\": [\"1627776586\"], \"nums1_element1\": [\"1976461453\"], \"nums2\": [1], \"nums2_element0\": [\"-43018970\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMedianSortedArrays. /*FC*/class Solution9 {\n/*FM*/double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int N1 = nums1.size(); \n        int N2 = nums2.size(); \n        if (N1 < N2) \t\n\n        int lo = 0, hi = N2 * 2; \n        while (lo <= hi) {\n            int mid2 = (lo + hi) / 2;    \n            int mid1 = N1 + N2 - mid2;   \n\n            double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2]; \t\n            double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2]; \n            double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2]; \n            double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2]; \n\n            if (L1 > R2) \t\t\n            else if (L2 > R1) hi = mid2 - 1; \t\n            else return (max(L1,L2) + min(R1, R2)) / 2; \t\n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution9\": [\"Solution9\", \"Solution9()\"], \"nums1\": [1], \"nums1_element0\": [\"1045720906\"], \"nums2\": [1], \"nums2_element0\": [\"1500895295\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution1 {\n/*FM*/string longestPalindrome(string s) {\n        int maxlen = 0, start = 0; \n        for(int i = 0;  i<s.size();  i++){\n            int len1 = PalLen(s, i, i); \n            int len2 = PalLen(s, i-1, i); \n            if(len1 > maxlen){\n                maxlen = len1;  \n                start = i - maxlen/2; \n            }\n            if(len2 > maxlen){\n                 \n                \n            }\n        }\n        return s.substr(start, maxlen); \n    };/*F*//*C*//*M*/int PalLen(const string &s, int i , int j){\n        while(i>=0 && j <s.size() && s[i]==s[j]){\n            i--;  j++; \n        }\n        return j-i-1; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution1\": [\"Solution1\", \"Solution1()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int PalLen. /*FC*/class Solution1 {\n/*FM*/int PalLen(const string &s, int i , int j){\n        while(i>=0 && j <s.size() && s[i]==s[j]){\n             \n        }\n        return j-i-1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution1\": [\"Solution1\", \"Solution1()\"], \"s\": [\"2\"], \"i\": [\"10\"], \"j\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution2 {\n/*FM*/string longestPalindrome(string s) {\n        if (s.empty()) \n        if (s.size() == 1) return s; \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void init. /*FC*/class Solution4 {\n/*FM*/void init(const string& s){\n        snew = \"$\"; \n        for(int i = 0;  i<s.size(); i++){\n            snew += \"#\"; \n            snew += s[i]; \n        }\n        snew+=\"#^\"; \n    };/*F*/string snew;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"AKA_INSTANCE___Solution4->snew\": [\"1\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\n        unordered_map<char,int>m;   \n        int cur = 0, res = 0; \n        for(int i = 0;  i<s.size(); i++){\n            if(i+1-m[s[i]]<cur+1) \n            else cur++; \n            res = max(cur, res); \n            m[s[i]] = i+1; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution3 {\n/*FM*/int lengthOfLongestSubstring(string s) {\n        unordered_set<int>st; \n        int res = 0, l = 0; \n        for(int i = 0;  i<s.size();  ++i){\n            while(st.count(s[i])){\n                \n            }\n            st.insert(s[i]); \n            res = max(res, i - l + 1); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution4 {\n/*FM*/int lengthOfLongestSubstring(string s) {\n        unordered_set<char>set; \n        int res = 0; \n        for(int i = 0, j = 0;  i<s.size(); ){\n            if(!set.count(s[i])){\n                set.insert(s[i++]); \n                res = max(res, (int)set.size()); \n            }else{\n                \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* addTwoNumbers. /*FC*/class Solution {\n/*FM*/ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carry = 0; \n        ListNode *head = new ListNode(0); \n        ListNode *cur = head; \n        while(l1 || l2 || carry){\n            cur->next = new ListNode(carry); \n            if(l1) {\n                cur->next->val += (l1->val); \n                l1 = l1->next; \n            }\n            if(l2) {\n                \n                \n            }\n            \n            \n            carry = cur->next->val/10; \n            cur->next->val %= 10; \n            cur = cur->next; \n        }\n        return head->next; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* addTwoNumbers. /*FC*/class Solution {\n/*FM*/ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carry = 0; \n        ListNode *head = new ListNode(0); \n        ListNode *cur = head; \n        while(l1 || l2 || carry){\n            cur->next = new ListNode(carry); \n            if(l1) {\n                \n                \n            }\n            if(l2) {\n                cur->next->val += (l2->val); \n                l2 = l2->next; \n            }\n            \n            \n            carry = cur->next->val/10; \n            cur->next->val %= 10; \n            cur = cur->next; \n        }\n        return head->next; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l2\": [1], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* addTwoNumbers. /*FC*/class Solution {\n/*FM*/ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carry = 0; \n        ListNode *head = new ListNode(0); \n        ListNode *cur = head; \n        while(l1 || l2 || carry){\n            cur->next = new ListNode(carry); \n            if(l1) {\n                cur->next->val += (l1->val); \n                l1 = l1->next; \n            }\n            if(l2) {\n                cur->next->val += (l2->val); \n                l2 = l2->next; \n            }\n            \n            \n            carry = cur->next->val/10; \n            cur->next->val %= 10; \n            cur = cur->next; \n        }\n        return head->next; \n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [3], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"0\"], \"l1[1]\": [\"ListNode\", \"ListNode(int)\"], \"l11_x\": [\"0\"], \"l1[2]\": [\"ListNode\", \"ListNode(int)\"], \"l12_x\": [\"0\"], \"l2\": [2], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"0\"], \"l2[1]\": [\"ListNode\", \"ListNode(int)\"], \"l21_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution {\n/*FM*/int reverse(int x) {\n        int res = 0; \n        while(x){\n            int prev = res; \n            res = res * 10 + x%10; \n            if(res/10 != prev){\n                res =0; \n                break; \n            }\n            x /= 10; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"-1359408558\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution {\n/*FM*/int reverse(int x) {\n        int res = 0; \n        while(x){\n            int prev = res; \n            res = res * 10 + x%10; \n            if(res/10 != prev){\n                \n                \n            }\n            x /= 10; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"-1194508681\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution2 {\n/*FM*/int reverse(int x) {\n        int64_t res = 0; \n        int sign = 1; \n        \n        if (x < 0) {\n            \n            \n        }\n        \n        while (x) {\n            res = res * 10 + x % 10; \n            x *= 0.1; \n        }\n        \n        res *= sign; \n        \n        if (res < INT_MIN || res > INT_MAX) return 0; \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"x\": [\"1121594083\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution2 {\n/*FM*/int reverse(int x) {\n        int64_t res = 0; \n        int sign = 1; \n        \n        if (x < 0) {\n            x = -x; \n            sign = -sign; \n        }\n        \n        while (x) {\n            res = res * 10 + x % 10; \n            x *= 0.1; \n        }\n        \n        res *= sign; \n        \n        if (res < INT_MIN || res > INT_MAX) \n        \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"x\": [\"-603967771\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution2 {\n/*FM*/int reverse(int x) {\n        int64_t res = 0; \n        int sign = 1; \n        \n        if (x < 0) {\n            x = -x; \n            sign = -sign; \n        }\n        \n        while (x) {\n            res = res * 10 + x % 10; \n            x *= 0.1; \n        }\n        \n        res *= sign; \n        \n        if (res < INT_MIN || res > INT_MAX) return 0; \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"x\": [\"-1819748487\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestBeautifulSubstring. /*FC*/class Solution {\n/*FM*/int longestBeautifulSubstring(string word) {\n        int start = 0, cnt = 1, res = 0; \n        for(int i = 1;  i<word.size();  ){\n            \n            \n            \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestBeautifulSubstring. /*FC*/class Solution2 {\n/*FM*/int longestBeautifulSubstring(string word) {\n        const auto n = word.size(); \n\n        int cnt = 1; \n        int len = 1; \n        int max_len = 0; \n        for (int i = 1;  i != n;  ) {\n            \n            \n            \n        }\n        return max_len; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"word\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestBeautifulSubstring. /*FC*/class Solution3 {\n/*FM*/int longestBeautifulSubstring(string word) {\n        int res = 0; \n        for (int i = 0, j = 0;  i < word.size();  ++i) {\n            if (word[i] == 'a') {\n                \n                     \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"word\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\n        int i = 0; \n        while(i<str.size() && str[i]==' ') \n        if(i>=str.size() || str[i]!='-' && str[i]!='+' && !isdigit(str[i])) return 0; \n        \n        \n        \n        mits<int>::max())\n            \n        else \n            \n    };/*F*//*C*//*M*/inline bool isdigit(char c)\n\t{\n\t\treturn c >= '0'&c <= '9'; \n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution2 {\n/*FM*/int myAtoi(string str) {\n\t\tif (str.size() == 0)\n\t\tint i = 0, res = 0; \n\t\tbool minus = false; \n\t\twhile (str[i] == ' ')\n\t\tif (str[i] == '-'){\n\t\t\t\n\t\t\t\n\t\t}\n\t\telse if (str[i] == '+')\n\t\telse if (!isdigit(str[i]))return 0; \n\n\t\twhile (isdigit(str[i])){\n            \n\t\t\t\n            \n\t\t\t\n\t\t}\n\t\t\n\t};/*F*//*C*//*M*/inline bool isdigit(char c)\n\t{\n\t\treturn c >= '0'&c <= '9'; \n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"str\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution3 {\n/*FM*/int myAtoi(string str) {\n        long result = 0; \n        int indicator = 1; \n        for(int i = 0;  i<str.size(); )\n        {\n            i = str.find_first_not_of(' '); \n            if(str[i] == '-' || str[i] == '+')\n                \n            while('0'<= str[i] && str[i] <= '9') \n            {\n                \n                \n                if(result*indicator <= INT_MIN)                 \n            }\n            return result*indicator; \n        }\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"str\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution {\n/*FM*/int maxArea(vector<int>& height) {\n        if(height.empty()) \n        int i = 0, j = height.size()-1, h = 0, water = 0; \n        while(i<j){\n            h = min(height[i], height[j]); \n            water = max(water, (j-i)*h); \n            while( i<j && height[i] <= h) i++; \n            while(i<j && height[j] <= h) \n        }\n        return water; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [2], \"height_element0\": [\"-644432403\"], \"height_element1\": [\"883022578\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution {\n/*FM*/int maxArea(vector<int>& height) {\n        if(height.empty()) \n        int i = 0, j = height.size()-1, h = 0, water = 0; \n        while(i<j){\n            h = min(height[i], height[j]); \n            water = max(water, (j-i)*h); \n            while( i<j && height[i] <= h) \n            while(i<j && height[j] <= h) j--; \n        }\n        return water; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [2], \"height_element0\": [\"1230538943\"], \"height_element1\": [\"-1810643027\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution2 {\n/*FM*/int maxArea(vector<int>& height) {\n        int i = 0, j = height.size() - 1,  ans = -1, cur; \n        while(i < j)\n        {\n            if(height[i] < height[j]) {\n                \n                \n            }\n            else{\n                cur = height[j] * (j - i); \n                j --; \n            }\n            if(ans < cur) ans = cur; \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"height\": [2], \"height_element0\": [\"1741373890\"], \"height_element1\": [\"1699829466\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution3 {\n/*FM*/int maxArea(vector<int> &height) {\n        int l(0), r=height.size()-1, result(0); \n        while(l < r){\n            if(height[l] < height[r]){\n                 \n                 \n                          }else{\n                 result = max(result, height[r] * (r - l)); \n                 int pivot = height[r--]; \n                 while(l < r && height[r] <= pivot) \n            }\n        }\n        return result; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"height\": [2], \"height_element0\": [\"-862909856\"], \"height_element1\": [\"-1534515919\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution5 {\n/*FM*/int maxArea(vector<int>& height) {\n        if(height.size() <= 1 )\n            \n        int l = 0, r = height.size()-1; \n        int area = 0; \n        while(l<r){\n            area = max(area, (r-l)*min(height[l], height[r])); \n            if(height[l]<height[r]){\n                \n            }\n            else --r; \n        }\n        return area; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"height\": [2], \"height_element0\": [\"545450490\"], \"height_element1\": [\"316234201\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution5 {\n/*FM*/int maxArea(vector<int>& height) {\n        if(height.size() <= 1 )\n            return 0; \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"height\": [1], \"height_element0\": [\"-1601863642\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution5 {\n/*FM*/int maxArea(vector<int>& height) {\n        if(height.size() <= 1 )\n            \n        int l = 0, r = height.size()-1; \n        int area = 0; \n        while(l<r){\n            area = max(area, (r-l)*min(height[l], height[r])); \n            if(height[l]<height[r]){\n                ++l; \n            }\n            else \n        }\n        return area; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"height\": [2], \"height_element0\": [\"-1834198316\"], \"height_element1\": [\"-780005043\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution4 {\n/*FM*/int maxArea(vector<int>& height) {\n        int i = 0; \n        int j = height.size()-1; \n        int M = 0; \n        while(i < j){\n            if (height[i] < height[j]){\n                M = max(M,height[i]*(j-i)); \n                i++; \n            } else {\n                \n                \n            }\n        }\n        return M; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"height\": [2], \"height_element0\": [\"-865254299\"], \"height_element1\": [\"1394431361\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\n        if (x<0) \n        int cur = 0, n = x; \n        while(n){\n            cur = cur*10 + n%10; \n            n /= 10; \n        }\n        return x == cur; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"1790701997\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\n        if (x<0) return false; \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"-1619957814\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution2 {\n/*FM*/bool isPalindrome(int x) {\n        if (x<0 || (x!=0 && x%10==0)) \n        int rev = 0; \n        while (x>rev){\n            rev = rev*10 + x%10; \n            x = x/10; \n        }\n        return (x==rev || x==rev/10); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"x\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution3 {\n/*FM*/bool isPalindrome(int x) {\n        if(x < 0) {\n            \n        }\n\n        int divisor = 1; \n        while (x / divisor >= 10) {\n            \n        }\n\n        for (;  x > 0;  x = (x % divisor) / 10, divisor /= 100) {\n            int left = x / divisor; \n            int right = x % 10; \n            if (left != right) {\n                \n            }\n        }\n\n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"x\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution {\n/*FM*/string intToRoman(int num) {\n        vector<int> divider{1000, 900, 500, 400, 100, 90,  50,  40, 10,  9,  5,   4,   1 }; \n        vector<string>roman{\"M\", \"CM\", \"D\", \"CD\",\"C\", \"XC\",\"L\",\"XL\",\"X\",\"IX\", \"V\",\"IV\",\"I\"}; \n        string res; \n        for(int i = 0;  num;  i++){\n            int times = num/divider[i]; \n            while(times-->0){\n                res.append(roman[i]); \n                num -= divider[i]; \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> minInterval. /*FC*/class Solution {\n/*FM*/vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        unordered_map<int,int>mp; \n        vector<int>Q = queries, res; \n        priority_queue<vector<int>>pq; \n        \n        sort(Q.begin(),Q.end()); \n        sort(intervals.begin(),intervals.end()); \n        int i = 0; \n        for(auto q: Q){\n            while(i < intervals.size() && intervals[i][0] <= q){\n                pq.push({intervals[i][0] - intervals[i][1] - 1, intervals[i][1]}); \n                ++i; \n            }\n            while(!pq.empty() && pq.top()[1] < q){\n                pq.pop(); \n            }\n            mp[q] = pq.size() ? -pq.top()[0] : -1;    \n        }\n        for(int i = 0;  i<queries.size();  ++i)\n            res.push_back(mp[queries[i]]); \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [2], \"intervals_element0_element0\": [\"-851168242\"], \"intervals_element0_element1\": [\"996272158\"], \"intervals_element1\": [2], \"intervals_element1_element0\": [\"644720637\"], \"intervals_element1_element1\": [\"-1973141770\"], \"queries\": [1], \"queries_element0\": [\"1362883499\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> minInterval. /*FC*/class Solution {\n/*FM*/vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        unordered_map<int,int>mp; \n        vector<int>Q = queries, res; \n        priority_queue<vector<int>>pq; \n        \n        sort(Q.begin(),Q.end()); \n        sort(intervals.begin(),intervals.end()); \n        int i = 0; \n        for(auto q: Q){\n            while(i < intervals.size() && intervals[i][0] <= q){\n                pq.push({intervals[i][0] - intervals[i][1] - 1, intervals[i][1]}); \n                ++i; \n            }\n            while(!pq.empty() && pq.top()[1] < q){\n                \n            }\n            mp[q] = pq.size() ? -pq.top()[0] : -1;    \n        }\n        for(int i = 0;  i<queries.size();  ++i)\n            res.push_back(mp[queries[i]]); \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [1], \"intervals_element0\": [2], \"intervals_element0_element0\": [\"-875393126\"], \"intervals_element0_element1\": [\"2006297159\"], \"queries\": [2], \"queries_element0\": [\"-280264556\"], \"queries_element1\": [\"-1649473482\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxBuilding. /*FC*/class Solution {\n/*FM*/int maxBuilding(int n, vector<vector<int>>& r) {\n        r.push_back({1,0});  r.push_back({n,n-1}); \n        sort(r.begin(), r.end()); \n        \n        int res = 0; \n        for(int i = r.size()-2;  i>=0;  --i){\n            r[i][1] = min(r[i][1], r[i+1][0] - r[i][0] + r[i+1][1]); \n        }\n        \n        for(int i = 1;  i<r.size();  ++i){\n            r[i][1] = min(r[i][1], r[i][0] - r[i-1][0] + r[i-1][1]); \n             \n            int distance = r[i][0] - r[i-1][0]; \n            int actual_dist = distance - abs(r[i][1] - r[i-1][1]); \n            res = max(res , max(r[i][1],r[i-1][1]) + actual_dist/2); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-1076333850\"], \"r\": [2], \"r_element0\": [1], \"r_element0_element0\": [\"2132200179\"], \"r_element1\": [2], \"r_element1_element0\": [\"353210491\"], \"r_element1_element1\": [\"1027556384\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxBuilding. /*FC*/class Solution2 {\n/*FM*/int maxBuilding(int n, vector<vector<int>>& arr) {\n        arr.push_back({1, 0}); \n        arr.push_back({n, n - 1}); \n        sort(arr.begin(), arr.end()); \n        int m = arr.size(); \n        \n        for (int i = 1;  i < m;  ++i)\n            arr[i][1] = min(arr[i][1], arr[i-1][1] + arr[i][0] - arr[i-1][0]); \n        for (int i = m - 2;  i >= 0;  --i)\n            arr[i][1] = min(arr[i][1], arr[i+1][1] + arr[i+1][0] - arr[i][0]); \n        \n        int ans = 0, l, h1, r, h2; \n        for (int i = 1;  i < m;  ++i) {\n            l = arr[i-1][0], r = arr[i][0], h1 = arr[i-1][1], h2 = arr[i][1]; \n            ans = max(ans, max(h1, h2) + (r - l - abs(h1 - h2)) / 2); \n        }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"n\": [\"-558478455\"], \"arr\": [2], \"arr_element0\": [1], \"arr_element0_element0\": [\"505457668\"], \"arr_element1\": [1], \"arr_element1_element0\": [\"1469086095\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMinSwaps. /*FC*/class Solution3 {\n/*FM*/int getMinSwaps(string num, int k) {\n        string target(num); \n        for (int i = 0;  i < k;  ++i)\n            next_permutation(target.begin(), target.end()); \n        int res = 0, n = num.size(); \n        for (int i = 0;  i < n;  ++i) {\n            if (num[i] != target[i]) {\n                \n                \n                \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"num\": [\"3\"], \"k\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getMinSwaps. /*FC*/class Solution4 {\n/*FM*/int getMinSwaps(string num, int k) {\n        list<char> ls1(num.begin(), num.end()); \n        for (int i=0;  i<k;  ++i) {\n            next_permutation(num.begin(), num.end()); \n        }\n        list<char> ls2(num.begin(), num.end()); \n        auto it1 = ls1.begin(); \n        int ret = 0; \n        while(it1!=ls1.end()) {\n            auto it2 = ls2.begin(); \n            int cnt = 0; \n            while(*it2 != *it1) {\n                \n                \n            }\n            ls2.erase(it2); \n            it1 = ls1.erase(it1);  \n            \n            ret+= cnt; \n        }\n        return ret; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"num\": [\"2\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int treeSum. /*FC*/class Solution {\n/*FM*/int treeSum(TreeNode* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int left = treeSum(root->left); \n        int right = treeSum(root->right); \n        int sum = left + root->val + right; \n        if (++table[sum] > maxCount) {\n            maxCount = table[sum]; \n        }\n        return sum; \n    };/*F*/unordered_map<int, int> table;  int maxCount;/*C*//*M*/int treeSum(TreeNode* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int left = treeSum(root->left); \n        int right = treeSum(root->right); \n        int sum = left + root->val + right; \n        if (++table[sum] > maxCount) {\n            maxCount = table[sum]; \n        }\n        return sum; \n    } int treeSum(TreeNode* root) {\n        if (root == nullptr) {\n            return 0; \n        }\n        \n        int left = treeSum(root->left); \n        int right = treeSum(root->right); \n        int sum = left + root->val + right; \n        if (++table[sum] > maxCount) {\n            maxCount = table[sum]; \n        }\n        return sum; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->table\": [0], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root[0].val\": [\"1\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumSetSize. /*FC*/class Solution {\n/*FM*/int maximumSetSize(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set<int>s1; \n        unordered_set<int>s2; \n        unordered_set<int>both; \n        for(auto i: nums1){\n            s1.insert(i); \n            both.insert(i); \n        }\n        for(auto i: nums2){\n            s2.insert(i); \n            both.insert(i); \n        }\n        int size = nums1.size(); \n        int n1 = s1.size(); \n        int n2 = s2.size(); \n        int all = both.size(); \n        return min(min(n1, size/2) + min(n2, size/2), all); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [1], \"nums1_element0\": [\"-1298125646\"], \"nums2\": [2], \"nums2_element0\": [\"1085507855\"], \"nums2_element1\": [\"1786961617\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumSetSize. /*FC*/class Solution2 {\n/*FM*/int maximumSetSize(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set<int> s1(nums1.begin(), nums1.end()); \n        unordered_set<int> s2(nums2.begin(), nums2.end()); \n        unordered_set<int> common; \n        for (int x: s1) {\n            if (s2.find(x) != s2.end()) {\n                \n            }\n        }\n        int n = nums1.size(), n1 = s1.size(), n2 = s2.size(), c = common.size(); \n        cout<<n<<\" n1 \"<<n1<<\" n2 \"<<n2 << \"  c \" <<c<<endl; \n        if (n1 - c >= n/2 && n2 - c >= n/2){\n            return n; \n        }\n        if (n1 - c >= n/2 && n2 - c < n/2){\n            \n        }\n        if (n1 - c < n/2 && n2 - c > n/2){\n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"nums1\": [1], \"nums1_element0\": [\"-241381111\"], \"nums2\": [2], \"nums2_element0\": [\"-364980976\"], \"nums2_element1\": [\"-212064959\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximumSetSize. /*FC*/class Solution3 {\n/*FM*/int maximumSetSize(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set<int> s1(nums1.begin(), nums1.end()); \n        unordered_set<int> s2(nums2.begin(), nums2.end()); \n        unordered_set<int> common; \n        for (int x: s1) {\n            if (s2.find(x) != s2.end()) {\n                \n            }\n        }\n        int n = nums1.size(), n1 = s1.size(), n2 = s2.size(), c = common.size(); \n        return min(n, min(n1 - c, n / 2) + min(n2 - c, n / 2) + c); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"nums1\": [1], \"nums1_element0\": [\"261430473\"], \"nums2\": [1], \"nums2_element0\": [\"-1541927345\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> beautifulIndices. /*FC*/class Solution {\n/*FM*/vector<int> beautifulIndices(string s, string a, string b, int k) {\n        vector<int>match_a;  \n        vector<int>match_b; \n        kmp(a, s, match_a); \n        kmp(b, s, match_b); \n        vector<int>res; \n        int i = 0, j = 0, match_a_size = match_a.size(), match_b_size = match_b.size(); \n        for(int i = 0;  i < match_a_size;  ){\n            \n            if (j < match_b_size &&  abs(match_a[i] - match_b[j]) <= k ){\n                \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"a\": [\"1\"], \"b\": [\"1\"], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void kmp. /*FC*/class Solution {\n/*FM*/void kmp(const string& pattern, const string& text, vector<int>&res){\n        vector<int>lps(pattern.size(), 0); \n        computeLps(pattern, lps); \n        int j = 0;  \n        for(int i = 0;  i<text.size();  ++i){\n            while (j > 0 && pattern[j] != text[i])\n                \n            if (pattern[j] == text[i])\n                \n            if (j == pattern.size()){\n                \n                \n            }\n        }\n    };/*F*//*C*//*M*/void computeLps(const string& pattern, vector<int>&lps){\n        int j = 0;  \n        for(int i = 1;  i < pattern.size();  ++i){\n            while(j > 0 && pattern[j] != pattern[i])\n                j = lps[j-1]; \n            if (pattern[j] == pattern[i])\n                ++j; \n            lps[i] = j; \n        }\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pattern\": [\"1\"], \"text\": [\"1\"], \"res\": [1], \"res_element0\": [\"695252049\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> beautifulIndices. /*FC*/class Solution2 {\n/*FM*/vector<int> beautifulIndices(string s, string a, string b, int k) {\n        vector<int>match_a;  \n        vector<int>match_b; \n        kmp(a, s, match_a); \n        kmp(b, s, match_b); \n        vector<int>res; \n        int i = 0, j = 0, match_a_size = match_a.size(), match_b_size = match_b.size(); \n        for(int i = 0;  i < match_a_size;  ){\n            \n            if (j < match_b_size &&  abs(match_a[i] - match_b[j]) <= k ){\n                \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"], \"a\": [\"2\"], \"b\": [\"1\"], \"k\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void kmp. /*FC*/class Solution2 {\n/*FM*/void kmp(const string& pattern, const string& text, vector<int>&res){\n        string combine = pattern + \"@\" + text; \n        int pattern_size = pattern.size(); \n        vector<int>lps(combine.size(), 0); \n        \n        int j = 0;  \n        for(int i = 1;  i < combine.size();  ++i){\n            while(j > 0 && combine[i]!=combine[j])\n                \n            if (combine[i] == combine[j])\n                \n            lps[i] = j; \n        }\n        for(int i = 0;  i<combine.size();  ++i){\n            if(lps[i] == pattern.size())\n                \n        }\n        return; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"pattern\": [\"2\"], \"text\": [\"1\"], \"res\": [1], \"res_element0\": [\"-1626917815\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minOrAfterOperations. /*FC*/class Solution {\n/*FM*/int minOrAfterOperations(vector<int>& nums, int k) {\n        int  n= nums.size();  \n        int ans = 0; \n        int cur = 0; \n        for (int i = 30;  i>=0;  --i){\n            cur = ((1<<30)-1); \n            int target = ans | ((1<<i)-1); \n            int cnt = 0; \n            for(auto x: nums){\n                cur = cur & x; \n                if ((cur | target) == target){\n                    ++cnt; \n                    cur = ((1<<30)-1); \n                }\n            }\n            if ( n - cnt > k){\n                ans |= (1<<i); \n            }\n        }\n        return ans;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1575198891\"], \"nums_element1\": [\"83438050\"], \"k\": [\"-1446770806\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minOrAfterOperations. /*FC*/class Solution2 {\n/*FM*/int minOrAfterOperations(vector<int>& nums, int k) {\n        int  n= nums.size();  \n        int ans = 0; \n        int cur = 0; \n        for (int i = 29;  i>=0;  --i){\n            cur = -1;  \n            int target = ans | ((1<<i)-1); \n            int cnt = 0; \n            for(auto x: nums){\n                cur = cur & x; \n                if ((cur | target) == target){\n                    \n                    \n                }\n            }\n            if ( n - cnt > k){\n                ans |= (1<<i); \n            }\n        }\n        return ans;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"nums\": [1], \"nums_element0\": [\"-223618299\"], \"k\": [\"-1712591506\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minOrAfterOperations. /*FC*/class Solution2 {\n/*FM*/int minOrAfterOperations(vector<int>& nums, int k) {\n        int  n= nums.size();  \n        int ans = 0; \n        int cur = 0; \n        for (int i = 29;  i>=0;  --i){\n            cur = -1;  \n            int target = ans | ((1<<i)-1); \n            int cnt = 0; \n            for(auto x: nums){\n                cur = cur & x; \n                if ((cur | target) == target){\n                    \n                    \n                }\n            }\n            if ( n - cnt > k){\n                \n            }\n        }\n        return ans;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"nums\": [1], \"nums_element0\": [\"2011999077\"], \"k\": [\"1107326902\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minOrAfterOperations. /*FC*/class Solution3 {\n/*FM*/int minOrAfterOperations(vector<int>& nums, int k) {\n        int  n= nums.size();  \n        int ans = 0; \n        int cur = 0; \n        for (int i = 30;  i>=0;  --i){\n            cur = cur | (1<<i) ;  \n            int cnt = 0; \n            int temp = cur; \n            for(auto x: nums){\n                temp = temp & x; \n                if ((temp | ans) == ans){\n                    ++cnt; \n                    temp = cur; \n                }\n            }\n            if ( n - cnt > k){\n                \n            }\n        }\n        return ans;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"nums\": [2], \"nums_element0\": [\"-1596166356\"], \"nums_element1\": [\"2105812575\"], \"k\": [\"476736517\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minOrAfterOperations. /*FC*/class Solution3 {\n/*FM*/int minOrAfterOperations(vector<int>& nums, int k) {\n        int  n= nums.size();  \n        int ans = 0; \n        int cur = 0; \n        for (int i = 30;  i>=0;  --i){\n            cur = cur | (1<<i) ;  \n            int cnt = 0; \n            int temp = cur; \n            for(auto x: nums){\n                temp = temp & x; \n                if ((temp | ans) == ans){\n                    ++cnt; \n                    temp = cur; \n                }\n            }\n            if ( n - cnt > k){\n                ans |= (1<<i); \n            }\n        }\n        return ans;  \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"nums\": [2], \"nums_element0\": [\"663654932\"], \"nums_element1\": [\"-794043185\"], \"k\": [\"-762536319\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumTimeToInitialState. /*FC*/class Solution {\n/*FM*/int minimumTimeToInitialState(string word, int k) {\n        int n = word.size(); \n        vector<int> kmp(n); \n        int  j = 0; \n        for(int i = 1;  i<n;  ){\n            \n        }\n        while (j && (n -j)%k){\n            \n        }\n        return (n-j ) / k + ((n-j) % k == 0 ? 0: 1); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word\": [\"2\"], \"k\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumTimeToInitialState. /*FC*/class Solution2 {\n/*FM*/int minimumTimeToInitialState(string word, int k) {\n        int res = 1, n = word.size(); \n        auto z = z_function(word); \n        for( ; res * k < n ;  ){\n            \n        }\n        return res; \n    };/*F*//*C*//*M*/vector<int> z_function(const string & s){\n        int n = s.size(); \n        vector<int>z(n); \n        int l = 0, r = 0; \n        for(int i = 1;  i<n;  ++i){\n            if (i < r)\n                z[i] = min(r - i, z[i-l]); \n            while(i + z[i] < n && s[z[i]] == s[i + z[i]])\n                ++z[i]; \n            if (i+z[i] > r){\n                l = i; \n                r = i + z[i]; \n            }\n        }\n        return z; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"word\": [\"1\"], \"k\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int>kmp. /*FC*/class Solution {\n/*FM*/vector<int>kmp(vector<int>&pattern){\n        int j = 0; \n        vector<int>res(pattern.size());  \n        for(int i = 1;  i<pattern.size();  ++i){\n            while (j && pattern[i]!=pattern[j]){\n                \n            }\n            res[i] = (j += pattern[i] == pattern[j]); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pattern\": [2], \"pattern_element0\": [\"-245312138\"], \"pattern_element1\": [\"1999736391\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long countPrefixSuffixPairs. /*FC*/class Solution {\n/*FM*/long long countPrefixSuffixPairs(vector<string>& words) {\n        Trie* cur = new Trie; \n        long long res = 0; \n        for(auto w: words){\n            int n = w.size(); \n            Trie* tmp = cur; \n            for(int i = 0;  i<n;  ++i){\n                int key = (w[i] - 'a')*128 + (w[n-i-1] - 'a'); \n                tmp = tmp->t.insert({key, new Trie()}).first->second; \n                res += tmp->count; \n            }\n            tmp->count+=1; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long countPrefixSuffixPairs. /*FC*/class Solution2 {\n/*FM*/long long countPrefixSuffixPairs(vector<string>& words) {\n        Trie* cur = new Trie; \n        long long res = 0; \n        for(auto w: words){\n            int n = w.size(); \n            Trie* tmp = cur; \n            for(int i = 0;  i<n;  ++i){\n                int key = (w[i] - 'a')*128 + (w[n-i-1] - 'a'); \n                if (tmp->t.count(key) == 0){\n                    tmp->t[key] = new Trie(); \n                }\n                tmp = tmp->t[key]; \n                res += tmp->count; \n            }\n            tmp->count+=1; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"words\": [2], \"words_element0\": [\"1\"], \"words_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int earliestSecondToMarkIndices. /*FC*/class Solution {\n/*FM*/int earliestSecondToMarkIndices(vector<int>& nums, vector<int>& changeIndices) {\n        int l = 0, r = changeIndices.size() + 1;  \n        while ( l < r){\n            int mid = (l + r)/2;  \n            if (possible(nums, changeIndices, mid)){\n                \n            } else {\n                l = mid + 1; \n            }\n        }\n        return l > changeIndices.size()? -1 : l; \n    };/*F*//*C*//*M*/bool possible(vector<int>& nums, vector<int>& changeIndices, int bound){\n        unordered_map<int, int>last_index; \n        for(int i = 0;  i < changeIndices.size() && i < bound;  ++i){\n            last_index[changeIndices[i]] = i; \n        }\n        cout<<\" last_index.size() \"<<last_index.size()<<endl; \n        if (last_index.size() != nums.size()) return false;  \n        int cnt = 0;  \n        for(int i = 0;  i < bound;  ++i){\n            if(i == last_index[changeIndices[i]]){\n                int val = nums[changeIndices[i]-1]; \n                if (cnt < val) {\n                    return false; \n                }\n                cnt -= val; \n            }\n            else \n                ++cnt; \n        }\n        return true; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"313423027\"], \"nums_element1\": [\"-1715281670\"], \"changeIndices\": [1], \"changeIndices_element0\": [\"-329233707\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxNonDecreasingLength. /*FC*/class Solution {\n/*FM*/int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {\n        vector<int>l1 = {1}; \n        vector<int>l2 = {1}; \n        int cnt = 1; \n        for(int i = 1;  i<nums1.size(); ++i){\n            int l1_cur = 1; \n            if(nums1[i] >= nums1[i-1]) {\n                l1_cur = max(l1_cur, l1.back()+1); \n            }\n            if(nums1[i] >= nums2[i-1]){\n                \n            }\n            int l2_cur = 1; \n            if(nums2[i] >= nums1[i-1]) {\n                l2_cur = max(l2_cur, l1.back()+1); \n            }\n            if(nums2[i] >= nums2[i-1]){\n                \n            }\n            l1.push_back(l1_cur); \n            l2.push_back(l2_cur); \n            cnt = max(cnt, max(l1_cur, l2_cur)); \n        }\n        return cnt; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"-333375695\"], \"nums1_element1\": [\"-146660935\"], \"nums2\": [1], \"nums2_element0\": [\"232325313\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxNonDecreasingLength. /*FC*/class Solution {\n/*FM*/int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {\n        vector<int>l1 = {1}; \n        vector<int>l2 = {1}; \n        int cnt = 1; \n        for(int i = 1;  i<nums1.size(); ++i){\n            int l1_cur = 1; \n            if(nums1[i] >= nums1[i-1]) {\n                \n            }\n            if(nums1[i] >= nums2[i-1]){\n                \n            }\n            int l2_cur = 1; \n            if(nums2[i] >= nums1[i-1]) {\n                \n            }\n            if(nums2[i] >= nums2[i-1]){\n                l2_cur = max(l2_cur, l2.back()+1); \n            }\n            l1.push_back(l1_cur); \n            l2.push_back(l2_cur); \n            cnt = max(cnt, max(l1_cur, l2_cur)); \n        }\n        return cnt; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"1989974375\"], \"nums1_element1\": [\"-1518686658\"], \"nums2\": [2], \"nums2_element0\": [\"-784315859\"], \"nums2_element1\": [\"1941477445\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canMakeSubsequence. /*FC*/class Solution {\n/*FM*/bool canMakeSubsequence(string str1, string str2) {\n        int j = 0, n = str1.size(), m = str2.size(); \n        for(int i = 0;  i < n && j < m;  ++i){\n            if (str1[i] == str2[j] || str1[i] + 1 == str2[j] || str1[i] - 25 == str2[j])\n                \n        }\n        return j==m; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str1\": [\"1\"], \"str2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> minEdgeReversals. /*FC*/class Solution {\n/*FM*/vector<int> minEdgeReversals(int n, vector<vector<int>>& edges) {\n        unordered_map<int,unordered_map<int,int>>graph; \n        unordered_map<int,unordered_map<int,int>>dp; \n        for(auto & edge: edges){\n            graph[edge[0]][edge[1]] = 0; \n            graph[edge[1]][edge[0]] = 1; \n        }\n\n        function<int(int, int)> dfs = [&](int parent, int cur){\n            if(dp.count(parent) && dp[parent].count(cur)){\n                return dp[parent][cur]; \n            }\n            dp[parent][cur] = 0; \n            for(auto nxt: graph[cur]){\n                if(nxt.first == parent) continue; \n                dp[parent][cur] += dfs(cur, nxt.first) +  nxt.second; \n            }\n            return dp[parent][cur]; \n        }; \n\n        vector<int>res; \n        for(int i = 0;  i < n;  ++i){\n            res.push_back(dfs(-1, i)); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"7\"], \"edges\": [1], \"edges_element0\": [1], \"edges_element0_element0\": [\"1207749039\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> minEdgeReversals. /*FC*/class Solution2 {\n/*FM*/vector<int> minEdgeReversals(int n, vector<vector<int>>& edges) {\n        unordered_map<int, unordered_map<int, int>> G; \n        for (auto& e : edges) {\n            G[e[0]][e[1]] = 0, G[e[1]][e[0]] = 1; \n        }\n        vector<int> res(n, -1); \n\n        function<int(int, int)> dp = [&](int i, int j) {\n            int cur = 0; \n            for (auto& k : G[j]) {\n                if (k.first == i) continue; \n                cur += dp(j, k.first) + k.second; \n            }\n            return cur; \n        }; \n\n        function<void(int, int)> dfs = [&](int i, int v) {\n            res[i] = v; \n            for (auto& j : G[i])\n                if (res[j.first] < 0)\n                    dfs(j.first, v - j.second + G[j.first][i]); \n        }; \n\n        dfs(0, dp(-1, 0)); \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"n\": [\"1705947214\"], \"edges\": [1], \"edges_element0\": [1], \"edges_element0_element0\": [\"1634258343\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minSum. /*FC*/class Solution {\n/*FM*/long long minSum(vector<int>& nums1, vector<int>& nums2) {\n        long long cnt1 = 0, zero1 = 0; \n        for(auto i: nums1){\n            cnt1 += i; \n            zero1 += (i == 0); \n        }\n        long long cnt2 = 0, zero2 = 0; \n        for(auto i: nums2){\n            cnt2 += i; \n            zero2 += (i == 0); \n        }\n        if (zero1 == 0 && zero2 == 0){\n            return cnt1 == cnt2 ? cnt1 : -1; \n        }\n        if(zero1 == 0) {\n            \n        }\n        if(zero2 == 0) {\n            \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"-196657439\"], \"nums1_element1\": [\"-2006201857\"], \"nums2\": [1], \"nums2_element0\": [\"1728340030\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minSum. /*FC*/class Solution2 {\n/*FM*/long long minSum(vector<int>& A, vector<int>& B) {\n        long long sa = 0, sb = 0, a0 = 0, b0 = 0; \n        for (int a: A) {\n            a0 += a == 0; \n            sa += max(a, 1); \n        }\n        for (int b: B) {\n            b0 += b == 0; \n            sb += max(b, 1); \n        }\n        if (sa < sb && a0 == 0) \n        if (sa > sb && b0 == 0) \n        return max(sa, sb); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"A\": [2], \"A_element0\": [\"-1458185125\"], \"A_element1\": [\"-987308009\"], \"B\": [2], \"B_element0\": [\"-1572016457\"], \"B_element1\": [\"-910321085\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minSum. /*FC*/class Solution2 {\n/*FM*/long long minSum(vector<int>& A, vector<int>& B) {\n        long long sa = 0, sb = 0, a0 = 0, b0 = 0; \n        for (int a: A) {\n            a0 += a == 0; \n            sa += max(a, 1); \n        }\n        for (int b: B) {\n            b0 += b == 0; \n            sb += max(b, 1); \n        }\n        if (sa < sb && a0 == 0) \n        if (sa > sb && b0 == 0) return -1; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"A\": [2], \"A_element0\": [\"347602922\"], \"A_element1\": [\"2133193115\"], \"B\": [1], \"B_element0\": [\"114487640\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minSum. /*FC*/class Solution2 {\n/*FM*/long long minSum(vector<int>& A, vector<int>& B) {\n        long long sa = 0, sb = 0, a0 = 0, b0 = 0; \n        for (int a: A) {\n            a0 += a == 0; \n            sa += max(a, 1); \n        }\n        for (int b: B) {\n            b0 += b == 0; \n            sb += max(b, 1); \n        }\n        if (sa < sb && a0 == 0) return -1; \n        if (sa > sb && b0 == 0) \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"A\": [2], \"A_element0\": [\"972944534\"], \"A_element1\": [\"1400864665\"], \"B\": [2], \"B_element0\": [\"1562798003\"], \"B_element1\": [\"1341457904\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumCost. /*FC*/class Solution {\n/*FM*/long long minimumCost(string source, string target, vector<char>& original, vector<char>& changed, vector<int>& cost) {\n        if(source.size() != target.size()){\n            \n        }\n        vector<vector<long long>>graph(26, vector<long long>(26, numeric_limits<int>::max())); \n        for(int i = 0;  i < original.size();  ++i){\n            graph[original[i]-'a'][changed[i]-'a'] = min(graph[original[i]-'a'][changed[i]-'a'], (long long)cost[i]); \n        }\n        for(int k = 0;  k < 26;  ++k){\n            for(int i = 0;  i < 26;  ++i){\n                for(int j = 0;  j < 26;  ++j){\n                    graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]); \n                }\n            }\n        }\n        long long res = 0;  \n        for(int i = 0;  i < source.size();  ++i){\n            if(source[i] == target[i]) \n            if (graph[source[i]-'a'][target[i]-'a'] >= numeric_limits<int>::max()) \n            res += graph[source[i]-'a'][target[i]-'a']; \n            \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"source\": [\"2\"], \"target\": [\"2\"], \"original\": [1], \"original_element0\": [\"104\"], \"changed\": [2], \"changed_element0\": [\"-93\"], \"changed_element1\": [\"64\"], \"cost\": [1], \"cost_element0\": [\"-1506384664\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestNumber. /*FC*/class Solution2 {\n/*FM*/string smallestNumber(string s) {\n        string res, stack; \n        for (int i = 0;  i <= s.length();  i++) {\n            stack.push_back('1' + i); \n            if (i == s.length() || s[i] == 'I') {\n                while (!stack.empty()) {\n                    res.push_back(stack.back()); \n                    stack.pop_back(); \n                }\n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int picklowestK. /*FC*/class Solution {\n/*FM*/int picklowestK(vector<int>&choice, int k){\n        for(int i = 0;  i<choice.size();  ++i)\n        {\n            if ( choice[i] == 0) \n            if (k == 0){\n                \n                \n            }\n        }\n        return -1; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"choice\": [1], \"choice_element0\": [\"-825117339\"], \"k\": [\"-735636488\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestNumber. /*FC*/class Solution {\n/*FM*/string smallestNumber(string pattern) {\n        vector<int>D(pattern.size(), 0); \n        for(int i = pattern.size()-1;  i>=0;  --i){\n            if(pattern[i] == 'D'){\n                \n            }\n        }\n        vector<int>choice(9, 0); \n        string cur = \"\"; \n        for(int i = 0;  i <D.size();  ++i){\n            if (D[i] == 0)\n                cur += to_string(picklowestK(choice, 1)); \n            else \n                \n        }\n        return cur + to_string(picklowestK(choice, 1)); \n    };/*F*//*C*//*M*/int picklowestK(vector<int>&choice, int k){\n        for(int i = 0;  i<choice.size();  ++i)\n        {\n            if ( choice[i] == 0) --k; \n            if (k == 0){\n                choice[i] = 1; \n                return i+1; \n            }\n        }\n        return -1; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pattern\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestNumber. /*FC*/class Solution3 {\n/*FM*/string smallestNumber(string s) {\n        string res; \n        int n = s.size(), j = 0; \n        for (int i = 0;  i <= s.size();  ++i) {\n            res.push_back('1' + i); \n            if (i == n || s[i] == 'I') {\n                reverse(res.begin() + j, res.end()); \n                j = i + 1; \n            }\n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution3\": [\"Solution3\", \"Solution3()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestNumber. /*FC*/class Solution4 {\n/*FM*/string smallestNumber(string pattern) {\n        stack<int>stk; \n        string res; \n        for(int i = 0;  i<=pattern.size();  ++i){\n            if (i>0 && pattern[i-1] == 'I'){\n                \n            }\n            stk.push(i+1); \n        }\n        while(!stk.empty()){\n            res += to_string(stk.top()); \n            stk.pop(); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"pattern\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestNumber. /*FC*/class Solution5 {\n/*FM*/string smallestNumber(string pattern) {\n        stack<int> s; \n        string ans = \"\"; \n        if(pattern[0] == 'I') \n        else s.push('1'); \n        for(int i = 1;  i <= pattern.size();  i++){\n            if(pattern[i-1] == 'I'){\n                \n            }\n            s.push('0' + i+1); \n        }\n        while(!s.empty()){ ans += s.top();  s.pop();   }\n        return ans; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution5\": [\"Solution5\", \"Solution5()\"], \"pattern\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dfs. /*FC*/class Solution6 {\n/*FM*/int dfs(string& p, int i, int n, int mask) {\n        if (i > p.size())\n            return n; \n        \n                       \n        \n    };/*F*//*C*//*M*/int dfs(string& p, int i, int n, int mask) {\n        if (i > p.size())\n            return n; \n        int res = INT_MAX, last = n % 10, increment = i == 0 || p[i - 1] == 'I'; \n        for (int d = 1;  d <= 9;  ++d)\n            if ((mask & (1 << d)) == 0 && d > last == increment)\n                res = min(res, dfs(p, i + 1, n * 10 + d, mask + (1 << d)));                \n        return res; \n    } int dfs(string& p, int i, int n, int mask) {\n        if (i > p.size())\n            return n; \n        int res = INT_MAX, last = n % 10, increment = i == 0 || p[i - 1] == 'I'; \n        for (int d = 1;  d <= 9;  ++d)\n            if ((mask & (1 << d)) == 0 && d > last == increment)\n                res = min(res, dfs(p, i + 1, n * 10 + d, mask + (1 << d)));                \n        return res; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution6\": [\"Solution6\", \"Solution6()\"], \"p\": [\"1\"], \"i\": [\"-1528982134\"], \"n\": [\"1422686359\"], \"mask\": [\"925337975\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countGoodStrings. /*FC*/class Solution2 {\n/*FM*/int countGoodStrings(int low, int high, int zero, int one) {\n        vector<int> dp(high + 1); \n        dp[0] = 1; \n        int res = 0, mod = 1e9 + 7; \n        for (int i = 1;  i <= high;  ++i) {\n            if (i >= zero) \n            if (i >= one) \n            if (i >= low) res = (res + dp[i]) % mod; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"low\": [\"-724316543\"], \"high\": [\"3\"], \"zero\": [\"2060343742\"], \"one\": [\"520947964\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int similarPairs. /*FC*/class Solution {\n/*FM*/int similarPairs(vector<string>& words) {\n        unordered_map<int,int>m; \n        int res = 0;  \n        for(auto & w: words){\n            int bits = 0; \n            for(auto& ch: w){\n                bits |= (1<< (ch - 'a')); \n            }\n            res += m[bits]++; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstCompleteIndex. /*FC*/class Solution {\n/*FM*/int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();  \n        vector<int>row(n, m); \n        vector<int>col(m, n); \n        unordered_map<int, pair<int,int>>mp; \n        for(int i = 0;  i<n;  ++i){\n            for(int j = 0;  j < m;  ++j){\n                mp[mat[i][j]] = {i, j}; \n            }\n        }\n        for(int i = 0;  i<arr.size();  ){\n            int r = mp[arr[i]].first, c = mp[arr[i]].second; \n            if(--row[r] == 0) \n            if(--col[c] == 0) return i; \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [1], \"arr_element0\": [\"1838843007\"], \"mat\": [1], \"mat_element0\": [2], \"mat_element0_element0\": [\"-1807334269\"], \"mat_element0_element1\": [\"-1800663627\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstCompleteIndex. /*FC*/class Solution {\n/*FM*/int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();  \n        vector<int>row(n, m); \n        vector<int>col(m, n); \n        unordered_map<int, pair<int,int>>mp; \n        for(int i = 0;  i<n;  ++i){\n            for(int j = 0;  j < m;  ++j){\n                mp[mat[i][j]] = {i, j}; \n            }\n        }\n        for(int i = 0;  i<arr.size();  ){\n            int r = mp[arr[i]].first, c = mp[arr[i]].second; \n            if(--row[r] == 0) return i; \n            if(--col[c] == 0) \n        }\n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"arr\": [1], \"arr_element0\": [\"-1973471798\"], \"mat\": [1], \"mat_element0\": [1], \"mat_element0_element0\": [\"-1506398530\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long countBadPairs. /*FC*/class Solution {\n/*FM*/long long countBadPairs(vector<int>& nums) {\n        unordered_map<long long,long long>mp; \n        long long res = 0; \n        for(int i = 0;  i<nums.size();  ++i)\n            res += i - mp[i - nums[i]]++; \n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-255017602\"], \"nums_element1\": [\"-1560794362\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumReplacement. /*FC*/class Solution {\n/*FM*/long long minimumReplacement(vector<int>& nums) {\n        if (nums.size() <= 1) \n        long last = nums.back(); \n        long step = 0; \n        for(int i = nums.size()-2;  i>=0;  --i){\n            if (last < nums[i]) {\n                long curStep = nums[i]/ last + (nums[i] % last != 0); \n                last = nums[i] % last == 0 ? last :  nums[i]/curStep; \n                step += (curStep - 1); \n            } else {\n                \n            } \n        }\n        return step; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"493605583\"], \"nums_element1\": [\"-1867638230\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumReplacement. /*FC*/class Solution {\n/*FM*/long long minimumReplacement(vector<int>& nums) {\n        if (nums.size() <= 1) \n        long last = nums.back(); \n        long step = 0; \n        for(int i = nums.size()-2;  i>=0;  --i){\n            if (last < nums[i]) {\n                \n                \n                \n            } else {\n                last = nums[i]; \n            } \n        }\n        return step; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-2049464973\"], \"nums_element1\": [\"-371887394\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumReplacement. /*FC*/class Solution {\n/*FM*/long long minimumReplacement(vector<int>& nums) {\n        if (nums.size() <= 1) return 0; \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"2078842677\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long minimumReplacement. /*FC*/class Solution2 {\n/*FM*/long long minimumReplacement(vector<int>& nums) {\n        long n = nums.size(), x = 1e9, res = 0, k; \n        for (int i = n - 1;  i >= 0;  --i) {\n            k = (nums[i] + x - 1) / x; \n            x = nums[i] / k; \n            res += k - 1; \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"nums\": [1], \"nums_element0\": [\"709944284\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int arithmeticTriplets. /*FC*/class Solution {\n/*FM*/int arithmeticTriplets(vector<int>& nums, int diff) {\n        unordered_set<int>st; \n        int res = 0; \n        for(auto i: nums){\n            if (st.count(i -diff) && st.count(i-diff*2))\n                \n            st.insert(i); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-687288377\"], \"diff\": [\"-262779388\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validPartition. /*FC*/class Solution2 {\n/*FM*/bool validPartition(vector<int>& nums) {\n        if (nums.size() < 2) \n            \n        vector<int>dp(nums.size()+1,0); \n        dp[0] = 1; \n        for(int i = 1;  i<nums.size();  ++i){\n            if(nums[i-1] == nums[i])\n                \n            if(i> 1 && nums[i] == nums[i-1] && nums[i] == nums[i-2])\n                \n            if(i>1 && nums[i] == nums[i-1] + 1 && nums[i] == nums[i-2]+2)\n                \n        }\n        return dp.back(); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"nums\": [2], \"nums_element0\": [\"1219344434\"], \"nums_element1\": [\"-2144493110\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validPartition. /*FC*/class Solution2 {\n/*FM*/bool validPartition(vector<int>& nums) {\n        if (nums.size() < 2) \n            return false; \n        \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"nums\": [1], \"nums_element0\": [\"1453155343\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validPartition. /*FC*/class Solution4 {\n/*FM*/bool validPartition(vector<int>& nums) {\n        if (nums.size() <= 1) \n        vector<int>dp(nums.size()+1, 0); \n        \n        return topDown(nums, nums.size()-1, dp); \n    };/*F*//*C*//*M*/bool topDown(vector<int>& nums, int index, vector<int>&dp){\n        if(index == -1) return 1; \n        if (dp[index+1])\n            return dp[index + 1]; \n        return dp[index+1] = (index >= 1 && nums[index] == nums[index-1] && topDown(nums,index-2, dp)) ||\n             (index >= 2 && nums[index] == nums[index-1] && nums[index] == nums[index-2] && topDown(nums,index-3, dp)) ||\n            (index >= 2 && nums[index] == nums[index-1] + 1 && nums[index] == nums[index-2] + 2 && topDown(nums,index-3, dp)); \n                        \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"nums\": [2], \"nums_element0\": [\"960659877\"], \"nums_element1\": [\"-1747669555\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validPartition. /*FC*/class Solution4 {\n/*FM*/bool validPartition(vector<int>& nums) {\n        if (nums.size() <= 1) return false; \n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\", \"Solution4()\"], \"nums\": [1], \"nums_element0\": [\"-1085037329\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestIdealString. /*FC*/class Solution {\n/*FM*/int longestIdealString(string s, int k) {\n        vector<int>cnt(26,0);  \n        int maxlen = 0; \n        for(int i = 0;  i<s.size();  ++i) {\n            int cur = s[i] - 'a'; \n            int curmax = 0; \n            for(int j = max(cur - k, 0);  j <= min(cur+k,25);  ++j){\n                curmax = max(curmax, cnt[j]+1); \n            }\n            cnt[cur] = curmax; \n        }\n        return *max_element(cnt.begin(), cnt.end()); \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"k\": [\"866825579\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestIdealString. /*FC*/class Solution2 {\n/*FM*/int longestIdealString(string s, int k) {\n        int dp[150] = {}, res = 0; \n        for (auto& i : s) {\n            for (int j = i - k;  j <= i + k;  ++j)\n                dp[i] = max(dp[i], dp[j]); \n            res = max(res, ++dp[i]); \n        }\n        return res; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"], \"k\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPossible. /*FC*/class Solution {\n/*FM*/bool isPossible(vector<int>& nums, vector<int>& changeIndices, unordered_map<int,int>& first_index_to_value_mp, int bound){\n        int time_available = 0; \n        vector<long>heap; \n        for(int i = min(bound, (int)changeIndices.size()) - 1;  i >= 0;  --i){\n            if (first_index_to_value_mp.count(i)) {\n                \n                \n                \n\n                \n            } else {\n                ++time_available; \n            }\n        }\n        long nums_total = accumulate(nums.begin(), nums.end(), 0L); \n        long q_total = -accumulate(heap.begin(), heap.end(), 0L); \n        long decrement_total = nums_total - q_total + nums.size() - heap.size(); \n        long mark_zero = heap.size() * 2; \n        \n        return decrement_total + mark_zero <= bound; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-838355064\"], \"changeIndices\": [1], \"changeIndices_element0\": [\"-1456441318\"], \"bound\": [\"555795710\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumValueSum. /*FC*/class Solution {\n/*FM*/int minimumValueSum(vector<int>& nums, vector<int>& andValues) {\n\t\tint n=nums.size(); \n\t\tdp.resize(n, vector<unordered_map<int,int>> (10)); \n\n\t\tint ans = helper(nums, andValues, 0, 0, ((1<<17)-1)); \n\t\tif(ans==1e8) return -1; \n\t\t\n\t};/*F*/vector<vector<unordered_map<int,int>>> dp;/*C*//*M*/int helper(vector<int>& nums, vector<int>& andValues, int cur, int andCur, int And){\n\t\tif(cur>=nums.size()){\n\t\t\tif(andCur>=andValues.size()) return 0; \n\t\t\telse return 1e8; \n\t\t}\n\t\telse if(andCur>=andValues.size()) return 1e8; \n\n\t\tif(dp[cur][andCur].count(And)) return dp[cur][andCur][And]; \n\n\t\tint inclu=1e8; \n\t\tif((And&nums[cur])==andValues[andCur]){\n\t\t\tinclu = nums[cur] + helper(nums, andValues, cur+1, andCur+1, ((1<<17)-1)); \n\t\t}\n\t\tint exclu = helper(nums, andValues, cur+1, andCur, (And&nums[cur])); \n\n\t\treturn dp[cur][andCur][And]=min(inclu, exclu); \n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->dp\": [1], \"AKA_INSTANCE___Solution_dp_element0\": [1], \"nums\": [1], \"nums_element0\": [\"-1572872805\"], \"andValues\": [1], \"andValues_element0\": [\"359919092\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<string>> groupAnagrams. /*FC*/class Solution {\n/*FM*/vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, multiset<string>> mp; \n        for (string s : strs) {\n            string t = s;  \n            sort(t.begin(), t.end()); \n            mp[t].insert(s); \n        }\n        vector<vector<string>> anagrams; \n        for (auto m : mp) { \n            vector<string> anagram(m.second.begin(), m.second.end()); \n            anagrams.push_back(anagram); \n        }\n        return anagrams; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [1], \"strs_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<string>> groupAnagrams. /*FC*/class Solution2 {\n/*FM*/vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, multiset<string>> mp; \n        for (string s : strs) {\n            string t = strSort(s); \n            mp[t].insert(s); \n        }\n        vector<vector<string>> anagrams; \n        for (auto m : mp) { \n            vector<string> anagram(m.second.begin(), m.second.end()); \n            anagrams.push_back(anagram); \n        }\n        return anagrams; \n    };/*F*//*C*//*M*/string strSort(string& s) {\n        int count[26] = {0}, n = s.length(); \n        for (int i = 0;  i < n;  i++)\n            count[s[i] - 'a']++; \n        int p = 0; \n        string t(n, 'a'); \n        for (int j = 0;  j < 26;  j++)\n            for (int i = 0;  i < count[j];  i++)\n                t[p++] += j; \n        return t; \n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"strs\": [1], \"strs_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string strSort. /*FC*/class Solution2 {\n/*FM*/string strSort(string& s) {\n        int count[26] = {0}, n = s.length(); \n        for (int i = 0;  i < n;  i++)\n            count[s[i] - 'a']++; \n        int p = 0; \n        string t(n, 'a'); \n        for (int j = 0;  j < 26;  j++)\n            for (int i = 0;  i < count[j];  )\n                \n        return t; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution {\n/*FM*/bool isAnagram(string s, string t) {\n        vector<int>map(128,0); \n        for(int i = 0;  i<s.length();  i++){\n            map[s[i]]++; \n        }\n        for(int i = 0;  i<t.length();  ){\n            if(--map[t[i]]<0) \n                return false; \n        }\n        \n        \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution {\n/*FM*/bool isAnagram(string s, string t) {\n        vector<int>map(128,0); \n        for(int i = 0;  i<s.length();  i++){\n            map[s[i]]++; \n        }\n        for(int i = 0;  i<t.length();  i++){\n            if(--map[t[i]]<0) \n                \n        }\n        for(int i = 97;  i<123; i++){ \n            if(map[i]>0) \n                \n        }\n        return true; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution2 {\n/*FM*/bool isAnagram(string s, string t) {\n        if (s.length() != t.length()) \n        int n = s.length(); \n        int counts[26] = {0}; \n        for (int i = 0;  i < n;  i++) { \n            counts[s[i] - 'a']++; \n            counts[t[i] - 'a']--; \n        }\n        for (int i = 0;  i < 26;  i++)\n            if (counts[i]) return false; \n        \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution2 {\n/*FM*/bool isAnagram(string s, string t) {\n        if (s.length() != t.length()) \n        int n = s.length(); \n        int counts[26] = {0}; \n        for (int i = 0;  i < n;  i++) { \n            counts[s[i] - 'a']++; \n            counts[t[i] - 'a']--; \n        }\n        for (int i = 0;  i < 26;  i++)\n            if (counts[i]) \n        return true; \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> twoSum. /*FC*/ {\n/*FM*/vector<int> twoSum(vector<int> &numbers, int target){\r\n\t\r\n\tmap<int,int> table; \r\n\t\r\n\tint size = numbers.size(); \r\n\tfor ( int i = 0;  i < size;  i++ ){\r\n\t\tpair<int,int> node(numbers[i], i); \r\n\t\ttable.insert(node); \r\n\t}\r\n\t\r\n\tvector<int> result; \r\n\tmap<int,int>::iterator it; \r\n    \r\n\tfor ( int i = 0;  i < numbers.size();  i++ ){\r\n\t\tif ( table.find(target - numbers[i]) != table.end() ){\r\n            \r\n            if ( i > table[target-numbers[i]]){\r\n                \r\n                 \r\n                \r\n            }\r\n\t\t}\r\n\t}\r\n    return result; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"numbers\": [1], \"numbers_element0\": [\"-1087344743\"], \"target\": [\"-1998279814\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isMatch. /*FC*/ {\n/*FM*/bool isMatch(const char *s, const char *p){\r\n\t\r\n\tif ( *p == '\\0' )\r\n\t\t\r\n\t\r\n\tif ( *(p+1) != '*' ){\r\n\t\treturn ((*p == *s) || ( *p == '.' && *s != '\\0')) && isMatch(s+1, p+1); \r\n\t}\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/bool isMatch(const char *s, const char *p){\r\n\t\r\n\tif ( *p == '\\0' )\r\n\t\treturn *s == '\\0'; \r\n\t\r\n\tif ( *(p+1) != '*' ){\r\n\t\treturn ((*p == *s) || ( *p == '.' && *s != '\\0')) && isMatch(s+1, p+1); \r\n\t}\r\n\t\r\n\twhile ((*p == *s) || (*p == '.' && *s != '\\0')){\r\n\t\tif ( isMatch(s,p+2) )\r\n\t\t\treturn true; \r\n\t\ts++; \r\n\t}\r\n\treturn isMatch(s, p+2); \r\n} bool isMatch(const char *s, const char *p){\r\n\t\r\n\tif ( *p == '\\0' )\r\n\t\treturn *s == '\\0'; \r\n\t\r\n\tif ( *(p+1) != '*' ){\r\n\t\treturn ((*p == *s) || ( *p == '.' && *s != '\\0')) && isMatch(s+1, p+1); \r\n\t}\r\n\t\r\n\twhile ((*p == *s) || (*p == '.' && *s != '\\0')){\r\n\t\tif ( isMatch(s,p+2) )\r\n\t\t\treturn true; \r\n\t\ts++; \r\n\t}\r\n\treturn isMatch(s, p+2); \r\n};\n}",
        "target": "{\"s\": [1], \"s_constantPointer[0]\": [\"-111\"], \"s_constantPointer[1]\": [\"0\"], \"p\": [1], \"p_constantPointer[0]\": [\"-43\"], \"p_constantPointer[1]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/ {\n/*FM*/int maxArea(vector<int> &height){\r\n\t\r\n\tif ( height.size() == 1 )\r\n\t\treturn -1; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"height\": [1], \"height_element0\": [\"-217937671\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/ {\n/*FM*/int maxArea(vector<int> &height){\r\n\t\r\n\tif ( height.size() == 1 )\r\n\t\t\r\n\t\r\n\tint left = 0; \r\n\tint right = height.size() - 1; \r\n\tint area = 0; \r\n\t\r\n\twhile ( left < right ){\r\n\t\tint tmp = min(height[left], height[right])*(right-left); \r\n\t\tif ( tmp > area )\r\n\t\t\tarea = tmp; \r\n\t\t\r\n\t\tif ( height[left] < height[right] )\r\n\t\t\tleft++; \r\n\t\telse\r\n\t\t\t\r\n\t}\r\n\treturn area; \r\n\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"height\": [3], \"height_element0\": [\"1990607756\"], \"height_element1\": [\"1988659219\"], \"height_element2\": [\"2005994713\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/ {\n/*FM*/void insert(ListNode *head, int x){\r\n\tListNode* cur = head; \r\n\twhile (cur->next != NULL)\r\n\t\t\r\n\tListNode* newnode = new ListNode(); \r\n\tnewnode->val = x; \r\n\tnewnode->next = NULL; \r\n\tcur->next = newnode; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[1]\": [\"ListNode\", \"ListNode()\"], \"head[2]\": [\"ListNode\", \"ListNode()\"], \"x\": [\"-932048762\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void traverse. /*FC*/ {\n/*FM*/void traverse(ListNode *head){\r\n\tListNode *cur = head; \r\n\twhile ( cur != NULL ){\r\n\t\tcout << cur->val << \" \"; \r\n\t\tcur = cur->next; \r\n\t}\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode()\"], \"head[1]\": [\"ListNode\", \"ListNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *addTwoNumbers. /*FC*/ {\n/*FM*/ListNode *addTwoNumbers(ListNode *l1, ListNode *l2){\r\n\t\r\n\tint carry = 0; \r\n\t\r\n\tif ( l1 == NULL && l2 == NULL )\r\n\t\t\r\n\t\r\n\tif ( l1 == NULL )\r\n\t\t\r\n\t\r\n\tif ( l2 == NULL )\r\n\t\treturn l1; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\tif ( cur1 == NULL ){\r\n\t\t\r\n\t}\r\n\t\r\n\telse{\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"l1\": [3], \"l1[0]\": [\"ListNode\", \"ListNode()\"], \"l1[1]\": [\"ListNode\", \"ListNode()\"], \"l1[2]\": [\"ListNode\", \"ListNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *addTwoNumbers. /*FC*/ {\n/*FM*/ListNode *addTwoNumbers(ListNode *l1, ListNode *l2){\r\n\t\r\n\tint carry = 0; \r\n\t\r\n\tif ( l1 == NULL && l2 == NULL )\r\n\t\t\r\n\t\r\n\tif ( l1 == NULL )\r\n\t\treturn l2; \r\n\t\r\n\tif ( l2 == NULL )\r\n\t\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\tif ( cur1 == NULL ){\r\n\t\t\r\n\t}\r\n\t\r\n\telse{\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"l2\": [2], \"l2[0]\": [\"ListNode\", \"ListNode()\"], \"l2[1]\": [\"ListNode\", \"ListNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring1. /*FC*/ {\n/*FM*/int lengthOfLongestSubstring1(string s){\r\n\tif ( s == \"\" )\r\n\t\t\r\n\t\r\n\tif ( s.length() == 1 )\r\n\t\treturn 1; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\tif( curlen > maxlen )\r\n\t\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring2. /*FC*/ {\n/*FM*/int lengthOfLongestSubstring2(string s){\r\n\tint len = s.length(); \r\n\tif ( len == 0 )\r\n\t\t\r\n\t\r\n\tint exist[256]; \r\n\tmemset(exist, -1, sizeof(exist)); \r\n\tint head = 0; \r\n\tint tail = 0; \r\n\tint max1 = 0; \r\n\t\r\n\twhile(tail < len){\r\n\t\tint index = (int)s[tail]; \r\n\t\tif (exist[index] == -1){\r\n\t\t\texist[index] = tail; \r\n\t\t\ttail++; \r\n\t\t}\r\n\t\telse{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\tcout << head << endl; \r\n\treturn max(max1, len - head); \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring2. /*FC*/ {\n/*FM*/int lengthOfLongestSubstring2(string s){\r\n\tint len = s.length(); \r\n\tif ( len == 0 )\r\n\t\t\r\n\t\r\n\tint exist[256]; \r\n\tmemset(exist, -1, sizeof(exist)); \r\n\tint head = 0; \r\n\tint tail = 0; \r\n\tint max1 = 0; \r\n\t\r\n\twhile(tail < len){\r\n\t\tint index = (int)s[tail]; \r\n\t\tif (exist[index] == -1){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << head << \" \" << tail << endl; \r\n\t\t\tmax1 = max(tail-head, max1); \r\n\t\t\tcout << max1 << endl; \r\n\t\t\thead = max(head, exist[index] + 1); \r\n\t\t\texist[index] = tail; \r\n\t\t\ttail++; \r\n\t\t}\r\n\t}\r\n\tcout << head << endl; \r\n\treturn max(max1, len - head); \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string preProcess. /*FC*/ {\n/*FM*/string preProcess(string s) {\r\n  int n = s.length(); \r\n  if (n == 0) \r\n  string ret = \"^\"; \r\n  for (int i = 0;  i < n;  i++)\r\n    ret += \"#\" + s.substr(i, 1); \r\n \r\n  ret += \"#$\"; \r\n  return ret; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/ {\n/*FM*/string longestPalindrome(string s){\r\n\t\r\n\tif ( s == \"\" )\r\n\t\t\r\n\t\r\n\tif ( s.length() == 1)\r\n\t\treturn s; \r\n\t\r\n\t\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n    \r\n    \r\n    \r\n\t\n  \r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/ {\n/*FM*/string convert(string s, int nRows) {\r\n\tif ( nRows == 1 )\r\n\t\t\r\n        \r\n    int iter = 2*nRows-2; \r\n    string result = \"\"; \r\n    int len = s.length(); \r\n    for ( int i = 0;  i < len;  i = i + iter )\r\n        result = result + s[i]; \r\n    for ( int i = 1;  i < nRows-1;  i++ ){\r\n        for ( int j  = i;  j < len;   ){\r\n            \r\n            \r\n        }\r\n    }\r\n    for ( int i = nRows-1;  i < len;   )\r\n        \r\n    return result; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"], \"nRows\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/ {\n/*FM*/string convert(string s, int nRows) {\r\n\tif ( nRows == 1 )\r\n\t\treturn s; \r\n        \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"3\"], \"nRows\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/ {\n/*FM*/int reverse(int x) {\r\n        long int a, b; \r\n        a = x; \r\n        b = 0; \r\n        while ( a != 0 ){\r\n            b = b*10 + (a%10); \r\n            a /= 10; \r\n        }\r\n        if ( b > INT_MAX )\r\n            \r\n        else if ( b < INT_MIN )\r\n            \r\n        else\r\n            return b; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"x\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int atoi. /*FC*/ {\n/*FM*/int atoi(string str) {\r\n        if (str == \"\")\r\n            \r\n            \r\n        int cur = 0; \r\n        while ( str[cur] == ' ' )\r\n            \r\n        \r\n        int pos = 0; \r\n        int neg = 0; \r\n        while ( str[cur] == '+' || str[cur] == '-'){\r\n            if ( str[cur] == '+')\r\n                pos++; \r\n            else\r\n                \r\n            cur++; \r\n        }\r\n        if( pos > 1 || neg > 1 || (pos > 0 && neg >0 ))\r\n            \r\n        \r\n        long int result = 0; \r\n        while (isdigit(str[cur])){\r\n            \r\n            f ( result > INT_MAX && neg > 0 )\r\n                \r\n            \r\n        }\r\n        if (neg)\r\n            \r\n        return (int)result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"str\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int atoi. /*FC*/ {\n/*FM*/int atoi(string str) {\r\n        if (str == \"\")\r\n            \r\n            \r\n        int cur = 0; \r\n        while ( str[cur] == ' ' )\r\n            \r\n        \r\n        int pos = 0; \r\n        int neg = 0; \r\n        while ( str[cur] == '+' || str[cur] == '-'){\r\n            \r\n            \r\n        }\r\n        if( pos > 1 || neg > 1 || (pos > 0 && neg >0 ))\r\n            \r\n        \r\n        long int result = 0; \r\n        while (isdigit(str[cur])){\r\n            \r\n            f ( result > INT_MAX && neg > 0 )\r\n                \r\n            \r\n        }\r\n        if (neg)\r\n            \r\n        return (int)result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"str\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/ {\n/*FM*/bool isPalindrome(int x) {\r\n        if ( x < 0 )\r\n            \r\n        if ( x < 10 )\r\n            return true; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"x\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int romanToInt. /*FC*/ {\n/*FM*/int romanToInt(string s) {\r\n       int len = s.length(); \r\n       if ( len == 0 )\r\n           \r\n       int value[7] = {1, 5, 10, 50, 100, 500, 1000}; \r\n       int count[7] = {0, 0, 0, 0, 0, 0, 0}; \r\n       \r\n       for ( int i = len - 1;  i >= 0;  i-- ){\r\n           if ( s[i] == 'I' ){\r\n                 }\r\n           \r\n           else if ( s[i] == 'V' )\r\n               count[1]++; \r\n               \r\n           else if ( s[i] == 'X' ){\r\n                 }\r\n           \r\n           else if ( s[i] == 'L' )\r\n               \r\n               \r\n           else if ( s[i] == 'C' ){\r\n                 }\r\n           \r\n           else if ( s[i] == 'D' )\r\n               \r\n           \r\n           else\r\n               \r\n       }\r\n       \r\n       int result = 0; \r\n       for ( int i = 0;  i < 7;  i++ )\r\n           result = result + value[i]*count[i]; \r\n       return result; \r\n   };/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int romanToInt. /*FC*/ {\n/*FM*/int romanToInt(string s) {\r\n       int len = s.length(); \r\n       if ( len == 0 )\r\n           \r\n       int value[7] = {1, 5, 10, 50, 100, 500, 1000}; \r\n       int count[7] = {0, 0, 0, 0, 0, 0, 0}; \r\n       \r\n       for ( int i = len - 1;  i >= 0;  i-- ){\r\n           if ( s[i] == 'I' ){\r\n                 }\r\n           \r\n           else if ( s[i] == 'V' )\r\n               \r\n               \r\n           else if ( s[i] == 'X' ){\r\n                 }\r\n           \r\n           else if ( s[i] == 'L' )\r\n               \r\n               \r\n           else if ( s[i] == 'C' ){\r\n                 }\r\n           \r\n           else if ( s[i] == 'D' )\r\n               \r\n           \r\n           else\r\n               count[6]++; \r\n       }\r\n       \r\n       int result = 0; \r\n       for ( int i = 0;  i < 7;  i++ )\r\n           result = result + value[i]*count[i]; \r\n       return result; \r\n   };/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > threeSum. /*FC*/ {\n/*FM*/vector<vector<int> > threeSum(vector<int> &num){\r\n\t\r\n\tvector<vector<int> > res; \r\n\t\r\n\tif ( num.size() < 3)\r\n\t\treturn res; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"num\": [2], \"num_element0\": [\"1460091051\"], \"num_element1\": [\"354126522\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > fourSum. /*FC*/ {\n/*FM*/vector<vector<int> > fourSum(vector<int> &num, int target) {\r\n       \r\n       sort(num.begin(), num.end()); \r\n   \r\n       vector<vector<int> > combs; \r\n       int size = num.size(); \r\n       \r\n       for ( int i = 0;  i < size - 3;   ){\r\n               \r\n           \r\n       }\r\n       return combs; \r\n   };/*F*//*C*//*M*/\n}",
        "target": "{\"num\": [2], \"num_element0\": [\"1338038334\"], \"num_element1\": [\"-625941637\"], \"target\": [\"8567377\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/ {\n/*FM*/bool isValid(string s) {\r\n      stack<char> S; \r\n      for ( int i = 0;  i < s.length();   ){\r\n          if ( s[i] == '(' || s[i] == '{' || s[i] == '[' )\r\n              \r\n          \r\n          else if ( s[i] == ')' ){\r\n                  }\r\n          \r\n          else if ( s[i] == '}' ){\r\n                  }\r\n          \r\n          else {\r\n              if (S.empty() || S.top() != '[')\r\n                  return false; \r\n              else\r\n                  \r\n          }\r\n      }\r\n      \r\n      \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void traverse. /*FC*/ {\n/*FM*/void traverse(ListNode* head){\r\n\tListNode* cur = head; \r\n\twhile ( cur != NULL ){\r\n\t\tcout << cur->val << \" \"; \r\n\t\tcur = cur->next; \r\n\t}\r\n\treturn; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"260659113\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/ {\n/*FM*/void insert(ListNode* head, int x){\r\n\tListNode* cur = head; \r\n\twhile ( cur->next != NULL )\r\n\t\t\r\n\tListNode *node = new ListNode(x); \r\n\tcur->next = node; \r\n\treturn; \r\n};/*F*//*C*//*M*/ListNode(int x): val(x), next(NULL) {};\n}",
        "target": "{\"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"559643223\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-2139642145\"], \"x\": [\"-37610933\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *swapPairs. /*FC*/ {\n/*FM*/ListNode *swapPairs(ListNode *head){\r\n\t\r\n\t\n      \n      ListNode *p = new ListNode(0); \r\n      p->next = head; \r\n      head = p; \r\n      while(true){\r\n          if (p->next==NULL){break; }\r\n          if (p->next->next==NULL){}\r\n          ListNode* q1 = p->next; \r\n          ListNode* q2 = q1->next; \r\n          q1->next = q2->next; \r\n          q2->next = q1; \r\n          p->next = q2; \r\n          p=q1; \r\n      } \r\n      return head->next; \r\n};/*F*//*C*//*M*/ListNode(int x): val(x), next(NULL) {};\n}",
        "target": "{\"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-754382686\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-299695819\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *swapPairs. /*FC*/ {\n/*FM*/ListNode *swapPairs(ListNode *head){\r\n\t\r\n\t\n      \n      ListNode *p = new ListNode(0); \r\n      p->next = head; \r\n      head = p; \r\n      while(true){\r\n          if (p->next==NULL){}\r\n          if (p->next->next==NULL){break; }\r\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n      } \r\n      return head->next; \r\n};/*F*//*C*//*M*/ListNode(int x): val(x), next(NULL) {};\n}",
        "target": "{\"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1049997184\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"981816739\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseKGroup. /*FC*/ {\n/*FM*/ListNode* reverseKGroup(ListNode *head, int k){\r\n\t\r\n\tif ( k == 0 || k == 1 || head == NULL )\r\n\t\t\r\n\tListNode* dnode = new ListNode(0); \r\n\tdnode->next = head; \r\n\tListNode* slow = head; \r\n\tListNode* fast = head; \r\n\tListNode* pre1 = dnode; \r\n\t\n\t\r\n\twhile ( true ){\r\n\t\t\r\n\t\tint counter = 0; \r\n\t\twhile ( fast != NULL && counter != k ){\r\n\t\t\tif ( counter != k -1 )\r\n\t\t\t\tpre1 = pre1->next; \r\n\t\t\tfast = fast->next; \r\n\t\t\tcounter++; \r\n\t\t}\r\n\t\t\r\n\t\r\n\t\tif ( counter == k ){\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t\tbreak; \r\n\t}\r\n\treturn dnode->next; \r\n};/*F*//*C*//*M*/ListNode* reverse(ListNode* start, ListNode* end){\r\n\tListNode* dnode = new ListNode(0); \r\n\tdnode->next = start; \r\n\tstart = start->next; \r\n\tdnode->next->next = end; \r\n\t\r\n\twhile ( start != end ){\r\n\t\tListNode *tmp = start; \r\n\t\tstart = start->next; \r\n\t\ttmp->next = dnode->next; \r\n\t\tdnode->next = tmp; \r\n\t}\r\n\treturn dnode->next; \r\n} ListNode(int x): val(x), next(NULL) {};\n}",
        "target": "{\"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1012828430\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1108150579\"], \"k\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseKGroup. /*FC*/ {\n/*FM*/ListNode* reverseKGroup(ListNode *head, int k){\r\n\t\r\n\tif ( k == 0 || k == 1 || head == NULL )\r\n\t\treturn head; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/ListNode* reverse(ListNode* start, ListNode* end){\r\n\tListNode* dnode = new ListNode(0); \r\n\tdnode->next = start; \r\n\tstart = start->next; \r\n\tdnode->next->next = end; \r\n\t\r\n\twhile ( start != end ){\r\n\t\tListNode *tmp = start; \r\n\t\tstart = start->next; \r\n\t\ttmp->next = dnode->next; \r\n\t\tdnode->next = tmp; \r\n\t}\r\n\treturn dnode->next; \r\n} ListNode(int x): val(x), next(NULL) {};\n}",
        "target": "{\"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1374465511\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-2069625039\"], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/ {\n/*FM*/int removeDuplicates(int A[], int n) {\r\n\tif(n <= 0)\r\n    \treturn 0; \r\n       \r\n    \r\n        \r\n   \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [3], \"A[0]\": [\"770057114\"], \"A[1]\": [\"1095133991\"], \"A[2]\": [\"-623398816\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/ {\n/*FM*/int removeDuplicates(int A[], int n) {\r\n\tif(n <= 0)\r\n    \t\r\n       \r\n    int realindex = 1; \r\n    for ( int i = 1;  i < n;  i++ ){\r\n       if(A[i] != A[i-1]){\r\n           A[realindex] = A[i]; \r\n           realindex++; \r\n       }\r\n   }    \r\n   return realindex; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"-247018877\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeElement. /*FC*/ {\n/*FM*/int removeElement(int A[], int n, int elem) {\r\n       int realindex = 0; \r\n       for ( int i = 0;  i < n;  i++ ){\r\n           if ( A[i] != elem){\r\n               A[realindex] = A[i]; \r\n               realindex++; \r\n           }\r\n       }\r\n       return realindex; \r\n   };/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [3], \"A[0]\": [\"-729091185\"], \"A[1]\": [\"-1877246495\"], \"A[2]\": [\"70279116\"], \"n\": [\"6\"], \"elem\": [\"-43747735\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strStr. /*FC*/ {\n/*FM*/int strStr(char *haystack, char *needle) {\r\n        \r\n        if ( haystack == NULL || needle == NULL )\r\n            \r\n        \r\n        if ( *haystack == '\\0'){\r\n            \r\n        }\r\n        \r\n        int loc = 0; \r\n        while ( *haystack != '\\0' ){\r\n            char* cur1 = haystack; \r\n            char* cur2 = needle; \r\n            while ( *cur1 == *cur2 && *cur1 != '\\0' && *cur2 != '\\0' ){\r\n                \r\n                \r\n            }\r\n            \r\n            if ( *cur2 == '\\0' )\r\n                \r\n            if ( *cur1 == '\\0' )\r\n                \r\n            \r\n            loc++; \r\n            haystack++; \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"haystack\": [1], \"haystack[0]\": [\"61\"], \"haystack[1]\": [\"-34\"], \"needle\": [1], \"needle[0]\": [\"-94\"], \"needle[1]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strStr. /*FC*/ {\n/*FM*/int strStr(char *haystack, char *needle) {\r\n        \r\n        if ( haystack == NULL || needle == NULL )\r\n            return -1; \r\n        \r\n        if ( *haystack == '\\0'){\r\n            \r\n        }\r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"needle\": [1], \"needle[0]\": [\"-2\"], \"needle[1]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/ {\n/*FM*/int divide(int dividend, int divisor){\r\n\n      long long a = dividend >= 0 ? dividend : -(long long)dividend; \r\n      \n      long long b = divisor >= 0 ? divisor : -(long long)divisor; \r\n      long long result = 0; \r\n      while(a >= b){\r\n          \r\n          \n      }\n      if((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0)){\r\n          \r\n      }\n      \n      if (result > INT_MAX || result < INT_MIN){\r\n          \r\n      }\r\n      return static_cast<int>(result); \t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"dividend\": [\"845535392\"], \"divisor\": [\"1463382253\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/ {\n/*FM*/int divide(int dividend, int divisor){\r\n\n      long long a = dividend >= 0 ? dividend : -(long long)dividend; \r\n      \n      long long b = divisor >= 0 ? divisor : -(long long)divisor; \r\n      long long result = 0; \r\n      while(a >= b){\r\n          long long c = b; \r\n          for(int i = 0; a >= c; ++i,c <<= 1){\r\n              a -= c; \r\n              result += 1 << i; \r\n          }\n      }\n      if((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0)){\r\n          \r\n      }\n      \n      if (result > INT_MAX || result < INT_MIN){\r\n          \r\n      }\r\n      return static_cast<int>(result); \t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"dividend\": [\"-790357086\"], \"divisor\": [\"-750157442\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/ {\n/*FM*/int divide(int dividend, int divisor){\r\n\n      long long a = dividend >= 0 ? dividend : -(long long)dividend; \r\n      \n      long long b = divisor >= 0 ? divisor : -(long long)divisor; \r\n      long long result = 0; \r\n      while(a >= b){\r\n          \r\n          \n      }\n      if((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0)){\r\n          result = -result; \r\n      }\n      \n      if (result > INT_MAX || result < INT_MIN){\r\n          \r\n      }\r\n      return static_cast<int>(result); \t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"dividend\": [\"370083116\"], \"divisor\": [\"-1743239344\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findSubstring. /*FC*/ {\n/*FM*/vector<int> findSubstring(string S, vector<string> &L){\r\n\t\r\n\tmap<string, int> table1, table2; \r\n\tint size = L.size(); \r\n\tint len = L[0].size(); \r\n\tint counter = 0; \r\n\tvector<int> indices; \r\n\tfor ( int k = 0;  k < size;  k++ ){\r\n\t\tif ( table1.find(L[k]) == table1.end() )\r\n\t\t\ttable1[L[k]] = 1; \r\n\t\telse\r\n\t\t\t\r\n\t}\r\n\t\r\n\tfor ( int i = 0;  i <= (int)(S.length() - len * size);  i++ ){\r\n\t\t\r\n\t\tint cur = i; \r\n\t\tcounter = 0; \r\n\t\tfor ( int k = 0;  k < size;  k++ )\r\n\t\t\ttable2[L[k]] = table1[L[k]]; \r\n\t\t\r\n\t\twhile ( true ){\r\n\t\t\t\r\n\t\t\tif ( counter == size )\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\tstring tmp = S.substr(cur, len); \r\n\t\t\tif ( table2.find(tmp) == table2.end() )\r\n\t\t\t\tbreak; \r\n\t\t\t\r\n\t\t\tif ( table2[tmp] <= 0 )\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\tif ( table2[tmp] > 0 ){\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif ( counter == size ){\r\n\t\t\t\r\n\t\t}\t\r\n\t}\r\n\treturn indices; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"S\": [\"1\"], \"L\": [1], \"L_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/ {\n/*FM*/void nextPermutation(vector<int> &num){\r\n\t\r\n\tint size = num.size(); \r\n\t\r\n\tif ( size == 1 )\r\n\t\treturn; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"num\": [1], \"num_element0\": [\"1144750612\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/ {\n/*FM*/void nextPermutation(vector<int> &num){\r\n\t\r\n\tint size = num.size(); \r\n\t\r\n\tif ( size == 1 )\r\n\t\t\r\n\t\r\n\tint pre = size - 2; \r\n\tint cur = size - 1; \r\n\t\r\n\twhile ( num[pre] >= num[cur] ){\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\tif ( pre == -1 ){\r\n\t\t\r\n\t} \r\n\telse{\r\n\t\tcur = size - 1; \r\n\t\twhile ( num[pre] >= num[cur] )\r\n\t\t\t\r\n\t\tint tmp = num[cur]; \r\n\t\tnum[cur]= num[pre]; \r\n\t\tnum[pre] = tmp; \r\n\t\tsort(num.begin()+pre+1, num.end()); \r\n\t}\r\n\treturn; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"num\": [3], \"num_element0\": [\"-85491446\"], \"num_element1\": [\"-979732769\"], \"num_element2\": [\"1523789862\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestValidParentheses. /*FC*/ {\n/*FM*/int longestValidParentheses(string s){\r\n\t\r\n\tstack<int> buf; \r\n\t\r\n\tint len = s.length(); \r\n\tint pre = -1; \r\n\tint global = 0; \r\n\t\r\n\tfor ( int i = 0;  i < len;  i++ ){\r\n\t\tif ( s[i] == '(' )\r\n\t\t\t\r\n\t\telse{\r\n\t\t\tif ( !buf.empty() ){\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tpre = i; \r\n\t\t}\r\n\t}\r\n\treturn global; \t\r\n\t\t\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/ {\n/*FM*/int searchInsert(int A[], int n, int target){\r\n\t\r\n\tif ( n == 0 )\r\n\t\t\r\n\t\r\n\tint left = 0; \r\n\tint right = n - 1; \r\n\tint mid; \r\n\t\r\n\twhile ( left <= right ){\r\n\t\tmid = (left + right)/2; \r\n\t\t\r\n\t\tif ( A[mid] == target )\r\n\t\t\t\r\n\t\t\r\n\t\telse if ( A[mid] > target )\r\n\t\t\tright = mid - 1; \r\n\t\t\r\n\t\telse{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\t\r\n\t}\r\n\treturn left; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"999\"], \"n\": [\"10\"], \"target\": [\"-713589653\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/ {\n/*FM*/int searchInsert(int A[], int n, int target){\r\n\t\r\n\tif ( n == 0 )\r\n\t\t\r\n\t\r\n\tint left = 0; \r\n\tint right = n - 1; \r\n\tint mid; \r\n\t\r\n\twhile ( left <= right ){\r\n\t\tmid = (left + right)/2; \r\n\t\t\r\n\t\tif ( A[mid] == target )\r\n\t\t\treturn mid; \r\n\t\t\r\n\t\telse if ( A[mid] > target )\r\n\t\t\t\r\n\t\t\r\n\t\telse{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\t\r\n\t}\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"698\"], \"n\": [\"6\"], \"target\": [\"-763963287\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/ {\n/*FM*/int searchInsert(int A[], int n, int target){\r\n\t\r\n\tif ( n == 0 )\r\n\t\t\r\n\t\r\n\tint left = 0; \r\n\tint right = n - 1; \r\n\tint mid; \r\n\t\r\n\twhile ( left <= right ){\r\n\t\tmid = (left + right)/2; \r\n\t\t\r\n\t\tif ( A[mid] == target )\r\n\t\t\t\r\n\t\t\r\n\t\telse if ( A[mid] > target )\r\n\t\t\t\r\n\t\t\r\n\t\telse{\r\n\t\t\tif ( mid+1 < n ){\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tleft = mid + 1; \r\n\t\t\t\r\n\t\t}\t\r\n\t}\r\n\treturn left; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"172\"], \"n\": [\"1\"], \"target\": [\"1398282078\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void solveSudoku. /*FC*/ {\n/*FM*/void solveSudoku(vector<vector<char> > &board) {\r\n       queue<vector<vector<char> > > que; \r\n       que.push(board); \r\n       vector<vector<char> > cur; \r\n       unordered_set<char> se; \r\n       int i=0; \r\n       int j=0; \r\n       while (!que.empty()){\r\n           cur = que.front(); \r\n           que.pop(); \r\n           if (find(cur,i,j)==false){\r\n               \r\n               \r\n           }else{\r\n               \r\n               for (: se){\r\n                   \r\n                     \r\n               }\r\n           }\r\n       }\r\n   };/*F*//*C*//*M*/bool find(vector<vector<char> > &cur, int &i, int &j){\r\n       for (int ii=0; ii<9; ii++){\r\n           for (int jj=0; jj<9; jj++){\r\n               if (cur[ii][jj]=='.'){\r\n                   i=ii; \r\n                   j=jj; \r\n                   return true; \r\n               }\r\n           }\r\n       }\r\n       return false; \r\n   };\n}",
        "target": "{\"board\": [2], \"board_element0\": [1], \"board_element0_element0\": [\"48\"], \"board_element1\": [2], \"board_element1_element0\": [\"-34\"], \"board_element1_element1\": [\"113\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string countAndSay. /*FC*/ {\n/*FM*/string countAndSay(int n) {\r\n       if ( n <= 0 )\r\n           \r\n       \r\n       string s = \"1\"; \r\n       string tmp; \r\n       for ( int i = 1;  i < n;  i++ ){\r\n           tmp = \"\"; \r\n           int counter = 1; \r\n           for ( int j = 1;  j < s.length();  j++){\r\n               if ( s[j] == s[j-1] )\r\n                   counter++; \r\n               else{\r\n                   tmp = tmp + char('0' + counter) + s[j-1]; \r\n                   counter=1; \r\n               }\r\n           }\r\n           tmp = tmp + char('0' + counter) + s[s.length()-1]; \r\n           s = tmp; \r\n       }\r\n       return s; \r\n   };/*F*//*C*//*M*/\n}",
        "target": "{\"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstMissingPositive. /*FC*/ {\n/*FM*/int firstMissingPositive(int A[], int n) {\r\n        if ( n <= 0 )\r\n            \r\n        \r\n        for ( int i = 0;  i < n;  ){\r\n\t\t\t\r\n            if ( A[i] <= 0 || A[i] > n || A[i] == i+1 )\r\n                i++; \r\n            else{\r\n                int index = A[i]-1; \r\n\t\t\t\tif ( A[i] == A[index]){\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n                int tmp = A[i]; \r\n                A[i] = A[index]; \r\n                A[index] = tmp; \r\n            }\r\n\t\t\tfor ( int k = 0;  k < n;  k++ )\r\n\t\t\t\tcout << A[k] << \" \"; \r\n\t\t\tcout << endl; \r\n        }\r\n        \r\n\t\tfor ( int i = 0;  i < n;  i++ )\r\n\t\t\tcout << A[i] << \" \"; \r\n\t\tcout << endl; \r\n\t\t\r\n        for ( int i = 0;  i < n;   ){\r\n            if ( A[i] != (i+1) )\r\n                return (i+1); \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"616363021\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int trap. /*FC*/ {\n/*FM*/int trap(int A[], int n){\r\n\t\r\n\tint contain = 0; \r\n\t\r\n\tif ( n == 0 )\r\n\t\treturn 0; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [2], \"A[0]\": [\"993962727\"], \"A[1]\": [\"-842542138\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int trap. /*FC*/ {\n/*FM*/int trap(int A[], int n){\r\n\t\r\n\tint contain = 0; \r\n\t\r\n\tif ( n == 0 )\r\n\t\t\r\n\t\r\n\tint maxleft[n]; \r\n\tint maxright[n]; \r\n\t\r\n\tint max = A[0]; \r\n\t\r\n\tfor ( int i = 1;  i < n;  i++ ){\r\n\t\tmaxleft[i] = max; \r\n\t\tif ( A[i] > max )\r\n\t\t\tmax = A[i]; \r\n\t}\r\n\t\r\n\tmax = A[n-1]; \r\n\tfor ( int i = n - 2;  i >= 0;  i-- ){\r\n\t\tmaxright[i] = max; \r\n\t\tif ( A[i] > max )\r\n\t\t\tmax = A[i]; \r\n\t}\r\n\t\r\n\tfor ( int i = 0;  i < n - 1;  i++ ){\r\n\t\tint trap = min(maxleft[i], maxright[i]) - A[i]; \r\n\t\tif ( trap > 0 )\r\n\t\t\tcontain += trap; \r\n\t}\r\n\treturn contain; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [3], \"A[0]\": [\"86846582\"], \"A[1]\": [\"-1590553469\"], \"A[2]\": [\"882659081\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isMatch. /*FC*/ {\n/*FM*/bool isMatch(string s, string p) {\r\n        int cur1 = 0; \r\n        int cur2 = 0; \r\n        \r\n        int pp = -1; \r\n        int ss = -1; \r\n        while(cur1 < s.length()){\r\n            if( s[cur1] == p[cur2] || p[cur2] == '?' ){\r\n                cur1++; \r\n                cur2++; \r\n                continue; \r\n            }\r\n            if(p[cur2] == '*'){\r\n                \r\n                \r\n                \r\n                \r\n            }\r\n            if (pp != -1){\r\n                \r\n                \r\n                \r\n            }\r\n\t\t\t\r\n            \r\n        }\r\n        while (cur2 < p.length() && p[cur2] == '*')\r\n            \r\n        return (cur2 == p.length()); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"], \"p\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isMatch. /*FC*/ {\n/*FM*/bool isMatch(string s, string p) {\r\n        int cur1 = 0; \r\n        int cur2 = 0; \r\n        \r\n        int pp = -1; \r\n        int ss = -1; \r\n        while(cur1 < s.length()){\r\n            if( s[cur1] == p[cur2] || p[cur2] == '?' ){\r\n                \r\n                \r\n                \r\n            }\r\n            if(p[cur2] == '*'){\r\n                \r\n                \r\n                \r\n                \r\n            }\r\n            if (pp != -1){\r\n                \r\n                \r\n                \r\n            }\r\n\t\t\tcout << cur1 << \" \" << cur2 << endl; \r\n            return false; \r\n        }\r\n           \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"], \"p\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/ {\n/*FM*/int jump(int A[], int n){\r\n\t\r\n\tint ret = 0;  \r\n\tint last = 0; \r\n\tint curr = 0; \r\n\tfor ( int i = 0;  i <n;  i++ ){\r\n\t\tif ( i > last ){\r\n\t\t\tlast = curr; \r\n\t\t\t++ret; \r\n\t\t}\r\n\t\tcurr = max(curr, i+A[i]); \r\n\t}\r\n\treturn ret; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [2], \"A[0]\": [\"-1536812452\"], \"A[1]\": [\"1986642634\"], \"n\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/ {\n/*FM*/void rotate(vector<vector<int> > &matrix){\r\n\t\r\n\tint len = matrix.size(); \r\n\t\r\n\tif ( len == 1 )\r\n\t\t\r\n\t\r\n\tfor ( int i = 0;  i < len/2;  i++ ){\r\n\t\tint first = i; \r\n\t\tint last = len - 1 - i; \r\n\t\tfor ( int j = 0;  first < last;   first++, j++ ){\r\n\t\t\tint tmp = matrix[i][first]; \r\n\t\t\t\r\n\t\t\tmatrix[i][first] = matrix[last-j][i]; \r\n\t\t\tmatrix[last-j][i] = matrix[last][last-j]; \r\n\t\t\tmatrix[last][last-j] = matrix[first][last]; \r\n\t\t\tmatrix[first][last] = tmp; \r\n\t\t}\r\n\t}\r\n\treturn; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"1047292354\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"1970241644\"], \"matrix_element1_element1\": [\"1621581433\"], \"matrix_element1_element2\": [\"1775991280\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/ {\n/*FM*/void rotate(vector<vector<int> > &matrix){\r\n\t\r\n\tint len = matrix.size(); \r\n\t\r\n\tif ( len == 1 )\r\n\t\treturn; \r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"matrix\": [1], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"1372076165\"], \"matrix_element0_element1\": [\"298326342\"], \"matrix_element0_element2\": [\"-16491418\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double pow. /*FC*/ {\n/*FM*/double pow(double x, int n){\r\n\tif ( n < 0 )\r\n\t\t\r\n\t\r\n\telse\r\n\t\treturn power(x, n); \r\n};/*F*//*C*//*M*/double power(double x, int n){\r\n\t\r\n\tif ( n == 0 )\r\n\t\treturn 1; \r\n\t\r\n\tdouble v = power(x, n/2); \r\n\r\n\tif (n % 2 == 0 )\r\n\t\treturn v * v; \r\n\t\r\n\telse\r\n\t\treturn v * v * x; \r\n};\n}",
        "target": "{\"x\": [\"0.87\"], \"n\": [\"1312025550\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double power. /*FC*/ {\n/*FM*/double power(double x, int n){\r\n\t\r\n\tif ( n == 0 )\r\n\t\treturn 1; \r\n\t\r\n\tdouble v = power(x, n/2); \r\n\r\n\tif (n % 2 == 0 )\r\n\t\treturn v * v; \r\n\t\r\n\telse\r\n\t\treturn v * v * x; \r\n};/*F*//*C*//*M*/double power(double x, int n){\r\n\t\r\n\tif ( n == 0 )\r\n\t\treturn 1; \r\n\t\r\n\tdouble v = power(x, n/2); \r\n\r\n\tif (n % 2 == 0 )\r\n\t\treturn v * v; \r\n\t\r\n\telse\r\n\t\treturn v * v * x; \r\n} double power(double x, int n){\r\n\t\r\n\tif ( n == 0 )\r\n\t\treturn 1; \r\n\t\r\n\tdouble v = power(x, n/2); \r\n\r\n\tif (n % 2 == 0 )\r\n\t\treturn v * v; \r\n\t\r\n\telse\r\n\t\treturn v * v * x; \r\n};\n}",
        "target": "{\"x\": [\"0.92\"], \"n\": [\"-954826317\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxSubArray. /*FC*/ {\n/*FM*/int maxSubArray(int A[], int n){\r\n\t\r\n\tif ( n == 0 )\r\n\t\treturn 0; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [2], \"A[0]\": [\"-691020370\"], \"A[1]\": [\"-579212167\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxSubArray. /*FC*/ {\n/*FM*/int maxSubArray(int A[], int n){\r\n\t\r\n\tif ( n == 0 )\r\n\t\t\r\n\t\r\n\tint local = 0; \r\n\tint global = INT_MIN; \r\n\t\r\n\tfor ( int i = 0;  i < n;  i++ )\r\n\t{\r\n\t\tif ( local + A[i] < A[i])\r\n\t\t\tlocal = A[i]; \r\n\t\telse \r\n\t\t\tlocal = local + A[i]; \r\n\t\t\r\n\t\tif ( local > global )\r\n\t\t\tglobal = local; \r\n\t}\r\n\treturn global; \r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"1126951975\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/ {\n/*FM*/bool canJump(int A[], int n){\r\n\tint localstep = 0; \r\n\tint globalstep = 0; \r\n\t\r\n\tfor ( int i = 0;  i <= globalstep && i < n;  i++ ){\r\n\t\tlocalstep = i + A[i]; \r\n\t\tglobalstep = max(globalstep, localstep); \r\n\t}\r\n\t\r\n\treturn globalstep >= (n-1); \r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"974186123\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> merge. /*FC*/ {\n/*FM*/vector<Interval> merge(vector<Interval> &intervals, Interval newInterval){\r\n\t\r\n    vector<Interval> result; \r\n\t\r\n \tint size = intervals.size(); \r\n\t\r\n \tint i; \r\n\t\r\n \tfor ( i = 0;  i < size;  i++ ){\r\n \t\tif ( intervals[i].end < newInterval.start ){\r\n \t\t\tresult.push_back(intervals[i]); \r\n \t\t\tcontinue; \r\n \t\t}\r\n\t\t\r\n \t\tif ( intervals[i].start > newInterval.end )\r\n \t\t\t\r\n\t\t\r\n \t\t\r\n \t\t\r\n \t}\r\n\t\r\n \tresult.push_back(newInterval); \r\n\t\r\n \twhile ( i < size ){\r\n \t    \r\n \t    \r\n \t}\r\n\t\r\n \treturn result; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"intervals\": [2], \"intervals_element0\": [\"Interval\", \"Interval()\"], \"intervals_element0.start\": [\"2018999027\"], \"intervals_element0.end\": [\"-2109159840\"], \"intervals_element1\": [\"Interval\", \"Interval()\"], \"intervals_element1.start\": [\"-2116022319\"], \"intervals_element1.end\": [\"-147102809\"], \"newInterval\": [\"Interval\", \"Interval()\"], \"newInterval.start\": [\"2077726088\"], \"newInterval.end\": [\"-156736727\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> merge. /*FC*/ {\n/*FM*/vector<Interval> merge(vector<Interval> &intervals, Interval newInterval){\r\n\t\r\n    vector<Interval> result; \r\n\t\r\n \tint size = intervals.size(); \r\n\t\r\n \tint i; \r\n\t\r\n \tfor ( i = 0;  i < size;  i++ ){\r\n \t\tif ( intervals[i].end < newInterval.start ){\r\n \t\t\t\r\n \t\t\t\r\n \t\t}\r\n\t\t\r\n \t\tif ( intervals[i].start > newInterval.end )\r\n \t\t\t\r\n\t\t\r\n \t\tnewInterval.start = min(newInterval.start, intervals[i].start); \r\n \t\tnewInterval.end   = max(newInterval.end, intervals[i].end); \r\n \t}\r\n\t\r\n \tresult.push_back(newInterval); \r\n\t\r\n \twhile ( i < size ){\r\n \t    \r\n \t    \r\n \t}\r\n\t\r\n \treturn result; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"intervals\": [2], \"intervals_element0\": [\"Interval\", \"Interval()\"], \"intervals_element0.start\": [\"-552662818\"], \"intervals_element0.end\": [\"510751195\"], \"intervals_element1\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element1_s\": [\"455008240\"], \"intervals_element1_e\": [\"505486711\"], \"intervals_element1.start\": [\"-1756198202\"], \"intervals_element1.end\": [\"256483507\"], \"newInterval\": [\"Interval\", \"Interval(int,int)\"], \"newInterval_s\": [\"-1113402901\"], \"newInterval_e\": [\"-1838496791\"], \"newInterval.start\": [\"59185305\"], \"newInterval.end\": [\"-116870179\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/ {\n/*FM*/int lengthOfLastWord(string s) {\r\n        s = s + ' '; \r\n        int len = s.length(); \r\n        int counter = 0; \r\n        int cur = 0; \r\n        int index = 0; \r\n        \r\n        while ( index < len ){\r\n            if ( s[index] != ' ' )\r\n                cur++; \r\n            else{\r\n                if ( cur != 0 ){\r\n                    counter = cur; \r\n                    cur = 0; \r\n                }\r\n            }\r\n            index++; \r\n        }\r\n        return counter; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/ {\n/*FM*/string simplifyPath(string path){\r\n\t\r\n\tstring s = \"\"; \r\n\t\r\n\tint dot = 0; \r\n\tint back = 0; \r\n\tint charac = 0; \r\n\tint valid = 1; \r\n\tint len = path.length(); \r\n\t\r\n\tfor ( int i = len - 1;  i >= 0;  i-- ){\r\n\t\t\r\n\t\tif ( path[i] == '/' ){\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse if ( path[i] == '.'){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse{\r\n\t\t\tcharac++; \r\n\t\t\tif ( !valid )\r\n\t\t\t\t\r\n\t\t}\r\n\t}\r\n\t\r\n\tint lens = s.length(); \r\n\tif ( s[lens-1] == '/' && lens > 1)\r\n\t\t\r\n\telse if ( lens == 0 )\r\n\t\treturn \"/\"; \r\n\telse\r\n\t\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"path\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/ {\n/*FM*/int minDistance(string word1, string word2){\r\n\t\r\n\tint len1 = word1.length(); \r\n\tint len2 = word2.length(); \r\n\t\r\n\tint **dp = new int*[len1+1]; \r\n\tfor ( int i = 0;  i <= len1;  i++ )\r\n\t\tdp[i] = new int[len2+1]; \r\n\t\r\n\tfor ( int i = 0;  i <= len1;  i++ )\r\n\t\tdp[i][0] = i; \r\n\t\r\n\tfor ( int j = 0;  j <= len2;  j++ )\r\n\t\tdp[0][j] = j; \r\n\t\r\n\tfor ( int i = 0;  i < len1;  i++ ){\r\n\t\tchar c1 = word1[i]; \r\n\t\tfor ( int j = 0;  j < len2;  j++ ){\r\n\t\t\tchar c2 = word2[j]; \r\n\t\t\tif ( c1 == c2 )\r\n\t\t\t\t\r\n\t\t\telse{\r\n\t\t\t\tint replace = dp[i][j] + 1; \r\n\t\t\t\tint insert = dp[i][j+1] + 1; \r\n\t\t\t\tint delet = dp[i+1][j] + 1; \r\n\t\t\t\t\r\n\t\t\t\tdp[i+1][j+1] = min(min(replace, insert), delet); \r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn dp[len1][len2]; \r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"word1\": [\"1\"], \"word2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void setZeroes. /*FC*/ {\n/*FM*/void setZeroes(vector<vector<int> > &matrix){\r\n\t\r\n\tint len = matrix.size(); \r\n\tint wid = matrix[0].size(); \r\n\t\r\n\tint row[len]; \r\n\tint column[wid]; \r\n\t\r\n\tmemset(row, 0,  sizeof(row)); \r\n\tmemset(column, 0, sizeof(column)); \r\n\t\r\n\tfor ( int i = 0;  i < len;  i++ )\r\n\t\tfor ( int j = 0;  j < wid;  j++ ){\r\n\t\t\tif ( matrix[i][j] == 0 ){\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tfor ( int i = 0;  i < len;  i++ )\r\n\t\tfor ( int j = 0;  j < wid;  j++ ){\r\n\t\t\tif ( row[i] || column[j] )\r\n\t\t\t\t\r\n\t\t}\r\n\treturn; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"-681\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"-691\"], \"matrix_element1_element1\": [\"828\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/ {\n/*FM*/bool searchMatrix(vector<vector<int> > &matrix, int target){\r\n \t\r\n\tint length = matrix.size(); \r\n\tint width  = matrix[0].size(); \r\n\r\n\tint mid; \r\n\tint left = 0; \r\n\tint right = length - 1; \r\n\tint cur = 0; \r\n\t\r\n\twhile ( left + 1 < right ){\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\tif ( right - left == 1){\r\n\t\tif (matrix[left][width-1] == target)\r\n\t\t\t\r\n\t\t\r\n\t\telse if (matrix[left][width-1] > target)\r\n\t\t\tcur = left; \r\n\t\t\r\n\t\telse\r\n\t\t\t\r\n\t}\r\n\telse\r\n\t\t\r\n\t\r\n\tleft = 0; \r\n\tright = width - 1; \r\n\t\r\n\twhile ( left <= right ){\r\n\t\t\r\n\t\tmid = (left + right)/2; \r\n\t\t\r\n\t\tif ( matrix[cur][mid] == target )\r\n\t\t\t\r\n\t\t\r\n\t\telse if ( target < matrix[cur][mid] )\r\n\t\t\tright = mid - 1; \r\n\t\t\r\n\t\telse\r\n\t\t\t\r\n\t}\r\n\treturn false; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-564\"], \"matrix_element0_element1\": [\"383\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"829\"], \"matrix_element1_element1\": [\"974\"], \"target\": [\"-1893649213\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/ {\n/*FM*/bool searchMatrix(vector<vector<int> > &matrix, int target){\r\n \t\r\n\tint length = matrix.size(); \r\n\tint width  = matrix[0].size(); \r\n\r\n\tint mid; \r\n\tint left = 0; \r\n\tint right = length - 1; \r\n\tint cur = 0; \r\n\t\r\n\twhile ( left + 1 < right ){\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\tif ( right - left == 1){\r\n\t\tif (matrix[left][width-1] == target)\r\n\t\t\t\r\n\t\t\r\n\t\telse if (matrix[left][width-1] > target)\r\n\t\t\t\r\n\t\t\r\n\t\telse\r\n\t\t\tcur = right; \r\n\t}\r\n\telse\r\n\t\t\r\n\t\r\n\tleft = 0; \r\n\tright = width - 1; \r\n\t\r\n\twhile ( left <= right ){\r\n\t\t\r\n\t\tmid = (left + right)/2; \r\n\t\t\r\n\t\tif ( matrix[cur][mid] == target )\r\n\t\t\t\r\n\t\t\r\n\t\telse if ( target < matrix[cur][mid] )\r\n\t\t\t\r\n\t\t\r\n\t\telse\r\n\t\t\tleft = mid + 1; \r\n\t}\r\n\treturn false; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"714\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"-615\"], \"target\": [\"122381483\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/ {\n/*FM*/bool searchMatrix(vector<vector<int> > &matrix, int target){\r\n \t\r\n\tint length = matrix.size(); \r\n\tint width  = matrix[0].size(); \r\n\r\n\tint mid; \r\n\tint left = 0; \r\n\tint right = length - 1; \r\n\tint cur = 0; \r\n\t\r\n\twhile ( left + 1 < right ){\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\tif ( right - left == 1){\r\n\t\t\r\n\t}\r\n\telse\r\n\t\tcur = left; \r\n\t\r\n\tleft = 0; \r\n\tright = width - 1; \r\n\t\r\n\twhile ( left <= right ){\r\n\t\t\r\n\t\tmid = (left + right)/2; \r\n\t\t\r\n\t\tif ( matrix[cur][mid] == target )\r\n\t\t\t\r\n\t\t\r\n\t\telse if ( target < matrix[cur][mid] )\r\n\t\t\t\r\n\t\t\r\n\t\telse\r\n\t\t\tleft = mid + 1; \r\n\t}\r\n\treturn false; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"matrix\": [1], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-763\"], \"matrix_element0_element1\": [\"700\"], \"target\": [\"56081655\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors1. /*FC*/ {\n/*FM*/void sortColors1(int A[], int n){\r\n\t\r\n\tif ( n == 0 )\r\n\t\treturn; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"565\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors1. /*FC*/ {\n/*FM*/void sortColors1(int A[], int n){\r\n\t\r\n\tif ( n == 0 )\r\n\t\t\r\n\t\r\n\tint red = 0, white = 0, blue = 0; \r\n\t\r\n\tfor ( int i = 0;  i < n;  i++ ){\r\n\t\t\r\n\t\tif (A[i] == 0)\r\n\t\t\t\r\n\t\telse if (A[i] == 1)\r\n\t\t\t\r\n\t\telse\r\n\t\t\tblue++; \r\n\t}\r\n\t\r\n\tfor ( int i = 0;  i< n;  i++ ){\r\n\t\t\r\n\t\tif ( red > 0 ){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse if (white > 0){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse{\r\n\t\t\tA[i] = 2; \r\n\t\t}\r\n\t}\r\n\treturn; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [2], \"A[0]\": [\"-489\"], \"A[1]\": [\"301\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/ {\n/*FM*/string minWindow(string S, string T){\r\n\r\n\tmap<char, int> Ttable; \r\n\tmap<char, int> Stable; \r\n\t\r\n\tint Tlen = T.length(); \r\n\tint Slen = S.length(); \r\n\t\r\n\tfor ( int i = 0;  i < Tlen;  i++ ){\r\n\t\tif ( Ttable.find(T[i]) == Ttable.end() ){\r\n\t\t\tTtable[T[i]] = 1; \r\n\t\t\tStable[T[i]] = 0; \r\n\t\t}\r\n\t\telse\r\n\t\t\t\r\n\t}\r\n\t\r\n\tint begin = 0; \r\n\tint end = 0; \r\n\tint counter = 0; \r\n\tint start = -1; \r\n\tint epi = -1; \r\n\t\r\n\twhile ( begin != Slen ){\r\n\t\t\r\n\t\tcout << begin << end << counter << endl; \r\n\t\tif ( counter < Tlen && end < Slen ){\r\n\r\n\t\t\tif ( Stable.find(S[end]) != Stable.end() ){\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\tend++; \r\n\t\t}\r\n\t\t\r\n\t\telse{\r\n\t\t\t\r\n\t\t\tif ( counter == Tlen ){\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( Stable.find(S[begin]) != Stable.end() ){\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tbegin++; \r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tif ( start == -1 )\r\n\t\treturn \"\"; \r\n\telse\r\n\t\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"S\": [\"1\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > combine. /*FC*/ {\n/*FM*/vector<vector<int> > combine(int n, int k) {\r\n        \n        \n        res.clear(); \r\n         \r\n        if ((k<1)||(n<1)||(k>n)){return res; }\r\n        \r\n        \r\n        \r\n        \r\n        \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"res\": [2], \"res_element0\": [3], \"res_element0_element0\": [\"-960906554\"], \"res_element0_element1\": [\"-1272755141\"], \"res_element0_element2\": [\"-251724720\"], \"res_element1\": [2], \"res_element1_element0\": [\"189332753\"], \"res_element1_element1\": [\"1136353919\"], \"n\": [\"3\"], \"k\": [\"1306138346\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void dfs. /*FC*/ {\n/*FM*/void dfs(vector<int> &cand, int st, int ed, vector<int> &lr){\r\n\tif (lr.size()==ed){\r\n    \t\r\n        \r\n    }\r\n    for (int i = st;  i< cand.size(); ){\r\n        \r\n        \r\n        \r\n\t}        \r\n};/*F*//*C*//*M*/void dfs(vector<int> &cand, int st, int ed, vector<int> &lr){\r\n\tif (lr.size()==ed){\r\n    \tres.push_back(lr); \r\n        return; \r\n    }\r\n    for (int i = st;  i< cand.size(); i++){\r\n        lr.push_back(cand[i]); \r\n        dfs(cand,i+1,ed,lr); \r\n        lr.pop_back(); \r\n\t}        \r\n} void dfs(vector<int> &cand, int st, int ed, vector<int> &lr){\r\n\tif (lr.size()==ed){\r\n    \tres.push_back(lr); \r\n        return; \r\n    }\r\n    for (int i = st;  i< cand.size(); i++){\r\n        lr.push_back(cand[i]); \r\n        dfs(cand,i+1,ed,lr); \r\n        lr.pop_back(); \r\n\t}        \r\n};\n}",
        "target": "{\"res\": [1], \"res_element0\": [2], \"res_element0_element0\": [\"-949677645\"], \"res_element0_element1\": [\"-713452832\"], \"cand\": [3], \"cand_element0\": [\"-1867334297\"], \"cand_element1\": [\"1973792340\"], \"cand_element2\": [\"-1491372929\"], \"st\": [\"3\"], \"ed\": [\"-1197991730\"], \"lr\": [3], \"lr_element0\": [\"556607472\"], \"lr_element1\": [\"1994264814\"], \"lr_element2\": [\"5302905\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool exist. /*FC*/ {\n/*FM*/bool exist(vector<vector<char > > &board, string word) {\r\n\tif ( word == \"\" )\r\n\t\t\r\n\t\r\n\tint length = board.size(); \r\n\tint width  = board[0].size(); \r\n\t\r\n\t\r\n\tint **table; \r\n\ttable = new int *[length]; \r\n\tfor (int i = 0;  i < length;  i++ )\r\n\t\ttable[i] = new int[width]; \r\n\t\r\n\tfor ( int i = 0;  i < length;  i++ )\r\n\t\tfor ( int j = 0;  j < width;  j++ )\r\n\t\t\ttable[i][j] = 0; \r\n\t\r\n\tfor (int i = 0;  i < board.size();  i++)\r\n\t\tfor (int j = 0;  j < board[i].size();  j++){\r\n\t\t\tif ( board[i][j] == word[0]){\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\treturn false; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"board\": [1], \"board_element0\": [3], \"board_element0_element0\": [\"18\"], \"board_element0_element1\": [\"-17\"], \"board_element0_element2\": [\"104\"], \"word\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/ {\n/*FM*/int removeDuplicates(int A[], int n){\r\n\t\r\n\tif ( n <= 2 )\r\n\t\t\r\n\t\r\n\tint pre = 0; \r\n\tint len = 1; \r\n\tint cur_num = A[0]; \r\n\tint num = 1; \r\n\t\r\n\tfor ( int cur = 1;  cur < n;  cur++ ){\r\n\t\tif ( A[cur] == A[cur-1] ){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse{\r\n\t\t\tcur_num = A[cur]; \r\n\t\t\tnum = 1; \r\n\t\t\tA[pre+1] = A[cur]; \r\n\t\t\tpre++; \r\n\t\t\tlen++; \r\n\t\t}\t \r\n\t}\r\n\treturn len; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [2], \"A[0]\": [\"765882183\"], \"A[1]\": [\"111668926\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void traverse_print. /*FC*/ {\n/*FM*/void traverse_print(TreeNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\ttraverse_print(root->left); \r\n\ttraverse_print(root->right); \r\n\tcout << root->val << \" \"; \r\n\t\n};/*F*//*C*//*M*/void traverse_print(TreeNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\ttraverse_print(root->left); \r\n\ttraverse_print(root->right); \r\n\tcout << root->val << \" \"; \r\n\t\n} void traverse_print(TreeNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\ttraverse_print(root->left); \r\n\ttraverse_print(root->right); \r\n\tcout << root->val << \" \"; \r\n\t\n};\n}",
        "target": "{\"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1960818037\"], \"root[0].val\": [\"1788899057\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/ {\n/*FM*/void insert(TreeNode *root, int a){\r\n\tif (root->left == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->left = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse if ( root->right == NULL ){\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\telse\r\n\t\t\r\n};/*F*//*C*//*M*/void insert(TreeNode *root, int a){\r\n\tif (root->left == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->left = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse if ( root->right == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->right = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse\r\n\t\tinsert(root->left, a); \r\n} void insert(TreeNode *root, int a){\r\n\tif (root->left == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->left = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse if ( root->right == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->right = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse\r\n\t\tinsert(root->left, a); \r\n} TreeNode(int x): val(x), left(NULL), right(NULL){};\n}",
        "target": "{\"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1201658306\"], \"root[0].right\": [3], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-194569873\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"0\"], \"root[0].right[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right2_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1647646645\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"-798571468\"], \"a\": [\"1399502227\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/ {\n/*FM*/void insert(TreeNode *root, int a){\r\n\tif (root->left == NULL ){\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\telse if ( root->right == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->right = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse\r\n\t\t\r\n};/*F*//*C*//*M*/void insert(TreeNode *root, int a){\r\n\tif (root->left == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->left = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse if ( root->right == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->right = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse\r\n\t\tinsert(root->left, a); \r\n} void insert(TreeNode *root, int a){\r\n\tif (root->left == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->left = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse if ( root->right == NULL ){\r\n\t\tTreeNode* node = new TreeNode(a); \r\n\t\troot->right = node; \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse\r\n\t\tinsert(root->left, a); \r\n} TreeNode(int x): val(x), left(NULL), right(NULL){};\n}",
        "target": "{\"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1287745389\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1986452163\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"a\": [\"1138170536\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSameTree. /*FC*/ {\n/*FM*/bool isSameTree(TreeNode *p, TreeNode *q) {\r\n       if ( p == NULL && q == NULL )\r\n           \r\n       \r\n       if ( p == NULL || q == NULL )\r\n           \r\n       \r\n       if ( p->val == q->val ){\r\n           \r\n       }\r\n       else\r\n           return false; \r\n   };/*F*//*C*//*M*/bool isSameTree(TreeNode *p, TreeNode *q) {\r\n       if ( p == NULL && q == NULL )\r\n           return true; \r\n       \r\n       if ( p == NULL || q == NULL )\r\n           return false; \r\n       \r\n       if ( p->val == q->val ){\r\n           if ( isSameTree(p->left, q->left) )\r\n               return isSameTree(p->right, q->right); \r\n           else\r\n               return false; \r\n       }\r\n       else\r\n           return false; \r\n   } bool isSameTree(TreeNode *p, TreeNode *q) {\r\n       if ( p == NULL && q == NULL )\r\n           return true; \r\n       \r\n       if ( p == NULL || q == NULL )\r\n           return false; \r\n       \r\n       if ( p->val == q->val ){\r\n           if ( isSameTree(p->left, q->left) )\r\n               return isSameTree(p->right, q->right); \r\n           else\r\n               return false; \r\n       }\r\n       else\r\n           return false; \r\n   };\n}",
        "target": "{\"p\": [1], \"p[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_x\": [\"517\"], \"p[0].val\": [\"437\"], \"p[0].left\": [1], \"p[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_left0_x\": [\"-106\"], \"p[0].left[0].val\": [\"887\"], \"p[0].right\": [2], \"p[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_right0_x\": [\"141\"], \"p[0].right[0].val\": [\"530\"], \"p[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"p0_right1_x\": [\"-539\"], \"p[0].right[1].val\": [\"-36\"], \"q\": [1], \"q[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"q0_x\": [\"400\"], \"q[0].val\": [\"650\"], \"q[0].left\": [1], \"q[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"q0_left0_x\": [\"-739\"], \"q[0].left[0].val\": [\"409\"], \"q[0].right\": [1], \"q[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"q0_right0_x\": [\"917\"], \"q[0].right[0].val\": [\"-67\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSymmetric. /*FC*/ {\n/*FM*/bool isSymmetric(TreeNode *root) {\r\n       if ( root == NULL )\r\n           \r\n       \r\n       return isS(root->left, root->right); \r\n   };/*F*//*C*//*M*/bool isS(TreeNode* left, TreeNode* right){\r\n       if (left == NULL && right == NULL)\r\n           return true; \r\n       \r\n       if ( left == NULL || right == NULL )\r\n           return false; \r\n       \r\n       if (left->val != right->val)\r\n           return false; \r\n       \r\n       if ( isS(left->left, right->right) )\r\n           return isS(left->right, right->left); \r\n       else\r\n           return false; \r\n   };\n}",
        "target": "{\"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-273\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-1000\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"753\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isS. /*FC*/ {\n/*FM*/bool isS(TreeNode* left, TreeNode* right){\r\n       if (left == NULL && right == NULL)\r\n           \r\n       \r\n       if ( left == NULL || right == NULL )\r\n           \r\n       \r\n       if (left->val != right->val)\r\n           return false; \r\n       \r\n       if ( isS(left->left, right->right) )\r\n           \r\n       else\r\n           \r\n   };/*F*//*C*//*M*/bool isS(TreeNode* left, TreeNode* right){\r\n       if (left == NULL && right == NULL)\r\n           return true; \r\n       \r\n       if ( left == NULL || right == NULL )\r\n           return false; \r\n       \r\n       if (left->val != right->val)\r\n           return false; \r\n       \r\n       if ( isS(left->left, right->right) )\r\n           return isS(left->right, right->left); \r\n       else\r\n           return false; \r\n   } bool isS(TreeNode* left, TreeNode* right){\r\n       if (left == NULL && right == NULL)\r\n           return true; \r\n       \r\n       if ( left == NULL || right == NULL )\r\n           return false; \r\n       \r\n       if (left->val != right->val)\r\n           return false; \r\n       \r\n       if ( isS(left->left, right->right) )\r\n           return isS(left->right, right->left); \r\n       else\r\n           return false; \r\n   };\n}",
        "target": "{\"left\": [2], \"left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"left0_x\": [\"945\"], \"left[0].val\": [\"-802\"], \"left[0].left\": [1], \"left[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"left0_left0_x\": [\"-796\"], \"left[0].left[0].val\": [\"-738\"], \"left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"left1_x\": [\"666\"], \"left[1].val\": [\"557\"], \"left[1].left\": [2], \"left[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"left1_left0_x\": [\"106\"], \"left[1].left[0].val\": [\"390\"], \"left[1].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"left1_left1_x\": [\"636\"], \"left[1].left[1].val\": [\"635\"], \"left[1].right\": [1], \"left[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"left1_right0_x\": [\"-511\"], \"left[1].right[0].val\": [\"826\"], \"right\": [2], \"right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"right0_x\": [\"-693\"], \"right[0].val\": [\"96\"], \"right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"right1_x\": [\"-846\"], \"right[1].val\": [\"613\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isS. /*FC*/ {\n/*FM*/bool isS(TreeNode* left, TreeNode* right){\r\n       if (left == NULL && right == NULL)\r\n           \r\n       \r\n       if ( left == NULL || right == NULL )\r\n           return false; \r\n       \r\n       if (left->val != right->val)\r\n           \r\n       \r\n       if ( isS(left->left, right->right) )\r\n           \r\n       else\r\n           \r\n   };/*F*//*C*//*M*/bool isS(TreeNode* left, TreeNode* right){\r\n       if (left == NULL && right == NULL)\r\n           return true; \r\n       \r\n       if ( left == NULL || right == NULL )\r\n           return false; \r\n       \r\n       if (left->val != right->val)\r\n           return false; \r\n       \r\n       if ( isS(left->left, right->right) )\r\n           return isS(left->right, right->left); \r\n       else\r\n           return false; \r\n   } bool isS(TreeNode* left, TreeNode* right){\r\n       if (left == NULL && right == NULL)\r\n           return true; \r\n       \r\n       if ( left == NULL || right == NULL )\r\n           return false; \r\n       \r\n       if (left->val != right->val)\r\n           return false; \r\n       \r\n       if ( isS(left->left, right->right) )\r\n           return isS(left->right, right->left); \r\n       else\r\n           return false; \r\n   };\n}",
        "target": "{\"left\": [2], \"left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"left0_x\": [\"-464\"], \"left[0].val\": [\"301\"], \"left[0].left\": [1], \"left[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"left0_left0_x\": [\"72\"], \"left[0].left[0].val\": [\"-33\"], \"left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"left1_x\": [\"783\"], \"left[1].val\": [\"526\"], \"left[1].left\": [1], \"left[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"left1_left0_x\": [\"-704\"], \"left[1].left[0].val\": [\"708\"], \"left[1].right\": [2], \"left[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"left1_right0_x\": [\"568\"], \"left[1].right[0].val\": [\"82\"], \"left[1].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"left1_right1_x\": [\"266\"], \"left[1].right[1].val\": [\"848\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > levelOrder. /*FC*/ {\n/*FM*/vector<vector<int> > levelOrder(TreeNode *root) {\r\n        vector<vector<int> > res; \r\n        if ( root == NULL )\r\n            \r\n        \r\n        vector<TreeNode*> buf1; \r\n        buf1.push_back(root); \r\n        \r\n        while (!buf1.empty()){\r\n            int size = buf1.size(); \r\n            vector<int> row; \r\n            int pos = 0; \r\n            for ( int i = 0;  i < size;  i++  ){\r\n                row.push_back(buf1[0]->val); \r\n                if ( buf1[0]->left )\r\n                    \r\n                if ( buf1[0]->right )\r\n                    \r\n                buf1.erase(buf1.begin()); \r\n            }\r\n            res.push_back(row); \r\n        }\r\n        return res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"152\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-371\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/ {\n/*FM*/int maxDepth(TreeNode *root) {\r\n\tif ( root == NULL )\r\n    \treturn 0; \r\n\treturn 1 + max(maxDepth(root->left), maxDepth(root->right)); \r\n};/*F*//*C*//*M*/int maxDepth(TreeNode *root) {\r\n\tif ( root == NULL )\r\n    \treturn 0; \r\n\treturn 1 + max(maxDepth(root->left), maxDepth(root->right)); \r\n} int maxDepth(TreeNode *root) {\r\n\tif ( root == NULL )\r\n    \treturn 0; \r\n\treturn 1 + max(maxDepth(root->left), maxDepth(root->right)); \r\n};\n}",
        "target": "{\"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-535\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"283\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/ {\n/*FM*/void insert(ListNode *head, int x){\r\n\tListNode *cur = head; \r\n\twhile(cur->next != NULL)\r\n\t\t\r\n\tListNode *node = new ListNode(x); \r\n\tcur->next = node; \r\n};/*F*//*C*//*M*/ListNode(int x): val(x), next(NULL) {};\n}",
        "target": "{\"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"277727304\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1440659619\"], \"x\": [\"40963530\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void traverse. /*FC*/ {\n/*FM*/void traverse(TreeNode*root){\r\n\tif (root == NULL )\r\n\t\treturn; \r\n\ttraverse(root->left); \r\n\tcout << root->val << \" \"; \r\n\ttraverse(root->right); \r\n\treturn; \r\n};/*F*//*C*//*M*/void traverse(TreeNode*root){\r\n\tif (root == NULL )\r\n\t\treturn; \r\n\ttraverse(root->left); \r\n\tcout << root->val << \" \"; \r\n\ttraverse(root->right); \r\n\treturn; \r\n} void traverse(TreeNode*root){\r\n\tif (root == NULL )\r\n\t\treturn; \r\n\ttraverse(root->left); \r\n\tcout << root->val << \" \"; \r\n\ttraverse(root->right); \r\n\treturn; \r\n};\n}",
        "target": "{\"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"631\"], \"root[0].val\": [\"-471\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-812\"], \"root[0].left[0].val\": [\"817\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"-494\"], \"root[0].left[1].val\": [\"827\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-293\"], \"root[0].right[0].val\": [\"604\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDepth. /*FC*/ {\n/*FM*/int minDepth(TreeNode *root) {\r\n       if ( root == NULL )\r\n           \r\n       \r\n       if ( root->left == NULL && root->right == NULL )\r\n           return 1; \r\n       else if ( root->left == NULL )\r\n           \r\n       else if ( root->right == NULL )\r\n           return 1+minDepth(root->left); \r\n       else\r\n           \r\n   };/*F*//*C*//*M*/int minDepth(TreeNode *root) {\r\n       if ( root == NULL )\r\n           return 0; \r\n       \r\n       if ( root->left == NULL && root->right == NULL )\r\n           return 1; \r\n       else if ( root->left == NULL )\r\n           return 1+minDepth(root->right); \r\n       else if ( root->right == NULL )\r\n           return 1+minDepth(root->left); \r\n       else\r\n           return 1+min(minDepth(root->left), minDepth(root->right)); \r\n   } int minDepth(TreeNode *root) {\r\n       if ( root == NULL )\r\n           return 0; \r\n       \r\n       if ( root->left == NULL && root->right == NULL )\r\n           return 1; \r\n       else if ( root->left == NULL )\r\n           return 1+minDepth(root->right); \r\n       else if ( root->right == NULL )\r\n           return 1+minDepth(root->left); \r\n       else\r\n           return 1+min(minDepth(root->left), minDepth(root->right)); \r\n   };\n}",
        "target": "{\"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"597\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"830\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDistinct. /*FC*/ {\n/*FM*/int numDistinct(string S, string T){\r\n\t\r\n\tint len1 = S.length(); \r\n\tint len2 = T.length(); \r\n\t\r\n\tint **dp; \r\n\tdp = new int*[len2+1]; \r\n\tfor ( int i = 0;  i <= len2;  i++ )\r\n\t\tdp[i] = new int[len1+1]; \r\n\t\r\n\tfor ( int i = 0;  i <= len1;  i++ )\r\n\t\tdp[0][i] = 1; \r\n\t\r\n\tfor ( int i = 1;  i <= len2;  i++ ){\r\n\t\tdp[i][0] = 0; \r\n\t}\r\n\t\r\n\tfor ( int i = 1;  i <= len2;  i++ )\r\n\t\tfor ( int j = 1;  j <= len1;  j++ ){\r\n\t\t\tif ( T[i-1] != S[j-1] )\r\n\t\t\t\tdp[i][j] = dp[i][j-1]; \r\n\t\t\telse\r\n\t\t\t\t\r\n\t}\r\n\treturn dp[len2][len1]; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"S\": [\"1\"], \"T\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void traverse. /*FC*/ {\n/*FM*/void traverse(TreeLinkNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\ttraverse(root->left); \r\n\tcout << root->val << \" \"; \r\n\ttraverse(root->right); \r\n};/*F*//*C*//*M*/void traverse(TreeLinkNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\ttraverse(root->left); \r\n\tcout << root->val << \" \"; \r\n\ttraverse(root->right); \r\n} void traverse(TreeLinkNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\ttraverse(root->left); \r\n\tcout << root->val << \" \"; \r\n\ttraverse(root->right); \r\n};\n}",
        "target": "{\"root\": [3], \"root[0]\": [\"TreeLinkNode\", \"TreeLinkNode()\"], \"root[0].val\": [\"192339389\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeLinkNode\", \"TreeLinkNode()\"], \"root[0].left[0].val\": [\"-314137732\"], \"root[0].left[1]\": [\"TreeLinkNode\", \"TreeLinkNode()\"], \"root[0].left[1].val\": [\"-322427270\"], \"root[0].left[2]\": [\"TreeLinkNode\", \"TreeLinkNode()\"], \"root[1]\": [\"TreeLinkNode\", \"TreeLinkNode()\"], \"root[1].val\": [\"-1045663878\"], \"root[2]\": [\"TreeLinkNode\", \"TreeLinkNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void connect. /*FC*/ {\n/*FM*/void connect(TreeLinkNode *root){\r\n\tif ( root == NULL )\r\n\t\t\r\n\troot->next = NULL; \r\n\tdfs(root); \r\n\treturn; \r\n};/*F*//*C*//*M*/void dfs(TreeLinkNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\t\r\n\tif ( root->next == NULL){\r\n\t\tif ( root->right != NULL )\r\n\t\t\troot->right->next = NULL; \r\n\t\tif ( root->left  != NULL )\r\n\t\t\troot->left->next = root->right; \r\n\t}\r\n\telse{\r\n\t\tif ( root->right != NULL )\r\n\t\t\troot->right->next = root->next->left; \r\n\t\tif ( root->left )\r\n\t\t\troot->left->next = root->right; \r\n\t}\r\n\t\r\n\tdfs(root->right); \r\n\tdfs(root->left); \r\n\treturn; \r\n};\n}",
        "target": "{\"root\": [1], \"root[0]\": [\"TreeLinkNode\", \"TreeLinkNode()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> getRow. /*FC*/ {\n/*FM*/vector<int> getRow(int rowIndex) {\r\n       vector<int> row; \r\n       if ( rowIndex < 0 )\r\n           \r\n       \r\n       row.push_back(1); \r\n       for ( int cur = 2;  cur <= rowIndex+1;  cur++ ){\r\n           for ( int i = cur - 2;  i >= 1;  i-- )\r\n               row[i] = row[i] + row[i-1]; \r\n           row.push_back(1); \r\n       }\r\n       return row; \r\n   };/*F*//*C*//*M*/\n}",
        "target": "{\"rowIndex\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumTotal. /*FC*/ {\n/*FM*/int minimumTotal(vector<vector<int> > &triangle){\r\n    int n = triangle.size(); \r\n       vector<int> minlen(triangle.back()); \r\n       for (int layer = n-2;  layer >= 0;  layer--) \n       {\r\n           for (int i = 0;  i <= layer;  i++) \n           {\r\n               \n               minlen[i] = min(minlen[i], minlen[i+1]) + triangle[layer][i];  \r\n           }\r\n       }\r\n\t   sort(minlen.begin(), minlen.end()); \r\n       return minlen[0]; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"triangle\": [2], \"triangle_element0\": [3], \"triangle_element0_element0\": [\"754101251\"], \"triangle_element0_element1\": [\"-1015773202\"], \"triangle_element0_element2\": [\"-1929051368\"], \"triangle_element1\": [1], \"triangle_element1_element0\": [\"1491284670\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/ {\n/*FM*/int maxProfit(vector<int> &prices){\r\n\tif (prices.size() <= 1)\r\n\t\treturn 0; \r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"prices\": [1], \"prices_element0\": [\"2026636410\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/ {\n/*FM*/int maxProfit(vector<int> &prices){\r\n\tif (prices.size() <= 1)\r\n\t\t\r\n\t\r\n\tinfo cur_info; \r\n\tcur_info.profit = prices[1] - prices[0]; \r\n\tif ( cur_info.profit >= 0 )\r\n\t\t\r\n\telse\r\n\t\tcur_info.min = prices[1]; \r\n\t\r\n\tfor (int i = 2;  i < prices.size();  i++ ){\r\n\t\tif ( prices[i] - cur_info.min > cur_info.profit )\r\n\t\t\tcur_info.profit = prices[i] - cur_info.min; \r\n\t\t\r\n\t\tif ( prices[i] < cur_info.min )\r\n\t\t\t\r\n\t}\r\n\t\r\n\tif ( cur_info.profit < 0)\r\n\t\t\r\n\telse\r\n\t\treturn cur_info.profit; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"prices\": [3], \"prices_element0\": [\"899943884\"], \"prices_element1\": [\"-265154538\"], \"prices_element2\": [\"815020145\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/ {\n/*FM*/int maxProfit(vector<int> &prices){\r\n\tif (prices.size() <= 1)\r\n\t\t\r\n\t\r\n\tinfo cur_info; \r\n\tcur_info.profit = prices[1] - prices[0]; \r\n\tif ( cur_info.profit >= 0 )\r\n\t\tcur_info.min = prices[0]; \r\n\telse\r\n\t\t\r\n\t\r\n\tfor (int i = 2;  i < prices.size();   ){\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\tif ( cur_info.profit < 0)\r\n\t\t\r\n\telse\r\n\t\treturn cur_info.profit; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"prices\": [2], \"prices_element0\": [\"1428626183\"], \"prices_element1\": [\"1941750704\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void traverse. /*FC*/ {\n/*FM*/void traverse(TreeNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\ttraverse(root->left); \r\n\tcout << root->val << \" \"; \r\n\ttraverse(root->right); \r\n};/*F*//*C*//*M*/void traverse(TreeNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\ttraverse(root->left); \r\n\tcout << root->val << \" \"; \r\n\ttraverse(root->right); \r\n} void traverse(TreeNode *root){\r\n\tif ( root == NULL )\r\n\t\treturn; \r\n\ttraverse(root->left); \r\n\tcout << root->val << \" \"; \r\n\ttraverse(root->right); \r\n};\n}",
        "target": "{\"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-722\"], \"root[0].val\": [\"-899\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-11\"], \"root[0].left[0].val\": [\"544\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"-45\"], \"root[0].left[1].val\": [\"188\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"80\"], \"root[0].right[0].val\": [\"521\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"-890\"], \"root[0].right[1].val\": [\"249\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > pathSum. /*FC*/ {\n/*FM*/vector<vector<int> > pathSum(TreeNode *root, int sum){\r\n\tvector<vector<int> > result; \r\n\t\r\n\tif ( root == NULL )\r\n\t\treturn result; \r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"sum\": [\"572512972\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > pathSum. /*FC*/ {\n/*FM*/vector<vector<int> > pathSum(TreeNode *root, int sum){\r\n\tvector<vector<int> > result; \r\n\t\r\n\tif ( root == NULL )\r\n\t\t\r\n\t\r\n\tvector<int> buf; \r\n\tpathCal(result, buf, root, sum); \r\n\treturn result; \r\n};/*F*//*C*//*M*/void pathCal(vector<vector<int> > &result, vector<int> &buf, TreeNode *root, int sum){\r\n\tif (root->left == NULL && root->right == NULL ){\r\n\t\tif ( root->val == sum ){\r\n\t\t\tbuf.push_back(root->val); \r\n\t\t\tresult.push_back(buf); \r\n\t\t\tbuf.pop_back(); \r\n\t\t\treturn; \r\n\t\t}\r\n\t\telse\r\n\t\t\treturn; \r\n\t}\r\n\t\r\n\telse if ( root->right == NULL ){\r\n\t\tbuf.push_back(root->val); \r\n\t\tpathCal(result, buf, root->left, sum-root->val); \r\n\t\tbuf.pop_back(); \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse if ( root->left == NULL ){\r\n\t\tbuf.push_back(root->val); \r\n\t\tpathCal(result, buf, root->right, sum-root->val); \r\n\t\tbuf.pop_back(); \r\n\t\treturn; \r\n\t}\r\n\t\r\n\telse{\r\n\t\tbuf.push_back(root->val); \r\n\t\tpathCal(result, buf, root->left, sum-root->val); \r\n\t\tpathCal(result, buf, root->right, sum-root->val); \r\n\t\tbuf.pop_back(); \r\n\t\treturn; \r\n\t}\r\n};\n}",
        "target": "{\"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-508\"], \"sum\": [\"268022767\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/ {\n/*FM*/int maxProfit(vector<int> &prices){\r\n\tif ( prices.size() <= 1 )\r\n\t\t\r\n\t\r\n\tint buy = 1; \r\n\t\n\tint pre = 0; \r\n\tint profit = 0 - prices[0]; \r\n\t\r\n\tfor ( int i = 1;  i < prices.size();  i++ ){\r\n\t\tif ( buy == 1 ){\r\n\t\t\tif ( prices[i] > prices[pre] ){\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tprofit = profit + prices[pre] - prices[i]; \r\n\t\t\t\tpre = i; \r\n\t\t\t\tbuy = 1; \r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\telse{\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tif ( buy == 1 )\r\n\t\tprofit = profit + prices[pre]; \r\n\treturn profit; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"prices\": [2], \"prices_element0\": [\"602\"], \"prices_element1\": [\"-647\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/ {\n/*FM*/int maxProfit(vector<int> &prices){\r\n\tif ( prices.size() <= 1 )\r\n\t\t\r\n\t\r\n\tint buy = 1; \r\n\t\n\tint pre = 0; \r\n\tint profit = 0 - prices[0]; \r\n\t\r\n\tfor ( int i = 1;  i < prices.size();  i++ ){\r\n\t\tif ( buy == 1 ){\r\n\t\t\tif ( prices[i] > prices[pre] ){\r\n\t\t\t\tprofit = profit + prices[i]; \r\n\t\t\t\tpre = i; \r\n\t\t\t\tbuy = 0; \r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\telse{\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tif ( buy == 1 )\r\n\t\t\r\n\treturn profit; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"prices\": [2], \"prices_element0\": [\"-184\"], \"prices_element1\": [\"594\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProfit. /*FC*/ {\n/*FM*/int maxProfit(vector<int> &prices){\r\n\tif ( prices.size() <= 1 )\r\n\t\treturn 0; \r\n\t\r\n\t\r\n\t\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"prices\": [1], \"prices_element0\": [\"-861\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/ {\n/*FM*/bool isPalindrome(string s) {\r\n\tint len = s.length(); \r\n    if ( len == 0 )\r\n        \r\n       \r\n    string S = \"\"; \r\n    for ( int i = 0;  i < len;  i++ ){\r\n        if ( isalpha(s[i]) ){\r\n            \r\n        }\r\n\t\tif  (isdigit(s[i]))\r\n\t\t\t\r\n    }\r\n    \r\n\tcout << S << endl; \r\n    for ( int i = 0;  i < S.length()/2;   ){\r\n        \r\n    }\r\n    return true; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int ladderLength. /*FC*/ {\n/*FM*/int ladderLength(string start, string end, unordered_set<string> &dict){\r\n\tmap<string, int> distance; \r\n\t\tqueue<string> S; \r\n\t\tS.push(start); \r\n\t\tdistance[start] = 1; \r\n\t\tint size = S.size(); \r\n\t\tint found = 0; \r\n    \r\n\t    if ( start == end )\r\n\t        \r\n\t\r\n\t\twhile (size){\r\n\t\t\tfor ( int i = 0;  i < size;  i++ ){\r\n\t\t\t\tint len = S.front().length(); \r\n\t\t\t\tfor ( int j = 0;  j < len;  j++ ){\r\n\t\t\t\t\tfor ( char c = 'a';  c <= 'z';  c++ ){\r\n\t\t\t\t\t\tif ( c == S.front()[j] )\r\n\t\t\t\t\t\t\tcontinue; \r\n\t\t\t\t\t\tstring ns = S.front(); \r\n\t\t\t\t\t\tns[j] = c; \r\n\t                    if ( ns == end ){\r\n\t                        \r\n\t                        \r\n\t                        \r\n\t                    }\r\n\t\t\t\t\t\tif ( dict.find(ns) != dict.end() ){\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tcontinue; \r\n\t\t\t\t\t}\r\n\t                if (found)\r\n\t                    \r\n\t\t\t\t}\r\n\t            if(found)\r\n\t                \r\n\t\t\t\tS.pop(); \r\n\t\t\t}\r\n\t\t\tsize = S.size(); \r\n\t\t\tif ( found == 1 )\r\n\t\t\t\t\r\n\t\t}\r\n\t\treturn distance[end]; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"start\": [\"1\"], \"end\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void solve. /*FC*/ {\n/*FM*/void solve(vector<vector<char> > &board){\r\n\t\r\n\tint height = board.size(); \r\n\tint length = board[0].size(); \r\n\tbool flip[height][length]; \r\n\tmemset(flip,   true,  sizeof(flip)); \r\n\tstack<location> buf; \r\n\tlocation cur ; \r\n\tlocation node; \r\n\t\r\n\tfor ( int i = 0;  i < length;  i ++ ){\r\n\t\tif ( board[0][i] == 'O' ){\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif ( board[height-1][i] == 'O'){\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor ( int i = 1;  i < height-1;   ){\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\twhile (!buf.empty()){\r\n\t\t\r\n\t\t\r\n\t\t\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\tfor (int i = 0;  i < height;  i++ )\r\n\t\tfor ( int j = 0;  j < length;  j++ ){\r\n\t\t\tif ( board[i][j] == 'O' && flip[i][j] )\r\n\t\t\t\t\r\n\t\t}\r\n\t\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"board\": [2], \"board_element0\": [2], \"board_element0_element0\": [\"-8\"], \"board_element0_element1\": [\"49\"], \"board_element1\": [2], \"board_element1_element0\": [\"51\"], \"board_element1_element1\": [\"-70\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/ {\n/*FM*/bool isValid(string &s, int start, int end){\r\n\twhile ( start < end ){\r\n\t\tif ( s[start] != s[end] )\r\n\t\t\treturn false; \r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"], \"start\": [\"3\"], \"end\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/ {\n/*FM*/bool isValid(string &s, int start, int end){\r\n\twhile ( start < end ){\r\n\t\tif ( s[start] != s[end] )\r\n\t\t\t\r\n\t\tstart++; \r\n\t\tend--; \r\n\t}\r\n\treturn true; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"2\"], \"start\": [\"7\"], \"end\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCut. /*FC*/ {\n/*FM*/int minCut(string s){\r\n int len = s.size();   \r\n            int D[len+1];   \r\n            bool P[len][len];   \r\n            \n            for(int i = 0;  i <= len;  i++)   \r\n            D[i] = len-i;   \r\n            for(int i = 0;  i < len;  i++)  \r\n            for(int j = 0;  j < len;  j++)  \r\n            P[i][j] = false;   \r\n            for(int i = len-1;  i >= 0;  i--){  \r\n                 for(int j = i;  j < len;  j++){  \r\n                      if(s[i] == s[j] && (j-i<2 || P[i+1][j-1])){  \r\n                           P[i][j] = true;   \r\n                           D[i] = min(D[i],D[j+1]+1);   \r\n                      }  \r\n                 }  \r\n            }  \r\n            return D[0]-1; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int canCompleteCircuit. /*FC*/ {\n/*FM*/int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\r\n      int size = gas.size(); \r\n      int counter = 0; \r\n      int start = 0; \r\n      int end = 0; \r\n      int sum = 0; \r\n      \r\n      while (counter != size){\r\n\t\t  cout << start << \" \" << end << endl; \r\n          if ( sum + gas[end] - cost[end] >= 0 ){\r\n               \r\n               \r\n               \r\n               \r\n               \r\n           }\r\n          \r\n           start--; \r\n           if ( start == - 1 )\r\n               start = size - 1; \r\n           sum = sum + gas[start] - cost[start]; \r\n           counter++; \r\n      }\r\n      if ( sum >= 0 )\r\n          \r\n      else\r\n           return -1; \r\n   };/*F*//*C*//*M*/\n}",
        "target": "{\"gas\": [2], \"gas_element0\": [\"-389\"], \"gas_element1\": [\"-14\"], \"cost\": [1], \"cost_element0\": [\"259\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int canCompleteCircuit. /*FC*/ {\n/*FM*/int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\r\n      int size = gas.size(); \r\n      int counter = 0; \r\n      int start = 0; \r\n      int end = 0; \r\n      int sum = 0; \r\n      \r\n      while (counter != size){\r\n\t\t  cout << start << \" \" << end << endl; \r\n          if ( sum + gas[end] - cost[end] >= 0 ){\r\n               sum = sum + gas[end] - cost[end]; \r\n               end++; \r\n               counter++; \r\n               if ( end == size )\r\n                   end = 0; \r\n               continue; \r\n           }\r\n          \r\n           \r\n           \r\n           \r\n           \r\n      }\r\n      if ( sum >= 0 )\r\n          return start; \r\n      else\r\n           \r\n   };/*F*//*C*//*M*/\n}",
        "target": "{\"gas\": [1], \"gas_element0\": [\"470\"], \"cost\": [2], \"cost_element0\": [\"-383\"], \"cost_element1\": [\"278\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int candy. /*FC*/ {\n/*FM*/int candy(vector<int> &ratings){\r\n\t\r\n\tint size = ratings.size(); \r\n\tif ( size == 0 )\r\n\t\t\r\n\t\r\n\tvector<int> candy(size); \r\n\tcandy[0] = 1; \r\n\tint counter = 0; \r\n\tfor ( int i = 1;  i < size;   ){\r\n\t\t\r\n\t}\r\n\t\r\n\tif ( counter != 0 )\r\n\t\t\r\n\t\r\n\tint result = 0; \r\n\tfor ( int i = 0;  i < size;  i++ ){\r\n\t\tcout << candy[i] << endl; \r\n\t\tresult += candy[i]; \r\n\t}\r\n\treturn result; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"ratings\": [1], \"ratings_element0\": [\"681\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int candy. /*FC*/ {\n/*FM*/int candy(vector<int> &ratings){\r\n\t\r\n\tint size = ratings.size(); \r\n\tif ( size == 0 )\r\n\t\t\r\n\t\r\n\tvector<int> candy(size); \r\n\tcandy[0] = 1; \r\n\tint counter = 0; \r\n\tfor ( int i = 1;  i < size;  i++ ){\r\n\t\tif ( ratings[i] > ratings[i-1] ){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse if ( ratings[i] == ratings[i-1] ){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse if ( ratings[i] < ratings[i-1] ){\r\n\t\t\tcandy[i] = candy[i-1] - 1; \r\n\t\t\tcounter++; \r\n\t\t}\r\n\t}\r\n\t\r\n\tif ( counter != 0 )\r\n\t\tadjust(candy, size, counter); \r\n\t\r\n\tint result = 0; \r\n\tfor ( int i = 0;  i < size;  i++ ){\r\n\t\tcout << candy[i] << endl; \r\n\t\tresult += candy[i]; \r\n\t}\r\n\treturn result; \r\n};/*F*//*C*//*M*/void adjust(vector<int>& candy, int tail, int counter){\r\n\tcandy[tail-1] = 1; \r\n\tfor ( int i = 1;  i < counter;  i++ )\r\n\t\tcandy[tail-i-1] = candy[tail-i] + 1; \r\n\tif ( candy[tail-counter] >= candy[tail-counter-1] )\r\n\t\tcandy[tail-counter-1] = candy[tail-counter] + 1; \r\n\treturn; \r\n};\n}",
        "target": "{\"ratings\": [2], \"ratings_element0\": [\"815\"], \"ratings_element1\": [\"267\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNumber. /*FC*/ {\n/*FM*/int singleNumber(int A[], int n){\r\n\t\r\n\tint left = A[0]; \r\n\t\r\n\tfor ( int i = 1;  i < n;  i++ )\r\n\t\tleft = left ^ A[i]; \r\n\t\r\n\treturn left; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [2], \"A[0]\": [\"994\"], \"A[1]\": [\"-539\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNumber. /*FC*/ {\n/*FM*/int singleNumber(int A[], int n){\r\n\t\r\n    int t1 = 0; \r\n          int t2 = 0; \r\n          int t3 = 0; \r\n         \r\n          for (int i = 0;  i < n;  i++){\r\n              t1 = t1 ^ A[i]; \r\n              t2 = t2 | ((t1^A[i]) & A[i]); \r\n              t3 = ~(t1 & t2); \r\n              t1 = t1 & t3; \r\n              t2 = t2 & t3; \r\n          }\r\n         \r\n          return t1; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [2], \"A[0]\": [\"959\"], \"A[1]\": [\"278\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool wordBreak. /*FC*/ {\n/*FM*/bool wordBreak(string s, unordered_set<string> &dict) {\r\n\t\r\n    string s2 = '#' + s;          \r\n          int len = s2.size(); \r\n          vector<bool> possible(len, 0); \r\n            \r\n          possible[0] = true;  \r\n          for(int i =1;  i< len;  ++i)\r\n          {\r\n               for(int k=0;  k<i;  ++k)             \r\n               {\r\n                   possible[i] = possible[k] && \r\n                   dict.find(s2.substr(k+1, i-k)) != dict.end(); \r\n                   if(possible[i]) \r\n              }\r\n            \r\n          }\r\n        \r\n          return possible[len-1]; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reverseWords. /*FC*/ {\n/*FM*/void reverseWords(string &s){\r\n\tint start = 0; \r\n\tstring result = \"\"; \r\n\twhile ( s[start] == ' ' )\r\n\t\t\r\n\t\r\n\tint hd = start; \r\n\tint tl = start; \r\n\tfor ( int i = start;  i < s.length();  i++ ){\r\n\t\t\r\n\t\tif ( i == s.length() - 1 && s[i] != ' '){\r\n\t\t\ttl++; \r\n\t\t\tif ( result.length () > 0 )\r\n\t\t\t\t\r\n\t\t\telse\r\n\t\t\t\tresult = s.substr(hd, tl-hd+1); \r\n\t\t\tcontinue; \r\n\t\t}\r\n\t\t\r\n\t\tif ( s[i] == ' ' && s[i-1] != ' ' && i > start ){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse if ( s[i] != ' ' && s[i-1] == ' ' && i > start ){\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\telse if ( s[i] != ' ' && s[i-1] != ' ' && i > start )\r\n\t\t\t\r\n\r\n\t}\r\n\ts = result; \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxProduct. /*FC*/ {\n/*FM*/int maxProduct(int A[], int n){\r\n\t\r\n\tint result = A[0]; \r\n\t\r\n\tint cur_max = A[0]; \r\n\tint cur_min = A[0]; \r\n\t\r\n\tfor ( int i = 1;  i < n;  i++ ){\r\n\t\t\r\n\t\tcout << cur_max << \" \" << cur_min << endl; \r\n\t\t\r\n\t\tint maxtmp = cur_max; \r\n\t\tint mintmp = cur_min; \r\n\t\t\r\n\t\tcur_max = max(max(maxtmp*A[i], mintmp*A[i]),A[i]); \r\n\t\tcur_min = min(min(maxtmp*A[i], mintmp*A[i]),A[i]); \r\n\t\t\t\r\n\t\tresult = max(cur_max, result); \r\n\t\t\r\n\t}\r\n\t\r\n\treturn result; \r\n    \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"A\": [1], \"A[0]\": [\"890\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMin. /*FC*/ {\n/*FM*/int findMin(vector<int> &num){\r\n\tif ( num.size() == 0 )\r\n\t\t\r\n\t\r\n\tint result = find(num, 0, num.size()-1); \r\n\treturn result; \r\n\t\r\n};/*F*//*C*//*M*/int find(vector<int> &num, int start, int end){\r\n\t\r\n\tif( start == end )\r\n\t\treturn num[start]; \r\n\t\r\n\tif ( end - start == 1 ){\r\n\t\tif ( num[start] < num[end] )\r\n\t\t\treturn num[start]; \r\n\t\telse\r\n\t\t\treturn num[end]; \r\n\t}\r\n\t\r\n\tint mid = (start + end)/2; \r\n\t\r\n\tif ( num[mid] > num[end] )\r\n\t\treturn find(num, mid+1, end); \r\n\telse\r\n\t\treturn find(num, start, mid); \r\n};\n}",
        "target": "{\"num\": [2], \"num_element0\": [\"794\"], \"num_element1\": [\"-902\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > threeSum(vector<int> &num) {\r\n\t\tstd::sort(num.begin(), num.end()); \r\n\t\tvector<vector<int>> result; \r\n\t\tfor (int i = 0 ;  i < num.size() ;  i++ )\r\n\t\t{\r\n\t\t\tint target = 0 - num[i]; \r\n\t\t\tint start = i + 1, end = num.size() - 1; \r\n\t\t\twhile (start < end)\r\n\t\t\t{\r\n\t\t\t\tint sum = num[start] + num[end]; \r\n\t\t\t\tif (sum == target)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\r\n\t\t\t\tif (sum < target)\r\n\t\t\t\t{\r\n\t\t\t\t\tstart++; \r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sum > target)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twhile (i < num.size() - 1 && num[i] == num[i + 1]) \r\n\t\t}\r\n\t\treturn result; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"-709165345\"], \"num_element1\": [\"-226532380\"], \"num_element2\": [\"611214325\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > threeSum(vector<int> &num) {\r\n\t\tstd::sort(num.begin(), num.end()); \r\n\t\tvector<vector<int>> result; \r\n\t\tfor (int i = 0 ;  i < num.size() ;  i++ )\r\n\t\t{\r\n\t\t\tint target = 0 - num[i]; \r\n\t\t\tint start = i + 1, end = num.size() - 1; \r\n\t\t\twhile (start < end)\r\n\t\t\t{\r\n\t\t\t\tint sum = num[start] + num[end]; \r\n\t\t\t\tif (sum == target)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\r\n\t\t\t\tif (sum < target)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sum > target)\r\n\t\t\t\t{\r\n\t\t\t\t\tend--; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twhile (i < num.size() - 1 && num[i] == num[i + 1]) \r\n\t\t}\r\n\t\treturn result; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"-914681204\"], \"num_element1\": [\"-237653230\"], \"num_element2\": [\"1184531208\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int threeSumClosest. /*FC*/class Solution {\n/*FM*/int threeSumClosest(vector<int> &num, int target) {\r\n\r\n    std::sort(num.begin(), num.end()); \r\n    int len = num.size(); \r\n    int minV = INT_MAX, record; \r\n    for (int i = 0;  i < len;  i++)\r\n    {\r\n      int start = i + 1, end = len - 1; \r\n      while (start < end)\r\n      {\r\n        int sum = num[i] + num[start] + num[end]; \r\n        if (sum == target)\r\n        {\r\n          \r\n          \r\n          \r\n        }\r\n        if (sum < target)\r\n        {\r\n          \r\n          \r\n        }\r\n        else\r\n        {\r\n          if (sum - target < minV)\r\n          {\r\n            minV = sum - target; \r\n            record = sum; \r\n          }\r\n          end--; \r\n        }\r\n      }\r\n      if (record == target) \r\n      while (i < len - 1 && num[i] == num[i + 1]) \r\n    }\r\n    return record; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"1022870588\"], \"num_element1\": [\"213758500\"], \"num_element2\": [\"294530136\"], \"target\": [\"989071954\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int threeSumClosest. /*FC*/class Solution {\n/*FM*/int threeSumClosest(vector<int> &num, int target) {\r\n\r\n    std::sort(num.begin(), num.end()); \r\n    int len = num.size(); \r\n    int minV = INT_MAX, record; \r\n    for (int i = 0;  i < len;  )\r\n    {\r\n      \r\n      \r\n      \r\n        }\r\n    return record; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\r\n        int carry = 0; \r\n        string result; \r\n        for (\r\n            int i = a.size() - 1, j = b.size() - 1; \r\n            i >= 0 || j >= 0; \r\n            --i, --j\r\n        )\r\n        {\r\n            int ai = i >= 0 ? a[i] - '0' : 0; \r\n            int bj = j >= 0 ? b[j] - '0' : 0; \r\n            int val = (ai + bj + carry) % 2; \r\n            carry = (ai + bj + carry) / 2; \r\n            result.insert(result.begin(), val + '0'); \r\n        }\r\n\r\n        if (carry == 1)\r\n        {\r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"1\"], \"b\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\r\n        int carry = 0; \r\n        string result; \r\n        for (\r\n            int i = a.size() - 1, j = b.size() - 1; \r\n            i >= 0 || j >= 0; \r\n            \r\n        )\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n\r\n        if (carry == 1)\r\n        {\r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *addTwoNumbers. /*FC*/class Solution {\n/*FM*/ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\r\n\t\tListNode* result = new ListNode(-1); \r\n\t\tListNode* pre = result; \r\n\t\tListNode *pa = l1, *pb = l2; \r\n\t\tint carry = 0; \r\n\t\twhile (pa != NULL || pb != NULL)\r\n\t\t{\r\n\t\t\tint av = pa == NULL ? 0 : pa->val; \r\n\t\t\tint bv = pb == NULL ? 0 : pb->val; \r\n\t\t\tListNode* node = new ListNode((av + bv + carry) % 10); \r\n\t\t\tcarry = (av + bv + carry) / 10; \r\n\t\t\tpre->next = node; \r\n\t\t\tpre = pre->next; \r\n\t\t\tpa = pa == NULL ? NULL : pa->next; \r\n\t\t\tpb = pb == NULL ? NULL : pb->next; \r\n\t\t}\r\n\t\tif (carry > 0)\r\n\t\t\tpre->next = new ListNode(1); \r\n\t\tpre = result->next; \r\n\t\tdelete result; \r\n\t\treturn pre; \r\n\t};/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [3], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"374596061\"], \"l1[1]\": [\"ListNode\", \"ListNode(int)\"], \"l11_x\": [\"-761395107\"], \"l1[2]\": [\"ListNode\", \"ListNode(int)\"], \"l12_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *addTwoNumbers. /*FC*/class Solution {\n/*FM*/ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\r\n\t\tListNode* result = new ListNode(-1); \r\n\t\tListNode* pre = result; \r\n\t\tListNode *pa = l1, *pb = l2; \r\n\t\tint carry = 0; \r\n\t\twhile (pa != NULL || pb != NULL)\r\n\t\t{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\tif (carry > 0)\r\n\t\t\t\r\n\t\tpre = result->next; \r\n\t\tdelete result; \r\n\t\treturn pre; \r\n\t};/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isBalanced. /*FC*/class Solution {\n/*FM*/bool isBalanced(TreeNode *root) {\r\n\t\tif (root == NULL) \r\n\t\tint val = GetBalance(root); \r\n\t\tif (val == -1) \r\n\t\treturn true; \r\n\t};/*F*//*C*//*M*/int GetBalance(TreeNode* node)\r\n\t{\r\n\t\tif (node == NULL)\r\n\t\t\treturn 0; \r\n\t\tint left = GetBalance(node->left); \r\n\t\tif (left == -1) return -1; \r\n\t\tint right = GetBalance(node->right); \r\n\t\tif (right == -1) return -1; \r\n\t\tif (left - right > 1 || right - left > 1)\r\n\t\t\treturn -1; \r\n\t\treturn left > right ? left + 1 : right + 1; \r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-485821910\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-300648668\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int GetBalance. /*FC*/class Solution {\n/*FM*/int GetBalance(TreeNode* node)\r\n\t{\r\n\t\tif (node == NULL)\r\n\t\t\treturn 0; \r\n\t\tint left = GetBalance(node->left); \r\n\t\tif (left == -1) \r\n\t\tint right = GetBalance(node->right); \r\n\t\tif (right == -1) \r\n\t\tif (left - right > 1 || right - left > 1)\r\n\t\t\t\r\n\t\treturn left > right ? left + 1 : right + 1; \r\n\t};/*F*//*C*//*M*/int GetBalance(TreeNode* node)\r\n\t{\r\n\t\tif (node == NULL)\r\n\t\t\treturn 0; \r\n\t\tint left = GetBalance(node->left); \r\n\t\tif (left == -1) return -1; \r\n\t\tint right = GetBalance(node->right); \r\n\t\tif (right == -1) return -1; \r\n\t\tif (left - right > 1 || right - left > 1)\r\n\t\t\treturn -1; \r\n\t\treturn left > right ? left + 1 : right + 1; \r\n\t} int GetBalance(TreeNode* node)\r\n\t{\r\n\t\tif (node == NULL)\r\n\t\t\treturn 0; \r\n\t\tint left = GetBalance(node->left); \r\n\t\tif (left == -1) return -1; \r\n\t\tint right = GetBalance(node->right); \r\n\t\tif (right == -1) return -1; \r\n\t\tif (left - right > 1 || right - left > 1)\r\n\t\t\treturn -1; \r\n\t\treturn left > right ? left + 1 : right + 1; \r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"node\": [1], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"-724209497\"], \"node[0].left\": [2], \"node[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_left0_x\": [\"-1097075264\"], \"node[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_left1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void GetCombine. /*FC*/class Solution {\n/*FM*/void GetCombine(\r\n\t    int n,\r\n\t    int k,\r\n\t    int level,\r\n\t    vector<int>& solution,\r\n\t    vector<vector<int> >& result)\r\n\t{\r\n\t\tif (solution.size() == k)\r\n\t\t{\r\n\t\t\tresult.push_back(solution); \r\n\t\t\treturn; \r\n\t\t}\r\n\t\t\r\n\t};/*F*//*C*//*M*/void GetCombine(\r\n\t    int n,\r\n\t    int k,\r\n\t    int level,\r\n\t    vector<int>& solution,\r\n\t    vector<vector<int> >& result)\r\n\t{\r\n\t\tif (solution.size() == k)\r\n\t\t{\r\n\t\t\tresult.push_back(solution); \r\n\t\t\treturn; \r\n\t\t}\r\n\t\tfor (int i = level;  i <= n;  i++)\r\n\t\t{\r\n\t\t\tsolution.push_back(i); \r\n\t\t\tGetCombine(n, k, i + 1, solution, result); \r\n\t\t\tsolution.pop_back(); \r\n\t\t}\r\n\t} void GetCombine(\r\n\t    int n,\r\n\t    int k,\r\n\t    int level,\r\n\t    vector<int>& solution,\r\n\t    vector<vector<int> >& result)\r\n\t{\r\n\t\tif (solution.size() == k)\r\n\t\t{\r\n\t\t\tresult.push_back(solution); \r\n\t\t\treturn; \r\n\t\t}\r\n\t\tfor (int i = level;  i <= n;  i++)\r\n\t\t{\r\n\t\t\tsolution.push_back(i); \r\n\t\t\tGetCombine(n, k, i + 1, solution, result); \r\n\t\t\tsolution.pop_back(); \r\n\t\t}\r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"6\"], \"k\": [\"0\"], \"level\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void GetCombinations. /*FC*/class Solution {\n/*FM*/void GetCombinations(vector<int>& candidates, int& sum, int level, int target, vector<int>& solution, vector<vector<int> >& result)\r\n\t{\r\n\t\t\r\n\t\tif (sum == target)\r\n\t\t{\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t};/*F*//*C*//*M*/void GetCombinations(vector<int>& candidates, int& sum, int level, int target, vector<int>& solution, vector<vector<int> >& result)\r\n\t{\r\n\t\tif (sum > target) return; \r\n\t\tif (sum == target)\r\n\t\t{\r\n\t\t\tresult.push_back(solution); \r\n\t\t\treturn; \r\n\t\t}\r\n\t\tfor (int i = level;  i < candidates.size();  i++)\r\n\t\t{\r\n\t\t\tsum += candidates[i]; \r\n\t\t\tsolution.push_back(candidates[i]); \r\n\t\t\tGetCombinations(\r\n\t\t\t    candidates, sum, i, target, solution, result); \r\n\t\t\tsolution.pop_back();  \n\t\t\tsum -= candidates[i]; \r\n\t\t}\r\n\t} void GetCombinations(vector<int>& candidates, int& sum, int level, int target, vector<int>& solution, vector<vector<int> >& result)\r\n\t{\r\n\t\tif (sum > target) return; \r\n\t\tif (sum == target)\r\n\t\t{\r\n\t\t\tresult.push_back(solution); \r\n\t\t\treturn; \r\n\t\t}\r\n\t\tfor (int i = level;  i < candidates.size();  i++)\r\n\t\t{\r\n\t\t\tsum += candidates[i]; \r\n\t\t\tsolution.push_back(candidates[i]); \r\n\t\t\tGetCombinations(\r\n\t\t\t    candidates, sum, i, target, solution, result); \r\n\t\t\tsolution.pop_back();  \n\t\t\tsum -= candidates[i]; \r\n\t\t}\r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"candidates\": [2], \"candidates_element0\": [\"-253481584\"], \"candidates_element1\": [\"-1200663618\"], \"sum\": [\"1605707765\"], \"level\": [\"8\"], \"target\": [\"-1406179527\"], \"solution\": [2], \"solution_element0\": [\"-1536021454\"], \"solution_element1\": [\"-1978475926\"], \"result\": [1], \"result_element0\": [3], \"result_element0_element0\": [\"741744559\"], \"result_element0_element1\": [\"-1460904373\"], \"result_element0_element2\": [\"160880977\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution {\n/*FM*/int maxArea(vector<int> &height) {\r\n\t\tint start = 0; \r\n\t\tint end = height.size() - 1; \r\n\t\tint maxV = INT_MIN; \r\n\t\twhile (start < end)\r\n\t\t{\r\n\t\t\tint contain = min(height[end], height[start]) * (end - start); \r\n\t\t\tmaxV = max(maxV, contain); \r\n\t\t\tif (height[start] <= height[end])\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tend--; \r\n\t\t\t}\r\n\t\t}\r\n\t\treturn maxV; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [3], \"height_element0\": [\"262189561\"], \"height_element1\": [\"53835229\"], \"height_element2\": [\"6528382\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution {\n/*FM*/int maxArea(vector<int> &height) {\r\n\t\tint start = 0; \r\n\t\tint end = height.size() - 1; \r\n\t\tint maxV = INT_MIN; \r\n\t\twhile (start < end)\r\n\t\t{\r\n\t\t\tint contain = min(height[end], height[start]) * (end - start); \r\n\t\t\tmaxV = max(maxV, contain); \r\n\t\t\tif (height[start] <= height[end])\r\n\t\t\t{\r\n\t\t\t\tstart++; \r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn maxV; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [3], \"height_element0\": [\"-1789346117\"], \"height_element1\": [\"437129088\"], \"height_element2\": [\"935244211\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *BuildTree. /*FC*/class Solution {\n/*FM*/TreeNode *BuildTree(vector<int> &num, int start, int end)\r\n\t{\r\n\t\tif (start > end) return NULL; \r\n\t\tif (start == end) \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t};/*F*//*C*//*M*/TreeNode *BuildTree(vector<int> &num, int start, int end)\r\n\t{\r\n\t\tif (start > end) return NULL; \r\n\t\tif (start == end) return new TreeNode(num[start]); \r\n\t\tint mid = (start + end) / 2; \r\n\t\tTreeNode *node = new TreeNode(num[mid]); \r\n\t\tnode->left = BuildTree(num, start, mid - 1); \r\n\t\tnode->right = BuildTree(num, mid + 1, end); \r\n\t\treturn node; \r\n\t} TreeNode *BuildTree(vector<int> &num, int start, int end)\r\n\t{\r\n\t\tif (start > end) return NULL; \r\n\t\tif (start == end) return new TreeNode(num[start]); \r\n\t\tint mid = (start + end) / 2; \r\n\t\tTreeNode *node = new TreeNode(num[mid]); \r\n\t\tnode->left = BuildTree(num, start, mid - 1); \r\n\t\tnode->right = BuildTree(num, mid + 1, end); \r\n\t\treturn node; \r\n\t} TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [2], \"num_element0\": [\"559546826\"], \"num_element1\": [\"-1925876381\"], \"start\": [\"894419044\"], \"end\": [\"-1024897018\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode *sortedListToBST. /*FC*/class Solution {\n/*FM*/TreeNode *sortedListToBST(ListNode *head) {\r\n\t\tint len = 0; \r\n\t\tListNode *p = head; \r\n\t\twhile (p)\r\n\t\t{\r\n\t\t\tlen++; \r\n\t\t\tp = p->next; \r\n\t\t}\r\n\t\treturn BuildBST(head, 0, len - 1); \r\n\t};/*F*//*C*//*M*/TreeNode* BuildBST(ListNode*& list, int start, int end)\r\n\t{\r\n\t\tif (start > end) return NULL; \r\n\t\tint mid = (start + end) / 2; \r\n\t\tTreeNode *leftChild = BuildBST(list, start, mid - 1); \r\n\t\tTreeNode *parent = new TreeNode(list->val); \r\n\t\tparent->left = leftChild; \r\n\t\tlist = list->next; \r\n\t\tparent->right = BuildBST(list, mid + 1, end); \r\n\t\treturn parent; \r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"861688365\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1239406977\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string countAndSay. /*FC*/class Solution {\n/*FM*/string countAndSay(int n) {\r\n\t\tstring seq = \"1\"; \r\n\t\tint it = 1; \r\n\t\twhile (it < n)\r\n\t\t{\r\n\t\t\tstringstream newSeq; \r\n\t\t\tchar last = seq[0]; \r\n\t\t\tint count = 0; \r\n\t\t\tfor (int i = 0;  i <= seq.size();  i++)\r\n\t\t\t{\r\n\t\t\t\tif (seq[i] == last)\r\n\t\t\t\t{\r\n\t\t\t\t\tcount ++; \r\n\t\t\t\t\tcontinue; \r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tnewSeq << count << last; \r\n\t\t\t\t\tlast = seq[i]; \r\n\t\t\t\t\tcount = 1; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tseq = newSeq.str(); \r\n\t\t\tit++; \r\n\t\t}\r\n\t\treturn seq; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDecodings. /*FC*/class Solution {\n/*FM*/int numDecodings(string s) {\r\n\t\tif (s.empty() || s[0] == '0') return 0; \r\n\t\tif (s.size() == 1) \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDecodings. /*FC*/class Solution {\n/*FM*/int numDecodings(string s) {\r\n\t\tif (s.empty() || s[0] == '0') \r\n\t\tif (s.size() == 1) return check(s[0]); \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> diffWaysToCompute. /*FC*/class Solution {\n/*FM*/vector<int> diffWaysToCompute(string input) {\r\n        return diffWaysToComputeWithMemo(input, 0, input.size()-1); \r\n    };/*F*//*C*//*M*/vector<int> diffWaysToComputeWithMemo(string& input, int startIndex, int endIndex) {    \r\n        string cache_key = generateKey(startIndex, endIndex); \r\n        if(memo.find(cache_key) != memo.end()) return memo[cache_key]; \r\n        \r\n        int number = 0, i=startIndex; \r\n        for(;  i<= endIndex && isdigit(input[i]);  ++i) {\r\n            number  = number * 10 + input[i]-'0'; \r\n        }\r\n        \n        if(i > endIndex)  return {number}; \r\n        \r\n        vector<int> diffWays, lefts, rights; \r\n        for(int i =startIndex;  i< endIndex;  i++) {\r\n            if(isdigit(input[i])) continue; \r\n            lefts = \r\n                diffWaysToComputeWithMemo(input, startIndex, i-1); \r\n            rights = \r\n                diffWaysToComputeWithMemo(input, i+1, endIndex ); \r\n            for(int j = 0;  j < lefts.size();  ++j) \r\n                for( int k =0;  k < rights.size();  ++k) \r\n                    diffWays.push_back(compute(lefts[j], rights[k], input[i])); \r\n        }\r\n        memo[cache_key] = diffWays; \r\n        return diffWays; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"input\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDistinct. /*FC*/class Solution {\n/*FM*/int numDistinct(string S, string T) {\r\n\t\tint match[200]; \r\n\t\tif (S.size() < T.size()) \r\n\t\tmatch[0] = 1; \r\n\t\tfor (int i = 1;  i <= T.size();  i++)\r\n\t\t\tmatch[i] = 0; \r\n\t\tfor (int i = 1;  i <= S.size();  i ++)\r\n\t\t\tfor (int j = T.size();  j >= 1;  j--)\r\n\t\t\t\tif (S[i - 1] == T[j - 1])\r\n\t\t\t\t\t\r\n\t\treturn match[T.size()]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"], \"T\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDistinct. /*FC*/class Solution {\n/*FM*/int numDistinct(string S, string T) {\r\n\t\tint match[200]; \r\n\t\tif (S.size() < T.size()) \r\n\t\tmatch[0] = 1; \r\n\t\tfor (int i = 1;  i <= T.size();  )\r\n\t\t\t\r\n\t\tfor (int i = 1;  i <= S.size();  )\r\n\t\t\t\r\n\t\treturn match[T.size()]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/class Solution {\n/*FM*/int divide(int dividend, int divisor) {\r\n\t\tint sign = 1; \r\n\t\tif (dividend == 0) \r\n\t\tif (dividend < 0) \r\n\t\tif (divisor < 0) \r\n\t\tunsigned int dvd = dividend > 0 ? dividend : -dividend; \r\n\t\tunsigned int dvs = divisor > 0 ? divisor : -divisor;  \n\t\tunsigned int inc[32]; \r\n\t\tunsigned int migValue = dvs; \r\n\t\tint i = 0; \r\n\t\twhile (migValue > 0 && migValue <= dvd)\r\n\t\t{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\ti--; \r\n\t\tunsigned int res = 0; \r\n\t\twhile (i >= 0 && dvd != 0)\r\n\t\t{\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\tres *= sign; \r\n\t\treturn res; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dividend\": [\"1\"], \"divisor\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/class Solution {\n/*FM*/int divide(int dividend, int divisor) {\r\n\t\tint sign = 1; \r\n\t\tif (dividend == 0) return 0; \r\n\t\tif (dividend < 0) \r\n\t\t\r\n\t\t\r\n\t\t \n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dividend\": [\"0\"], \"divisor\": [\"-2147483648\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/class Solution {\n/*FM*/int divide(int dividend, int divisor) {\r\n\t\tint sign = 1; \r\n\t\tif (dividend == 0) \r\n\t\tif (dividend < 0) sign *= -1; \r\n\t\tif (divisor < 0) sign *= -1; \r\n\t\tunsigned int dvd = dividend > 0 ? dividend : -dividend; \r\n\t\tunsigned int dvs = divisor > 0 ? divisor : -divisor;  \n\t\tunsigned int inc[32]; \r\n\t\tunsigned int migValue = dvs; \r\n\t\tint i = 0; \r\n\t\twhile (migValue > 0 && migValue <= dvd)\r\n\t\t{\r\n\t\t\tinc[i] = migValue; \r\n\t\t\tmigValue = migValue << 1; \r\n\t\t\ti++; \r\n\t\t}\r\n\t\ti--; \r\n\t\tunsigned int res = 0; \r\n\t\twhile (i >= 0 && dvd != 0)\r\n\t\t{\r\n\t\t\tif (dvd >= inc[i])\r\n\t\t\t{\r\n\t\t\t\tdvd = dvd - inc[i]; \r\n\t\t\t\tres += 1 << i; \r\n\t\t\t}\r\n\t\t\ti--; \r\n\t\t}\r\n\t\tres *= sign; \r\n\t\treturn res; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dividend\": [\"-2104360751\"], \"divisor\": [\"-974916990\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int divide. /*FC*/class Solution {\n/*FM*/int divide(int dividend, int divisor) {\r\n\t\tint sign = 1; \r\n\t\tif (dividend == 0) \r\n\t\tif (dividend < 0) \r\n\t\tif (divisor < 0) \r\n\t\tunsigned int dvd = dividend > 0 ? dividend : -dividend; \r\n\t\tunsigned int dvs = divisor > 0 ? divisor : -divisor;  \n\t\tunsigned int inc[32]; \r\n\t\tunsigned int migValue = dvs; \r\n\t\tint i = 0; \r\n\t\twhile (migValue > 0 && migValue <= dvd)\r\n\t\t{\r\n\t\t\tinc[i] = migValue; \r\n\t\t\tmigValue = migValue << 1; \r\n\t\t\ti++; \r\n\t\t}\r\n\t\ti--; \r\n\t\tunsigned int res = 0; \r\n\t\twhile (i >= 0 && dvd != 0)\r\n\t\t{\r\n\t\t\tif (dvd >= inc[i])\r\n\t\t\t{\r\n\t\t\t\tdvd = dvd - inc[i]; \r\n\t\t\t\tres += 1 << i; \r\n\t\t\t}\r\n\t\t\ti--; \r\n\t\t}\r\n\t\tres *= sign; \r\n\t\treturn res; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dividend\": [\"1249310456\"], \"divisor\": [\"165179742\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/class Solution {\n/*FM*/int minDistance(string word1, string word2) {\r\n\t\tif (word1.size() < word2.size())\r\n\t\t\t\r\n\t\tint * matchUp = new int[20000]; \r\n\t\tint* matchDown = new int[20000]; \r\n\t\tfor (int i = 0;  i <= word2.size();  i++)\r\n\t\t{\r\n\t\t\tmatchUp[i] = 0; \r\n\t\t\tmatchDown[i] = i; \r\n\t\t}\r\n\t\tfor (int i = 1;  i <= word1.size();  i++)\r\n\t\t{\r\n\t\t\tmatchUp[0] = i; \r\n\t\t\tfor (int j = 1;  j <= word2.size();  j++)\r\n\t\t\t{\r\n\t\t\t\tif (word1[i - 1] == word2[j - 1])\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmatchUp[j] = min(matchDown[j], matchDown[j - 1]); \r\n\t\t\t\t\tmatchUp[j] = min(matchUp[j], matchUp[j - 1]) + 1; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint* temp = matchUp; \r\n\t\t\tmatchUp = matchDown; \r\n\t\t\tmatchDown = temp; \r\n\t\t}\r\n\t\treturn matchDown[word2.size()]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word1\": [\"1\"], \"word2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/class Solution {\n/*FM*/int minDistance(string word1, string word2) {\r\n\t\tif (word1.size() < word2.size())\r\n\t\t\t\r\n\t\tint * matchUp = new int[20000]; \r\n\t\tint* matchDown = new int[20000]; \r\n\t\tfor (int i = 0;  i <= word2.size();  i++)\r\n\t\t{\r\n\t\t\tmatchUp[i] = 0; \r\n\t\t\tmatchDown[i] = i; \r\n\t\t}\r\n\t\tfor (int i = 1;  i <= word1.size();  )\r\n\t\t{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\treturn matchDown[word2.size()]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word1\": [\"1\"], \"word2\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int evalRPN. /*FC*/class Solution {\n/*FM*/int evalRPN(vector<string> &tokens) {\r\n\t\tstack<int> operand; \r\n\t\tfor (int i = 0;  i < tokens.size();  )\r\n\t\t{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\treturn operand.top(); \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int evalRPN. /*FC*/class Solution {\n/*FM*/int evalRPN(vector<string> &tokens) {\r\n\t\tstack<int> operand; \r\n\t\tfor (int i = 0;  i < tokens.size();  i++)\r\n\t\t{\r\n\t\t\tif ((tokens[i][0] == '-' && tokens[i].size() > 1)\r\n\t\t\t        || (tokens[i][0] >= '0' && tokens[i][0] <= '9'))\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tint op1 = operand.top(); \r\n\t\t\toperand.pop(); \r\n\t\t\tint op2 = operand.top(); \r\n\t\t\toperand.pop(); \r\n\t\t\tif (tokens[i] == \"+\") \r\n\t\t\tif (tokens[i] == \"-\") \r\n\t\t\tif (tokens[i] == \"*\") \r\n\t\t\tif (tokens[i] == \"/\") \r\n\t\t}\r\n\t\treturn operand.top(); \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"tokens\": [3], \"tokens_element0\": [\"1\"], \"tokens_element1\": [\"1\"], \"tokens_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstMissingPositive. /*FC*/class Solution {\n/*FM*/int firstMissingPositive(vector<int>& nums) {\r\n\t\tint i = 0; \r\n\t\tint n = nums.size(); \r\n\t\tfor (int i = 0;  i < n;  i++)\r\n\t\t{\r\n\t\t\twhile (nums[i] != i + 1)\r\n\t\t\t{\r\n\t\t\t\tif (nums[i] <= 0 || nums[i] > n || nums[i] == nums[nums[i] - 1]) break; \r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int i = 0;  i < n;  )\r\n\t\t\tif (nums[i] != i + 1)\r\n\t\t\t\treturn i + 1; \r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-331273977\"], \"nums_element1\": [\"-895301083\"], \"nums_element2\": [\"676307338\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstMissingPositive. /*FC*/class Solution {\n/*FM*/int firstMissingPositive(vector<int>& nums) {\r\n\t\tint i = 0; \r\n\t\tint n = nums.size(); \r\n\t\tfor (int i = 0;  i < n;  )\r\n\t\t{\r\n\t\t\t\r\n\t\t}\r\n\t\tfor (int i = 0;  i < n;  )\r\n\t\t\tif (nums[i] != i + 1)\r\n\t\t\t\t\r\n\t\treturn n + 1; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int canCompleteCircuit. /*FC*/class Solution {\n/*FM*/int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\r\n\t\tvector<int> diff(gas.size()); \r\n\t\tfor (int i = 0;  i < gas.size();  ++i)\r\n\t\t{\r\n\t\t\tdiff[i] = gas[i] - cost[i]; \r\n\t\t}\r\n\t\tint leftGas = 0, sum = 0, startnode = 0; \r\n\t\tfor (int i = 0;  i < gas.size();  ++i)\r\n\t\t{\r\n\t\t\tleftGas += diff[i]; \r\n\t\t\tsum += diff[i]; \r\n\t\t\tif (sum < 0) \n\t\t\t{\r\n\t\t\t\tstartnode = i + 1; \r\n\t\t\t\tsum = 0; \r\n\t\t\t}\r\n\t\t}\r\n\t\tif (leftGas < 0)\r\n\t\t\t\r\n\t\telse\r\n\t\t\treturn startnode; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"gas\": [2], \"gas_element0\": [\"-27654560\"], \"gas_element1\": [\"-1084943690\"], \"cost\": [1], \"cost_element0\": [\"2003601255\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int canCompleteCircuit. /*FC*/class Solution {\n/*FM*/int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\r\n\t\tvector<int> diff(gas.size()); \r\n\t\tfor (int i = 0;  i < gas.size();  ++i)\r\n\t\t{\r\n\t\t\tdiff[i] = gas[i] - cost[i]; \r\n\t\t}\r\n\t\tint leftGas = 0, sum = 0, startnode = 0; \r\n\t\tfor (int i = 0;  i < gas.size();  ++i)\r\n\t\t{\r\n\t\t\tleftGas += diff[i]; \r\n\t\t\tsum += diff[i]; \r\n\t\t\tif (sum < 0) \n\t\t\t{\r\n\t\t\t\tstartnode = i + 1; \r\n\t\t\t\tsum = 0; \r\n\t\t\t}\r\n\t\t}\r\n\t\tif (leftGas < 0)\r\n\t\t\treturn -1; \r\n\t\telse\r\n\t\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"gas\": [2], \"gas_element0\": [\"423574810\"], \"gas_element1\": [\"132167875\"], \"cost\": [3], \"cost_element0\": [\"-1348694278\"], \"cost_element1\": [\"-731681713\"], \"cost_element2\": [\"-955112037\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution {\n/*FM*/string intToRoman(int num) {\r\n\t\tchar symbol[7] = { 'I', 'V', 'X', 'L', 'C', 'D', 'M'}; \r\n\t\tstring roman; \r\n\t\tint scale = 1000; \r\n\t\tfor (int i = 6;  i >= 0;  i -= 2)\r\n\t\t{\r\n\t\t\tint digit = num / scale; \r\n\t\t\tif (digit != 0)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tnum = num % scale; \r\n\t\t\tscale /= 10; \r\n\t\t}\r\n\t\treturn roman; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution {\n/*FM*/string intToRoman(int num) {\r\n\t\tchar symbol[7] = { 'I', 'V', 'X', 'L', 'C', 'D', 'M'}; \r\n\t\tstring roman; \r\n\t\tint scale = 1000; \r\n\t\tfor (int i = 6;  i >= 0;  i -= 2)\r\n\t\t{\r\n\t\t\tint digit = num / scale; \r\n\t\t\tif (digit != 0)\r\n\t\t\t{\r\n\t\t\t\tif (digit <= 3)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse if (digit == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\troman.append(1, symbol[i]); \r\n\t\t\t\t\troman.append(1, symbol[i + 1]); \r\n\t\t\t\t}\r\n\t\t\t\telse if (digit == 5)\r\n\t\t\t\t{\r\n\t\t\t\t\troman.append(1, symbol[i + 1]); \r\n\t\t\t\t}\r\n\t\t\t\telse if (digit <= 8)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse if (digit == 9)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tnum = num % scale; \r\n\t\t\tscale /= 10; \r\n\t\t}\r\n\t\treturn roman; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"1955964544\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution {\n/*FM*/string intToRoman(int num) {\r\n\t\tchar symbol[7] = { 'I', 'V', 'X', 'L', 'C', 'D', 'M'}; \r\n\t\tstring roman; \r\n\t\tint scale = 1000; \r\n\t\tfor (int i = 6;  i >= 0;  i -= 2)\r\n\t\t{\r\n\t\t\tint digit = num / scale; \r\n\t\t\tif (digit != 0)\r\n\t\t\t{\r\n\t\t\t\tif (digit <= 3)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse if (digit == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse if (digit == 5)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse if (digit <= 8)\r\n\t\t\t\t{\r\n\t\t\t\t\troman.append(1, symbol[i + 1]); \r\n\t\t\t\t\troman.append(digit - 5, symbol[i]); \r\n\t\t\t\t}\r\n\t\t\t\telse if (digit == 9)\r\n\t\t\t\t{\r\n\t\t\t\t\troman.append(1, symbol[i]); \r\n\t\t\t\t\troman.append(1, symbol[i + 2]); \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tnum = num % scale; \r\n\t\t\tscale /= 10; \r\n\t\t}\r\n\t\treturn roman; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"897350969\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int>& nums) {\r\n    int n = nums.size(); \r\n    int maxCover = 0;   \r\n    for(int start =0;  start<= maxCover && start<n;  start++)  \r\n    {  \r\n      if(nums[start]+start > maxCover)  \r\n          \r\n        if(maxCover >= n-1)   \r\n    }  \r\n    return false;   \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-650977520\"], \"nums_element1\": [\"-2013901075\"], \"nums_element2\": [\"-1733350525\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int>& nums) {\r\n    int n = nums.size(); \r\n    int maxCover = 0;   \r\n    for(int start =0;  start<= maxCover && start<n;  )  \r\n    {  \r\n        \r\n          \r\n    }  \r\n    return false;   \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int>& nums) {\r\n    int n = nums.size(); \r\n    int maxCover = 0;   \r\n    for(int start =0;  start<= maxCover && start<n;  )  \r\n    {  \r\n      if(nums[start]+start > maxCover)  \r\n        maxCover = nums[start]+start;   \r\n        if(maxCover >= n-1) return true;   \r\n    }  \r\n      \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"368219716\"], \"nums_element1\": [\"-649777760\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestRectangleArea. /*FC*/class Solution {\n/*FM*/int largestRectangleArea(vector<int>& h) {\r\n    stack<int> S; \r\n    h.push_back(0);   \n    int sum = 0; \r\n    for (int i = 0;  i < h.size();  i++) {\r\n      if (S.empty() || h[i] > h[S.top()]) S.push(i); \r\n      else {\r\n        int tmp = S.top(); \r\n        S.pop(); \r\n        sum = max(sum, h[tmp] * (S.empty() ? i : i - S.top() - 1)); \r\n        i--; \r\n      }\r\n    }\r\n    return sum; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"h\": [2], \"h_element0\": [\"455813483\"], \"h_element1\": [\"1998854796\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestRectangleArea. /*FC*/class Solution {\n/*FM*/int largestRectangleArea(vector<int>& h) {\r\n    stack<int> S; \r\n    h.push_back(0);   \n    int sum = 0; \r\n    for (int i = 0;  i < h.size();  i++) {\r\n      if (S.empty() || h[i] > h[S.top()]) S.push(i); \r\n      else {\r\n        \r\n        \r\n        \r\n        \r\n      }\r\n    }\r\n    return sum; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(const char *s) {\r\n        const char* pStart = s; \r\n        const char* pEnd = s; \r\n        const char* p = s; \r\n        const char* pre = s; \r\n\r\n        while (*p != '\\0')\r\n        {\r\n            if (*pre == ' ' && *p != ' ') \r\n            if (*pre != ' ' && *p == ' ') \r\n\r\n            pre = p; \r\n            p++; \r\n        }\r\n\r\n        if (*pre != ' ' && *p == '\\0') pEnd = p; \r\n        return pEnd - pStart; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [1], \"s_constantPointer[0]\": [\"93\"], \"s_constantPointer[1]\": [\"-21\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSquares. /*FC*/class Solution {\n/*FM*/int numSquares(int n) {\r\n        vector<int> dp_nums(1,0); \r\n        \r\n        while(dp_nums.size() <= n) {\r\n            int k = dp_nums.size(); \r\n            int least_num = INT_MAX; \r\n            for(int i =1;  i*i <=k;  i++){\r\n                least_num = min(least_num, dp_nums[k-i*i] +1);                \r\n            }\r\n            dp_nums.push_back(least_num); \r\n        }\r\n        return dp_nums[n]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSquares. /*FC*/class Solution {\n/*FM*/int numSquares(int n) {\r\n        vector<int> dp_nums(1,0); \r\n        \r\n        while(dp_nums.size() <= n) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return dp_nums[n]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\r\n    int len = s.size(); \r\n    int P[len][len]; \r\n    memset(P, 0, len * len * sizeof(int)); \r\n    int maxL = 0, start = 0, end = 0; \r\n    for (int i = 0;  i < s.size();  )\r\n    {\r\n      \r\n      \r\n    }\r\n    return s.substr(start, end - start + 1); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\r\n    int len = s.size(); \r\n    int P[len][len]; \r\n    memset(P, 0, len * len * sizeof(int)); \r\n    int maxL = 0, start = 0, end = 0; \r\n    for (int i = 0;  i < s.size();  i++)\r\n    {\r\n      for (int j = 0;  j < i;  )\r\n      {\r\n        \r\n        \r\n      }\r\n      P[i][i] = 1; \r\n    }\r\n    return s.substr(start, end - start + 1); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n    int count[256]; \r\n    memset(count, -1, 256 * sizeof(int)); \r\n    int len = 0, maxL = 0; \r\n    for (int i = 0;  i < s.size();  i++, len++)\r\n    {\r\n      if (count[s[i]] >= 0)\r\n      {\r\n        maxL = max(len, maxL); \r\n        len = 0; \r\n        i = count[s[i]] + 1; \r\n        memset(count, -1, 256 * sizeof(int)); \r\n      }\r\n      count[s[i]] = i; \r\n    }\r\n    return max(len, maxL); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n    int count[256]; \r\n    memset(count, -1, 256 * sizeof(int)); \r\n    int len = 0, maxL = 0; \r\n    for (int i = 0;  i < s.size();  i++, len++)\r\n    {\r\n      if (count[s[i]] >= 0)\r\n      {\r\n        \r\n        \r\n        \r\n        \r\n      }\r\n      count[s[i]] = i; \r\n    }\r\n    return max(len, maxL); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n    int count[256]; \r\n    memset(count, -1, 256 * sizeof(int)); \r\n    int len = 0, maxL = 0; \r\n    for (int i = 0;  i < s.size();  )\r\n    {\r\n      \r\n      \r\n    }\r\n    return max(len, maxL); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int get. /*FC*/class LRUCache {\n/*FM*/int get(int key) {\r\n\t\tif (m_map.find(key) == m_map.end())\r\n\t\t\treturn -1; \r\n\r\n\t\t\r\n\t\t\r\n\t};/*F*/unordered_map<int, list<CacheEntry>::iterator> m_map;/*C*/LRUCache(int capacity) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___LRUCache\": [\"LRUCache\", \"LRUCache(int)\"], \"AKA_INSTANCE___LRUCache_capacity\": [\"1530703831\"], \"key\": [\"2102074450\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void set. /*FC*/class LRUCache {\n/*FM*/void set(int key, int value) {\r\n\t\tif (m_map.find(key) == m_map.end())\r\n\t\t{\r\n\t\t\tCacheEntry newItem(key, value); \r\n\t\t\tif (m_LRU_cache.size() >= m_capacity)\r\n\t\t\t{\r\n\t\t\t\t\n\t\t\t\tm_map.erase(m_LRU_cache.back().key); \r\n\t\t\t\tm_LRU_cache.pop_back(); \r\n\t\t\t}\r\n\r\n\t\t\t\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\t\r\n\t\t\r\n\t};/*F*/unordered_map<int, list<CacheEntry>::iterator> m_map;  list<CacheEntry> m_LRU_cache;  int m_capacity;/*C*/LRUCache(int capacity) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___LRUCache\": [\"LRUCache\", \"LRUCache(int)\"], \"AKA_INSTANCE___LRUCache_capacity\": [\"0\"], \"key\": [\"0\"], \"value\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void set. /*FC*/class LRUCache {\n/*FM*/void set(int key, int value) {\r\n\t\tif (m_map.find(key) == m_map.end())\r\n\t\t{\r\n\t\t\tCacheEntry newItem(key, value); \r\n\t\t\tif (m_LRU_cache.size() >= m_capacity)\r\n\t\t\t{\r\n\t\t\t\t\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\t\n\t\t\tm_LRU_cache.push_front(newItem); \r\n\t\t\tm_map[key] = m_LRU_cache.begin(); \r\n\t\t\treturn; \r\n\t\t}\r\n\r\n\t\t\r\n\t\t\r\n\t};/*F*/unordered_map<int, list<CacheEntry>::iterator> m_map;  list<CacheEntry> m_LRU_cache;  int m_capacity;/*C*/LRUCache(int capacity) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___LRUCache\": [\"LRUCache\", \"LRUCache(int)\"], \"AKA_INSTANCE___LRUCache_capacity\": [\"421159086\"], \"key\": [\"-149595269\"], \"value\": [\"-793026850\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(TreeNode *root) {\r\n\t\tif (root == NULL)\r\n\t\t\treturn 0; \r\n\t\tint lmax = maxDepth(root->left); \r\n\t\tint rmax = maxDepth(root->right); \r\n\t\treturn max(lmax, rmax) + 1; \r\n\t};/*F*//*C*//*M*/int maxDepth(TreeNode *root) {\r\n\t\tif (root == NULL)\r\n\t\t\treturn 0; \r\n\t\tint lmax = maxDepth(root->left); \r\n\t\tint rmax = maxDepth(root->right); \r\n\t\treturn max(lmax, rmax) + 1; \r\n\t} int maxDepth(TreeNode *root) {\r\n\t\tif (root == NULL)\r\n\t\t\treturn 0; \r\n\t\tint lmax = maxDepth(root->left); \r\n\t\tint rmax = maxDepth(root->right); \r\n\t\treturn max(lmax, rmax) + 1; \r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-2013784104\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-1782798536\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1915779079\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"-2091253768\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxPoints. /*FC*/class Solution {\n/*FM*/int maxPoints(vector<Point> &points) {\r\n\t\tunordered_map<float, int> statistic; \r\n\r\n\t\tint maxNum = 0; \r\n\t\tfor (int i = 0;  i < points.size();  )\r\n\t\t{\r\n\t\t\t\r\n\t\t\t \n\t\t\t\r\n\t\t\t\r\n\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\treturn maxNum; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxPoints. /*FC*/class Solution {\n/*FM*/int maxPoints(vector<Point> &points) {\r\n\t\tunordered_map<float, int> statistic; \r\n\r\n\t\tint maxNum = 0; \r\n\t\tfor (int i = 0;  i < points.size();  i++)\r\n\t\t{\r\n\t\t\tstatistic.clear(); \r\n\t\t\tstatistic[INT_MIN] = 0;  \n\t\t\tint duplicate = 1; \r\n\t\t\tfor (int j = 0;  j < points.size();  j++)\r\n\t\t\t{\r\n\t\t\t\tif (j == i) continue; \r\n\t\t\t\tif (points[j].x == points[i].x && points[j].y == points[i].y) \n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tfloat key = (points[j].x - points[i].x) == 0 ?\r\n\t\t\t\t            INT_MAX : \n\t\t\t\t            (float) (points[j].y - points[i].y) / (points[j].x - points[i].x); \r\n\t\t\t\tstatistic[key]++; \r\n\t\t\t}\r\n\r\n\t\t\tfor (unordered_map<float, int>::iterator it = statistic.begin();  it != statistic.end();  ++it)\r\n\t\t\t{\r\n\t\t\t\tif (it->second + duplicate > maxNum)\r\n\t\t\t\t{\r\n\t\t\t\t\tmaxNum = it->second + duplicate; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn maxNum; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"points\": [2], \"points_element0\": [\"Point\", \"Point()\"], \"points_element0.x\": [\"238929224\"], \"points_element0.y\": [\"262966041\"], \"points_element1\": [\"Point\", \"Point()\"], \"points_element1.x\": [\"589400358\"], \"points_element1.y\": [\"1616433256\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMedianSortedArrays. /*FC*/class Solution {\n/*FM*/double findMedianSortedArrays(int A[], int m, int B[], int n) {\r\n    if ((n + m) % 2 == 0)\r\n    {\r\n      return (GetMedian(A, m, B, n, (m + n) / 2)\r\n              + GetMedian(A, m, B, n, (m + n) / 2 + 1)) / 2.0; \r\n    }\r\n    else\r\n      \r\n  };/*F*//*C*//*M*/int GetMedian(int a[], int n, int b[], int m, int k)\r\n  {\r\n    assert(a && b); \r\n    if (n <= 0) return b[k - 1]; \r\n    if (m <= 0) return a[k - 1]; \r\n    if (k <= 1) return min(a[0], b[0]); \r\n    if (b[m / 2] >= a[n / 2])\r\n    {\r\n      if ((n / 2 + 1 + m / 2) >= k)\r\n        return GetMedian(a, n, b, m / 2, k); \r\n      else\r\n        return GetMedian(\r\n                 a + n / 2 + 1, n - (n / 2 + 1), b, m, k - (n / 2 + 1)); \r\n    }\r\n    else\r\n    {\r\n      if ((m / 2 + 1 + n / 2) >= k)\r\n        return GetMedian( a, n / 2, b, m, k); \r\n      else\r\n        return GetMedian(\r\n                 a, n, b + m / 2 + 1, m - (m / 2 + 1), k - (m / 2 + 1)); \r\n    }\r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A[0]\": [\"-135313794\"], \"m\": [\"462375842\"], \"B\": [3], \"B[0]\": [\"-1497005615\"], \"B[1]\": [\"-1762212726\"], \"B[2]\": [\"-1906083201\"], \"n\": [\"86233502\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double findMedianSortedArrays. /*FC*/class Solution {\n/*FM*/double findMedianSortedArrays(int A[], int m, int B[], int n) {\r\n    if ((n + m) % 2 == 0)\r\n    {\r\n      \r\n    }\r\n    else\r\n      return GetMedian(A, m, B, n, (m + n) / 2 + 1); \r\n  };/*F*//*C*//*M*/int GetMedian(int a[], int n, int b[], int m, int k)\r\n  {\r\n    assert(a && b); \r\n    if (n <= 0) return b[k - 1]; \r\n    if (m <= 0) return a[k - 1]; \r\n    if (k <= 1) return min(a[0], b[0]); \r\n    if (b[m / 2] >= a[n / 2])\r\n    {\r\n      if ((n / 2 + 1 + m / 2) >= k)\r\n        return GetMedian(a, n, b, m / 2, k); \r\n      else\r\n        return GetMedian(\r\n                 a + n / 2 + 1, n - (n / 2 + 1), b, m, k - (n / 2 + 1)); \r\n    }\r\n    else\r\n    {\r\n      if ((m / 2 + 1 + n / 2) >= k)\r\n        return GetMedian( a, n / 2, b, m, k); \r\n      else\r\n        return GetMedian(\r\n                 a, n, b + m / 2 + 1, m - (m / 2 + 1), k - (m / 2 + 1)); \r\n    }\r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"m\": [\"2147483647\"], \"B\": [1], \"n\": [\"-2147483644\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> merge. /*FC*/class Solution {\n/*FM*/vector<Interval> merge(vector<Interval> &intervals) {\r\n    vector<Interval> result; \r\n    for (int i = 0;  i < intervals.size();  )\r\n    {\r\n      \r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<Interval> merge. /*FC*/class Solution {\n/*FM*/vector<Interval> merge(vector<Interval> &intervals) {\r\n    vector<Interval> result; \r\n    for (int i = 0;  i < intervals.size();  i++)\r\n    {\r\n      insert(result, intervals[i]); \r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/void insert(vector<Interval> &intervals, Interval newInterval) {\r\n    vector<Interval>::iterator it = intervals.begin(); \r\n    while (it != intervals.end())\r\n    {\r\n      if (newInterval.end < it->start)\r\n      {\r\n        intervals.insert(it, newInterval); \r\n        return; \r\n      }\r\n      else if (newInterval.start > it->end)\r\n      {\r\n        it++; \r\n        continue; \r\n      }\r\n      else\r\n      {\r\n        newInterval.start = min(newInterval.start, it->start); \r\n        newInterval.end = max(newInterval.end, it->end); \r\n        it = intervals.erase(it); \r\n      }\r\n    }\r\n    intervals.insert(intervals.end(), newInterval); \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [3], \"intervals_element0\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element0_s\": [\"1909543212\"], \"intervals_element0_e\": [\"-1270750171\"], \"intervals_element1\": [\"Interval\", \"Interval()\"], \"intervals_element2\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element2_s\": [\"0\"], \"intervals_element2_e\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/class Solution {\n/*FM*/void insert(vector<Interval> &intervals, Interval newInterval) {\r\n    vector<Interval>::iterator it = intervals.begin(); \r\n    while (it != intervals.end())\r\n    {\r\n      if (newInterval.end < it->start)\r\n      {\r\n        intervals.insert(it, newInterval); \r\n        return; \r\n      }\r\n      else if (newInterval.start > it->end)\r\n      {\r\n        \r\n        \r\n      }\r\n      else\r\n      {\r\n        newInterval.start = min(newInterval.start, it->start); \r\n        newInterval.end = max(newInterval.end, it->end); \r\n        it = intervals.erase(it); \r\n      }\r\n    }\r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [3], \"intervals_element0\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element0_s\": [\"-1339000315\"], \"intervals_element0_e\": [\"-196162690\"], \"intervals_element0.start\": [\"-617411251\"], \"intervals_element0.end\": [\"-1079926241\"], \"intervals_element1\": [\"Interval\", \"Interval()\"], \"intervals_element1.start\": [\"1071872924\"], \"intervals_element1.end\": [\"-1347283542\"], \"intervals_element2\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element2_s\": [\"-1825729307\"], \"intervals_element2_e\": [\"-1804860959\"], \"intervals_element2.start\": [\"210292696\"], \"intervals_element2.end\": [\"-1392854400\"], \"newInterval\": [\"Interval\", \"Interval(int,int)\"], \"newInterval_s\": [\"-1807260815\"], \"newInterval_e\": [\"-1681060028\"], \"newInterval.start\": [\"-1596129047\"], \"newInterval.end\": [\"995048125\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void insert. /*FC*/class Solution {\n/*FM*/void insert(vector<Interval> &intervals, Interval newInterval) {\r\n    vector<Interval>::iterator it = intervals.begin(); \r\n    while (it != intervals.end())\r\n    {\r\n      if (newInterval.end < it->start)\r\n      {\r\n        \r\n        \r\n      }\r\n      else if (newInterval.start > it->end)\r\n      {\r\n        it++; \r\n        continue; \r\n      }\r\n      else\r\n      {\r\n        \r\n        \r\n        \r\n      }\r\n    }\r\n    intervals.insert(intervals.end(), newInterval); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [3], \"intervals_element0\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element0_s\": [\"1464654948\"], \"intervals_element0_e\": [\"-2082973889\"], \"intervals_element0.start\": [\"-1588125567\"], \"intervals_element0.end\": [\"744273507\"], \"intervals_element1\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element1_s\": [\"-796931800\"], \"intervals_element1_e\": [\"-1493783820\"], \"intervals_element1.start\": [\"-2099183586\"], \"intervals_element1.end\": [\"1211410448\"], \"intervals_element2\": [\"Interval\", \"Interval(int,int)\"], \"intervals_element2_s\": [\"63681564\"], \"intervals_element2_e\": [\"-1278408126\"], \"intervals_element2.start\": [\"144174024\"], \"intervals_element2.end\": [\"590221557\"], \"newInterval\": [\"Interval\", \"Interval()\"], \"newInterval.start\": [\"1616471468\"], \"newInterval.end\": [\"174686902\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *mergeKLists. /*FC*/class Solution {\n/*FM*/ListNode *mergeKLists(vector<ListNode *> &lists) {\r\n        ListNode* one = NULL; \r\n        for (int i = 0;  i < lists.size();  )\r\n        {\r\n            \r\n        }\r\n        return one; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *mergeKLists. /*FC*/class Solution {\n/*FM*/ListNode *mergeKLists(vector<ListNode *> &lists) {\r\n        ListNode* one = NULL; \r\n        for (int i = 0;  i < lists.size();  i++)\r\n        {\r\n            one = merge2Lists(one, lists[i]); \r\n        }\r\n        return one; \r\n    };/*F*//*C*//*M*/ListNode* merge2Lists(ListNode* one, ListNode* two)\r\n    {\r\n        if (one == NULL) return two; \r\n        if (two == NULL) return one; \r\n        ListNode* newHead = new ListNode(-1); \r\n        ListNode* p = newHead; \r\n        while (one != NULL && two != NULL)\r\n        {\r\n            if (one->val < two->val)\r\n            {\r\n                p->next = one; \r\n                one = one->next; \r\n            }\r\n            else\r\n            {\r\n                p->next = two; \r\n                two = two->next; \r\n            }\r\n            p = p->next; \r\n        }\r\n\r\n        if (one == NULL)\r\n        {\r\n            p->next = two; \r\n        }\r\n        else\r\n        {\r\n            p->next = one; \r\n        }\r\n        p = newHead->next; \r\n        delete newHead; \r\n        return p; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"lists\": [2], \"lists_element0\": [2], \"lists_element0[0]\": [\"ListNode\", \"ListNode(int)\"], \"lists_element00_x\": [\"-444282433\"], \"lists_element0[1]\": [\"ListNode\", \"ListNode(int)\"], \"lists_element01_x\": [\"1110839745\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* merge2Lists. /*FC*/class Solution {\n/*FM*/ListNode* merge2Lists(ListNode* one, ListNode* two)\r\n    {\r\n        if (one == NULL) return two; \r\n        if (two == NULL) \r\n        \r\n        \r\n        \r\n\r\n        if (one == NULL)\r\n        {\r\n            \r\n        }\r\n        else\r\n        {\r\n            \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* merge2Lists. /*FC*/class Solution {\n/*FM*/ListNode* merge2Lists(ListNode* one, ListNode* two)\r\n    {\r\n        if (one == NULL) \r\n        if (two == NULL) \r\n        ListNode* newHead = new ListNode(-1); \r\n        ListNode* p = newHead; \r\n        while (one != NULL && two != NULL)\r\n        {\r\n            if (one->val < two->val)\r\n            {\r\n                \r\n                \r\n            }\r\n            else\r\n            {\r\n                p->next = two; \r\n                two = two->next; \r\n            }\r\n            p = p->next; \r\n        }\r\n\r\n        if (one == NULL)\r\n        {\r\n            \r\n        }\r\n        else\r\n        {\r\n            p->next = one; \r\n        }\r\n        p = newHead->next; \r\n        delete newHead; \r\n        return p; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"one\": [3], \"one[0]\": [\"ListNode\", \"ListNode(int)\"], \"one0_x\": [\"-131213060\"], \"one[0].val\": [\"2000410881\"], \"one[0].next\": [2], \"one[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"one0_next0_x\": [\"-1123207092\"], \"one[0].next[0].val\": [\"2009073077\"], \"one[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"one0_next1_x\": [\"-637269947\"], \"one[0].next[1].val\": [\"2090235506\"], \"one[1]\": [\"ListNode\", \"ListNode(int)\"], \"one1_x\": [\"1951907992\"], \"one[1].val\": [\"-829178101\"], \"one[1].next\": [2], \"one[1].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"one1_next0_x\": [\"-264519393\"], \"one[1].next[0].val\": [\"519247754\"], \"one[1].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"one1_next1_x\": [\"1209803803\"], \"one[1].next[1].val\": [\"1696603090\"], \"one[2]\": [\"ListNode\", \"ListNode(int)\"], \"one2_x\": [\"-1254779284\"], \"one[2].val\": [\"1614437435\"], \"one[2].next\": [1], \"one[2].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"one2_next0_x\": [\"-1268812275\"], \"one[2].next[0].val\": [\"-1199794319\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* merge2Lists. /*FC*/class Solution {\n/*FM*/ListNode* merge2Lists(ListNode* one, ListNode* two)\r\n    {\r\n        if (one == NULL) \r\n        if (two == NULL) return one; \r\n        \r\n        \r\n        \r\n\r\n        if (one == NULL)\r\n        {\r\n            \r\n        }\r\n        else\r\n        {\r\n            \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"one\": [1], \"one[0]\": [\"ListNode\", \"ListNode(int)\"], \"one0_x\": [\"0\"], \"two\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* merge2Lists. /*FC*/class Solution {\n/*FM*/ListNode* merge2Lists(ListNode* one, ListNode* two)\r\n    {\r\n        if (one == NULL) \r\n        if (two == NULL) \r\n        ListNode* newHead = new ListNode(-1); \r\n        ListNode* p = newHead; \r\n        while (one != NULL && two != NULL)\r\n        {\r\n            if (one->val < two->val)\r\n            {\r\n                p->next = one; \r\n                one = one->next; \r\n            }\r\n            else\r\n            {\r\n                \r\n                \r\n            }\r\n            p = p->next; \r\n        }\r\n\r\n        if (one == NULL)\r\n        {\r\n            p->next = two; \r\n        }\r\n        else\r\n        {\r\n            \r\n        }\r\n        p = newHead->next; \r\n        delete newHead; \r\n        return p; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"one\": [1], \"one[0]\": [\"ListNode\", \"ListNode(int)\"], \"one0_x\": [\"-2096739345\"], \"one[0].val\": [\"-1377061986\"], \"two\": [3], \"two[0]\": [\"ListNode\", \"ListNode(int)\"], \"two0_x\": [\"1049484191\"], \"two[0].val\": [\"-928392060\"], \"two[0].next\": [2], \"two[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"two0_next0_x\": [\"-1515622866\"], \"two[0].next[0].val\": [\"1766468022\"], \"two[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"two0_next1_x\": [\"-734050001\"], \"two[0].next[1].val\": [\"-507494761\"], \"two[1]\": [\"ListNode\", \"ListNode(int)\"], \"two1_x\": [\"-1268158900\"], \"two[1].val\": [\"1382870461\"], \"two[1].next\": [1], \"two[1].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"two1_next0_x\": [\"203691362\"], \"two[1].next[0].val\": [\"-1896311963\"], \"two[2]\": [\"ListNode\", \"ListNode(int)\"], \"two2_x\": [\"1516127324\"], \"two[2].val\": [\"-309504451\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void merge. /*FC*/class Solution {\n/*FM*/void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n    int k = m + n - 1; \r\n    int i = m - 1, j = n - 1; \r\n    for (;  i >= 0 && j >= 0;  k--)\r\n    {\r\n      if (nums1[i] >= nums2[j])\r\n      {\r\n        nums1[k] = nums1[i]; \r\n        i--; \r\n      }\r\n      else\r\n      {\r\n        nums1[k] = nums2[j]; \r\n        j--; \r\n      }\r\n    }\r\n    while (j >= 0)\r\n    {\r\n      nums1[k] = nums2[j]; \r\n      k--;  j--; \r\n    }\r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"898789286\"], \"nums1_element1\": [\"1348739971\"], \"m\": [\"8\"], \"nums2\": [2], \"nums2_element0\": [\"185363489\"], \"nums2_element1\": [\"-223337160\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void merge. /*FC*/class Solution {\n/*FM*/void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n    int k = m + n - 1; \r\n    int i = m - 1, j = n - 1; \r\n    for (;  i >= 0 && j >= 0;  )\r\n    {\r\n      \r\n    }\r\n    while (j >= 0)\r\n    {\r\n      nums1[k] = nums2[j]; \r\n       \r\n    }\r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"0\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void merge. /*FC*/class Solution {\n/*FM*/void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n    int k = m + n - 1; \r\n    int i = m - 1, j = n - 1; \r\n    for (;  i >= 0 && j >= 0;  )\r\n    {\r\n      \r\n    }\r\n    while (j >= 0)\r\n    {\r\n      \r\n       \r\n    }\r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"1\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int missingNumber. /*FC*/class Solution {\n/*FM*/int missingNumber(vector<int>& nums) {\r\n        \r\n        int length = nums.size(); \r\n        for(int i =0;  i< length;  i++) {\r\n            if(nums[i] == i) {\r\n                \r\n            }\r\n            \r\n            int j=i; \r\n            while(nums[j]<length && j != nums[j]) {\r\n                \r\n                \r\n                \r\n            }\r\n        }\r\n        \r\n        for(int i =0;  i< length;  ) {\r\n            if(nums[i] != i)\r\n                return i; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1682330136\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int missingNumber. /*FC*/class Solution {\n/*FM*/int missingNumber(vector<int>& nums) {\r\n        \r\n        int length = nums.size(); \r\n        for(int i =0;  i< length;  ) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        \r\n        for(int i =0;  i< length;  ) {\r\n            \r\n        }\r\n        return length; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector<int> &num) {\r\n        assert(num.size() > 0); \r\n        int vioIndex = num.size() - 1; \r\n        while (vioIndex > 0)\r\n        {\r\n            \r\n            \r\n        }\r\n        if (vioIndex > 0)\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        int end = num.size() - 1; \r\n        while (end > vioIndex)\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [1], \"num_element0\": [\"-29859744\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector<int> &num) {\r\n        assert(num.size() > 0); \r\n        int vioIndex = num.size() - 1; \r\n        while (vioIndex > 0)\r\n        {\r\n            if (num[vioIndex - 1] < num[vioIndex])\r\n                break; \r\n            vioIndex --; \r\n        }\r\n        if (vioIndex > 0)\r\n        {\r\n            vioIndex--; \r\n            int rightIndex = num.size() - 1; \r\n            while (rightIndex >= 0 && num[rightIndex] <= num[vioIndex])\r\n            {\r\n                rightIndex --; \r\n            }\r\n            int swap = num[vioIndex]; \r\n            num[vioIndex] = num[rightIndex]; \r\n            num[rightIndex] = swap; \r\n            vioIndex++; \r\n        }\r\n        int end = num.size() - 1; \r\n        while (end > vioIndex)\r\n        {\r\n            int swap = num[vioIndex]; \r\n            num[vioIndex] = num[end]; \r\n            num[end] = swap; \r\n            end--; \r\n            vioIndex++; \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"-1216693319\"], \"num_element1\": [\"-627495035\"], \"num_element2\": [\"-1947236089\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\r\n        if (x < 0) \r\n        int div = 1; \r\n        while (x / div >= 10)\r\n            \r\n        while (x > 0)\r\n        {\r\n            int l = x / div; \r\n            int r = x % 10; \r\n            if (l != r) \r\n            x = x % div / 10; \r\n            div /= 100; \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasPathSum. /*FC*/class Solution {\n/*FM*/bool hasPathSum(TreeNode *root, int sum, int target) {\r\n        if (root == NULL) return false; \r\n        sum += root->val; \r\n        if (root->left == NULL && root->right == NULL) \n        {\r\n            if (sum == target)\r\n                return true; \r\n            else\r\n                \r\n        }\r\n        return hasPathSum(root->left, sum, target)\r\n               || hasPathSum(root->right, sum, target); \r\n    };/*F*//*C*//*M*/bool hasPathSum(TreeNode *root, int sum, int target) {\r\n        if (root == NULL) return false; \r\n        sum += root->val; \r\n        if (root->left == NULL && root->right == NULL) \n        {\r\n            if (sum == target)\r\n                return true; \r\n            else\r\n                return false; \r\n        }\r\n        return hasPathSum(root->left, sum, target)\r\n               || hasPathSum(root->right, sum, target); \r\n    } bool hasPathSum(TreeNode *root, int sum, int target) {\r\n        if (root == NULL) return false; \r\n        sum += root->val; \r\n        if (root->left == NULL && root->right == NULL) \n        {\r\n            if (sum == target)\r\n                return true; \r\n            else\r\n                return false; \r\n        }\r\n        return hasPathSum(root->left, sum, target)\r\n               || hasPathSum(root->right, sum, target); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[0].val\": [\"0\"], \"root[0].left\": [0], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"0\"], \"sum\": [\"0\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasPathSum. /*FC*/class Solution {\n/*FM*/bool hasPathSum(TreeNode *root, int sum, int target) {\r\n        if (root == NULL) \r\n        sum += root->val; \r\n        if (root->left == NULL && root->right == NULL) \n        {\r\n            if (sum == target)\r\n                return true; \r\n            else\r\n                \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/bool hasPathSum(TreeNode *root, int sum, int target) {\r\n        if (root == NULL) return false; \r\n        sum += root->val; \r\n        if (root->left == NULL && root->right == NULL) \n        {\r\n            if (sum == target)\r\n                return true; \r\n            else\r\n                return false; \r\n        }\r\n        return hasPathSum(root->left, sum, target)\r\n               || hasPathSum(root->right, sum, target); \r\n    } bool hasPathSum(TreeNode *root, int sum, int target) {\r\n        if (root == NULL) return false; \r\n        sum += root->val; \r\n        if (root->left == NULL && root->right == NULL) \n        {\r\n            if (sum == target)\r\n                return true; \r\n            else\r\n                return false; \r\n        }\r\n        return hasPathSum(root->left, sum, target)\r\n               || hasPathSum(root->right, sum, target); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[0].val\": [\"0\"], \"root[0].left\": [0], \"root[0].right\": [0], \"sum\": [\"0\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasPathSum. /*FC*/class Solution {\n/*FM*/bool hasPathSum(TreeNode *root, int sum, int target) {\r\n        if (root == NULL) return false; \r\n        sum += root->val; \r\n        if (root->left == NULL && root->right == NULL) \n        {\r\n            if (sum == target)\r\n                \r\n            else\r\n                return false; \r\n        }\r\n        return hasPathSum(root->left, sum, target)\r\n               || hasPathSum(root->right, sum, target); \r\n    };/*F*//*C*//*M*/bool hasPathSum(TreeNode *root, int sum, int target) {\r\n        if (root == NULL) return false; \r\n        sum += root->val; \r\n        if (root->left == NULL && root->right == NULL) \n        {\r\n            if (sum == target)\r\n                return true; \r\n            else\r\n                return false; \r\n        }\r\n        return hasPathSum(root->left, sum, target)\r\n               || hasPathSum(root->right, sum, target); \r\n    } bool hasPathSum(TreeNode *root, int sum, int target) {\r\n        if (root == NULL) return false; \r\n        sum += root->val; \r\n        if (root->left == NULL && root->right == NULL) \n        {\r\n            if (sum == target)\r\n                return true; \r\n            else\r\n                return false; \r\n        }\r\n        return hasPathSum(root->left, sum, target)\r\n               || hasPathSum(root->right, sum, target); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1806861872\"], \"root[0].val\": [\"1327569472\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1365533551\"], \"root[0].left[0].val\": [\"-944319243\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"-344291882\"], \"root[0].left[1].val\": [\"-201674529\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"-422680923\"], \"root[0].left[2].val\": [\"2055419016\"], \"sum\": [\"1730672706\"], \"target\": [\"-1037086973\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > pathSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > pathSum(TreeNode *root, int sum) {\r\n        vector<vector<int> > collect; \r\n        vector<int> solution; \r\n        if (root != NULL)\r\n            GetPath(root, sum, 0, solution, collect); \r\n        return collect; \r\n    };/*F*//*C*//*M*/void GetPath(TreeNode* node, int sum, int cal, vector<int>& solution, vector<vector<int> >& collect)\r\n    {\r\n        solution.push_back(node->val); \r\n        cal += node->val; \r\n        if (cal == sum && node->left == NULL && node->right == NULL)\r\n        {\r\n            collect.push_back(solution); \r\n        }\r\n        else\r\n        {\r\n            if (node->left != NULL)\r\n            {\r\n                GetPath(node->left, sum, cal, solution, collect); \r\n            }\r\n            if (node->right != NULL)\r\n            {\r\n                GetPath(node->right, sum, cal, solution, collect); \r\n            }\r\n        }\r\n        solution.pop_back(); \r\n\r\n        return; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-913475355\"], \"sum\": [\"-45793305\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > pathSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > pathSum(TreeNode *root, int sum) {\r\n        vector<vector<int> > collect; \r\n        vector<int> solution; \r\n        if (root != NULL)\r\n            \r\n        return collect; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"sum\": [\"972336183\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\r\n\r\n        ListNode* head = new ListNode(-1); \r\n\r\n        ListNode* cur = head, *first = l1, *second = l2; \r\n\r\n        while (first != NULL || second != NULL)\r\n        {\r\n            int lval = first == NULL ? INT_MAX : first->val; \r\n            int rval = second == NULL ? INT_MAX : second->val; \r\n            if (lval < rval)\r\n            {\r\n                cur->next = first; \r\n                cur = first; \r\n                first = first == NULL ? NULL : first->next; \r\n            }\r\n            else\r\n            {\r\n                cur->next = second; \r\n                cur = second; \r\n                second = second == NULL ? NULL : second->next; \r\n            }\r\n        }\r\n\r\n        ListNode* newhead = head->next; \r\n        delete head; \r\n        return newhead; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"2001676113\"], \"l2\": [1], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"-435170746\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDepth. /*FC*/class Solution {\n/*FM*/int minDepth(TreeNode *root) {\r\n    if (root == NULL)\r\n      return 0; \r\n    int lmin = minDepth(root->left); \r\n    int rmin = minDepth(root->right); \r\n    if (lmin == 0 && rmin == 0)\r\n      return 1; \r\n    if (lmin == 0)\r\n    {\r\n      \r\n    }\r\n    if (rmin == 0)\r\n    {\r\n      rmin = INT_MAX; \r\n    }\r\n    return min(lmin, rmin) + 1; \r\n  };/*F*//*C*//*M*/int minDepth(TreeNode *root) {\r\n    if (root == NULL)\r\n      return 0; \r\n    int lmin = minDepth(root->left); \r\n    int rmin = minDepth(root->right); \r\n    if (lmin == 0 && rmin == 0)\r\n      return 1; \r\n    if (lmin == 0)\r\n    {\r\n      lmin = INT_MAX; \r\n    }\r\n    if (rmin == 0)\r\n    {\r\n      rmin = INT_MAX; \r\n    }\r\n    return min(lmin, rmin) + 1; \r\n  } int minDepth(TreeNode *root) {\r\n    if (root == NULL)\r\n      return 0; \r\n    int lmin = minDepth(root->left); \r\n    int rmin = minDepth(root->right); \r\n    if (lmin == 0 && rmin == 0)\r\n      return 1; \r\n    if (lmin == 0)\r\n    {\r\n      lmin = INT_MAX; \r\n    }\r\n    if (rmin == 0)\r\n    {\r\n      rmin = INT_MAX; \r\n    }\r\n    return min(lmin, rmin) + 1; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-393893460\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-142327198\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-549714248\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"-300434665\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPathSum. /*FC*/class Solution {\n/*FM*/int minPathSum(vector<vector<int> > &grid) {\r\n\t\tint row = grid.size(); \r\n\t\tif (row == 0) \r\n\t\tint col = grid[0].size(); \r\n\t\tif (col == 0) \r\n\t\tvector<int> steps(col, INT_MAX); \r\n\t\tsteps[0] = 0; \r\n\t\tfor (int i = 0;  i < row;  i++)\r\n\t\t{\r\n\t\t\tsteps[0] = steps[0] + grid[i][0]; \r\n\t\t\tfor (int j = 1;  j < col;  j++)\r\n\t\t\t{\r\n\t\t\t\tsteps[j] = min(steps[j], steps[j - 1]) + grid[i][j]; \r\n\t\t\t}\r\n\t\t}\r\n\t\treturn steps[col - 1]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [3], \"grid_element0\": [3], \"grid_element0_element0\": [\"1213727785\"], \"grid_element0_element1\": [\"1416194837\"], \"grid_element0_element2\": [\"1412854854\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"-1213674749\"], \"grid_element1_element1\": [\"-1264326849\"], \"grid_element2\": [2], \"grid_element2_element0\": [\"-1684692354\"], \"grid_element2_element1\": [\"-376622849\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class Solution {\n/*FM*/string minWindow(string S, string T) {\r\n        if (S.size() == 0) \r\n        if (S.size() < T.size()) \r\n        int appearCount[256]; \r\n        int expectCount[256]; \r\n        memset(appearCount, 0, 256 * sizeof(appearCount[0])); \r\n        memset(expectCount, 0, 256 * sizeof(appearCount[0])); \r\n        for (int i = 0;  i < T.size();  i++)\r\n        {\r\n            expectCount[T[i]]++; \r\n        }\r\n        int minV = INT_MAX, min_start = 0; \r\n        int wid_start = 0; \r\n        int appeared = 0; \r\n        for (int wid_end = 0;  wid_end < S.size();  wid_end++)\r\n        {\r\n            if (expectCount[S[wid_end]] > 0) \n            {\r\n                \r\n                \r\n            }\r\n            if (appeared == T.size())\r\n            {\r\n                \r\n                if (minV > (wid_end - wid_start + 1))\r\n                {\r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        if (minV == INT_MAX) return \"\"; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"T\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string multiply. /*FC*/class Solution {\n/*FM*/string multiply(string num1, string num2) {\r\n    if (num1.size() == 0 || num2.size() == 0) \r\n    string res(num1.size() + num2.size() + 1, '0'); \r\n    std::reverse(num1.begin(), num1.end()); \r\n    std::reverse(num2.begin(), num2.end()); \r\n    for (int i = 0;  i < num1.size();  i++)\r\n    {\r\n      int dig1 = num1[i] - '0'; \r\n      int carry = 0; \r\n      for (int j = 0;  j < num2.size();  j++)\r\n      {\r\n        int dig2 = num2[j] - '0'; \r\n        int exist = res[i + j] - '0'; \r\n        res[i + j] = (dig1 * dig2 + carry + exist) % 10 + '0'; \r\n        carry = (dig1 * dig2 + carry + exist) / 10; \r\n      }\r\n      if (carry > 0)\r\n      {\r\n        \r\n      }\r\n    }\r\n    std::reverse(res.begin(), res.end()); \r\n    int start = 0; \r\n    while (res[start] == '0' && start < res.size())\r\n    {\r\n      start++; \r\n    }\r\n    if (start == res.size()) return \"0\"; \r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"1\"], \"num2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string multiply. /*FC*/class Solution {\n/*FM*/string multiply(string num1, string num2) {\r\n    if (num1.size() == 0 || num2.size() == 0) \r\n    string res(num1.size() + num2.size() + 1, '0'); \r\n    std::reverse(num1.begin(), num1.end()); \r\n    std::reverse(num2.begin(), num2.end()); \r\n    for (int i = 0;  i < num1.size();  i++)\r\n    {\r\n      int dig1 = num1[i] - '0'; \r\n      int carry = 0; \r\n      for (int j = 0;  j < num2.size();  j++)\r\n      {\r\n        int dig2 = num2[j] - '0'; \r\n        int exist = res[i + j] - '0'; \r\n        res[i + j] = (dig1 * dig2 + carry + exist) % 10 + '0'; \r\n        carry = (dig1 * dig2 + carry + exist) / 10; \r\n      }\r\n      if (carry > 0)\r\n      {\r\n        res[i + num2.size()] = carry + '0'; \r\n      }\r\n    }\r\n    std::reverse(res.begin(), res.end()); \r\n    int start = 0; \r\n    while (res[start] == '0' && start < res.size())\r\n    {\r\n      start++; \r\n    }\r\n    if (start == res.size()) \r\n    return res.substr(start, res.size() - start); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"1\"], \"num2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void DFS. /*FC*/class Solution {\n/*FM*/void DFS(string &s, int start, vector<string>& output,\r\n             vector<vector<string>> &result)\r\n    {\r\n        if (start == s.size())\r\n        {\r\n            \r\n            \r\n        }\r\n        for (int i = start;  i < s.size();  )\r\n        {\r\n            \r\n        }\r\n    };/*F*//*C*//*M*/void DFS(string &s, int start, vector<string>& output,\r\n             vector<vector<string>> &result)\r\n    {\r\n        if (start == s.size())\r\n        {\r\n            result.push_back(output); \r\n            return; \r\n        }\r\n        for (int i = start;  i < s.size();  i++)\r\n        {\r\n            if (isPalindrome(s, start, i))\r\n            {\r\n                output.push_back(s.substr(start, i - start + 1)); \r\n                DFS(s, i + 1, output, result); \r\n                output.pop_back(); \r\n            }\r\n        }\r\n    } void DFS(string &s, int start, vector<string>& output,\r\n             vector<vector<string>> &result)\r\n    {\r\n        if (start == s.size())\r\n        {\r\n            result.push_back(output); \r\n            return; \r\n        }\r\n        for (int i = start;  i < s.size();  i++)\r\n        {\r\n            if (isPalindrome(s, start, i))\r\n            {\r\n                output.push_back(s.substr(start, i - start + 1)); \r\n                DFS(s, i + 1, output, result); \r\n                output.pop_back(); \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"start\": [\"2\"], \"output\": [1], \"output_element0\": [\"1\"], \"result\": [2], \"result_element0\": [2], \"result_element0_element0\": [\"1\"], \"result_element0_element1\": [\"1\"], \"result_element1\": [2], \"result_element1_element0\": [\"1\"], \"result_element1_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void DFS. /*FC*/class Solution {\n/*FM*/void DFS(string &s, int start, vector<string>& output,\r\n             vector<vector<string>> &result)\r\n    {\r\n        if (start == s.size())\r\n        {\r\n            result.push_back(output); \r\n            return; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/void DFS(string &s, int start, vector<string>& output,\r\n             vector<vector<string>> &result)\r\n    {\r\n        if (start == s.size())\r\n        {\r\n            result.push_back(output); \r\n            return; \r\n        }\r\n        for (int i = start;  i < s.size();  i++)\r\n        {\r\n            if (isPalindrome(s, start, i))\r\n            {\r\n                output.push_back(s.substr(start, i - start + 1)); \r\n                DFS(s, i + 1, output, result); \r\n                output.pop_back(); \r\n            }\r\n        }\r\n    } void DFS(string &s, int start, vector<string>& output,\r\n             vector<vector<string>> &result)\r\n    {\r\n        if (start == s.size())\r\n        {\r\n            result.push_back(output); \r\n            return; \r\n        }\r\n        for (int i = start;  i < s.size();  i++)\r\n        {\r\n            if (isPalindrome(s, start, i))\r\n            {\r\n                output.push_back(s.substr(start, i - start + 1)); \r\n                DFS(s, i + 1, output, result); \r\n                output.pop_back(); \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"start\": [\"1\"], \"output\": [1], \"output_element0\": [\"3\"], \"result\": [3], \"result_element0\": [1], \"result_element0_element0\": [\"2\"], \"result_element1\": [2], \"result_element1_element0\": [\"1\"], \"result_element1_element1\": [\"3\"], \"result_element2\": [2], \"result_element2_element0\": [\"1\"], \"result_element2_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string &s, int start, int end)\r\n    {\r\n        while (start < end)\r\n        {\r\n            if (s[start] != s[end])\r\n                \r\n            start++;  end--; \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"], \"start\": [\"6\"], \"end\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCut. /*FC*/class Solution {\n/*FM*/int minCut(string s) {\r\n        int len = s.size(); \r\n        int D[len + 1]; \r\n        bool P[len][len]; \r\n        \n        for (int i = 0;  i <= len;  i++)\r\n            D[i] = len - i; \r\n        for (int i = 0;  i < len;  i++)\r\n            for (int j = 0;  j < len;  j++)\r\n                P[i][j] = false; \r\n        for (int i = len - 1;  i >= 0;  i--) {\r\n            for (int j = i;  j < len;  j++) {\r\n                if (s[i] == s[j] && (j - i < 2 || P[i + 1][j - 1])) {\r\n                    P[i][j] = true; \r\n                    D[i] = min(D[i], D[j + 1] + 1); \r\n                }\r\n            }\r\n        }\r\n        return D[0] - 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *partition. /*FC*/class Solution {\n/*FM*/ListNode *partition(ListNode *head, int x) {\r\n        ListNode* p = new ListNode(x - 1); \r\n        p->next = head; \r\n        head = p; \r\n        ListNode* pre; \r\n        while (p != NULL && p->val < x)\r\n        {\r\n            pre = p; \r\n            p = p->next; \r\n        }\r\n        if (p != NULL)\r\n        {\r\n            \n            \r\n            \r\n        }\r\n        ListNode* temp = head; \r\n        head = head->next; \r\n        delete temp; \r\n        return head; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"9\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"9\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"2\"], \"x\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *partition. /*FC*/class Solution {\n/*FM*/ListNode *partition(ListNode *head, int x) {\r\n        ListNode* p = new ListNode(x - 1); \r\n        p->next = head; \r\n        head = p; \r\n        ListNode* pre; \r\n        while (p != NULL && p->val < x)\r\n        {\r\n            pre = p; \r\n            p = p->next; \r\n        }\r\n        if (p != NULL)\r\n        {\r\n            \n            ListNode* cur = pre; \r\n            while (p != NULL)\r\n            {\r\n                if (p->val < x)\r\n                {\r\n                    ListNode* temp = cur->next; \r\n                    pre->next = p->next; \r\n                    cur->next = p; \r\n                    cur = p; \r\n                    p->next = temp; \r\n                    p = pre; \r\n                }\r\n                pre = p; \r\n                p = p->next; \r\n            }\r\n        }\r\n        ListNode* temp = head; \r\n        head = head->next; \r\n        delete temp; \r\n        return head; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"4\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"1\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"3\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"3\"], \"x\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> getRow. /*FC*/class Solution {\n/*FM*/vector<int> getRow(int rowIndex) {\r\n        vector<int> result; \r\n        result.resize(rowIndex + 2); \r\n        for (int i = 0;  i < rowIndex + 2;  i++)\r\n            result[i] = 0; \r\n        result[1] = 1; \r\n        for (int i = 0;  i < rowIndex;  i++)\r\n        {\r\n            \n            for (int j = rowIndex + 1;  j > 0;  j--)\r\n            {\r\n                result[j] = result[j - 1] + result[j]; \r\n            }\r\n        }\r\n        result.erase(result.begin()); \r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"rowIndex\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > permute. /*FC*/class Solution {\n/*FM*/vector<vector<int> > permute(vector<int> &num) {\r\n        vector<vector<int> > coll; \r\n        vector<int> solution; \r\n        if (num.size() == 0) \r\n        vector<int> visited(num.size(), 0); \r\n        GeneratePermute(num, 0, visited, solution, coll); \r\n        return coll; \r\n    };/*F*//*C*//*M*/void GeneratePermute(vector<int> & num, int step,\r\n                         vector<int>& visited,\r\n                         vector<int>& solution,\r\n                         vector<vector<int> >& coll)\r\n    {\r\n        if (step == num.size())\r\n        {\r\n            coll.push_back(solution); \r\n            return; \r\n        }\r\n        for (int i = 0;  i < num.size();  i++)\r\n        {\r\n            \n            if (visited[i] == 0)\r\n            {\r\n                visited[i] = 1; \r\n                solution.push_back(num[i]); \r\n                GeneratePermute(\r\n                    num, step + 1, visited, solution, coll); \r\n                solution.pop_back(); \r\n                visited[i] = 0; \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"-307322600\"], \"num_element1\": [\"-543579465\"], \"num_element2\": [\"-1495154962\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > permuteUnique. /*FC*/class Solution {\n/*FM*/vector<vector<int> > permuteUnique(vector<int> &num) {\r\n        vector<vector<int> > coll; \r\n        vector<int> solution; \r\n        if (num.size() == 0) \r\n        vector<int> visited(num.size(), 0); \r\n        sort(num.begin(), num.end()); \r\n        GeneratePermute(num, 0, visited, solution, coll); \r\n        return coll; \r\n    };/*F*//*C*//*M*/void GeneratePermute(vector<int> & num, int step, vector<int>& visited, vector<int>& solution, vector<vector<int> >& coll)\r\n    {\r\n        if (step == num.size())\r\n        {\r\n            coll.push_back(solution); \r\n            return; \r\n        }\r\n        for (int i = 0;  i < num.size();  i++)\r\n        {\r\n            if (visited[i] == 0)\r\n            {\r\n\r\n                visited[i] = 1; \r\n                solution.push_back(num[i]); \r\n                GeneratePermute(num, step + 1, visited, solution, coll); \r\n                solution.pop_back(); \r\n                visited[i] = 0; \r\n                while (i < num.size() - 1 && num[i] == num[i + 1])\r\n                    i++; \r\n            }\r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"-2015229404\"], \"num_element1\": [\"87247825\"], \"num_element2\": [\"1734794614\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string getPermutation. /*FC*/class Solution {\n/*FM*/string getPermutation(int n, int k) {\r\n        vector<int> nums(n); \r\n        int permCount = 1; \r\n        for (int i = 0;  i < n;  i++)\r\n        {\r\n            nums[i] = i + 1; \r\n            permCount *= (i + 1); \r\n        }\r\n        \n        k--; \r\n        string targetNum; \r\n        for (int i = 0;  i < n;  i++)\r\n        {\r\n            permCount = permCount / (n - i); \r\n            int choosed = k / permCount; \r\n            targetNum.push_back(nums[choosed] + '0'); \r\n            \n            for (int j = choosed;  j < n - i;  j++)\r\n            {\r\n                nums[j] = nums[j + 1]; \r\n            }\r\n            k = k % permCount; \r\n        }\r\n        return targetNum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"3\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int> &digits) {\r\n        vector<int> result(digits.size(), 0); \r\n\r\n        int carryon = 1; \r\n        for (int i = digits.size() - 1;  i >= 0;  i--)\r\n        {\r\n            int digit = digits[i]; \r\n            result[i] = (digit + carryon) % 10; \r\n            carryon = (digit + carryon) / 10; \r\n        }\r\n\r\n        if (carryon > 0)\r\n        {\r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [3], \"digits_element0\": [\"-1066067757\"], \"digits_element1\": [\"-1774494417\"], \"digits_element2\": [\"-950879412\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int> &digits) {\r\n        vector<int> result(digits.size(), 0); \r\n\r\n        int carryon = 1; \r\n        for (int i = digits.size() - 1;  i >= 0;  i--)\r\n        {\r\n            int digit = digits[i]; \r\n            result[i] = (digit + carryon) % 10; \r\n            carryon = (digit + carryon) / 10; \r\n        }\r\n\r\n        if (carryon > 0)\r\n        {\r\n            result.insert(result.begin(), carryon); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [3], \"digits_element0\": [\"619680687\"], \"digits_element1\": [\"-702460679\"], \"digits_element2\": [\"-954567134\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void connect. /*FC*/class Solution {\n/*FM*/void connect(TreeLinkNode *root) {\r\n\t\tif (root == NULL) return; \r\n\t\tif (root->left != NULL)\r\n\t\t\troot->left->next = root->right; \r\n\t\tif (root->right != NULL)\r\n\t\t\t\r\n\t\tconnect(root->left); \r\n\t\tconnect(root->right); \r\n\t};/*F*//*C*//*M*/void connect(TreeLinkNode *root) {\r\n\t\tif (root == NULL) return; \r\n\t\tif (root->left != NULL)\r\n\t\t\troot->left->next = root->right; \r\n\t\tif (root->right != NULL)\r\n\t\t\troot->right->next = root->next ? root->next->left : NULL; \r\n\t\tconnect(root->left); \r\n\t\tconnect(root->right); \r\n\t} void connect(TreeLinkNode *root) {\r\n\t\tif (root == NULL) return; \r\n\t\tif (root->left != NULL)\r\n\t\t\troot->left->next = root->right; \r\n\t\tif (root->right != NULL)\r\n\t\t\troot->right->next = root->next ? root->next->left : NULL; \r\n\t\tconnect(root->left); \r\n\t\tconnect(root->right); \r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_x\": [\"13640882\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_left0_x\": [\"256212589\"], \"root[1]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root1_x\": [\"961540172\"], \"root[2]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root2_x\": [\"1260229597\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void connect. /*FC*/class Solution {\n/*FM*/void connect(TreeLinkNode *root) {\r\n\t\tif (root == NULL) return; \r\n\t\tif (root->left != NULL)\r\n\t\t\t\r\n\t\tif (root->right != NULL)\r\n\t\t\troot->right->next = root->next ? root->next->left : NULL; \r\n\t\tconnect(root->left); \r\n\t\tconnect(root->right); \r\n\t};/*F*//*C*//*M*/void connect(TreeLinkNode *root) {\r\n\t\tif (root == NULL) return; \r\n\t\tif (root->left != NULL)\r\n\t\t\troot->left->next = root->right; \r\n\t\tif (root->right != NULL)\r\n\t\t\troot->right->next = root->next ? root->next->left : NULL; \r\n\t\tconnect(root->left); \r\n\t\tconnect(root->right); \r\n\t} void connect(TreeLinkNode *root) {\r\n\t\tif (root == NULL) return; \r\n\t\tif (root->left != NULL)\r\n\t\t\troot->left->next = root->right; \r\n\t\tif (root->right != NULL)\r\n\t\t\troot->right->next = root->next ? root->next->left : NULL; \r\n\t\tconnect(root->left); \r\n\t\tconnect(root->right); \r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_x\": [\"922474751\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_right0_x\": [\"-1541508775\"], \"root[1]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root1_x\": [\"1572260524\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void connect. /*FC*/class Solution {\n/*FM*/void connect(TreeLinkNode *root) {\r\n        TreeLinkNode* cur = root, *next = NULL; \r\n        while (cur != NULL)\r\n        {\r\n            TreeLinkNode *p = cur, *k = NULL; \r\n            while (p != NULL)\r\n            {\r\n                TreeLinkNode* sub = getLinkedLeftNode(p); \r\n                if (sub != NULL)\r\n                {\r\n                    \r\n                    \r\n                }\r\n                p = p->next; \r\n            }\r\n            cur = next; \r\n            next = NULL; \r\n        }\r\n    };/*F*//*C*//*M*/TreeLinkNode* getLinkedLeftNode(TreeLinkNode * root)\r\n    {\r\n        if (root->left != NULL && root->right != NULL)\r\n            root->left->next = root->right; \r\n        if (root->left != NULL)\r\n            return root->left; \r\n        if (root->right != NULL)\r\n            return root->right; \r\n        return NULL; \r\n    } TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_x\": [\"-1318910633\"], \"root[1]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root1_x\": [\"0\"], \"root[2]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeLinkNode* getLinkedLeftNode. /*FC*/class Solution {\n/*FM*/TreeLinkNode* getLinkedLeftNode(TreeLinkNode * root)\r\n    {\r\n        if (root->left != NULL && root->right != NULL)\r\n            \r\n        if (root->left != NULL)\r\n            \r\n        if (root->right != NULL)\r\n            return root->right; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_x\": [\"-187937927\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_right0_x\": [\"2013196568\"], \"root[1]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root1_x\": [\"-1934907545\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeLinkNode* getLinkedLeftNode. /*FC*/class Solution {\n/*FM*/TreeLinkNode* getLinkedLeftNode(TreeLinkNode * root)\r\n    {\r\n        if (root->left != NULL && root->right != NULL)\r\n            \r\n        if (root->left != NULL)\r\n            return root->left; \r\n        if (root->right != NULL)\r\n            \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_x\": [\"-2015369652\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_left0_x\": [\"574825661\"], \"root[0].left[1]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[0].left[2]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root0_left2_x\": [\"0\"], \"root[1]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root1_x\": [\"1873468586\"], \"root[2]\": [\"TreeLinkNode\", \"TreeLinkNode(int)\"], \"root2_x\": [\"-2009236606\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double power. /*FC*/class Solution {\n/*FM*/double power(double x, int n)\r\n    {\r\n        if (n == 0)\r\n            return 1; \r\n        double v = power(x, n / 2); \r\n        if (n % 2 == 0)\r\n            return v * v; \r\n        else\r\n            return v * v * x; \r\n    };/*F*//*C*//*M*/double power(double x, int n)\r\n    {\r\n        if (n == 0)\r\n            return 1; \r\n        double v = power(x, n / 2); \r\n        if (n % 2 == 0)\r\n            return v * v; \r\n        else\r\n            return v * v * x; \r\n    } double power(double x, int n)\r\n    {\r\n        if (n == 0)\r\n            return 1; \r\n        double v = power(x, n / 2); \r\n        if (n % 2 == 0)\r\n            return v * v; \r\n        else\r\n            return v * v * x; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"0.12\"], \"n\": [\"-141831913\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double myPow. /*FC*/class Solution {\n/*FM*/double myPow(double x, int n) {\r\n        if (n < 0)\r\n            \r\n        else\r\n            return power(x, n); \r\n    };/*F*//*C*//*M*/double power(double x, int n)\r\n    {\r\n        if (n == 0)\r\n            return 1; \r\n        double v = power(x, n / 2); \r\n        if (n % 2 == 0)\r\n            return v * v; \r\n        else\r\n            return v * v * x; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"0.18\"], \"n\": [\"1830502361\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> productExceptSelf. /*FC*/class Solution {\n/*FM*/vector<int> productExceptSelf(vector<int>& nums) {\r\n        vector<int> products; \r\n        if(nums.size() == 0) \r\n\r\n        int product = 1; \r\n        products.push_back(1); \r\n        for(int i =1;  i< nums.size();  i++) {\r\n            product *= nums[i-1]; \r\n            products.push_back(product); \r\n        }\r\n        \r\n        product = 1; \r\n        for(int i =nums.size()-2;  i>=0;  i--) {\r\n            product = product * nums[i+1]; \r\n            products[i] = products[i] * product;  \r\n        }\r\n        return products; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1296904625\"], \"nums_element1\": [\"-684750580\"], \"nums_element2\": [\"170676334\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int>& A) {\r\n        int n = A.size(); \r\n        if (n == 0) \r\n        int index = 0; \r\n        for (int i = 0;  i < n;  i++)\r\n        {\r\n            if (A[index] == A[i]) \n            {\r\n                continue; \r\n            }\r\n            index++;  \n            A[index] = A[i]; \r\n        }\r\n        return index + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"-1987883918\"], \"A_element1\": [\"-508527487\"], \"A_element2\": [\"1658004656\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int>& A) {\r\n        int n = A.size(); \r\n        if (n == 0) \r\n        int occur = 1; \r\n        int index = 0; \r\n\r\n        for (int i = 1;  i < n;  i++)\r\n        {\r\n            if (A[index] == A[i])\r\n            {\r\n                \r\n                \r\n            }\r\n            else\r\n            {\r\n                occur = 1 ; \r\n            }\r\n\r\n            A[++index] = A[i]; \r\n\r\n        }\r\n        return index + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"1601381022\"], \"A_element1\": [\"-317652580\"], \"A_element2\": [\"263767161\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\r\n        if (head == NULL) \r\n        ListNode * pre = head; \r\n        ListNode *p = head->next; \r\n        while (p != NULL)\r\n        {\r\n            if (pre->val == p->val)\r\n            {\r\n                \r\n                \r\n                \r\n                \n                \r\n                \r\n            }\r\n            pre = pre->next; \r\n            p = p->next; \r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1526610419\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-468262041\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\r\n        if (head == NULL) return NULL; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\r\n        ListNode* dummy =  new ListNode(INT_MIN); \r\n        dummy->next = head; \r\n\r\n        ListNode* pre = dummy, *cur = head; \r\n        while (cur != NULL)\r\n        {\r\n            ListNode* post = cur->next; \r\n            bool isDup = false; \r\n            while (post != NULL && cur->val == post->val)\r\n            {\r\n                \r\n                \r\n                \r\n                \r\n            }\r\n\r\n            if (isDup)\r\n            {\r\n                \r\n                \r\n                \r\n                \r\n            }\r\n\r\n            pre->next = cur; \r\n            pre = cur; \r\n            cur = cur->next; \r\n        }\r\n        pre->next = NULL; \r\n\r\n        ListNode* newHead = dummy->next; \r\n        delete dummy; \r\n        return newHead; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"916048435\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-310102143\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeElement. /*FC*/class Solution {\n/*FM*/int removeElement(vector<int>& nums, int val) {\r\n        int cur = 0; \r\n        for (int i = 0;  i < nums.size();  i++)\r\n        {\r\n            if (nums[i] == val)\r\n                \r\n            nums[cur] = nums[i]; \r\n            cur++; \r\n        }\r\n        return cur; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1921697815\"], \"nums_element1\": [\"-1707645074\"], \"nums_element2\": [\"354068061\"], \"val\": [\"1612308829\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *removeNthFromEnd. /*FC*/class Solution {\n/*FM*/ListNode *removeNthFromEnd(ListNode *head, int n) {\r\n        ListNode* pre, *cur; \r\n        pre = head;  cur = head; \r\n        int step = 0; \r\n        while (step < n && cur != NULL)\r\n        {\r\n            cur = cur->next; \r\n            step++; \r\n        }\r\n        if (step == n && cur == NULL)\r\n        {\r\n            head = head->next; \r\n            delete pre; \r\n            return head; \r\n        }\r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1317606013\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"429873457\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"0\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reorderList. /*FC*/class Solution {\n/*FM*/void reorderList(ListNode *head) {\r\n        if (head == NULL) \r\n        \n        ListNode* fast = head; \r\n        ListNode* slow = head; \r\n        while (true)\r\n        {\r\n            fast = fast->next; \r\n            if (fast == NULL)\r\n                break; \r\n            \r\n            \r\n            \r\n        }\r\n\r\n        if (slow == NULL) \r\n\r\n        \n        ListNode* cur = slow; \r\n        ListNode* pre = slow->next; \r\n        cur->next = NULL; \r\n        while (pre != NULL)\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n\r\n        \n        ListNode* first = head; \r\n        ListNode* second = cur; \r\n\r\n        while (second != NULL && first != NULL && first != second)\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1363485907\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1070924927\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution {\n/*FM*/int reverse(int x) {\r\n          int newN = 0, left = 0; \r\n          while (x != 0)\r\n          {\r\n               left = x % 10; \r\n               if (newN > INT_MAX / 10 || newN < INT_MIN / 10) \r\n               newN = newN * 10 + left; \r\n               x = x / 10; \r\n          }\r\n          return newN; \r\n     };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseBetween. /*FC*/class Solution {\n/*FM*/ListNode *reverseBetween(ListNode *head, int m, int n) {\r\n        int step = n - m; \r\n        \n        ListNode* safeG = new ListNode(-1); \r\n        safeG->next = head; \r\n        head = safeG; \r\n        ListNode* pre = head; \r\n        while (m > 1)\r\n        {\r\n            \r\n            \r\n        }\r\n        ListNode* cur = pre->next, *post = cur->next; \r\n        if (step >= 1)\r\n        {\r\n            \n            while (step > 0 && post != NULL)\r\n            {\r\n                ListNode* temp = post->next; \r\n                post->next = cur; \r\n                cur = post; \r\n                post = temp; \r\n                step--; \r\n            }\r\n            \n            ListNode* temp = pre->next; \r\n            pre->next = cur; \r\n            temp->next = post; \r\n        }\r\n        safeG = head;   \n        head = head->next; \r\n        delete safeG; \r\n        return head; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"179213865\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"543455916\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"0\"], \"m\": [\"0\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseKGroup. /*FC*/class Solution {\n/*FM*/ListNode *reverseKGroup(ListNode *head, int k) {\r\n        ListNode* safeG = new ListNode(-1); \r\n        safeG->next = head; \r\n        if (head == NULL || k == 1) \r\n        ListNode* pre = safeG, *cur = head, *post = head->next; \r\n        while (cur != NULL)\r\n        {\r\n            post = cur->next; \r\n            int i = 0; \r\n            while (i < k - 1 && post != NULL)\r\n            {\r\n                ListNode *temp = post->next; \r\n                post->next = cur; \r\n                cur = post; \r\n                post = temp; \r\n                i++; \r\n            }\r\n            if (i != k - 1)\r\n            {\r\n                int k = 0; \r\n                ListNode * temp = post; \r\n                post = cur; \r\n                cur = temp; \r\n                while (k < i)\r\n                {\r\n                    temp = post->next; \r\n                    post->next = cur; \r\n                    cur = post; \r\n                    post = temp; \r\n                    k++; \r\n                }\r\n                break; \r\n            }\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        head = safeG->next; \r\n        delete safeG; \r\n        return head; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1871042477\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-2034449294\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseKGroup. /*FC*/class Solution {\n/*FM*/ListNode *reverseKGroup(ListNode *head, int k) {\r\n        ListNode* safeG = new ListNode(-1); \r\n        safeG->next = head; \r\n        if (head == NULL || k == 1) return head; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int romanToInt. /*FC*/class Solution {\n/*FM*/int romanToInt(string s) {\r\n        int result = 0; \r\n        for (int i = 0;  i < s.size();  i++)\r\n        {\r\n            if (i > 0 && c2n(s[i]) > c2n(s[i - 1]))\r\n            {\r\n                \r\n            }\r\n            else\r\n            {\r\n                result += c2n(s[i]); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/inline int c2n(char c) {\r\n        switch (c) {\r\n        case 'I': return 1; \r\n        case 'V': return 5; \r\n        case 'X': return 10; \r\n        case 'L': return 50; \r\n        case 'C': return 100; \r\n        case 'D': return 500; \r\n        case 'M': return 1000; \r\n        default: return 0; \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution {\n/*FM*/void rotate(vector<vector<int> > &matrix) {\r\n        int len = matrix[0].size(); \r\n        for (int i = 0;  i < len - 1;  i++)\r\n        {\r\n            for (int j = 0;  j < len - i;  j++)\r\n            {\r\n                swap(matrix[i][j], matrix[len - 1 - j][len - 1 - i]); \r\n            }\r\n        }\r\n        for (int i = 0;  i < len / 2;  i++)\r\n        {\r\n            for (int j = 0;  j < len;  j++)\r\n            {\r\n                swap(matrix[i][j], matrix[len - i - 1][j]); \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/void swap(int& a1, int&a2)\r\n    {\r\n        int temp = a1; \r\n        a1 = a2; \r\n        a2 = temp; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"-2111137111\"], \"matrix_element0_element1\": [\"2029476934\"], \"matrix_element0_element2\": [\"1132743097\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"-2009517507\"], \"matrix_element2\": [2], \"matrix_element2_element0\": [\"-589849990\"], \"matrix_element2_element1\": [\"1409322279\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *rotateRight. /*FC*/class Solution {\n/*FM*/ListNode *rotateRight(ListNode *head, int k) {\r\n        if (head == NULL || k == 0) \r\n        int len = 1; \r\n        ListNode* p = head, *pre; \r\n        while (p->next != NULL)\r\n        {\r\n            \r\n            \r\n        }\r\n        k = len - k % len; \r\n        p->next = head; \r\n        int step = 0; \r\n        while (step < k)\r\n        {\r\n            p = p->next; \r\n            step++; \r\n        }\r\n        head = p->next; \r\n        p->next = NULL; \r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1142680267\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"939127520\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int> > &matrix, int target) {\r\n        int row = matrix.size(); \r\n        if (row == 0) \r\n        int col = matrix[0].size(); \r\n        if (target < matrix[0][0]) \r\n        int start = 0, end = row - 1; \r\n\r\n        while (start <= end)\r\n        {\r\n            int mid = (start + end) / 2; \r\n            if (matrix[mid][0] == target) \r\n\r\n            if (matrix[mid][0] < target) start = mid + 1; \r\n            else \r\n        }\r\n\r\n        int searchRow = end; \r\n\r\n        start = 0, end = col - 1; \r\n        while (start <= end)\r\n        {\r\n            int mid = (start + end) / 2; \r\n            if (matrix[searchRow][mid] == target) \r\n\r\n            if (matrix[searchRow][mid] < target) start = mid + 1; \r\n            else \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-438648260\"], \"matrix_element0_element1\": [\"-1330224752\"], \"target\": [\"1885121018\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int> > &matrix, int target) {\r\n        int row = matrix.size(); \r\n        if (row == 0) \r\n        int col = matrix[0].size(); \r\n        if (target < matrix[0][0]) return false; \r\n        \r\n\r\n        \r\n\r\n        \r\n\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"203427618\"], \"matrix_element0_element1\": [\"-1052007687\"], \"matrix_element0_element2\": [\"-1247066836\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"1038636813\"], \"matrix_element1_element1\": [\"1535966750\"], \"matrix_element2\": [1], \"matrix_element2_element0\": [\"-135207155\"], \"target\": [\"25286799\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> searchRange. /*FC*/class Solution {\n/*FM*/vector<int> searchRange(vector<int>& A, int target) {\r\n        int n = A.size(); \r\n        vector<int> result; \r\n        result.push_back(-1); \r\n        result.push_back(-1); \r\n        \n        int start = 0, end = n - 1; \r\n        while (start < end)\r\n        {\r\n            int mid = (start + end) / 2; \r\n            if (A[mid] < target)\r\n            {\r\n                start = mid + 1; \r\n                continue; \r\n            }\r\n            end = mid; \r\n        }\r\n        int low_bound = A[start] == target ? start : -1; \r\n        if (low_bound == -1)\r\n        {\r\n            return result; \r\n        }\r\n        \n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"-1485000522\"], \"A_element1\": [\"1811828879\"], \"A_element2\": [\"-993754421\"], \"target\": [\"-612421776\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/class Solution {\n/*FM*/int searchInsert(vector<int>& A, int target) {\r\n        int l = 0, r = A.size() - 1; \r\n        while (l <= r)\r\n        {\r\n            int mid = (l + r) / 2; \r\n            if (A[mid] == target) \r\n            if (mid > l && A[mid] > target && A[mid - 1] < target )\r\n                return mid; \r\n            if (A[mid] > target)\r\n                \r\n            else\r\n                \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"123116426\"], \"A_element1\": [\"1337378676\"], \"A_element2\": [\"456337578\"], \"target\": [\"976830948\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/class Solution {\n/*FM*/int searchInsert(vector<int>& A, int target) {\r\n        int l = 0, r = A.size() - 1; \r\n        while (l <= r)\r\n        {\r\n            int mid = (l + r) / 2; \r\n            if (A[mid] == target) \r\n            if (mid > l && A[mid] > target && A[mid - 1] < target )\r\n                \r\n            if (A[mid] > target)\r\n                r = mid - 1; \r\n            else\r\n                \r\n        }\r\n        return l; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"1279472940\"], \"target\": [\"-1573334663\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& A, int target) {\r\n        int l = 0, r = A.size() - 1; \r\n        while (l <= r)\r\n        {\r\n            int m = (l + r) / 2; \r\n            if (A[m] == target) \r\n            if (A[m] >= A[l])\r\n            {\r\n                \n                if (A[l] <= target && target <= A[m])\r\n                    \r\n                else\r\n                    l = m + 1; \r\n            }\r\n            else\r\n            {\r\n                \n                if (A[m] < target && target < A[l])\r\n                    \r\n                else\r\n                    r = m - 1; \r\n            }\r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"807632839\"], \"A_element1\": [\"-264277958\"], \"A_element2\": [\"1260332271\"], \"target\": [\"1487692476\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool search. /*FC*/class Solution {\n/*FM*/bool search(vector<int>& A, int target) {\r\n        int start = 0; \r\n        int end = A.size() - 1; \r\n        while (start <= end)\r\n        {\r\n            int mid = (start + end) / 2; \r\n            if (A[mid] == target) \r\n            if (A[start] < A[mid])\r\n            {\r\n                if (target >= A[start] && target < A[mid])\r\n                    \r\n                else\r\n                    start = mid + 1; \r\n            }\r\n            else if (A[start] > A[mid])\r\n            {\r\n                }\r\n            else \n                start++; \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"1686348397\"], \"A_element1\": [\"1876377440\"], \"A_element2\": [\"909057940\"], \"target\": [\"-1674021138\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool search. /*FC*/class Solution {\n/*FM*/bool search(vector<int>& A, int target) {\r\n        int start = 0; \r\n        int end = A.size() - 1; \r\n        while (start <= end)\r\n        {\r\n            int mid = (start + end) / 2; \r\n            if (A[mid] == target) \r\n            if (A[start] < A[mid])\r\n            {\r\n                \n            else if (A[start] > A[mid])\r\n            {\r\n                if (target > A[mid] && target <= A[end])\r\n                    \r\n                else\r\n                    end = mid - 1; \r\n            }\r\n            else \n                start++; \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"737426242\"], \"A_element1\": [\"298808685\"], \"A_element2\": [\"-2031608236\"], \"target\": [\"1553452090\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void setZeroes. /*FC*/class Solution {\n/*FM*/void setZeroes(vector<vector<int>>& matrix) {\r\n        assert(matrix.size() > 0); \r\n        int row = matrix.size(), col = matrix[0].size(); \r\n        bool zerorow = false, zerocol = false; \r\n        for (int i = 0;  i < col;  i++)\r\n            if (matrix[0][i] == 0)\r\n                \r\n        for (int i = 0;  i < row;  i++)\r\n            if (matrix[i][0] == 0)\r\n                \r\n        for (int i = 1;  i < row;  i++)\r\n            for (int j = 1;  j < col;  j++)\r\n                if (matrix[i][j] == 0)\r\n                {\r\n                    \r\n                    \r\n                }\r\n        for (int i = 1;  i < row;  i++)\r\n            for (int j = 1;  j < col;  j++)\r\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\r\n                    \r\n        if (zerorow == 1)\r\n            \r\n        if (zerocol == 1)\r\n            \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"1341994323\"], \"matrix_element0_element1\": [\"997990448\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"120407637\"], \"matrix_element1_element1\": [\"894477515\"], \"matrix_element1_element2\": [\"-1545884549\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNumber. /*FC*/class Solution {\n/*FM*/int singleNumber(int A[], int n) {\r\n        int left = A[0]; \r\n        for (int i = 1;  i < n;  i++)\r\n        {\r\n            left = left ^ A[i]; \r\n        }\r\n        return left; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A[0]\": [\"1731725282\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int singleNumber. /*FC*/class Solution {\n/*FM*/int singleNumber(int A[], int n) {\r\n        vector<int> bit(32, 0); \r\n\r\n        for (int i = 0;  i < n;  ++i)\r\n        {\r\n            int k = 1; \r\n            for (int j = 0;  j < 32;  ++j)\r\n            {\r\n                int rotated; \r\n                if ((rotated = A[i] >> j) == 0) break; \r\n                bit[j] += rotated & k; \r\n            }\r\n        }\r\n\r\n        int target = 0; \r\n        for (int i = 0;  i < 32;  ++i)\r\n        {\r\n            target += (bit[i] % 3 << i); \r\n        }\r\n        return target; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A[0]\": [\"1107438794\"], \"A[1]\": [\"443703001\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> singleNumber. /*FC*/class Solution {\n/*FM*/vector<int> singleNumber(vector<int>& nums) {\r\n        int length = nums.size(); \r\n        \r\n        \n        int xor_result = 0; \r\n        for(int i =0;  i< length;  i++) {\r\n            xor_result ^= nums[i]; \r\n        }\r\n        \r\n        \n        int first_one_index = 0; \r\n        for(first_one_index =0;  first_one_index< 32;  first_one_index++) {\r\n            if((xor_result>>first_one_index) & 1 == 1) {\r\n                break; \r\n            }\r\n        }\r\n        \r\n        \n        \n        int xor_twice = 0; \r\n        for(int i =0;  i< length;  i++) {\r\n            if((nums[i]>>first_one_index) & 1 == 1) {\r\n                xor_twice ^= nums[i]; \r\n            }\r\n        }\r\n        \r\n        \n        vector<int> result = {xor_twice, xor_result ^ xor_twice };         \r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-307682437\"], \"nums_element1\": [\"837750609\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSlidingWindow. /*FC*/class Solution {\n/*FM*/vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        vector<int> result; \r\n        vector<int> maxWindow; \r\n        for (int i = 0;  i < nums.size();  ++i) {\r\n            \n            while(!maxWindow.empty() && nums[maxWindow.back()] < nums[i]) maxWindow.pop_back(); \r\n            if(!maxWindow.empty() && maxWindow.front() == i-k)  \r\n            maxWindow.push_back(i); \r\n            if (i >= k - 1) \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1831010358\"], \"nums_element1\": [\"-1411786710\"], \"nums_element2\": [\"-513106791\"], \"k\": [\"1286840819\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors. /*FC*/class Solution {\n/*FM*/void sortColors(vector<int>& A) {\r\n        int redSt = 0, bluSt = A.size() - 1; \r\n        int i = 0; \r\n        while (i < bluSt + 1)\r\n        {\r\n            if (A[i] == 0)\r\n            {\r\n                \r\n                \r\n                   \n                \r\n            }\r\n            if (A[i] == 2)\r\n            {\r\n                \r\n                   \n                \r\n            }\r\n            i++; \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"1520464420\"], \"A_element1\": [\"-1170331504\"], \"A_element2\": [\"-1130433586\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mySqrt. /*FC*/class Solution {\n/*FM*/int mySqrt(int x) {\r\n        int start = 0, end; \r\n        end = x / 2 < std::sqrt(INT_MAX) ?\r\n              x / 2 + 1 : std::sqrt(INT_MAX); \r\n        while (start <= end)\r\n        {\r\n            int mid = (start + end) / 2; \r\n            int sqr = mid * mid; \r\n            if (sqr == x)\r\n            {\r\n                \r\n            }\r\n            if (sqr < x)\r\n            {\r\n                start = mid + 1; \r\n            }\r\n            else\r\n            {\r\n                end = mid - 1; \r\n            }\r\n        }\r\n        return (start + end) / 2; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"1377617347\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        int num = 0; \r\n        int sign = 1; \r\n        int len = str.size(); \r\n        int i = 0; \r\n        int signNum = 0; \r\n        while (str[i] == ' ' && i < len) \r\n        if (str[i] == '+') {\r\n            \r\n            \r\n        }\r\n        if (str[i] == '-')\r\n        {\r\n             \n            \r\n            \r\n        }\r\n        for (;  i < len;  )\r\n        {\r\n            if (str[i] == ' ') \r\n            if (str[i] < '0' || str[i] > '9') break; \r\n            if (INT_MAX / 10 < num\r\n                    || INT_MAX / 10 == num\r\n                    && INT_MAX % 10 < (str[i] - '0'))\r\n            {\r\n                \r\n                break; \r\n            }\r\n            \r\n        }\r\n        return num * sign; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void generateSub. /*FC*/class Solution {\n/*FM*/void generateSub(\r\n        vector<int> &s,\r\n        int step,\r\n        vector<vector<int> > &result,\r\n        vector<int>& output)\r\n    {\r\n        for (int i = step;  i < s.size();   )\r\n        {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n    };/*F*//*C*//*M*/void generateSub(\r\n        vector<int> &s,\r\n        int step,\r\n        vector<vector<int> > &result,\r\n        vector<int>& output)\r\n    {\r\n        for (int i = step;  i < s.size();  i++ )\r\n        {\r\n            output.push_back(s[i]); \r\n            result.push_back(output); \r\n            if (i < s.size() - 1)\r\n                generateSub(s, i + 1, result, output); \r\n            output.pop_back(); \r\n        }\r\n    } void generateSub(\r\n        vector<int> &s,\r\n        int step,\r\n        vector<vector<int> > &result,\r\n        vector<int>& output)\r\n    {\r\n        for (int i = step;  i < s.size();  i++ )\r\n        {\r\n            output.push_back(s[i]); \r\n            result.push_back(output); \r\n            if (i < s.size() - 1)\r\n                generateSub(s, i + 1, result, output); \r\n            output.pop_back(); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [2], \"s_element0\": [\"-1723771332\"], \"s_element1\": [\"684695102\"], \"step\": [\"3\"], \"result\": [3], \"result_element0\": [2], \"result_element0_element0\": [\"-529343060\"], \"result_element0_element1\": [\"1744862698\"], \"result_element1\": [3], \"result_element1_element0\": [\"1260978873\"], \"result_element1_element1\": [\"176750361\"], \"result_element1_element2\": [\"-1967002893\"], \"result_element2\": [2], \"result_element2_element0\": [\"1647628926\"], \"result_element2_element1\": [\"-1695089614\"], \"output\": [2], \"output_element0\": [\"-1791787083\"], \"output_element1\": [\"-1482873028\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sumPath. /*FC*/class Solution {\n/*FM*/void sumPath(TreeNode* node, int pathSum)\r\n    {\r\n        if (node == NULL) return; \r\n        \r\n        \r\n\r\n        \r\n\r\n        \r\n    };/*F*//*C*//*M*/void sumPath(TreeNode* node, int pathSum)\r\n    {\r\n        if (node == NULL) return; \r\n        int newSum = pathSum * 10 + node->val; \r\n        if (node->left == NULL && node->right == NULL)\r\n        {\r\n            total += newSum; \r\n            return; \r\n        }\r\n\r\n        sumPath(node->left, newSum); \r\n\r\n        sumPath(node->right, newSum); \r\n    } void sumPath(TreeNode* node, int pathSum)\r\n    {\r\n        if (node == NULL) return; \r\n        int newSum = pathSum * 10 + node->val; \r\n        if (node->left == NULL && node->right == NULL)\r\n        {\r\n            total += newSum; \r\n            return; \r\n        }\r\n\r\n        sumPath(node->left, newSum); \r\n\r\n        sumPath(node->right, newSum); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->total\": [\"1023710750\"], \"pathSum\": [\"-270844232\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sumPath. /*FC*/class Solution {\n/*FM*/void sumPath(TreeNode* node, int pathSum)\r\n    {\r\n        if (node == NULL) \r\n        int newSum = pathSum * 10 + node->val; \r\n        if (node->left == NULL && node->right == NULL)\r\n        {\r\n            total += newSum; \r\n            return; \r\n        }\r\n\r\n        sumPath(node->left, newSum); \r\n\r\n        sumPath(node->right, newSum); \r\n    };/*F*/int total;/*C*//*M*/void sumPath(TreeNode* node, int pathSum)\r\n    {\r\n        if (node == NULL) return; \r\n        int newSum = pathSum * 10 + node->val; \r\n        if (node->left == NULL && node->right == NULL)\r\n        {\r\n            total += newSum; \r\n            return; \r\n        }\r\n\r\n        sumPath(node->left, newSum); \r\n\r\n        sumPath(node->right, newSum); \r\n    } void sumPath(TreeNode* node, int pathSum)\r\n    {\r\n        if (node == NULL) return; \r\n        int newSum = pathSum * 10 + node->val; \r\n        if (node->left == NULL && node->right == NULL)\r\n        {\r\n            total += newSum; \r\n            return; \r\n        }\r\n\r\n        sumPath(node->left, newSum); \r\n\r\n        sumPath(node->right, newSum); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"AKA_INSTANCE___Solution->total\": [\"730110536\"], \"node\": [3], \"node[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_x\": [\"-670367460\"], \"node[0].val\": [\"989411753\"], \"node[0].left\": [1], \"node[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_left0_x\": [\"1592416240\"], \"node[0].left[0].val\": [\"876026710\"], \"node[0].right\": [1], \"node[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node0_right0_x\": [\"951806349\"], \"node[0].right[0].val\": [\"933903302\"], \"node[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"node1_x\": [\"300011185\"], \"node[1].val\": [\"-2102093995\"], \"node[1].left\": [1], \"node[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node1_left0_x\": [\"-1016917558\"], \"node[1].left[0].val\": [\"1940087647\"], \"node[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"node2_x\": [\"-2105908634\"], \"node[2].val\": [\"-1252789347\"], \"node[2].left\": [2], \"node[2].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"node2_left0_x\": [\"-965490791\"], \"node[2].left[0].val\": [\"-279588840\"], \"node[2].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"node2_left1_x\": [\"1816749311\"], \"node[2].left[1].val\": [\"-1752123276\"], \"pathSum\": [\"1205896399\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniquePathsWithObstacles. /*FC*/class Solution {\n/*FM*/int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\r\n        int m = obstacleGrid.size(); \r\n        if (m == 0) \r\n        int n = obstacleGrid[0].size(); \r\n        if (obstacleGrid[0][0] == 1) \r\n        vector<int> maxV(n, 0); \r\n        maxV[0] = 1; \r\n        for (int i = 0;  i < m;  i++)\r\n        {\r\n            for (int j = 0;  j < n;  j++)\r\n            {\r\n                if (obstacleGrid[i][j] == 1)\r\n                    \r\n                else if (j > 0)\r\n                    maxV[j] = maxV[j - 1] + maxV[j]; \r\n            }\r\n        }\r\n        return maxV[n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"obstacleGrid\": [1], \"obstacleGrid_element0\": [3], \"obstacleGrid_element0_element0\": [\"1870390428\"], \"obstacleGrid_element0_element1\": [\"-692400214\"], \"obstacleGrid_element0_element2\": [\"1777716931\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniquePathsWithObstacles. /*FC*/class Solution {\n/*FM*/int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\r\n        int m = obstacleGrid.size(); \r\n        if (m == 0) return 0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution {\n/*FM*/bool isAnagram(string s, string t) {\r\n        vector<int> charcount(26, 0); \r\n        for(int i =0;  i< s.length();  i++) {\r\n            charcount[s[i] - 'a'] ++; \r\n        }\r\n        \r\n        for(int i =0;  i< t.length();  i++) {\r\n            charcount[t[i] - 'a'] --; \r\n        }\r\n        \r\n        for(int i =0;  i<charcount.size();  i++) {\r\n            if(charcount[i] != 0) {\r\n                \r\n            }\r\n        }\r\n        \r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"5\"], \"t\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution {\n/*FM*/bool isAnagram(string s, string t) {\r\n        vector<int> charcount(26, 0); \r\n        for(int i =0;  i< s.length();  i++) {\r\n            charcount[s[i] - 'a'] ++; \r\n        }\r\n        \r\n        for(int i =0;  i< t.length();  ) {\r\n            \r\n        }\r\n        \r\n        for(int i =0;  i<charcount.size();  ) {\r\n            if(charcount[i] != 0) {\r\n                return false; \r\n            }\r\n        }\r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution {\n/*FM*/bool isAnagram(string s, string t) {\r\n        vector<int> charcount(26, 0); \r\n        for(int i =0;  i< s.length();  i++) {\r\n            charcount[s[i] - 'a'] ++; \r\n        }\r\n        \r\n        for(int i =0;  i< t.length();  i++) {\r\n            charcount[t[i] - 'a'] --; \r\n        }\r\n        \r\n        for(int i =0;  i<charcount.size();  ) {\r\n            if(charcount[i] != 0) {\r\n                return false; \r\n            }\r\n        }\r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"4\"], \"t\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string s) {\r\n        int start = 0; \r\n        int end = s.size() - 1; \r\n        std::transform(\r\n            s.begin(), s.end(), s.begin(), ::tolower); \r\n        while (start < end)\r\n        {\r\n            \n                  \n                    if (s[start] != s[end]) \r\n            \r\n            \r\n        }\r\n        if (start >= end)\r\n            return true; \r\n        else\r\n            \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAlpha. /*FC*/class Solution {\n/*FM*/bool isAlpha(char c)\r\n    {\r\n        if (c >= 'a' && c <= 'z') \r\n        if (c >= '0' && c <= '9') \r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"c\": [\"-66\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAlpha. /*FC*/class Solution {\n/*FM*/bool isAlpha(char c)\r\n    {\r\n        if (c >= 'a' && c <= 'z') return true; \r\n        if (c >= '0' && c <= '9') \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"c\": [\"97\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAlpha. /*FC*/class Solution {\n/*FM*/bool isAlpha(char c)\r\n    {\r\n        if (c >= 'a' && c <= 'z') \r\n        if (c >= '0' && c <= '9') return true; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"c\": [\"48\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        stack<char> container; \r\n\r\n        for (int i = 0;  i < s.size();  i++)\r\n        {\r\n            if (s[i] == '(' || s[i] == '{' || s[i] == '[')\r\n            {\r\n                container.push(s[i]); \r\n                continue; \r\n            }\r\n            if (container.size() == 0) \r\n\r\n            \r\n            \r\n             if (s[i] == '}' && top != '{') \r\n            if (s[i] == ']' && top != '[') \r\n        }\r\n\r\n        if (container.size() > 0) return false; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        stack<char> container; \r\n\r\n        for (int i = 0;  i < s.size();  )\r\n        {\r\n            if (s[i] == '(' || s[i] == '{' || s[i] == '[')\r\n            {\r\n                \r\n                \r\n            }\r\n            if (container.size() == 0) return false; \r\n\r\n            \r\n            \r\n             if (s[i] == '}' && top != '{') \r\n            if (s[i] == ']' && top != '[') \r\n        }\r\n\r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidSudoku. /*FC*/class Solution {\n/*FM*/bool isValidSudoku(vector<vector<char> > &board) {\r\n        if (board.size() == 0) return false; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool wordBreak. /*FC*/class Solution {\n/*FM*/bool wordBreak(string s, unordered_set<string> &dict) {\r\n        string s2 = '#' + s; \r\n        int len = s2.size(); \r\n        vector<bool> possible(len, 0); \r\n\r\n        possible[0] = true; \r\n\r\n        for (int i = 1;  i < len;  ++i)\r\n        {\r\n            for (int k = 0;  k < i;  ++k)\r\n            {\r\n                possible[i] = possible[k] &&\r\n                              dict.find(s2.substr(k + 1, i - k)) != dict.end(); \r\n                if (possible[i]) \r\n            }\r\n        }\r\n\r\n        return possible[len - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool wordBreak. /*FC*/class Solution {\n/*FM*/bool wordBreak(string s, unordered_set<string> &dict) {\r\n        string s2 = '#' + s; \r\n        int len = s2.size(); \r\n        vector<bool> possible(len, 0); \r\n\r\n        possible[0] = true; \r\n\r\n        for (int i = 1;  i < len;  )\r\n        {\r\n            \r\n        }\r\n\r\n        return possible[len - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > threeSum(vector<int> &num) {\r\n\t\tstd::sort(num.begin(), num.end()); \r\n\t\tvector<vector<int>> result; \r\n\t\tfor (int i = 0 ;  i < num.size() ;  i++ )\r\n\t\t{\r\n\t\t\tint target = 0 - num[i]; \r\n\t\t\tint start = i + 1, end = num.size() - 1; \r\n\t\t\twhile (start < end)\r\n\t\t\t{\r\n\t\t\t\tint sum = num[start] + num[end]; \r\n\t\t\t\tif (sum == target)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\r\n\t\t\t\tif (sum < target)\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sum > target)\r\n\t\t\t\t{\r\n\t\t\t\t\tend--; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twhile (i < num.size() - 1 && num[i] == num[i + 1]) i++; \r\n\t\t}\r\n\t\treturn result; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [4], \"num_element0\": [\"1\"], \"num_element1\": [\"2\"], \"num_element2\": [\"2\"], \"num_element3\": [\"-1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > threeSum(vector<int> &num) {\r\n\t\tstd::sort(num.begin(), num.end()); \r\n\t\tvector<vector<int>> result; \r\n\t\tfor (int i = 0 ;  i < num.size() ;  i++ )\r\n\t\t{\r\n\t\t\tint target = 0 - num[i]; \r\n\t\t\tint start = i + 1, end = num.size() - 1; \r\n\t\t\twhile (start < end)\r\n\t\t\t{\r\n\t\t\t\tint sum = num[start] + num[end]; \r\n\t\t\t\tif (sum == target)\r\n\t\t\t\t{\r\n\t\t\t\t\tvector<int> oneSolution; \r\n\t\t\t\t\toneSolution.push_back(num[i]); \r\n\t\t\t\t\toneSolution.push_back(num[start]); \r\n\t\t\t\t\toneSolution.push_back(num[end]); \r\n\t\t\t\t\tresult.push_back(oneSolution); \r\n\t\t\t\t\tstart++; \r\n\t\t\t\t\tend--; \r\n\t\t\t\t\twhile (start < num.size() && num[start] == num[start - 1]) start++; \r\n\t\t\t\t\twhile (end > 0 && num[end] == num[end + 1]) end--; \r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sum < target)\r\n\t\t\t\t{\r\n\t\t\t\t\tstart++; \r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sum > target)\r\n\t\t\t\t{\r\n\t\t\t\t\tend--; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twhile (i < num.size() - 1 && num[i] == num[i + 1]) i++; \r\n\t\t}\r\n\t\treturn result; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [5], \"num_element0\": [\"1\"], \"num_element1\": [\"1\"], \"num_element2\": [\"-2\"], \"num_element3\": [\"-2\"], \"num_element4\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int threeSumClosest. /*FC*/class Solution {\n/*FM*/int threeSumClosest(vector<int> &num, int target) {\r\n\r\n    std::sort(num.begin(), num.end()); \r\n    int len = num.size(); \r\n    int minV = INT_MAX, record; \r\n    for (int i = 0;  i < len;  i++)\r\n    {\r\n      int start = i + 1, end = len - 1; \r\n      while (start < end)\r\n      {\r\n        int sum = num[i] + num[start] + num[end]; \r\n        if (sum == target)\r\n        {\r\n          \r\n          \r\n          \r\n        }\r\n        if (sum < target)\r\n        {\r\n          if (target - sum < minV)\r\n          {\r\n            minV = target - sum; \r\n            record = sum; \r\n          }\r\n          start++; \r\n        }\r\n        else\r\n        {\r\n          \r\n          \r\n        }\r\n      }\r\n      if (record == target) \r\n      while (i < len - 1 && num[i] == num[i + 1]) \r\n    }\r\n    return record; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"2049202167\"], \"num_element1\": [\"-441965891\"], \"num_element2\": [\"-1519076725\"], \"target\": [\"722926688\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int threeSumClosest. /*FC*/class Solution {\n/*FM*/int threeSumClosest(vector<int> &num, int target) {\r\n\r\n    std::sort(num.begin(), num.end()); \r\n    int len = num.size(); \r\n    int minV = INT_MAX, record; \r\n    for (int i = 0;  i < len;  i++)\r\n    {\r\n      int start = i + 1, end = len - 1; \r\n      while (start < end)\r\n      {\r\n        int sum = num[i] + num[start] + num[end]; \r\n        if (sum == target)\r\n        {\r\n          \r\n          \r\n          \r\n        }\r\n        if (sum < target)\r\n        {\r\n          if (target - sum < minV)\r\n          {\r\n            minV = target - sum; \r\n            record = sum; \r\n          }\r\n          start++; \r\n        }\r\n        else\r\n        {\r\n          if (sum - target < minV)\r\n          {\r\n            minV = sum - target; \r\n            record = sum; \r\n          }\r\n          end--; \r\n        }\r\n      }\r\n      if (record == target) \r\n      while (i < len - 1 && num[i] == num[i + 1]) \r\n    }\r\n    return record; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [4], \"num_element0\": [\"-1\"], \"num_element1\": [\"2\"], \"num_element2\": [\"1\"], \"num_element3\": [\"-4\"], \"target\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int threeSumClosest. /*FC*/class Solution {\n/*FM*/int threeSumClosest(vector<int> &num, int target) {\r\n\r\n    std::sort(num.begin(), num.end()); \r\n    int len = num.size(); \r\n    int minV = INT_MAX, record; \r\n    for (int i = 0;  i < len;  i++)\r\n    {\r\n      int start = i + 1, end = len - 1; \r\n      while (start < end)\r\n      {\r\n        int sum = num[i] + num[start] + num[end]; \r\n        if (sum == target)\r\n        {\r\n          \r\n          \r\n          \r\n        }\r\n        if (sum < target)\r\n        {\r\n          if (target - sum < minV)\r\n          {\r\n            \r\n            \r\n          }\r\n          start++; \r\n        }\r\n        else\r\n        {\r\n          if (sum - target < minV)\r\n          {\r\n            minV = sum - target; \r\n            record = sum; \r\n          }\r\n          end--; \r\n        }\r\n      }\r\n      if (record == target) \r\n      while (i < len - 1 && num[i] == num[i + 1]) \r\n    }\r\n    return record; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [4], \"num_element0\": [\"1\"], \"num_element1\": [\"3\"], \"num_element2\": [\"5\"], \"num_element3\": [\"7\"], \"target\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\r\n        int carry = 0; \r\n        string result; \r\n        for (\r\n            int i = a.size() - 1, j = b.size() - 1; \r\n            i >= 0 || j >= 0; \r\n            --i, --j\r\n        )\r\n        {\r\n            int ai = i >= 0 ? a[i] - '0' : 0; \r\n            int bj = j >= 0 ? b[j] - '0' : 0; \r\n            int val = (ai + bj + carry) % 2; \r\n            carry = (ai + bj + carry) / 2; \r\n            result.insert(result.begin(), val + '0'); \r\n        }\r\n\r\n        if (carry == 1)\r\n        {\r\n            result.insert(result.begin(), '1'); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"a\": [\"101\"], \"b\": [\"11\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int> > levelOrder(TreeNode *root) {\r\n\t\tvector<vector<int> > result; \r\n\t\tif (root == NULL) return result; \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t};/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method UndirectedGraphNode *cloneGraph. /*FC*/class Solution {\n/*FM*/UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\r\n\t\tif (node == NULL) return NULL; \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\r\n\t\t\r\n\t};/*F*//*C*//*M*/UndirectedGraphNode(int x) : label(x) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method UndirectedGraphNode *cloneGraph. /*FC*/class Solution {\n/*FM*/UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\r\n\t\tif (node == NULL) \r\n\t\tunordered_map<UndirectedGraphNode *, UndirectedGraphNode *> nodeMap; \r\n\t\tqueue<UndirectedGraphNode *> visit; \r\n\t\tvisit.push(node); \r\n\t\tUndirectedGraphNode * nodeCopy = new UndirectedGraphNode(node->label); \r\n\t\tnodeMap[node] = nodeCopy; \r\n\t\twhile (visit.size() > 0)\r\n\t\t{\r\n\t\t\tUndirectedGraphNode * cur = visit.front(); \r\n\t\t\tvisit.pop(); \r\n\t\t\tfor (int i = 0;  i < cur->neighbors.size();  )\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn nodeCopy; \r\n\t};/*F*//*C*//*M*/UndirectedGraphNode(int x) : label(x) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"node\": [2], \"node[0]\": [\"UndirectedGraphNode\", \"UndirectedGraphNode(int)\"], \"node0_x\": [\"-2071168824\"], \"node[0].label\": [\"-524739266\"], \"node[1]\": [\"UndirectedGraphNode\", \"UndirectedGraphNode(int)\"], \"node1_x\": [\"902512133\"], \"node[1].label\": [\"1301294442\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDecodings. /*FC*/class Solution {\n/*FM*/int numDecodings(string s) {\r\n\t\tif (s.empty() || s[0] == '0') \r\n\t\tif (s.size() == 1) \r\n\t\tint fn = 0, fn_1 = 0, fn_2 = 1; \r\n\t\tfn_1 = (check(s[0]) * check(s[1])) + check(s[0], s[1]); \r\n\t\tfor (int i = 2;  i < s.size();  i++)\r\n\t\t{\r\n\t\t\tif (check(s[i])) fn += fn_1; \r\n\t\t\tif (check(s[i - 1], s[i])) fn += fn_2; \r\n\t\t\tif (fn == 0)\r\n\t\t\t\t\r\n\t\t\tfn_2 = fn_1; \r\n\t\t\tfn_1 = fn; \r\n\t\t\tfn = 0; \r\n\t\t}\r\n\t\treturn fn_1; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"226\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDecodings. /*FC*/class Solution {\n/*FM*/int numDecodings(string s) {\r\n\t\tif (s.empty() || s[0] == '0') \r\n\t\tif (s.size() == 1) \r\n\t\tint fn = 0, fn_1 = 0, fn_2 = 1; \r\n\t\tfn_1 = (check(s[0]) * check(s[1])) + check(s[0], s[1]); \r\n\t\tfor (int i = 2;  i < s.size();  )\r\n\t\t{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\treturn fn_1; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"12\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDistinct. /*FC*/class Solution {\n/*FM*/int numDistinct(string S, string T) {\r\n\t\tint match[200]; \r\n\t\tif (S.size() < T.size()) return 0; \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"a\"], \"T\": [\"aa\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDistinct. /*FC*/class Solution {\n/*FM*/int numDistinct(string S, string T) {\r\n\t\tint match[200]; \r\n\t\tif (S.size() < T.size()) \r\n\t\tmatch[0] = 1; \r\n\t\tfor (int i = 1;  i <= T.size();  i++)\r\n\t\t\tmatch[i] = 0; \r\n\t\tfor (int i = 1;  i <= S.size();  i ++)\r\n\t\t\tfor (int j = T.size();  j >= 1;  j--)\r\n\t\t\t\tif (S[i - 1] == T[j - 1])\r\n\t\t\t\t\tmatch[j] += match[j - 1]; \r\n\t\treturn match[T.size()]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"aaaa\"], \"T\": [\"aa\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDistinct. /*FC*/class Solution {\n/*FM*/int numDistinct(string S, string T) {\r\n\t\tint match[200]; \r\n\t\tif (S.size() < T.size()) \r\n\t\tmatch[0] = 1; \r\n\t\tfor (int i = 1;  i <= T.size();  )\r\n\t\t\t\r\n\t\tfor (int i = 1;  i <= S.size();  i ++)\r\n\t\t\tfor (int j = T.size();  j >= 1;  )\r\n\t\t\t\tif (S[i - 1] == T[j - 1])\r\n\t\t\t\t\t\r\n\t\treturn match[T.size()]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"abc\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/class Solution {\n/*FM*/int minDistance(string word1, string word2) {\r\n\t\tif (word1.size() < word2.size())\r\n\t\t\t\r\n\t\tint * matchUp = new int[20000]; \r\n\t\tint* matchDown = new int[20000]; \r\n\t\tfor (int i = 0;  i <= word2.size();  i++)\r\n\t\t{\r\n\t\t\tmatchUp[i] = 0; \r\n\t\t\tmatchDown[i] = i; \r\n\t\t}\r\n\t\tfor (int i = 1;  i <= word1.size();  i++)\r\n\t\t{\r\n\t\t\tmatchUp[0] = i; \r\n\t\t\tfor (int j = 1;  j <= word2.size();  j++)\r\n\t\t\t{\r\n\t\t\t\tif (word1[i - 1] == word2[j - 1])\r\n\t\t\t\t{\r\n\t\t\t\t\tmatchUp[j] = matchDown[j - 1]; \r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmatchUp[j] = min(matchDown[j], matchDown[j - 1]); \r\n\t\t\t\t\tmatchUp[j] = min(matchUp[j], matchUp[j - 1]) + 1; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint* temp = matchUp; \r\n\t\t\tmatchUp = matchDown; \r\n\t\t\tmatchDown = temp; \r\n\t\t}\r\n\t\treturn matchDown[word2.size()]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"word1\": [\"abcd\"], \"word2\": [\"abcd\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/class Solution {\n/*FM*/int minDistance(string word1, string word2) {\r\n\t\tif (word1.size() < word2.size())\r\n\t\t\tword1.swap(word2); \r\n\t\tint * matchUp = new int[20000]; \r\n\t\tint* matchDown = new int[20000]; \r\n\t\tfor (int i = 0;  i <= word2.size();  i++)\r\n\t\t{\r\n\t\t\tmatchUp[i] = 0; \r\n\t\t\tmatchDown[i] = i; \r\n\t\t}\r\n\t\tfor (int i = 1;  i <= word1.size();  i++)\r\n\t\t{\r\n\t\t\tmatchUp[0] = i; \r\n\t\t\tfor (int j = 1;  j <= word2.size();  j++)\r\n\t\t\t{\r\n\t\t\t\tif (word1[i - 1] == word2[j - 1])\r\n\t\t\t\t{\r\n\t\t\t\t\tmatchUp[j] = matchDown[j - 1]; \r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmatchUp[j] = min(matchDown[j], matchDown[j - 1]); \r\n\t\t\t\t\tmatchUp[j] = min(matchUp[j], matchUp[j - 1]) + 1; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint* temp = matchUp; \r\n\t\t\tmatchUp = matchDown; \r\n\t\t\tmatchDown = temp; \r\n\t\t}\r\n\t\treturn matchDown[word2.size()]; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"word1\": [\"a\"], \"word2\": [\"abc\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char *strStr. /*FC*/class Solution {\n/*FM*/char *strStr(char *haystack, char *needle) {\r\n\t\tif (haystack == NULL || needle == NULL) \r\n\t\tint hlen = strlen(haystack); \r\n\t\tint nlen = strlen(needle); \r\n\t\tif (nlen == 0) \r\n\t\tif (hlen == 0 ) \r\n\t\tint pattern[100000]; \r\n\t\tGeneratePattern(needle, nlen, pattern); \r\n\t\treturn Match(haystack, needle, pattern); \r\n\t};/*F*//*C*//*M*/void GeneratePattern(char* str, int len, int* pattern)\r\n\t{\r\n\t\tpattern[0] = -1; \r\n\t\tint k = -1; \r\n\t\tfor (int j = 1;  j < len;  j++)\r\n\t\t{\r\n\t\t\twhile (k > -1 && str[k + 1] != str[j])\r\n\t\t\t\tk = pattern[k]; \r\n\t\t\tif (str[k + 1] == str[j])\r\n\t\t\t\tk++; \r\n\t\t\tpattern[j] = k; \r\n\t\t}\r\n\t} char* Match(char* haystack, char* needle, int* pattern)\r\n\t{\r\n\t\tint hlen = strlen(haystack); \r\n\t\tint nlen = strlen(needle); \r\n\t\tint k = -1; \r\n\t\tfor (int j = 0;  j < hlen;  j++, haystack++)\r\n\t\t{\r\n\t\t\twhile (k > -1 && needle[k + 1] != *haystack)\r\n\t\t\t\tk = pattern[k]; \r\n\t\t\tif (needle[k + 1] == *haystack)\r\n\t\t\t\tk++; \r\n\t\t\tif (k == nlen - 1)\r\n\t\t\t\treturn haystack - k; \r\n\t\t}\r\n\t\treturn NULL; \r\n\t};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [1], \"haystack[0]\": [\"-105\"], \"haystack[1]\": [\"-21\"], \"needle\": [1], \"needle[0]\": [\"54\"], \"needle[1]\": [\"36\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char *strStr. /*FC*/class Solution {\n/*FM*/char *strStr(char *haystack, char *needle) {\r\n\t\tif (haystack == NULL || needle == NULL) return NULL; \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (hlen == 0 ) \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"haystack\": [3], \"haystack[0]\": [\"97\"], \"haystack[1]\": [\"98\"], \"haystack[2]\": [\"99\"], \"haystack[3]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void GeneratePattern. /*FC*/class Solution {\n/*FM*/void GeneratePattern(char* str, int len, int* pattern)\r\n\t{\r\n\t\tpattern[0] = -1; \r\n\t\tint k = -1; \r\n\t\tfor (int j = 1;  j < len;  j++)\r\n\t\t{\r\n\t\t\twhile (k > -1 && str[k + 1] != str[j])\r\n\t\t\t\tk = pattern[k]; \r\n\t\t\tif (str[k + 1] == str[j])\r\n\t\t\t\tk++; \r\n\t\t\tpattern[j] = k; \r\n\t\t}\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [1], \"str[0]\": [\"49\"], \"str[1]\": [\"77\"], \"len\": [\"10\"], \"pattern\": [1], \"pattern[0]\": [\"-701068083\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char* Match. /*FC*/class Solution {\n/*FM*/char* Match(char* haystack, char* needle, int* pattern)\r\n\t{\r\n\t\tint hlen = strlen(haystack); \r\n\t\tint nlen = strlen(needle); \r\n\t\tint k = -1; \r\n\t\tfor (int j = 0;  j < hlen;  )\r\n\t\t{\r\n\t\t\twhile (k > -1 && needle[k + 1] != *haystack)\r\n\t\t\t\t\r\n\t\t\tif (needle[k + 1] == *haystack)\r\n\t\t\t\tk++; \r\n\t\t\tif (k == nlen - 1)\r\n\t\t\t\treturn haystack - k; \r\n\t\t}\r\n\t\t\r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [1], \"haystack[0]\": [\"48\"], \"haystack[1]\": [\"0\"], \"needle\": [1], \"needle[0]\": [\"48\"], \"needle[1]\": [\"0\"], \"pattern\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char* Match. /*FC*/class Solution {\n/*FM*/char* Match(char* haystack, char* needle, int* pattern)\r\n\t{\r\n\t\tint hlen = strlen(haystack); \r\n\t\tint nlen = strlen(needle); \r\n\t\tint k = -1; \r\n\t\tfor (int j = 0;  j < hlen;  j++, haystack++)\r\n\t\t{\r\n\t\t\twhile (k > -1 && needle[k + 1] != *haystack)\r\n\t\t\t\t\r\n\t\t\tif (needle[k + 1] == *haystack)\r\n\t\t\t\t\r\n\t\t\tif (k == nlen - 1)\r\n\t\t\t\t\r\n\t\t}\r\n\t\treturn NULL; \r\n\t};/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [1], \"haystack[0]\": [\"82\"], \"haystack[1]\": [\"105\"], \"needle\": [1], \"needle[0]\": [\"-85\"], \"needle[1]\": [\"-18\"], \"pattern\": [1], \"pattern[0]\": [\"912588219\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(const char *s) {\r\n        const char* pStart = s; \r\n        const char* pEnd = s; \r\n        const char* p = s; \r\n        const char* pre = s; \r\n\r\n        while (*p != '\\0')\r\n        {\r\n            if (*pre == ' ' && *p != ' ') \r\n            if (*pre != ' ' && *p == ' ') \r\n\r\n            pre = p; \r\n            p++; \r\n        }\r\n\r\n        if (*pre != ' ' && *p == '\\0') \r\n        return pEnd - pStart; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [3], \"s_constantPointer[0]\": [\"32\"], \"s_constantPointer[1]\": [\"32\"], \"s_constantPointer[2]\": [\"32\"], \"s_constantPointer[3]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(const char *s) {\r\n        const char* pStart = s; \r\n        const char* pEnd = s; \r\n        const char* p = s; \r\n        const char* pre = s; \r\n\r\n        while (*p != '\\0')\r\n        {\r\n            if (*pre == ' ' && *p != ' ') \r\n            if (*pre != ' ' && *p == ' ') pEnd = p; \r\n\r\n            pre = p; \r\n            p++; \r\n        }\r\n\r\n        if (*pre != ' ' && *p == '\\0') \r\n        return pEnd - pStart; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [7], \"s_constantPointer[0]\": [\"104\"], \"s_constantPointer[1]\": [\"101\"], \"s_constantPointer[2]\": [\"108\"], \"s_constantPointer[3]\": [\"108\"], \"s_constantPointer[4]\": [\"111\"], \"s_constantPointer[5]\": [\"32\"], \"s_constantPointer[6]\": [\"32\"], \"s_constantPointer[7]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(const char *s) {\r\n        const char* pStart = s; \r\n        const char* pEnd = s; \r\n        const char* p = s; \r\n        const char* pre = s; \r\n\r\n        while (*p != '\\0')\r\n        {\r\n            if (*pre == ' ' && *p != ' ') pStart = p; \r\n            if (*pre != ' ' && *p == ' ') \r\n\r\n            pre = p; \r\n            p++; \r\n        }\r\n\r\n        if (*pre != ' ' && *p == '\\0') pEnd = p; \r\n        return pEnd - pStart; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [7], \"s_constantPointer[0]\": [\"32\"], \"s_constantPointer[1]\": [\"32\"], \"s_constantPointer[2]\": [\"104\"], \"s_constantPointer[3]\": [\"101\"], \"s_constantPointer[4]\": [\"108\"], \"s_constantPointer[5]\": [\"108\"], \"s_constantPointer[6]\": [\"111\"], \"s_constantPointer[7]\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\r\n    int len = s.size(); \r\n    int P[len][len]; \r\n    memset(P, 0, len * len * sizeof(int)); \r\n    int maxL = 0, start = 0, end = 0; \r\n    for (int i = 0;  i < s.size();  i++)\r\n    {\r\n      for (int j = 0;  j < i;  j++)\r\n      {\r\n        P[j][i] = (s[j] == s[i] && (i - j < 2 || P[j + 1][i - 1])); \r\n        if (P[j][i] && maxL < (i - j + 1))\r\n        {\r\n          maxL = i - j + 1; \r\n          start = j; \r\n          end = i; \r\n        }\r\n      }\r\n      P[i][i] = 1; \r\n    }\r\n    return s.substr(start, end - start + 1); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"abba\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\r\n    int len = s.size(); \r\n    int P[len][len]; \r\n    memset(P, 0, len * len * sizeof(int)); \r\n    int maxL = 0, start = 0, end = 0; \r\n    for (int i = 0;  i < s.size();  i++)\r\n    {\r\n      for (int j = 0;  j < i;  j++)\r\n      {\r\n        P[j][i] = (s[j] == s[i] && (i - j < 2 || P[j + 1][i - 1])); \r\n        if (P[j][i] && maxL < (i - j + 1))\r\n        {\r\n          \r\n          \r\n          \r\n        }\r\n      }\r\n      P[i][i] = 1; \r\n    }\r\n    return s.substr(start, end - start + 1); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"ab\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\r\n        if (x < 0) \r\n        int div = 1; \r\n        while (x / div >= 10)\r\n            div *= 10; \r\n        while (x > 0)\r\n        {\r\n            int l = x / div; \r\n            int r = x % 10; \r\n            if (l != r) \r\n            x = x % div / 10; \r\n            div /= 100; \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"x\": [\"12321\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\r\n        if (x < 0) \r\n        int div = 1; \r\n        while (x / div >= 10)\r\n            div *= 10; \r\n        while (x > 0)\r\n        {\r\n            int l = x / div; \r\n            int r = x % 10; \r\n            if (l != r) return false; \r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"x\": [\"123\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution {\n/*FM*/int maxArea(vector<int>& height) {\r\n        int max_area = 0, l = 0, r = height.size() - 1; \r\n        while (l < r) {\r\n            max_area = max(max_area, min(height[l], height[r]) * (r - l)); \r\n            if (height[l] < height[r]) {\r\n                l++; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return max_area; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [2], \"height_element0\": [\"1197387588\"], \"height_element1\": [\"1509366480\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxArea. /*FC*/class Solution {\n/*FM*/int maxArea(vector<int>& height) {\r\n        int max_area = 0, l = 0, r = height.size() - 1; \r\n        while (l < r) {\r\n            max_area = max(max_area, min(height[l], height[r]) * (r - l)); \r\n            if (height[l] < height[r]) {\r\n                \r\n            } else {\r\n                r--; \r\n            }\r\n        }\r\n        return max_area; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [3], \"height_element0\": [\"503687238\"], \"height_element1\": [\"-2102379984\"], \"height_element2\": [\"440249769\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* addTwoNumbers. /*FC*/class Solution {\n/*FM*/ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\r\n        ListNode fake(0), *pi = &fake; \r\n        int carry = 0; \r\n        \r\n        while ( l1 || l2 || carry ) {\r\n            int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry; \r\n            carry = sum / 10;    \n            \r\n            pi->next = new ListNode(sum % 10); \r\n            pi = pi->next; \r\n            \r\n            l1 = l1 ? l1->next : NULL; \r\n            l2 = l2 ? l2->next : NULL; \r\n        }\r\n        return fake.next; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"0\"], \"l1[0].val\": [\"0\"], \"l2\": [1], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"0\"], \"l2[0].val\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n        int max_len = 0; \r\n        for (int i = 0, last = -1;  i < s.size();  i++) {\r\n            for (int j = last + 1;  j < i;  ) {\r\n                \r\n            }\r\n            max_len = max(max_len, i - last); \r\n        }\r\n        return max_len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n        int max_len = 0; \r\n        for (int i = 0, last = -1;  i < s.size();  ) {\r\n            \r\n            \r\n        }\r\n        return max_len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\r\n        string _s = \"$#\"; \r\n        for (char c : s) {\r\n            \r\n            \r\n        }\r\n        \r\n        vector<int> p(_s.size()); \r\n        int id = 0, max_id = 0; \r\n        for (int i = 1;  i < _s.size();  i++) {\r\n            p[i] = p[id] + id > i ? min(p[2 * id - i], p[id] + id - i) : 1; \r\n            while (_s[i + p[i]] == _s[i - p[i]]) {\r\n                \r\n            }\r\n            if (p[i] + i > p[id] + id) {\r\n                id = i; \r\n                if (p[i] > p[max_id]) {\r\n                    max_id = i; \r\n                }\r\n            }\r\n        }\r\n        return s.substr((max_id - p[max_id]) / 2, p[max_id] - 1); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\r\n        string _s = \"$#\"; \r\n        for (char c : s) {\r\n            _s += c; \r\n            _s += \"#\"; \r\n        }\r\n        \r\n        vector<int> p(_s.size()); \r\n        int id = 0, max_id = 0; \r\n        for (int i = 1;  i < _s.size();  i++) {\r\n            p[i] = p[id] + id > i ? min(p[2 * id - i], p[id] + id - i) : 1; \r\n            while (_s[i + p[i]] == _s[i - p[i]]) {\r\n                p[i]++; \r\n            }\r\n            if (p[i] + i > p[id] + id) {\r\n                id = i; \r\n                if (p[i] > p[max_id]) {\r\n                    max_id = i; \r\n                }\r\n            }\r\n        }\r\n        return s.substr((max_id - p[max_id]) / 2, p[max_id] - 1); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/class Solution {\n/*FM*/string convert(string s, int numRows) {\r\n        if (numRows == 1) \r\n        \r\n        vector<string> vec(numRows); \r\n        for (int i = 0, x = numRows - 1;  i < s.size();  ) {\r\n            \r\n        }\r\n        \r\n        string ans; \r\n        for (string &str : vec) {\r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numRows\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution {\n/*FM*/int reverse(int x) {\r\n        int ans = 0; \r\n        while (x) {\r\n            if (ans  > INT_MAX / 10 ||\r\n                ans  < INT_MIN / 10 ||\r\n                ans == INT_MAX && x % 10 >  7 ||\r\n                ans == INT_MIN && x % 10 < -8) {\r\n                \r\n            }\r\n            ans = 10 * ans + x % 10; \r\n            x /= 10; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution {\n/*FM*/int reverse(int x) {\r\n        int ans = 0; \r\n        while (x) {\r\n            if (ans  > INT_MAX / 10 ||\r\n                ans  < INT_MIN / 10 ||\r\n                ans == INT_MAX && x % 10 >  7 ||\r\n                ans == INT_MIN && x % 10 < -8) {\r\n                return 0; \r\n            }\r\n            ans = 10 * ans + x % 10; \r\n            x /= 10; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"2139266726\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        int ans = 0, sign = 0; \r\n        for (char ch : str) {\r\n            if (!sign && ch == ' ') {\r\n                \r\n            } else if (!sign && ch == '-') {\r\n                \r\n            } else if (!sign && ch == '+') {\r\n                \r\n            } else if (!sign && '0' <= ch && ch <= '9') {\r\n                \r\n                \r\n            } else if ('0' <= ch && ch <= '9') {\r\n                \r\n                if (sign < 0 && (INT_MIN + ch - '0') / 10 > ans) {\r\n                         \n                }\r\n                \r\n            } else {\r\n                break; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\r\n        if (x < 0 || x && !(x % 10)) \r\n        int y = 0; \r\n        while (x > y) {\r\n            y = 10 * y + x % 10; \r\n            x /= 10; \r\n        }\r\n        return x == y || x == y / 10; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\r\n        if (x < 0 || x && !(x % 10)) return false; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string intToRoman. /*FC*/class Solution {\n/*FM*/string intToRoman(int num) {\r\n        string ans; \r\n        while (num > 0) {\r\n            auto it = mapi2r.lower_bound(num); \r\n            num -= it->first; \r\n            ans += it->second; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int romanToInt. /*FC*/class Solution {\n/*FM*/int romanToInt(string s) {\r\n        int ans = 0, num = 0; \r\n        for (char r : s) {\r\n            ans += mapr2i[r] > num ? -num : num; \r\n            num  = mapr2i[r]; \r\n        }\r\n        return ans + num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution {\n/*FM*/string longestCommonPrefix(vector<string>& strs) {\r\n        if (strs.empty()) return \"\"; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution {\n/*FM*/string longestCommonPrefix(vector<string>& strs) {\r\n        if (strs.empty()) \r\n        string ans; \r\n        for (int j = 0;  j < strs[0].size();  ) {\r\n            for (int i = 1;  i < strs.size();  ) {\r\n                if (j >= strs[i].size() || strs[0][j] != strs[i][j]) {\r\n                    return ans; \r\n                }\r\n            }\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [2], \"strs_element0\": [\"1\"], \"strs_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestCommonPrefix. /*FC*/class Solution {\n/*FM*/string longestCommonPrefix(vector<string>& strs) {\r\n        if (strs.empty()) \r\n        string ans; \r\n        for (int j = 0;  j < strs[0].size();  j++) {\r\n            for (int i = 1;  i < strs.size();  ) {\r\n                \r\n            }\r\n            ans.push_back(strs[0][j]); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [1], \"strs_element0\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int>> threeSum(vector<int>& nums) {\r\n        vector<vector<int>> ans; \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 0;  i + 2 < nums.size();  i++) {\r\n            if (i > 0 && nums[i] == nums[i - 1]) \r\n            int l = i + 1, r = nums.size() - 1, t2sum = -nums[i]; \r\n            while (l < r) {\r\n                if (nums[l] + nums[r] < t2sum) {\r\n                    l++; \r\n                } else if (nums[l] + nums[r] > t2sum) {\r\n                    \r\n                } else {\r\n                    \r\n                    \r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1304828798\"], \"nums_element1\": [\"-1582188463\"], \"nums_element2\": [\"1360918153\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int>> threeSum(vector<int>& nums) {\r\n        vector<vector<int>> ans; \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 0;  i + 2 < nums.size();  ) {\r\n                 \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> letterCombinations. /*FC*/class Solution {\n/*FM*/vector<string> letterCombinations(string digits) {\r\n        if (digits.empty()) \r\n        vector<string> ans; \r\n        string cur(digits.size(), '*'); \r\n        backtrack(ans, cur, digits, 0); \r\n        return ans; \r\n    };/*F*//*C*//*M*/void backtrack(vector<string> &ans, string &cur, string &digits, int di) {\r\n        if (di >= digits.size()) {\r\n            ans.push_back(cur); \r\n            return; \r\n        }\r\n        for (char ch : m[digits[di]]) {\r\n            cur[di] = ch; \r\n            backtrack(ans, cur, digits, di + 1); \r\n        }\r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> letterCombinations. /*FC*/class Solution {\n/*FM*/vector<string> letterCombinations(string digits) {\r\n        if (digits.empty()) return {}; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> fourSum. /*FC*/class Solution {\n/*FM*/vector<vector<int>> fourSum(vector<int>& nums, int target) {\r\n        vector<vector<int>> ans; \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 0;  i + 3 < nums.size();  ) {\r\n                 \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"332110787\"], \"nums_element1\": [\"176840826\"], \"nums_element2\": [\"-1129738110\"], \"target\": [\"145216428\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        if (s.size() % 2) return false; \r\n        \r\n        for ( : s) {\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        if (s.size() % 2) \r\n        stack<char> left_stack; \r\n        for (char ch : s) {\r\n            \r\n        }\r\n        return left_stack.empty(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\r\n        ListNode fake(0), *last = &fake; \r\n        while (l1 && l2) {\r\n            \r\n            \r\n        }\r\n        last->next = l1 ? l1 : l2; \r\n        return fake.next; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l2\": [3], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"-1883370841\"], \"l2[0].val\": [\"1604221157\"], \"l2[0].next\": [1], \"l2[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_next0_x\": [\"1853541375\"], \"l2[0].next[0].val\": [\"-1917997800\"], \"l2[1]\": [\"ListNode\", \"ListNode(int)\"], \"l21_x\": [\"497890138\"], \"l2[1].val\": [\"-157048271\"], \"l2[1].next\": [1], \"l2[1].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"l21_next0_x\": [\"692268447\"], \"l2[1].next[0].val\": [\"-219197869\"], \"l2[2]\": [\"ListNode\", \"ListNode(int)\"], \"l22_x\": [\"242313416\"], \"l2[2].val\": [\"568020105\"], \"l2[2].next\": [1], \"l2[2].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"l22_next0_x\": [\"383501688\"], \"l2[2].next[0].val\": [\"1459283190\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\r\n        ListNode fake(0), *last = &fake; \r\n        while (l1 && l2) {\r\n            if (l1->val < l2->val) {\r\n                \r\n                \r\n            } else {\r\n                last->next = l2; \r\n                l2 = l2->next; \r\n            }\r\n            last = last->next; \r\n        }\r\n        last->next = l1 ? l1 : l2; \r\n        return fake.next; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l2\": [1], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"-1747287186\"], \"l2[0].val\": [\"-2129362966\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* mergeTwoLists. /*FC*/class Solution {\n/*FM*/ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\r\n        ListNode fake(0), *last = &fake; \r\n        while (l1 && l2) {\r\n            if (l1->val < l2->val) {\r\n                last->next = l1; \r\n                l1 = l1->next; \r\n            } else {\r\n                \r\n                \r\n            }\r\n            last = last->next; \r\n        }\r\n        last->next = l1 ? l1 : l2; \r\n        return fake.next; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"l1\": [1], \"l1[0]\": [\"ListNode\", \"ListNode(int)\"], \"l10_x\": [\"0\"], \"l1[0].val\": [\"0\"], \"l2\": [1], \"l2[0]\": [\"ListNode\", \"ListNode(int)\"], \"l20_x\": [\"0\"], \"l2[0].val\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* mergeKLists. /*FC*/class Solution {\n/*FM*/ListNode* mergeKLists(vector<ListNode*>& lists) {\r\n        vector<ListNode *> nodes; \r\n        for (ListNode *pi : lists) {\r\n            while (pi) {\r\n                nodes.push_back(pi); \r\n                pi = pi->next; \r\n            }\r\n        }\r\n        \r\n        sort(nodes.begin(), nodes.end(),\r\n            [] (ListNode *a, ListNode *b) { return a->val < b->val;  }); \r\n        \r\n        ListNode fake(0), *tail = &fake; \r\n        for (ListNode *pi : nodes) {\r\n            tail->next = pi; \r\n            tail = tail->next; \r\n        }\r\n        tail->next = NULL; \r\n        return fake.next; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"lists\": [2], \"lists_element0\": [1], \"lists_element0[0]\": [\"ListNode\", \"ListNode(int)\"], \"lists_element00_x\": [\"934254964\"], \"lists_element0[0].val\": [\"623133453\"], \"lists_element1\": [3], \"lists_element1[0]\": [\"ListNode\", \"ListNode(int)\"], \"lists_element10_x\": [\"-2102340548\"], \"lists_element1[0].val\": [\"-1490161057\"], \"lists_element1[1]\": [\"ListNode\", \"ListNode(int)\"], \"lists_element11_x\": [\"-1585287756\"], \"lists_element1[1].val\": [\"-531190257\"], \"lists_element1[2]\": [\"ListNode\", \"ListNode(int)\"], \"lists_element12_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* mergeKLists. /*FC*/class Solution {\n/*FM*/ListNode* mergeKLists(vector<ListNode*>& lists) {\r\n        vector<ListNode *> nodes; \r\n        for (ListNode *pi : lists) {\r\n            \r\n        }\r\n        \r\n        sort(nodes.begin(), nodes.end(),\r\n            [] (ListNode *a, ListNode *b) { return a->val < b->val;  }); \r\n        \r\n        ListNode fake(0), *tail = &fake; \r\n        for (ListNode *pi : nodes) {\r\n            \r\n            \r\n        }\r\n        tail->next = NULL; \r\n        return fake.next; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* swapPairs. /*FC*/class Solution {\n/*FM*/ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next) return head; \r\n        ListNode *pa = head->next; \r\n        head->next = swapPairs(pa->next); \r\n        pa->next = head; \r\n        return pa; \r\n    };/*F*//*C*//*M*/ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next) return head; \r\n        ListNode *pa = head->next; \r\n        head->next = swapPairs(pa->next); \r\n        pa->next = head; \r\n        return pa; \r\n    } ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next) return head; \r\n        ListNode *pa = head->next; \r\n        head->next = swapPairs(pa->next); \r\n        pa->next = head; \r\n        return pa; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-393001359\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"836412675\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* swapPairs. /*FC*/class Solution {\n/*FM*/ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next) return head; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next) return head; \r\n        ListNode *pa = head->next; \r\n        head->next = swapPairs(pa->next); \r\n        pa->next = head; \r\n        return pa; \r\n    } ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next) return head; \r\n        ListNode *pa = head->next; \r\n        head->next = swapPairs(pa->next); \r\n        pa->next = head; \r\n        return pa; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1889165146\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"664172213\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseKGroup. /*FC*/class Solution {\n/*FM*/ListNode* reverseKGroup(ListNode* head, int k) {\r\n        ListNode *pa = head; \r\n        for (int i = 0;  i < k;  i++) {\r\n            if (!pa) {\r\n                return head; \r\n            }\r\n            pa = pa->next; \r\n        }\r\n\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/ListNode* reverseKGroup(ListNode* head, int k) {\r\n        ListNode *pa = head; \r\n        for (int i = 0;  i < k;  i++) {\r\n            if (!pa) {\r\n                return head; \r\n            }\r\n            pa = pa->next; \r\n        }\r\n\r\n        ListNode *pb = reverseKGroup(pa, k); \r\n        while (head != pa) {\r\n            ListNode *pc = head->next; \r\n            head->next = pb; \r\n            pb = head; \r\n            head = pc; \r\n        }\r\n        return pb; \r\n    } ListNode* reverseKGroup(ListNode* head, int k) {\r\n        ListNode *pa = head; \r\n        for (int i = 0;  i < k;  i++) {\r\n            if (!pa) {\r\n                return head; \r\n            }\r\n            pa = pa->next; \r\n        }\r\n\r\n        ListNode *pb = reverseKGroup(pa, k); \r\n        while (head != pa) {\r\n            ListNode *pc = head->next; \r\n            head->next = pb; \r\n            pb = head; \r\n            head = pc; \r\n        }\r\n        return pb; \r\n    } ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"0\"], \"head[0].next\": [0], \"k\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int>& nums) {\r\n        int len = 0; \r\n        for (int n : nums) {\r\n            \r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [-2147483648]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int>& nums) {\r\n        int len = 0; \r\n        for (int n : nums) {\r\n            if (len == 0 || n != nums[len - 1]) {\r\n                nums[len++] = n; \r\n            }\r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"212431882\"], \"nums_element1\": [\"-1482264544\"], \"nums_element2\": [\"2085251445\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeElement. /*FC*/class Solution {\n/*FM*/int removeElement(vector<int>& nums, int val) {\r\n        int len = 0; \r\n        for (int n : nums) {\r\n            if (n != val) {\r\n                nums[len++] = n; \r\n            }\r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-1348495290\"], \"val\": [\"2065785862\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeElement. /*FC*/class Solution {\n/*FM*/int removeElement(vector<int>& nums, int val) {\r\n        int len = 0; \r\n        for (int n : nums) {\r\n            \r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"val\": [\"-2147483648\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strStr. /*FC*/class Solution {\n/*FM*/int strStr(string haystack, string needle) {\r\n        int size = haystack.size() - needle.size() + 1; \r\n        for (int i = 0, j;  i < size;  i++) {\r\n            for (j = 0;  j < needle.size();  ) {\r\n                if (haystack[i + j] != needle[j]) {\r\n                    break; \r\n                }\r\n            }\r\n            if (j == needle.size()) {\r\n                \r\n            }\r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [\"1\"], \"needle\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int strStr. /*FC*/class Solution {\n/*FM*/int strStr(string haystack, string needle) {\r\n        int size = haystack.size() - needle.size() + 1; \r\n        for (int i = 0, j;  i < size;  ) {\r\n            for (j = 0;  j < needle.size();  ) {\r\n                \r\n            }\r\n            if (j == needle.size()) {\r\n                return i; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"haystack\": [\"9\"], \"needle\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/class Solution {\n/*FM*/int searchInsert(vector<int>& nums, int target) {\r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (nums[i] >= target) {\r\n                return i; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1165874276\"], \"nums_element1\": [\"1678374503\"], \"nums_element2\": [\"-1374250361\"], \"target\": [\"-472154975\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/class Solution {\n/*FM*/int searchInsert(vector<int>& nums, int target) {\r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (nums[i] >= target) {\r\n                \r\n            }\r\n        }\r\n        return nums.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-424868387\"], \"target\": [\"1453578186\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValidSudoku. /*FC*/class Solution {\n/*FM*/bool isValidSudoku(vector<vector<char>>& board) {\r\n        vector<vector<bool>> row(9, vector<bool>(9)), col(row), grid(row); \r\n        for (int i = 0;  i < 9;  ) {\r\n            for (int j = 0;  j < 9;  j++) {\r\n                char ch = board[i][j]; \r\n                if (ch == '.') \r\n                if (row[i][ch - '1'] ||\r\n                    col[j][ch - '1'] ||\r\n                    grid[i / 3 + j / 3 * 3][ch - '1']) {\r\n                    return false; \r\n                }\r\n                row[i][ch - '1'] = true; \r\n                col[j][ch - '1'] = true; \r\n                grid[i / 3 + j / 3 * 3][ch - '1'] = true; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"board\": [1], \"board_element0\": [3], \"board_element0_element0\": [\"-79\"], \"board_element0_element1\": [\"-76\"], \"board_element0_element2\": [\"-111\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string countAndSay. /*FC*/class Solution {\n/*FM*/string countAndSay(int n) {\r\n        string seq = \"1\"; \r\n        for (int i = 1;  i < n;  i++) {\r\n            string new_seq; \r\n            for (int j = 0, count = 1;  j < seq.size();  j++, count++) {\r\n                if (j + 1 >= seq.size() || seq[j] != seq[j + 1]) {\r\n                    new_seq += count + '0'; \r\n                    new_seq += seq[j]; \r\n                    count = 0; \r\n                }\r\n            }\r\n            seq = new_seq; \r\n        }\r\n        return seq; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstMissingPositive. /*FC*/class Solution {\n/*FM*/int firstMissingPositive(vector<int>& nums) {\r\n        for (int &n : nums) {\r\n            while (0 < n && n <= nums.size() && n != nums[n - 1]) {\r\n                \r\n            }\r\n        }\r\n        for (int i = 0;  i < nums.size();  ) {\r\n            if (nums[i] != i + 1) {\r\n                return i + 1; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"680307131\"], \"nums_element1\": [\"-1768345556\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstMissingPositive. /*FC*/class Solution {\n/*FM*/int firstMissingPositive(vector<int>& nums) {\r\n        for (int &n : nums) {\r\n            \r\n        }\r\n        for (int i = 0;  i < nums.size();  ) {\r\n            \r\n        }\r\n        return nums.size() + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/class Solution {\n/*FM*/int jump(vector<int>& nums) {\r\n        int step = 0; \r\n        for (int i = 0, j = 0, k = 0;  i < nums.size() - 1;  i++) {\r\n            j = max(j, i + nums[i]); \r\n            if (i >= k) {\r\n                k = j; \r\n                step++; \r\n            }\r\n        }\r\n        return step; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-286609298\"], \"nums_element1\": [\"-1862299317\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution {\n/*FM*/void rotate(vector<vector<int>>& matrix) {\r\n        for (int i = 0;  i < matrix.size();  ) {           \n            \r\n                \n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void rotate. /*FC*/class Solution {\n/*FM*/void rotate(vector<vector<int>>& matrix) {\r\n        for (int i = 0;  i < matrix.size();  i++) {           \n            for (int j = i + 1;  j < matrix[0].size();  j++) {\r\n                swap(matrix[i][j], matrix[j][i]); \r\n            }\r\n            reverse(matrix[i].begin(), matrix[i].end());     \n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"836491711\"], \"matrix_element0_element1\": [\"113374280\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"-964132321\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<string>> groupAnagrams. /*FC*/class Solution {\n/*FM*/vector<vector<string>> groupAnagrams(vector<string>& strs) {\r\n        unordered_map<string, vector<string>> m; \r\n        for (string &str : strs) {\r\n            string k = str; \r\n            sort(k.begin(), k.end()); \r\n            m[k].push_back(str); \r\n        }\r\n        \r\n        vector<vector<string>> ans; \r\n        for (auto &[k, v] : m) {\r\n            ans.push_back(v); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"strs\": [3], \"strs_element0\": [\"3\"], \"strs_element1\": [\"1\"], \"strs_element2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double myPow. /*FC*/class Solution {\n/*FM*/double myPow(double x, int n) {\r\n        if (n == 0) return 1; \r\n        if (n  < 0) {\r\n            x = 1 / x; \r\n        }\r\n        double p = myPow(x, abs(n / 2)); \r\n        return n % 2 ? p * p * x : p * p; \r\n    };/*F*//*C*//*M*/double myPow(double x, int n) {\r\n        if (n == 0) return 1; \r\n        if (n  < 0) {\r\n            x = 1 / x; \r\n        }\r\n        double p = myPow(x, abs(n / 2)); \r\n        return n % 2 ? p * p * x : p * p; \r\n    } double myPow(double x, int n) {\r\n        if (n == 0) return 1; \r\n        if (n  < 0) {\r\n            x = 1 / x; \r\n        }\r\n        double p = myPow(x, abs(n / 2)); \r\n        return n % 2 ? p * p * x : p * p; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"0.74\"], \"n\": [\"-758745007\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxSubArray. /*FC*/class Solution {\n/*FM*/int maxSubArray(vector<int>& nums) {\r\n        int ans = nums.front(), dpn = ans;    \n        for (int i = 1;  i < nums.size();  i++) {\r\n            dpn = max(dpn + nums[i], nums[i]); \r\n            ans = max(ans, dpn); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1509594457\"], \"nums_element1\": [\"-1269283316\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> spiralOrder. /*FC*/class Solution {\n/*FM*/vector<int> spiralOrder(vector<vector<int>>& matrix) {\r\n        if (matrix.empty() || matrix[0].empty()) \r\n        int m = matrix.size(); \r\n        int n = matrix[0].size(); \r\n        \r\n        vector<int> ans(m * n); \r\n        for (int r = 0, ai = 0;  ai < m * n;  r++) {\r\n            for (int j = r;  j < n - r;  j++) {       \n                ans[ai++] = matrix[r][j]; \r\n            }\r\n            for (int i = r + 1;  i < m - r;  i++) {   \n                ans[ai++] = matrix[i][n - r - 1]; \r\n            }\r\n            if (ai >= m * n) {\r\n                return ans; \r\n            }\r\n            for (int j = n - r - 2;  j >= r;  j--) {  \n                ans[ai++] = matrix[m - r - 1][j]; \r\n            }\r\n            for (int i = m - r - 2;  i > r;  i--) {   \n                ans[ai++] = matrix[i][r]; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"646719291\"], \"matrix_element0_element1\": [\"493539169\"], \"matrix_element0_element2\": [\"-2115029915\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"1627814411\"], \"matrix_element2\": [3], \"matrix_element2_element0\": [\"-267229722\"], \"matrix_element2_element1\": [\"-703371795\"], \"matrix_element2_element2\": [\"566852313\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> spiralOrder. /*FC*/class Solution {\n/*FM*/vector<int> spiralOrder(vector<vector<int>>& matrix) {\r\n        if (matrix.empty() || matrix[0].empty()) return {}; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int>& nums) {\r\n        for (int i = 0, j = 0;  i <= j;  i++) {\r\n            j = max(j, i + nums[i]); \r\n            if (j >= nums.size() - 1) {\r\n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1929731578\"], \"nums_element1\": [\"-573284174\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(vector<int>& nums) {\r\n        for (int i = 0, j = 0;  i <= j;  ) {\r\n            j = max(j, i + nums[i]); \r\n            if (j >= nums.size() - 1) {\r\n                return true; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1054579718\"], \"nums_element1\": [\"-1907562762\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> merge. /*FC*/class Solution {\n/*FM*/vector<vector<int>> merge(vector<vector<int>>& intervals) {\r\n        sort(intervals.begin(), intervals.end()); \r\n        vector<vector<int>> ans; \r\n        for (vector<int> &itv : intervals) {\r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> merge. /*FC*/class Solution {\n/*FM*/vector<vector<int>> merge(vector<vector<int>>& intervals) {\r\n        sort(intervals.begin(), intervals.end()); \r\n        vector<vector<int>> ans; \r\n        for (vector<int> &itv : intervals) {\r\n            if (!ans.empty() && itv[0] <= ans.back()[1]) {\r\n                ans.back()[1] = max(ans.back()[1], itv[1]); \r\n            } else {\r\n                ans.push_back(itv); \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [2], \"intervals_element0_element0\": [\"749826593\"], \"intervals_element0_element1\": [\"2145321629\"], \"intervals_element1\": [2], \"intervals_element1_element0\": [\"-77481325\"], \"intervals_element1_element1\": [\"1204149375\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> merge. /*FC*/class Solution {\n/*FM*/vector<vector<int>> merge(vector<vector<int>>& intervals) {\r\n        sort(intervals.begin(), intervals.end()); \r\n        vector<vector<int>> ans; \r\n        for (vector<int> &itv : intervals) {\r\n            if (!ans.empty() && itv[0] <= ans.back()[1]) {\r\n                \r\n            } else {\r\n                ans.push_back(itv); \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"intervals\": [2], \"intervals_element0\": [3], \"intervals_element0_element0\": [\"288432743\"], \"intervals_element0_element1\": [\"-796496160\"], \"intervals_element0_element2\": [\"-1663906994\"], \"intervals_element1\": [2], \"intervals_element1_element0\": [\"-768565239\"], \"intervals_element1_element1\": [\"79181912\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(string s) {\r\n        int len = 0; \r\n        for (int i = s.size();  i >= 0;  i--) {\r\n            if (isalpha(s[i])) {\r\n                \r\n            } else if (len > 0) {\r\n                \r\n            }\r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> generateMatrix. /*FC*/class Solution {\n/*FM*/vector<vector<int>> generateMatrix(int n) {\r\n        vector<vector<int> > ans(n, vector<int>(n)); \r\n        for (int r = 0, count = 1;  count <= n * n;  r++) {\r\n            for (int j = r;  j < n - r;  j++) {       \n                ans[r][j] = count++; \r\n            }\r\n            for (int i = r + 1;  i < n - r;  i++) {   \n                ans[i][n - r - 1] = count++; \r\n            }\r\n            if (count > n * n) {\r\n                \r\n            }\r\n            for (int j = n - r - 2;  j >= r;  j--) {  \n                ans[n - r - 1][j] = count++; \r\n            }\r\n            for (int i = n - r - 2;  i > r;  i--) {   \n                ans[i][r] = count++; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> generateMatrix. /*FC*/class Solution {\n/*FM*/vector<vector<int>> generateMatrix(int n) {\r\n        vector<vector<int> > ans(n, vector<int>(n)); \r\n        for (int r = 0, count = 1;  count <= n * n;  r++) {\r\n            for (int j = r;  j < n - r;  j++) {       \n                ans[r][j] = count++; \r\n            }\r\n            for (int i = r + 1;  i < n - r;  i++) {   \n                ans[i][n - r - 1] = count++; \r\n            }\r\n            if (count > n * n) {\r\n                return ans; \r\n            }\r\n            for (int j = n - r - 2;  j >= r;  j--) {  \n                ans[n - r - 1][j] = count++; \r\n            }\r\n            for (int i = n - r - 2;  i > r;  i--) {   \n                ans[i][r] = count++; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* rotateRight. /*FC*/class Solution {\n/*FM*/ListNode* rotateRight(ListNode* head, int k) {\r\n        if (!head) \r\n        \r\n        int size = 1; \r\n        ListNode *pi = head; \r\n        while (pi->next) {\r\n            \r\n            \r\n        }\r\n        pi->next = head; \r\n        \r\n        for (int i = 0;  i < (size - (k % size)) % size;  ) {\r\n            \r\n        }\r\n        head = pi->next; \r\n        pi->next = NULL; \r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1161795089\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"1999413372\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"0\"], \"k\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* rotateRight. /*FC*/class Solution {\n/*FM*/ListNode* rotateRight(ListNode* head, int k) {\r\n        if (!head) return NULL; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniquePaths. /*FC*/class Solution {\n/*FM*/int uniquePaths(int m, int n) {\r\n        vector<int> dp(n, 1); \r\n        for (int i = 1;  i < m;  i++) {\r\n            for (int j = 1;  j < n;  ) {\r\n                \r\n            }\r\n        }\r\n        return dp[n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"7\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniquePaths. /*FC*/class Solution {\n/*FM*/int uniquePaths(int m, int n) {\r\n        vector<int> dp(n, 1); \r\n        for (int i = 1;  i < m;  i++) {\r\n            for (int j = 1;  j < n;  j++) {\r\n                dp[j] += dp[j - 1]; \r\n            }\r\n        }\r\n        return dp[n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"2\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniquePathsWithObstacles. /*FC*/class Solution {\n/*FM*/int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\r\n        vector<long> dp(obstacleGrid[0].size()); \r\n        dp[0] = 1; \r\n        for (vector<int> &og : obstacleGrid) {\r\n            for (int j = 0;  j < obstacleGrid[0].size();  j++) {\r\n                if (og[j] == 1) {\r\n                    \r\n                } else if (j > 0) {\r\n                    dp[j] += dp[j - 1]; \r\n                }\r\n            }\r\n        }\r\n        return dp.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"obstacleGrid\": [3], \"obstacleGrid_element0\": [2], \"obstacleGrid_element0_element0\": [\"-945689498\"], \"obstacleGrid_element0_element1\": [\"1370942268\"], \"obstacleGrid_element1\": [3], \"obstacleGrid_element1_element0\": [\"603543019\"], \"obstacleGrid_element1_element1\": [\"174899290\"], \"obstacleGrid_element1_element2\": [\"-1579580220\"], \"obstacleGrid_element2\": [3], \"obstacleGrid_element2_element0\": [\"1912642762\"], \"obstacleGrid_element2_element1\": [\"1072959851\"], \"obstacleGrid_element2_element2\": [\"-1368153449\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPathSum. /*FC*/class Solution {\n/*FM*/int minPathSum(vector<vector<int>>& grid) {\r\n        for (int i = 0;  i < grid.size();  ) {\r\n            \r\n        }\r\n        return grid.back().back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPathSum. /*FC*/class Solution {\n/*FM*/int minPathSum(vector<vector<int>>& grid) {\r\n        for (int i = 0;  i < grid.size();  i++) {\r\n            for (int j = 0;  j < grid[0].size();  j++) {\r\n                if (i > 0 && j > 0) {\r\n                    grid[i][j] += min(grid[i][j - 1], grid[i - 1][j]); \r\n                } else if (i > 0) {\r\n                    grid[i][j] += grid[i - 1][j]; \r\n                } else if (j > 0) {\r\n                    grid[i][j] += grid[i][j - 1]; \r\n                }\r\n            }\r\n        }\r\n        return grid.back().back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [3], \"grid_element0_element0\": [\"1306275369\"], \"grid_element0_element1\": [\"1402612941\"], \"grid_element0_element2\": [\"220044183\"], \"grid_element1\": [3], \"grid_element1_element0\": [\"-1719464121\"], \"grid_element1_element1\": [\"-578498377\"], \"grid_element1_element2\": [\"1457235120\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(string s) {\r\n        int state = 0; \r\n        for (int i = 0;  state != -1 && i < s.size();  i++) {\r\n            switch (s[i]) {\r\n            \r\n                \r\n                \r\n            case '+':\r\n            \r\n                state = trans[state][1]; \r\n                break; \r\n            \r\n                \r\n                \r\n            \r\n                \r\n                \r\n            \r\n                \r\n            }\r\n        }\r\n        return state >= 5; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(string s) {\r\n        int state = 0; \r\n        for (int i = 0;  state != -1 && i < s.size();  i++) {\r\n            switch (s[i]) {\r\n            \r\n                \r\n                \r\n            \r\n            \r\n                \r\n                \r\n            case '.':\r\n                state = trans[state][2]; \r\n                break; \r\n            \r\n                \r\n                \r\n            \r\n                \r\n            }\r\n        }\r\n        return state >= 5; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(string s) {\r\n        int state = 0; \r\n        for (int i = 0;  state != -1 && i < s.size();  i++) {\r\n            switch (s[i]) {\r\n            \r\n                \r\n                \r\n            \r\n            case '-':\r\n                state = trans[state][1]; \r\n                break; \r\n            \r\n                \r\n                \r\n            \r\n                \r\n                \r\n            \r\n                \r\n            }\r\n        }\r\n        return state >= 5; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(string s) {\r\n        int state = 0; \r\n        for (int i = 0;  state != -1 && i < s.size();  i++) {\r\n            switch (s[i]) {\r\n            \r\n                \r\n                \r\n            \r\n            \r\n                \r\n                \r\n            \r\n                \r\n                \r\n            \r\n                \r\n                \r\n            default:\r\n                state = isdigit(s[i]) ? trans[state][4] : -1; \r\n            }\r\n        }\r\n        return state >= 5; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int>& digits) {\r\n        int carry = 1; \r\n        for (int i = digits.size() - 1;  carry && i >= 0;  i--) {\r\n            digits[i] += carry; \r\n            carry = digits[i] / 10; \r\n            digits[i] %= 10; \r\n        }\r\n        if (carry > 0) {\r\n            digits.insert(digits.begin(), carry); \r\n        }\r\n        return digits; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [3], \"digits_element0\": [\"1825206596\"], \"digits_element1\": [\"1807522894\"], \"digits_element2\": [\"952811455\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int>& digits) {\r\n        int carry = 1; \r\n        for (int i = digits.size() - 1;  carry && i >= 0;  i--) {\r\n            digits[i] += carry; \r\n            carry = digits[i] / 10; \r\n            digits[i] %= 10; \r\n        }\r\n        if (carry > 0) {\r\n            \r\n        }\r\n        return digits; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [3], \"digits_element0\": [\"-1985724865\"], \"digits_element1\": [\"1615435755\"], \"digits_element2\": [\"-1921573663\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int>& digits) {\r\n        int carry = 1; \r\n        for (int i = digits.size() - 1;  carry && i >= 0;  ) {\r\n            \r\n            \r\n            \r\n        }\r\n        if (carry > 0) {\r\n            digits.insert(digits.begin(), carry); \r\n        }\r\n        return digits; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\r\n        int carry = 0, as = a.size(), bs = b.size(); \r\n        string sum(max(as, bs), 0); \r\n        for (int i = 0, ss = sum.size();  i < ss;  ) {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        if (carry > 0) {\r\n            \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\r\n        int carry = 0, as = a.size(), bs = b.size(); \r\n        string sum(max(as, bs), 0); \r\n        for (int i = 0, ss = sum.size();  i < ss;  i++) {\r\n            sum[ss - i - 1] += i < as ? a[as - i - 1] - '0' : 0; \r\n            sum[ss - i - 1] += i < bs ? b[bs - i - 1] - '0' : 0; \r\n            sum[ss - i - 1] += carry; \r\n            carry = sum[ss - i - 1] / 2; \r\n            sum[ss - i - 1] = sum[ss - i - 1] % 2 + '0'; \r\n        }\r\n        if (carry > 0) {\r\n            \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"1\"], \"b\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addBinary. /*FC*/class Solution {\n/*FM*/string addBinary(string a, string b) {\r\n        int carry = 0, as = a.size(), bs = b.size(); \r\n        string sum(max(as, bs), 0); \r\n        for (int i = 0, ss = sum.size();  i < ss;  i++) {\r\n            sum[ss - i - 1] += i < as ? a[as - i - 1] - '0' : 0; \r\n            sum[ss - i - 1] += i < bs ? b[bs - i - 1] - '0' : 0; \r\n            sum[ss - i - 1] += carry; \r\n            carry = sum[ss - i - 1] / 2; \r\n            sum[ss - i - 1] = sum[ss - i - 1] % 2 + '0'; \r\n        }\r\n        if (carry > 0) {\r\n            sum = to_string(carry) + sum; \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"1\"], \"b\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> fullJustify. /*FC*/class Solution {\n/*FM*/vector<string> fullJustify(vector<string>& words, int maxWidth) {\r\n        vector<string> ans; \r\n        int begin = 0, width = 0; \r\n        for (int i = 0;  i < words.size();  i++) {\r\n            if (width + words[i].size() + i - begin - 1 >= maxWidth) {\r\n                \r\n                \r\n                \r\n                \r\n            }\r\n            width += words[i].size(); \r\n        }\r\n        ans.push_back(\"\"); \r\n        for (int i = begin;  i < words.size() - 1;  i++) {\r\n            ans.back() += words[i]; \r\n            ans.back() += \" \"; \r\n        }\r\n        ans.back() += words.back(); \r\n        ans.back() += string(maxWidth - ans.back().size(), ' '); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [3], \"words_element0\": [\"3\"], \"words_element1\": [\"1\"], \"words_element2\": [\"1\"], \"maxWidth\": [\"1266702505\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mySqrt. /*FC*/class Solution {\n/*FM*/int mySqrt(int x) {\r\n        int lo = 1, hi = min(x, 46340);  \n        while (lo <= hi) {\r\n            int mid = (lo + hi) / 2; \r\n            if (mid * mid <= x) {\r\n                lo = mid + 1; \r\n            } else {\r\n                hi = mid - 1; \r\n            }\r\n        }\r\n        return hi; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"702642901\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int climbStairs. /*FC*/class Solution {\n/*FM*/int climbStairs(int n) {\r\n        vector<int> dp = {1, 1}; \r\n        for (int i = 2;  i <= n;  i++) {\r\n            dp[i % 2] = dp[0] + dp[1]; \r\n        }\r\n        return dp[n % 2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        vector<string> v; \r\n        istringstream iss(path); \r\n        string buf; \r\n        while (getline(iss, buf, '/')) {\r\n            if (!buf.empty() && buf != \".\" && buf != \"..\") {\r\n                v.push_back(buf); \r\n            } else if (!v.empty() && buf == \"..\") {\r\n                \r\n            }\r\n        }\r\n        if (v.empty()) {\r\n            \r\n        }\r\n\r\n        buf.clear(); \r\n        for (string &s : v) {\r\n            buf += \"/\"; \r\n            buf += s; \r\n        }\r\n        return buf; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"path\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        vector<string> v; \r\n        istringstream iss(path); \r\n        string buf; \r\n        while (getline(iss, buf, '/')) {\r\n            \r\n        }\r\n        if (v.empty()) {\r\n            return \"/\"; \r\n        }\r\n\r\n        \r\n        for ( : v) {\r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void setZeroes. /*FC*/class Solution {\n/*FM*/void setZeroes(vector<vector<int>>& matrix) {\r\n        int m = matrix.size(); \r\n        int n = matrix[0].size(); \r\n        \r\n        bool col0 = false; \r\n        for (int i = 0;  i < m;  i++) {\r\n            if (matrix[i][0] == 0) {\r\n                \r\n            }\r\n        }\r\n        \r\n        bool row0 = false; \r\n        for (int j = 0;  j < n;  j++) {\r\n            if (matrix[0][j] == 0) {\r\n                \r\n            }\r\n        }\r\n        \r\n        for (int i = 1;  i < m;  i++) {\r\n            for (int j = 1;  j < n;  j++) {\r\n                if (matrix[i][j] == 0) {\r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        \r\n        for (int i = 1;  i < m;  i++) {\r\n            if (matrix[i][0] == 0) {\r\n                \r\n            }\r\n        }\r\n        \r\n        for (int j = 1;  j < n;  j++) {\r\n            if (matrix[0][j] == 0) {\r\n                \r\n            }\r\n        }\r\n        \r\n        if (col0) {\r\n            \r\n        }\r\n\r\n        if (row0) {\r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"-1110941296\"], \"matrix_element0_element1\": [\"-2036350761\"], \"matrix_element0_element2\": [\"-1648899326\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"-7836877\"], \"matrix_element1_element1\": [\"-155604219\"], \"matrix_element1_element2\": [\"-1509166810\"], \"matrix_element2\": [2], \"matrix_element2_element0\": [\"1306047999\"], \"matrix_element2_element1\": [\"-1584493877\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>>& matrix, int target) {\r\n        if (matrix.empty() || matrix[0].empty()) return false; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>>& matrix, int target) {\r\n        if (matrix.empty() || matrix[0].empty()) \r\n        int m = matrix.size(); \r\n        int n = matrix[0].size(); \r\n        \r\n        int lo = 0, hi = m * n - 1; \r\n        while (lo <= hi) {\r\n            int mid = lo + (hi - lo) / 2; \r\n            if (matrix[mid / n][mid % n] < target) {\r\n                lo = mid + 1; \r\n            } else if (matrix[mid / n][mid % n] > target) {\r\n                hi = mid - 1; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-355842006\"], \"matrix_element0_element1\": [\"2099468352\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"-1003388291\"], \"matrix_element2\": [3], \"matrix_element2_element0\": [\"840909359\"], \"matrix_element2_element1\": [\"-1916474649\"], \"matrix_element2_element2\": [\"-1010813436\"], \"target\": [\"491173672\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int>& nums) {\r\n        int len = 0; \r\n        for (int n : nums) {\r\n            if (len < 2 || n != nums[len - 2]) {\r\n                nums[len++] = n; \r\n            }\r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1469523418\"], \"nums_element1\": [\"-82885644\"], \"nums_element2\": [\"-2099885608\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode* deleteDuplicates(ListNode* head) {\r\n        ListNode fake(0); \r\n        fake.next = head; \r\n        \r\n        ListNode *pi = &fake; \r\n        while (pi->next && pi->next->next) {\r\n            \r\n        }\r\n        return fake.next; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode* deleteDuplicates(ListNode* head) {\r\n        ListNode *pi = head; \r\n        while (pi && pi->next) {\r\n            if (pi->val == pi->next->val) {\r\n                \r\n                \r\n                \r\n            } else {\r\n                pi = pi->next; \r\n            }\r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"0\"], \"head[0].val\": [\"1\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"0\"], \"head[0].next[0].val\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode* deleteDuplicates(ListNode* head) {\r\n        ListNode *pi = head; \r\n        while (pi && pi->next) {\r\n            if (pi->val == pi->next->val) {\r\n                ListNode *del = pi->next; \r\n                pi->next = pi->next->next; \r\n                delete del; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"0\"], \"head[0].val\": [\"0\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"0\"], \"head[0].next[0].val\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode* deleteDuplicates(ListNode* head) {\r\n        ListNode *pi = head; \r\n        while (pi && pi->next) {\r\n            \r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void merge. /*FC*/class Solution {\n/*FM*/void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n        int i = m - 1, j = n - 1, k = m + n - 1; \r\n        while (i >= 0 && j >= 0) {\r\n            nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--]; \r\n        }\r\n        while (j >= 0) {\r\n            nums1[k--] = nums2[j--]; \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [1], \"nums1_element0\": [\"346298070\"], \"m\": [\"5\"], \"nums2\": [3], \"nums2_element0\": [\"-938647645\"], \"nums2_element1\": [\"-2097058193\"], \"nums2_element2\": [\"-1427780948\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void merge. /*FC*/class Solution {\n/*FM*/void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n        int i = m - 1, j = n - 1, k = m + n - 1; \r\n        while (i >= 0 && j >= 0) {\r\n            \r\n        }\r\n        while (j >= 0) {\r\n            \r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"1\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSameTree. /*FC*/class Solution {\n/*FM*/bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (!p) return !q; \r\n        if (!q) \r\n        \r\n    };/*F*//*C*//*M*/bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (!p) return !q; \r\n        if (!q) return !p; \r\n        return  p->val == q->val &&\r\n            isSameTree(p->left, q->left) &&\r\n            isSameTree(p->right, q->right); \r\n    } bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (!p) return !q; \r\n        if (!q) return !p; \r\n        return  p->val == q->val &&\r\n            isSameTree(p->left, q->left) &&\r\n            isSameTree(p->right, q->right); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSymmetric. /*FC*/class Solution {\n/*FM*/bool isSymmetric(TreeNode* root) {\r\n        if (!root) \r\n        return dfs(root->left, root->right); \r\n    };/*F*//*C*//*M*/bool dfs(TreeNode *p, TreeNode *q) {\r\n        if (!p && !q) return true; \r\n        if (!p || !q) return false; \r\n        return p->val == q->val &&\r\n            dfs(p->left, q->right) &&\r\n            dfs(p->right, q->left); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-69824501\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1290153300\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-712885599\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"739078098\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSymmetric. /*FC*/class Solution {\n/*FM*/bool isSymmetric(TreeNode* root) {\r\n        if (!root) return true; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> levelOrder(TreeNode* root) {\r\n        if (!root) return {}; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> levelOrder(TreeNode* root) {\r\n        if (!root) \r\n        vector<vector<int>> ans; \r\n        \r\n        queue<TreeNode *> q; \r\n        q.push(root); \r\n        \r\n        while (!q.empty()) {\r\n            ans.emplace_back(q.size()); \r\n            for (int &val : ans.back()) {\r\n                TreeNode *front = q.front(); \r\n                q.pop(); \r\n                val = front->val; \r\n                if (front->left) {\r\n                    \r\n                }\r\n                if (front->right) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1118216724\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1222234626\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> zigzagLevelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\r\n        if (!root) \r\n        vector<vector<int>> ans; \r\n        \r\n        queue<TreeNode *> q; \r\n        q.push(root); \r\n        \r\n        while (!q.empty()) {\r\n            ans.emplace_back(q.size()); \r\n            for (int i = 0, n = q.size();  i < n;  i++) {\r\n                TreeNode *front = q.front(); \r\n                q.pop(); \r\n                ans.back()[ans.size() % 2 ? i : n - i - 1] = front->val; \r\n                if (front->left) {\r\n                    \r\n                }\r\n                if (front->right) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"1530553073\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-989860863\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> zigzagLevelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\r\n        if (!root) return {}; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(TreeNode* root) {\r\n        if (!root) return 0; \r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1; \r\n    };/*F*//*C*//*M*/int maxDepth(TreeNode* root) {\r\n        if (!root) return 0; \r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1; \r\n    } int maxDepth(TreeNode* root) {\r\n        if (!root) return 0; \r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1749522180\"], \"root[0].right\": [3], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-898701052\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"0\"], \"root[0].right[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right2_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<TreeNode*> generateTrees. /*FC*/class Solution {\n/*FM*/vector<TreeNode*> generateTrees(int n) {\r\n        if (n == 0) return {}; \r\n        \r\n    };/*F*//*C*//*M*/vector<TreeNode *> generate(int begin, int end) {\r\n        if (begin >= end) return {NULL}; \r\n        vector<TreeNode *> ans; \r\n        for (int i = begin;  i < end;  i++) {\r\n            vector<TreeNode *> vl = generate(begin, i); \r\n            vector<TreeNode *> vr = generate(i + 1, end); \r\n            for (TreeNode *l : vl) {\r\n                for (TreeNode *r : vr) {\r\n                    ans.push_back(new TreeNode(i)); \r\n                    ans.back()->left  = l; \r\n                    ans.back()->right = r; \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<TreeNode*> generateTrees. /*FC*/class Solution {\n/*FM*/vector<TreeNode*> generateTrees(int n) {\r\n        if (n == 0) \r\n        return generate(1, n + 1); \r\n    };/*F*//*C*//*M*/vector<TreeNode *> generate(int begin, int end) {\r\n        if (begin >= end) return {NULL}; \r\n        vector<TreeNode *> ans; \r\n        for (int i = begin;  i < end;  i++) {\r\n            vector<TreeNode *> vl = generate(begin, i); \r\n            vector<TreeNode *> vr = generate(i + 1, end); \r\n            for (TreeNode *l : vl) {\r\n                for (TreeNode *r : vr) {\r\n                    ans.push_back(new TreeNode(i)); \r\n                    ans.back()->left  = l; \r\n                    ans.back()->right = r; \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"222070413\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int>& nums) {\r\n        vector<int> dp(2); \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            dp[i % 2] = max(dp[i % 2] + nums[i], dp[(i + 1) % 2]); \r\n        }\r\n        return dp[(nums.size() + 1) % 2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-288\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numIslands. /*FC*/class Solution {\n/*FM*/int numIslands(vector<vector<char>>& grid) {\r\n        int num = 0; \r\n        for (int i = 0;  i < grid.size();  i++) {\r\n            for (int j = 0;  j < grid[0].size();  j++) {\r\n                if (grid[i][j] == '1') {\r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        return num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [1], \"grid_element0_element0\": [\"120\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"-109\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isHappy. /*FC*/class Solution {\n/*FM*/bool isHappy(int n) {\r\n        unordered_set<int> s; \r\n        while (n > 1) {\r\n            s.insert(n); \r\n            \r\n            int new_n = 0; \r\n            while (n) {\r\n                new_n += pow(n % 10, 2); \r\n                n /= 10; \r\n            }\r\n            \r\n            if (s.find(new_n) != s.end()) {\r\n                return false; \r\n            }\r\n            n = new_n; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isHappy. /*FC*/class Solution {\n/*FM*/bool isHappy(int n) {\r\n        unordered_set<int> s; \r\n        while (n > 1) {\r\n            s.insert(n); \r\n            \r\n            int new_n = 0; \r\n            while (n) {\r\n                new_n += pow(n % 10, 2); \r\n                n /= 10; \r\n            }\r\n            \r\n            if (s.find(new_n) != s.end()) {\r\n                \r\n            }\r\n            n = new_n; \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* removeElements. /*FC*/class Solution {\n/*FM*/ListNode* removeElements(ListNode* head, int val) {\r\n        ListNode fake(0); \r\n        fake.next = head; \r\n        \r\n        ListNode *pi = &fake; \r\n        while (pi->next) {\r\n            if (pi->next->val == val) {\r\n                \r\n                \r\n                \r\n            } else {\r\n                pi = pi->next; \r\n            }\r\n        }\r\n        return fake.next; \r\n    };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"717\"], \"head[0].val\": [\"2025017127\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"946\"], \"head[1].val\": [\"29719805\"], \"val\": [\"62604979\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countPrimes. /*FC*/class Solution {\n/*FM*/int countPrimes(int n) {\r\n        int cnt = 0; \r\n        vector<bool> prime(n, true); \r\n        for (int i = 2;  i < n;  i++) {\r\n            if (prime[i]) {\r\n                for (int j = 2 * i;  j < n;  j += i) {\r\n                    prime[j] = false; \r\n                }\r\n                cnt++; \r\n            }\r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isIsomorphic. /*FC*/class Solution {\n/*FM*/bool isIsomorphic(string s, string t) {\r\n        vector<int> sm(CHAR_MAX, -1), tm(CHAR_MAX, -1); \r\n        for (int i = 0;  i < s.size();  i++) {\r\n            if (sm[s[i]] != tm[t[i]]) {\r\n                \r\n            }\r\n            sm[s[i]] = i; \r\n            tm[t[i]] = i; \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isIsomorphic. /*FC*/class Solution {\n/*FM*/bool isIsomorphic(string s, string t) {\r\n        vector<int> sm(CHAR_MAX, -1), tm(CHAR_MAX, -1); \r\n        for (int i = 0;  i < s.size();  ) {\r\n            if (sm[s[i]] != tm[t[i]]) {\r\n                return false; \r\n            }\r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* reverseList. /*FC*/class Solution {\n/*FM*/ListNode* reverseList(ListNode* head) {\r\n        ListNode *pa = NULL; \r\n        while (head) {\r\n            ListNode *pb = head->next; \r\n            head->next = pa; \r\n            pa = head; \r\n            head = pb; \r\n        }\r\n        return pa; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"848\"], \"head[0].next\": [1], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"575\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-363\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPeakElement. /*FC*/class Solution {\n/*FM*/int findPeakElement(vector<int>& nums) {\r\n        int lo = 0, hi = nums.size() - 1; \r\n        while (lo < hi) {\r\n            int mid = (lo + hi) / 2; \r\n            if (nums[mid] < nums[mid + 1]) {\r\n                \r\n            } else {\r\n                hi = mid; \r\n            }\r\n        }\r\n        return lo; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"937\"], \"nums_element1\": [\"-244\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findPeakElement. /*FC*/class Solution {\n/*FM*/int findPeakElement(vector<int>& nums) {\r\n        int lo = 0, hi = nums.size() - 1; \r\n        while (lo < hi) {\r\n            int mid = (lo + hi) / 2; \r\n            if (nums[mid] < nums[mid + 1]) {\r\n                lo = mid + 1; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return lo; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-873\"], \"nums_element1\": [\"227\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int majorityElement. /*FC*/class Solution {\n/*FM*/int majorityElement(vector<int>& nums) {\r\n        unordered_map<int, int> m; \r\n        for (int n : nums) {\r\n            if (++m[n] > nums.size() / 2) {\r\n                return n; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-531\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int trailingZeroes. /*FC*/class Solution {\n/*FM*/int trailingZeroes(int n) {\r\n        int ans = 0; \r\n        while (n) {\r\n            ans += n / 5; \r\n            n /= 5; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-55\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string largestNumber. /*FC*/class Solution {\n/*FM*/string largestNumber(vector<int>& nums) {\r\n        vector<string> v(nums.size()); \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            v[i] = to_string(nums[i]); \r\n        }\r\n        \r\n        sort(v.begin(), v.end(),\r\n             [] (string &a, string &b) { return a + b > b + a;  }); \r\n        \r\n        if (v[0] == \"0\") {\r\n            \r\n        }\r\n        \r\n        string ans; \r\n        for (string &s : v) {\r\n            ans += s; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-451\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string largestNumber. /*FC*/class Solution {\n/*FM*/string largestNumber(vector<int>& nums) {\r\n        vector<string> v(nums.size()); \r\n        for (int i = 0;  i < nums.size();  ) {\r\n            \r\n        }\r\n        \r\n        sort(v.begin(), v.end(),\r\n             [] (string &a, string &b) { return a + b > b + a;  }); \r\n        \r\n        if (v[0] == \"0\") {\r\n            \r\n        }\r\n        \r\n        \r\n        for ( : v) {\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method uint32_t reverseBits. /*FC*/class Solution {\n/*FM*/uint32_t reverseBits(uint32_t n) {\r\n        uint32_t ans = 0; \r\n        for (int i = 0;  i < 8 * sizeof(uint32_t);  i++) {\r\n            ans = (ans << 1) + ((n >> i) & 1); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2554088869\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hammingWeight. /*FC*/class Solution {\n/*FM*/int hammingWeight(uint32_t n) {\r\n        int cnt = 0; \r\n        while (n) {\r\n            n &= n - 1; \r\n            cnt++; \r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1974035950\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSubArrayLen. /*FC*/class Solution {\n/*FM*/int minSubArrayLen(int s, vector<int>& nums) {\r\n        vector<int> sum(nums.size() + 1); \r\n        for (int i = 1;  i < sum.size();  i++) {\r\n            sum[i] = sum[i - 1] + nums[i - 1]; \r\n        }\r\n        if (sum.back() <  s) \r\n        if (sum.back() == s) \r\n        \r\n        int min_len = nums.size() + 1; \r\n        for (int i = 0;  i < sum.size() - 1;  i++) {\r\n            int end = min(i + min_len, (int)sum.size()); \r\n            for (int j = i + 1;  j < end;  ) {\r\n                if (sum[j] - sum[i] >= s) {\r\n                    min_len = j - i; \r\n                    break; \r\n                }\r\n            }\r\n        }\r\n        return min_len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"332\"], \"nums\": [1], \"nums_element0\": [\"846\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minSubArrayLen. /*FC*/class Solution {\n/*FM*/int minSubArrayLen(int s, vector<int>& nums) {\r\n        vector<int> sum(nums.size() + 1); \r\n        for (int i = 1;  i < sum.size();  i++) {\r\n            sum[i] = sum[i - 1] + nums[i - 1]; \r\n        }\r\n        if (sum.back() <  s) return 0; \r\n        if (sum.back() == s) \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"680\"], \"nums\": [1], \"nums_element0\": [\"91\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int>& nums) {\r\n        int ns = nums.size(); \r\n        if (ns == 0) \r\n        if (ns == 1) \r\n        \r\n        vector<int> dp1(2), dp2(2); \r\n        for (int i = 0;  i < ns - 1;  i++) {\r\n            dp1[i % 2] = max(dp1[i % 2] + nums[i], dp1[(i + 1) % 2]); \r\n            dp2[i % 2] = max(dp2[i % 2] + nums[i + 1], dp2[(i + 1) % 2]); \r\n        }\r\n        return max(dp1[ns % 2], dp2[ns % 2]); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"730182430\"], \"nums_element1\": [\"-64294896\"], \"nums_element2\": [\"-889770241\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int>& nums) {\r\n        int ns = nums.size(); \r\n        if (ns == 0) \r\n        if (ns == 1) return nums[0]; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-404696159\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rob. /*FC*/class Solution {\n/*FM*/int rob(vector<int>& nums) {\r\n        int ns = nums.size(); \r\n        if (ns == 0) return 0; \r\n        if (ns == 1) \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findKthLargest. /*FC*/class Solution {\n/*FM*/int findKthLargest(vector<int>& nums, int k) {\r\n        priority_queue<int> q; \r\n        for (int n : nums) {\r\n            q.push(n); \r\n        }\r\n        for (int i = 0;  i < k - 1;  i++) {\r\n            q.pop(); \r\n        }\r\n        return q.top(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-908270874\"], \"nums_element1\": [\"1244781162\"], \"nums_element2\": [\"1096233375\"], \"k\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findKthLargest. /*FC*/class Solution {\n/*FM*/int findKthLargest(vector<int>& nums, int k) {\r\n        priority_queue<int> q; \r\n        for (int n : nums) {\r\n            \r\n        }\r\n        for (int i = 0;  i < k - 1;  i++) {\r\n            q.pop(); \r\n        }\r\n        return q.top(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsDuplicate. /*FC*/class Solution {\n/*FM*/bool containsDuplicate(vector<int>& nums) {\r\n        unordered_set<int> s; \r\n        for (int num : nums) {\r\n            if (s.find(num) != s.end()) {\r\n                \r\n            }\r\n            s.insert(num); \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"853989680\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyDuplicate(vector<int>& nums, int k) {\r\n        unordered_set<int> s; \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (i > k) {\r\n                \r\n            }\r\n            if (s.find(nums[i]) != s.end()) {\r\n                \r\n            }\r\n            s.insert(nums[i]); \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1617910109\"], \"k\": [\"298793989\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyAlmostDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\r\n        set<long> s; \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (i > k) {\r\n                \r\n            }\r\n            auto it = s.lower_bound((long)nums[i] - t); \r\n            if (it != s.end() && *it - nums[i] <= t) {\r\n                \r\n            }\r\n            s.insert(nums[i]); \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"-341321117\"], \"k\": [\"635742645\"], \"t\": [\"-1765718090\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool containsNearbyAlmostDuplicate. /*FC*/class Solution {\n/*FM*/bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\r\n        set<long> s; \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (i > k) {\r\n                \r\n            }\r\n            auto it = s.lower_bound((long)nums[i] - t); \r\n            if (it != s.end() && *it - nums[i] <= t) {\r\n                return true; \r\n            }\r\n            s.insert(nums[i]); \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1898864364\"], \"nums_element1\": [\"1808383322\"], \"nums_element2\": [\"-558590906\"], \"k\": [\"52774692\"], \"t\": [\"-1259668961\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalSquare. /*FC*/class Solution {\n/*FM*/int maximalSquare(vector<vector<char>>& matrix) {\r\n        if (matrix.empty() || matrix[0].empty()) \r\n        int m = matrix.size(); \r\n        int n = matrix[0].size(); \r\n        \r\n        int max_side = 0; \r\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1)); \r\n        for (int i = 1;  i <= m;  i++) {\r\n            for (int j = 1;  j <= n;  j++) {\r\n                if (matrix[i - 1][j - 1] == '1') {\r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        return max_side * max_side; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-39\"], \"matrix_element0_element1\": [\"-75\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"51\"], \"matrix_element1_element1\": [\"9\"], \"matrix_element2\": [2], \"matrix_element2_element0\": [\"69\"], \"matrix_element2_element1\": [\"-97\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalSquare. /*FC*/class Solution {\n/*FM*/int maximalSquare(vector<vector<char>>& matrix) {\r\n        if (matrix.empty() || matrix[0].empty()) return 0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int computeArea. /*FC*/class Solution {\n/*FM*/int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\r\n        int a1 = (C - A) * (D - B); \r\n        int a2 = (G - E) * (H - F); \r\n        \r\n        int l = max(A, E); \r\n        int r = min(C, G); \r\n        int b = max(B, F); \r\n        int t = min(D, H); \r\n        \r\n        int overlap = 0; \r\n        if (l < r && b < t) {\r\n            \r\n        }\r\n        return a1 + a2 - overlap; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"1403235762\"], \"B\": [\"-785290989\"], \"C\": [\"-703709688\"], \"D\": [\"-1305134381\"], \"E\": [\"-1165039772\"], \"F\": [\"1364023285\"], \"G\": [\"-921418266\"], \"H\": [\"1169342986\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int calculate. /*FC*/class Solution {\n/*FM*/int calculate(string s) {\r\n        stack<int> stack; \r\n        int ans = 0, num = 0, sign = 1; \r\n        for (char ch : s) {\r\n            if (isdigit(ch)) {\r\n                \r\n            } else if (ch == '+') {\r\n                \r\n                \r\n                \r\n            } else if (ch == '-') {\r\n                \r\n                \r\n                \r\n            } else if (ch == '(') {\r\n                \r\n                \r\n                \r\n                \r\n            } else if (ch == ')') {\r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n            }\r\n        }\r\n        return ans + sign * num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* invertTree. /*FC*/class Solution {\n/*FM*/TreeNode* invertTree(TreeNode* root) {\r\n        if (!root) return NULL; \r\n        TreeNode *left = root->left; \r\n        root->left  = invertTree(root->right); \r\n        root->right = invertTree(left); \r\n        return root; \r\n    };/*F*//*C*//*M*/TreeNode* invertTree(TreeNode* root) {\r\n        if (!root) return NULL; \r\n        TreeNode *left = root->left; \r\n        root->left  = invertTree(root->right); \r\n        root->right = invertTree(left); \r\n        return root; \r\n    } TreeNode* invertTree(TreeNode* root) {\r\n        if (!root) return NULL; \r\n        TreeNode *left = root->left; \r\n        root->left  = invertTree(root->right); \r\n        root->right = invertTree(left); \r\n        return root; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-549093503\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-876562412\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> summaryRanges. /*FC*/class Solution {\n/*FM*/vector<string> summaryRanges(vector<int>& nums) {\r\n        vector<string> ans; \r\n        for (int i = 0, j = 0;  i < nums.size();  i++) {\r\n            if (i + 1 >= nums.size() || nums[i] + 1 != nums[i + 1]) {\r\n                if (i > j) {\r\n                    \r\n                } else {\r\n                    ans.push_back(to_string(nums[i])); \r\n                }\r\n                j = i + 1; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-76206821\"], \"nums_element1\": [\"-1837799267\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> majorityElement. /*FC*/class Solution {\n/*FM*/vector<int> majorityElement(vector<int>& nums) {\r\n        vector<int> ans; \r\n        unordered_map<int, int> m; \r\n        for (int n : nums) {\r\n            if (++m[n] == nums.size() / 3 + 1) {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"460075829\"], \"nums_element1\": [\"331222266\"], \"nums_element2\": [\"1109144427\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> majorityElement. /*FC*/class Solution {\n/*FM*/vector<int> majorityElement(vector<int>& nums) {\r\n        vector<int> ans; \r\n        unordered_map<int, int> m; \r\n        for (int n : nums) {\r\n            if (++m[n] == nums.size() / 3 + 1) {\r\n                ans.push_back(n); \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"1559430450\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode * dfs. /*FC*/class Solution {\n/*FM*/TreeNode * dfs(TreeNode *root, int &k) {\r\n        if (!root) return NULL; \r\n        TreeNode *left = dfs(root->left, k); \r\n        if (left) {\r\n            \r\n        }\r\n        if (!--k) {\r\n            \r\n        }\r\n        return dfs(root->right, k); \r\n    };/*F*//*C*//*M*/TreeNode * dfs(TreeNode *root, int &k) {\r\n        if (!root) return NULL; \r\n        TreeNode *left = dfs(root->left, k); \r\n        if (left) {\r\n            return left; \r\n        }\r\n        if (!--k) {\r\n            return root; \r\n        }\r\n        return dfs(root->right, k); \r\n    } TreeNode * dfs(TreeNode *root, int &k) {\r\n        if (!root) return NULL; \r\n        TreeNode *left = dfs(root->left, k); \r\n        if (left) {\r\n            return left; \r\n        }\r\n        if (!--k) {\r\n            return root; \r\n        }\r\n        return dfs(root->right, k); \r\n    } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [3], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-1305192039\"], \"root[0].left\": [3], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"377732799\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"0\"], \"root[0].left[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left2_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1683509201\"], \"root[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root2_x\": [\"-2030722482\"], \"k\": [\"-156278831\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode * dfs. /*FC*/class Solution {\n/*FM*/TreeNode * dfs(TreeNode *root, int &k) {\r\n        if (!root) return NULL; \r\n        \r\n        \r\n        if (!--k) {\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/TreeNode * dfs(TreeNode *root, int &k) {\r\n        if (!root) return NULL; \r\n        TreeNode *left = dfs(root->left, k); \r\n        if (left) {\r\n            return left; \r\n        }\r\n        if (!--k) {\r\n            return root; \r\n        }\r\n        return dfs(root->right, k); \r\n    } TreeNode * dfs(TreeNode *root, int &k) {\r\n        if (!root) return NULL; \r\n        TreeNode *left = dfs(root->left, k); \r\n        if (left) {\r\n            return left; \r\n        }\r\n        if (!--k) {\r\n            return root; \r\n        }\r\n        return dfs(root->right, k); \r\n    } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfTwo. /*FC*/class Solution {\n/*FM*/bool isPowerOfTwo(int n) {\r\n        if (n < 1) return false; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfTwo. /*FC*/class Solution {\n/*FM*/bool isPowerOfTwo(int n) {\r\n        if (n < 1) \r\n        while (n % 2 == 0) {\r\n            n /= 2; \r\n        }\r\n        return n == 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(ListNode* head) {\r\n        ListNode *ps = head, *pf = head; \r\n        while (pf && pf->next) {\r\n            \r\n            \r\n        }\r\n        \r\n        ListNode *rhead = NULL; \r\n        while (ps) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        \r\n        bool ans = true; \r\n        ListNode *pa = head, *pb = rhead; \r\n        while (pb) {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(ListNode* head) {\r\n        ListNode *ps = head, *pf = head; \r\n        while (pf && pf->next) {\r\n            \r\n            \r\n        }\r\n        \r\n        ListNode *rhead = NULL; \r\n        while (ps) {\r\n            ListNode *pt = ps->next; \r\n            ps->next = rhead; \r\n            rhead = ps; \r\n            ps = pt; \r\n        }\r\n        \r\n        bool ans = true; \r\n        ListNode *pa = head, *pb = rhead; \r\n        while (pb) {\r\n            if (pa->val != pb->val) {\r\n                \r\n            }\r\n            ListNode *pt = pb->next; \r\n            pb->next = ps; \r\n            ps = pb; \r\n            pb = pt; \r\n            pa = pa->next; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1161821008\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1820783534\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> productExceptSelf. /*FC*/class Solution {\n/*FM*/vector<int> productExceptSelf(vector<int>& nums) {\r\n        vector<int> ans(nums.size(), 1); \r\n        for (int i = 1;  i < ans.size();  i++) {\r\n            ans[i] = ans[i - 1] * nums[i - 1]; \r\n        }\r\n        for (int i = ans.size() - 2, p = 1;  i >= 0;  i--) {\r\n            p *= nums[i + 1]; \r\n            ans[i] *= p; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-789814207\"], \"nums_element1\": [\"-399185757\"], \"nums_element2\": [\"-968596983\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSlidingWindow. /*FC*/class Solution {\n/*FM*/vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        if (nums.empty()) return {}; \r\n        if (k == 1) \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool searchMatrix. /*FC*/class Solution {\n/*FM*/bool searchMatrix(vector<vector<int>>& matrix, int target) {\r\n        if (matrix.empty() || matrix[0].empty()) \r\n        int m = matrix.size(); \r\n        int n = matrix[0].size(); \r\n        \r\n        int i = 0, j = n - 1; \r\n        while (i < m && j >= 0) {\r\n            if (matrix[i][j] < target) {\r\n                i++; \r\n            } else if (matrix[i][j] > target) {\r\n                j--; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-1463208548\"], \"matrix_element0_element1\": [\"489509017\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"-1787454442\"], \"matrix_element1_element1\": [\"1023782934\"], \"matrix_element1_element2\": [\"-403214310\"], \"matrix_element2\": [2], \"matrix_element2_element0\": [\"-1892031982\"], \"matrix_element2_element1\": [\"-213013107\"], \"target\": [\"641476128\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution {\n/*FM*/bool isAnagram(string s, string t) {\r\n        if (s.size() != t.size()) \r\n        vector<int> ht(26); \r\n        for (int i = 0;  i < s.size();  ) {\r\n            \r\n            \r\n        }\r\n        for (int x : ht) {\r\n            if (x != 0) {\r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAnagram. /*FC*/class Solution {\n/*FM*/bool isAnagram(string s, string t) {\r\n        if (s.size() != t.size()) \r\n        vector<int> ht(26); \r\n        for (int i = 0;  i < s.size();  i++) {\r\n            ht[s[i] - 'a']++; \r\n            ht[t[i] - 'a']--; \r\n        }\r\n        for (int x : ht) {\r\n            if (x != 0) {\r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> singleNumber. /*FC*/class Solution {\n/*FM*/vector<int> singleNumber(vector<int>& nums) {\r\n        int d = 0; \r\n        for (int n : nums) {\r\n            d ^= n; \r\n        }\r\n        d &= -d; \r\n        \r\n        int ans1 = 0, ans2 = 0; \r\n        for (int n : nums) {\r\n            if (n & d) {\r\n                ans1 ^= n; \r\n            } else {\r\n                ans2 ^= n; \r\n            }\r\n        }\r\n        return {ans1, ans2}; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-55890558\"], \"nums_element1\": [\"214005281\"], \"nums_element2\": [\"1241046594\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUgly. /*FC*/class Solution {\n/*FM*/bool isUgly(int num) {\r\n        if (num < 1) return false; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUgly. /*FC*/class Solution {\n/*FM*/bool isUgly(int num) {\r\n        if (num < 1) \r\n        while (num % 2 == 0) {\r\n            num /= 2; \r\n        }\r\n        while (num % 3 == 0) {\r\n            \r\n        }\r\n        while (num % 5 == 0) {\r\n            num /= 5; \r\n        }\r\n        return num == 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthUglyNumber. /*FC*/class Solution {\n/*FM*/int nthUglyNumber(int n) {\r\n        vector<int> ugly(n); \r\n        ugly[0] = 1; \r\n        \r\n        int i2 = 0, i3 = 0, i5 = 0; \r\n        for (int i = 1;  i < n;  i++) {\r\n            ugly[i] = min({ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5}); \r\n            if (ugly[i] == ugly[i2] * 2) {\r\n                i2++; \r\n            }\r\n            if (ugly[i] == ugly[i3] * 3) {\r\n                i3++; \r\n            }\r\n            if (ugly[i] == ugly[i5] * 5) {\r\n                i5++; \r\n            }\r\n        }\r\n        return ugly.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthUglyNumber. /*FC*/class Solution {\n/*FM*/int nthUglyNumber(int n) {\r\n        vector<int> ugly(n); \r\n        ugly[0] = 1; \r\n        \r\n        int i2 = 0, i3 = 0, i5 = 0; \r\n        for (int i = 1;  i < n;  i++) {\r\n            ugly[i] = min({ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5}); \r\n            if (ugly[i] == ugly[i2] * 2) {\r\n                i2++; \r\n            }\r\n            if (ugly[i] == ugly[i3] * 3) {\r\n                i3++; \r\n            }\r\n            if (ugly[i] == ugly[i5] * 5) {\r\n                \r\n            }\r\n        }\r\n        return ugly.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int missingNumber. /*FC*/class Solution {\n/*FM*/int missingNumber(vector<int>& nums) {\r\n        int ans = 0; \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            ans ^= nums[i]; \r\n            ans ^= i + 1; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-611058157\"], \"nums_element1\": [\"1370347201\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int missingNumber. /*FC*/class Solution {\n/*FM*/int missingNumber(vector<int>& nums) {\r\n        int ans = 0; \r\n        for (int i = 0;  i < nums.size();  ) {\r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\r\n        int size = citations.size(); \r\n        vector<int> bucket(size + 1); \r\n        for (int ci : citations) {\r\n            \r\n        }\r\n        for (int i = size, sum = 0;  i > 0;  ) {\r\n            \r\n            \r\n        }\r\n        return 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\r\n        int size = citations.size(); \r\n        for (int i = 0;  i < size;  i++) {\r\n            if (citations[i] >= size - i) {\r\n                return size - i; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [2], \"citations_element0\": [\"-1601011565\"], \"citations_element1\": [\"1391280127\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\r\n        int size = citations.size(); \r\n        for (int i = 0;  i < size;  ) {\r\n            \r\n        }\r\n        return 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hIndex. /*FC*/class Solution {\n/*FM*/int hIndex(vector<int>& citations) {\r\n        int size = citations.size(); \r\n        for (int i = 0;  i < size;  i++) {\r\n            if (citations[i] >= size - i) {\r\n                \r\n            }\r\n        }\r\n        return 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"citations\": [2], \"citations_element0\": [\"-1454649923\"], \"citations_element1\": [\"-644243844\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void moveZeroes. /*FC*/class Solution {\n/*FM*/void moveZeroes(vector<int>& nums) {\r\n        for (int i = 0, j = 0;  i < nums.size();  i++) {\r\n            if (nums[i] != 0) {\r\n                swap(nums[i], nums[j++]); \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-97469925\"], \"nums_element1\": [\"51616745\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool wordPattern. /*FC*/class Solution {\n/*FM*/bool wordPattern(string pattern, string str) {\r\n        unordered_map<char, int> pm; \r\n        unordered_map<string, int> sm; \r\n        istringstream iss(str); \r\n        int i = 0, ps = pattern.size(); \r\n        for (string word;  iss >> word;  ) {\r\n            \r\n            \r\n            \r\n        }\r\n        return i >= ps; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pattern\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool wordPattern. /*FC*/class Solution {\n/*FM*/bool wordPattern(string pattern, string str) {\r\n        unordered_map<char, int> pm; \r\n        unordered_map<string, int> sm; \r\n        istringstream iss(str); \r\n        int i = 0, ps = pattern.size(); \r\n        for (string word;  iss >> word;  i++) {\r\n            if (i >= ps || pm[pattern[i]] != sm[word]) {\r\n                \r\n            }\r\n            pm[pattern[i]] = i + 1; \r\n            sm[word] = i + 1; \r\n        }\r\n        return i >= ps; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"pattern\": [\"3\"], \"str\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void addNum. /*FC*/class MedianFinder {\n/*FM*/void addNum(int num) {\r\n        lo.push(num); \r\n        \r\n        hi.push(lo.top()); \r\n        lo.pop(); \r\n    \r\n        if (lo.size() < hi.size()) {\r\n            lo.push(hi.top()); \r\n            hi.pop(); \r\n        }\r\n    };/*F*/priority_queue<int> lo;  priority_queue<int, vector<int>, greater<int>> hi;/*C*/MedianFinder() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___MedianFinder\": [\"MedianFinder\", \"MedianFinder()\"], \"num\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode * deserializeHelper. /*FC*/class Codec {\n/*FM*/TreeNode * deserializeHelper(istringstream &iss) {\r\n        string buf; \r\n        getline(iss, buf, '#'); \r\n        if (buf.empty()) {\r\n            return NULL; \r\n        }\r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/TreeNode * deserializeHelper(istringstream &iss) {\r\n        string buf; \r\n        getline(iss, buf, '#'); \r\n        if (buf.empty()) {\r\n            return NULL; \r\n        }\r\n        TreeNode *root = new TreeNode(stoi(buf)); \r\n        root->left  = deserializeHelper(iss); \r\n        root->right = deserializeHelper(iss); \r\n        return root; \r\n    } TreeNode * deserializeHelper(istringstream &iss) {\r\n        string buf; \r\n        getline(iss, buf, '#'); \r\n        if (buf.empty()) {\r\n            return NULL; \r\n        }\r\n        TreeNode *root = new TreeNode(stoi(buf)); \r\n        root->left  = deserializeHelper(iss); \r\n        root->right = deserializeHelper(iss); \r\n        return root; \r\n    } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Codec\": [\"Codec\", \"Codec()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthSuperUglyNumber. /*FC*/class Solution {\n/*FM*/int nthSuperUglyNumber(int n, vector<int>& primes) {\r\n        vector<int> ugly(n); \r\n        ugly[0] = 1; \r\n        \r\n        vector<int> idx(primes.size()); \r\n        for (int i = 1;  i < n;  i++) {\r\n            ugly[i] = ugly[idx[0]] * primes[0]; \r\n            for (int j = 1;  j < idx.size();  j++) {\r\n                ugly[i] = min(ugly[i], ugly[idx[j]] * primes[j]); \r\n            }\r\n            for (int j = 0;  j < idx.size();  j++) {\r\n                if (ugly[i] == ugly[idx[j]] * primes[j]) {\r\n                    idx[j]++; \r\n                }\r\n            }\r\n        }\r\n        return ugly.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"], \"primes\": [2], \"primes_element0\": [\"110220078\"], \"primes_element1\": [\"-1587225628\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfThree. /*FC*/class Solution {\n/*FM*/bool isPowerOfThree(int n) {\r\n        if (n < 1) return false; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfThree. /*FC*/class Solution {\n/*FM*/bool isPowerOfThree(int n) {\r\n        if (n < 1) \r\n        while (n % 3 == 0) {\r\n            n /= 3; \r\n        }\r\n        return n == 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPatches. /*FC*/class Solution {\n/*FM*/int minPatches(vector<int>& nums, int n) {\r\n        int i = 0, cnt = 0; \r\n        long miss = 1; \r\n        while (miss <= n) {\r\n            if (i < nums.size() && nums[i] <= miss) {\r\n                \r\n            } else {\r\n                miss *= 2; \r\n                cnt++; \r\n            }\r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPatches. /*FC*/class Solution {\n/*FM*/int minPatches(vector<int>& nums, int n) {\r\n        int i = 0, cnt = 0; \r\n        long miss = 1; \r\n        while (miss <= n) {\r\n            if (i < nums.size() && nums[i] <= miss) {\r\n                miss += nums[i++]; \r\n            } else {\r\n                miss *= 2; \r\n                cnt++; \r\n            }\r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-1827546244\"], \"nums_element1\": [\"-27739264\"], \"nums_element2\": [\"188490978\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> countBits. /*FC*/class Solution {\n/*FM*/vector<int> countBits(int num) {\r\n        vector<int> ans(num + 1); \r\n        for (int i = 0;  i <= num;  i++) {\r\n            ans[i] = ans[i / 2] + i % 2; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfFour. /*FC*/class Solution {\n/*FM*/bool isPowerOfFour(int num) {\r\n        if (num < 1) \r\n        while (num % 4 == 0) {\r\n            num /= 4; \r\n        }\r\n        return num == 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPowerOfFour. /*FC*/class Solution {\n/*FM*/bool isPowerOfFour(int num) {\r\n        if (num < 1) return false; \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseString. /*FC*/class Solution {\n/*FM*/string reverseString(string s) {\r\n        int i = 0, j = s.size() - 1; \r\n        while (i < j) {\r\n            \r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseVowels. /*FC*/class Solution {\n/*FM*/string reverseVowels(string s) {\r\n        int i = 0, j = s.size() - 1; \r\n        while (i < j) {\r\n            \r\n            \r\n            \r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> intersection. /*FC*/class Solution {\n/*FM*/vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\r\n        unordered_set<int> s1(nums1.begin(), nums1.end()); \r\n        unordered_set<int> s2(nums2.begin(), nums2.end()); \r\n        vector<int> ans; \r\n        for (int n : s1) {\r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> intersection. /*FC*/class Solution {\n/*FM*/vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\r\n        unordered_set<int> s1(nums1.begin(), nums1.end()); \r\n        unordered_set<int> s2(nums2.begin(), nums2.end()); \r\n        vector<int> ans; \r\n        for (int n : s1) {\r\n            if (s2.find(n) != s2.end()) {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [1], \"nums1_element0\": [\"-529123597\"], \"nums2\": [3], \"nums2_element0\": [\"2078476039\"], \"nums2_element1\": [\"-883558893\"], \"nums2_element2\": [\"963317145\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> intersect. /*FC*/class Solution {\n/*FM*/vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\r\n        unordered_map<int, int> m; \r\n        for (int n : nums1) {\r\n            m[n]++; \r\n        }\r\n        \r\n        vector<int> ans; \r\n        for (int n : nums2) {\r\n            if (m.find(n) != m.end() && m[n] > 0) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums1\": [2], \"nums1_element0\": [\"697707323\"], \"nums1_element1\": [\"647065074\"], \"nums2\": [1], \"nums2_element0\": [\"489340067\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> intersect. /*FC*/class Solution {\n/*FM*/vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\r\n        unordered_map<int, int> m; \r\n        for (int n : nums1) {\r\n            \r\n        }\r\n        \r\n        vector<int> ans; \r\n        for (int n : nums2) {\r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPerfectSquare. /*FC*/class Solution {\n/*FM*/bool isPerfectSquare(int num) {\r\n        int lo = 1, hi = min(num, 46340);    \n        while (lo <= hi) {\r\n            int mid = (lo + hi) / 2; \r\n            if (mid * mid < num) {\r\n                lo = mid + 1; \r\n            } else if (mid * mid > num) {\r\n                hi = mid - 1; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"186706343\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPerfectSquare. /*FC*/class Solution {\n/*FM*/bool isPerfectSquare(int num) {\r\n        int lo = 1, hi = min(num, 46340);    \n        while (lo <= hi) {\r\n            \r\n            \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"-2147483648\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getSum. /*FC*/class Solution {\n/*FM*/int getSum(int a, int b) {\r\n        while (a & b) {\r\n            int _xor = a ^ b; \r\n            a = (a & b) << 1; \r\n            b = _xor; \r\n        }\r\n        return a ^ b; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"a\": [\"10\"], \"b\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool insert. /*FC*/class RandomizedSet {\n/*FM*/bool insert(int val) {\r\n        if (m.find(val) != m.end()) \r\n        v.push_back(val); \r\n        m[val] = v.size() - 1; \r\n        return true; \r\n    };/*F*/vector<int> v;  unordered_map<int, int> m;/*C*/RandomizedSet() : dre(time(0)) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RandomizedSet\": [\"RandomizedSet\", \"RandomizedSet()\"], \"val\": [\"668064230\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool remove. /*FC*/class RandomizedSet {\n/*FM*/bool remove(int val) {\r\n        if (m.find(val) == m.end()) return false; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*/unordered_map<int, int> m;/*C*/RandomizedSet() : dre(time(0)) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RandomizedSet\": [\"RandomizedSet\", \"RandomizedSet()\"], \"val\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getRandom. /*FC*/class RandomizedSet {\n/*FM*/int getRandom() {\r\n        uniform_int_distribution<int> uid(0, v.size() - 1); \r\n        return v[uid(dre)]; \r\n    };/*F*/default_random_engine dre;  vector<int> v;/*C*/RandomizedSet() : dre(time(0)) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RandomizedSet\": [\"RandomizedSet\", \"RandomizedSet()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getRandom. /*FC*/class Solution {\n/*FM*/int getRandom() {\r\n        int ans, n = 0; \r\n        for (ListNode *pi = head;  pi;  pi = pi->next) {\r\n            uniform_int_distribution<int> uid(0, n++); \r\n            if (!uid(dre)) {\r\n                ans = pi->val; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*/default_random_engine dre;  ListNode *head;/*C*/Solution(ListNode* head) : dre(time(0)), head(head) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution(ListNode*)\"], \"AKA_INSTANCE___Solution_head\": [2], \"AKA_INSTANCE___Solution_head[0]\": [\"ListNode\", \"ListNode(int)\"], \"AKA_INSTANCE___Solution_head0_x\": [\"1539178669\"], \"AKA_INSTANCE___Solution_head[1]\": [\"ListNode\", \"ListNode(int)\"], \"AKA_INSTANCE___Solution_head1_x\": [\"72103631\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canConstruct. /*FC*/class Solution {\n/*FM*/bool canConstruct(string ransomNote, string magazine) {\r\n        if (ransomNote.size() > magazine.size()) \r\n        vector<int> ht(26); \r\n        for (char ch : magazine) {\r\n            \r\n        }\r\n        for (char ch : ransomNote) {\r\n            \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canConstruct. /*FC*/class Solution {\n/*FM*/bool canConstruct(string ransomNote, string magazine) {\r\n        if (ransomNote.size() > magazine.size()) \r\n        vector<int> ht(26); \r\n        for (char ch : magazine) {\r\n            ht[ch - 'a']++; \r\n        }\r\n        for (char ch : ransomNote) {\r\n            if (--ht[ch - 'a'] < 0) {\r\n                return false; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ransomNote\": [\"1\"], \"magazine\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canConstruct. /*FC*/class Solution {\n/*FM*/bool canConstruct(string ransomNote, string magazine) {\r\n        if (ransomNote.size() > magazine.size()) \r\n        vector<int> ht(26); \r\n        for (char ch : magazine) {\r\n            ht[ch - 'a']++; \r\n        }\r\n        for (char ch : ransomNote) {\r\n            if (--ht[ch - 'a'] < 0) {\r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"ransomNote\": [\"3\"], \"magazine\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstUniqChar. /*FC*/class Solution {\n/*FM*/int firstUniqChar(string s) {\r\n        vector<int> ht(26); \r\n        for (int i = 0;  i < s.size();  i++) {\r\n            ht[s[i] - 'a']++; \r\n        }\r\n        for (int i = 0;  i < s.size();  ) {\r\n            if (ht[s[i] - 'a'] == 1) {\r\n                return i; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstUniqChar. /*FC*/class Solution {\n/*FM*/int firstUniqChar(string s) {\r\n        vector<int> ht(26); \r\n        for (int i = 0;  i < s.size();  i++) {\r\n            ht[s[i] - 'a']++; \r\n        }\r\n        for (int i = 0;  i < s.size();  i++) {\r\n            if (ht[s[i] - 'a'] == 1) {\r\n                \r\n            }\r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method char findTheDifference. /*FC*/class Solution {\n/*FM*/char findTheDifference(string s, string t) {\r\n        char ans = 0; \r\n        for (char ch : s) {\r\n            ans ^= ch; \r\n        }\r\n        for (char ch : t) {\r\n            ans ^= ch; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"t\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pick. /*FC*/class Solution {\n/*FM*/int pick(int target) {\r\n        int ans; \r\n        for (int i = 0, n = 0;  i < nums.size();  i++) {\r\n            if (nums[i] == target) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*/vector<int> nums;/*C*/Solution(vector<int>& nums) : dre(time(0)), nums(nums) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution(vector<int>&)\"], \"AKA_INSTANCE___Solution_nums\": [3], \"AKA_INSTANCE___Solution_nums_element0\": [\"293550005\"], \"AKA_INSTANCE___Solution_nums_element1\": [\"1373997358\"], \"AKA_INSTANCE___Solution_nums_element2\": [\"1197693880\"], \"target\": [\"-535338017\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string toHex. /*FC*/class Solution {\n/*FM*/string toHex(int num) {\r\n        if (num == 0) \r\n        string ans; \r\n        while (num) {\r\n            ans += hex[num % 16u]; \r\n            num /= 16u; \r\n        }\r\n        reverse(ans.begin(), ans.end()); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"-1148435717\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestPalindrome. /*FC*/class Solution {\n/*FM*/int longestPalindrome(string s) {\r\n        vector<int> ht(128); \r\n        for (char ch : s) {\r\n            \r\n        }\r\n        int ans = 0; \r\n        for (int i : ht) {\r\n            ans += i / 2 * 2; \r\n        }\r\n        return ans == s.size() ? ans : ans + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestPalindrome. /*FC*/class Solution {\n/*FM*/int longestPalindrome(string s) {\r\n        vector<int> ht(128); \r\n        for (char ch : s) {\r\n            ht[ch]++; \r\n        }\r\n        int ans = 0; \r\n        for (int i : ht) {\r\n            ans += i / 2 * 2; \r\n        }\r\n        return ans == s.size() ? ans : ans + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> fizzBuzz. /*FC*/class Solution {\n/*FM*/vector<string> fizzBuzz(int n) {\r\n        vector<string> r_vec(n); \r\n        for (int i = 1;  i <= n;  i++) {\r\n            if (i % 15 == 0) {\r\n                \r\n            } else if (i % 3 == 0) {\r\n                r_vec[i - 1] = \"Fizz\"; \r\n            } else if (i % 5 == 0) {\r\n                r_vec[i - 1] = \"Buzz\"; \r\n            } else {\r\n                r_vec[i - 1] = to_string(i); \r\n            }\r\n        }\r\n        return r_vec; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> fizzBuzz. /*FC*/class Solution {\n/*FM*/vector<string> fizzBuzz(int n) {\r\n        vector<string> r_vec(n); \r\n        for (int i = 1;  i <= n;  i++) {\r\n            if (i % 15 == 0) {\r\n                \r\n            } else if (i % 3 == 0) {\r\n                \r\n            } else if (i % 5 == 0) {\r\n                \r\n            } else {\r\n                r_vec[i - 1] = to_string(i); \r\n            }\r\n        }\r\n        return r_vec; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfArithmeticSlices. /*FC*/class Solution {\n/*FM*/int numberOfArithmeticSlices(vector<int>& A) {\r\n        int num = 0, l = 0; \r\n        for (int i = 2;  i < A.size();  i++) {\r\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\r\n                \r\n            } else {\r\n                l = 0; \r\n            }\r\n        }\r\n        return num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [\"601180820\"], \"A_element1\": [\"1704693549\"], \"A_element2\": [\"-1664917456\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int thirdMax. /*FC*/class Solution {\n/*FM*/int thirdMax(vector<int>& nums) {\r\n        vector<int> max_nums; \r\n        for (int n : nums) {\r\n            for (int &m : max_nums) {\r\n                if (m == n) \r\n                if (m  < n) swap(m, n); \r\n            }\r\n            if (max_nums.empty() ||\r\n                max_nums.size() < 3 &&\r\n                max_nums.back() > n) {\r\n                max_nums.push_back(n); \r\n            }\r\n        }\r\n        return max_nums[max_nums.size() < 3 ? 0 : 2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-527783332\"], \"nums_element1\": [\"217030576\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int thirdMax. /*FC*/class Solution {\n/*FM*/int thirdMax(vector<int>& nums) {\r\n        vector<int> max_nums; \r\n        for (int n : nums) {\r\n            for (int &m : max_nums) {\r\n                if (m == n) \r\n                if (m  < n) \r\n            }\r\n            if (max_nums.empty() ||\r\n                max_nums.size() < 3 &&\r\n                max_nums.back() > n) {\r\n                max_nums.push_back(n); \r\n            }\r\n        }\r\n        return max_nums[max_nums.size() < 3 ? 0 : 2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"1702477339\"], \"nums_element1\": [\"496117338\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int thirdMax. /*FC*/class Solution {\n/*FM*/int thirdMax(vector<int>& nums) {\r\n        vector<int> max_nums; \r\n        for (int n : nums) {\r\n            for ( : max_nums) {\r\n                \r\n                if (m  < n) \r\n            }\r\n            \r\n        }\r\n        return max_nums[max_nums.size() < 3 ? 0 : 2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addStrings. /*FC*/class Solution {\n/*FM*/string addStrings(string num1, string num2) {\r\n        int carry = 0, s1 = num1.size(), s2 = num2.size(); \r\n        string sum(max(s1, s2), 0); \r\n        for (int i = 0, ss = sum.size();  i < ss;  i++) {\r\n            sum[ss - i - 1] += i < s1 ? num1[s1 - i - 1] - '0' : 0; \r\n            sum[ss - i - 1] += i < s2 ? num2[s2 - i - 1] - '0' : 0; \r\n            sum[ss - i - 1] += carry; \r\n            carry = sum[ss - i - 1] / 10; \r\n            sum[ss - i - 1] = sum[ss - i - 1] % 10 + '0'; \r\n        }\r\n        if (carry > 0) {\r\n            \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"3\"], \"num2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addStrings. /*FC*/class Solution {\n/*FM*/string addStrings(string num1, string num2) {\r\n        int carry = 0, s1 = num1.size(), s2 = num2.size(); \r\n        string sum(max(s1, s2), 0); \r\n        for (int i = 0, ss = sum.size();  i < ss;  i++) {\r\n            sum[ss - i - 1] += i < s1 ? num1[s1 - i - 1] - '0' : 0; \r\n            sum[ss - i - 1] += i < s2 ? num2[s2 - i - 1] - '0' : 0; \r\n            sum[ss - i - 1] += carry; \r\n            carry = sum[ss - i - 1] / 10; \r\n            sum[ss - i - 1] = sum[ss - i - 1] % 10 + '0'; \r\n        }\r\n        if (carry > 0) {\r\n            sum = to_string(carry) + sum; \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"1\"], \"num2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string addStrings. /*FC*/class Solution {\n/*FM*/string addStrings(string num1, string num2) {\r\n        int carry = 0, s1 = num1.size(), s2 = num2.size(); \r\n        string sum(max(s1, s2), 0); \r\n        for (int i = 0, ss = sum.size();  i < ss;  ) {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        if (carry > 0) {\r\n            \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countBattleships. /*FC*/class Solution {\n/*FM*/int countBattleships(vector<vector<char>>& board) {\r\n        int cnt = 0; \r\n        for (int i = 0;  i < board.size();  i++) {\r\n            for (int j = 0;  j < board[0].size();  j++) {\r\n                if (board[i][j] == 'X' &&\r\n                    (i == 0 || board[i - 1][j] != 'X') &&\r\n                    (j == 0 || board[i][j - 1] != 'X')) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"board\": [1], \"board_element0\": [1], \"board_element0_element0\": [\"-101\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countBattleships. /*FC*/class Solution {\n/*FM*/int countBattleships(vector<vector<char>>& board) {\r\n        int cnt = 0; \r\n        for (int i = 0;  i < board.size();  ) {\r\n            \r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method Node* construct. /*FC*/class Solution {\n/*FM*/Node* construct(vector<vector<int>>& grid) {\r\n        if (grid.empty()) \r\n        return dfs(grid, 0, 0, grid.size()); \r\n    };/*F*//*C*//*M*/Node * dfs(vector<vector<int>> &grid, int x, int y, int size) {\r\n        if (size == 1) return new Node(grid[x][y], true, NULL, NULL, NULL, NULL); \r\n        \r\n        Node *tl = dfs(grid, x, y, size / 2); \r\n        Node *tr = dfs(grid, x, y + size / 2, size / 2); \r\n        Node *bl = dfs(grid, x + size / 2, y, size / 2); \r\n        Node *br = dfs(grid, x + size / 2, y + size / 2, size / 2); \r\n        \r\n        if (tl->isLeaf && tr->isLeaf && bl->isLeaf && br->isLeaf &&\r\n            ((tl->val && tr->val && bl->val && br->val) ||\r\n            !(tl->val || tr->val || bl->val || br->val))) {\r\n            delete tl, tr, bl; \r\n            return br; \r\n        }\r\n        return new Node(0, false, tl, tr, bl, br); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"-883375404\"], \"grid_element0_element1\": [\"-1927038869\"], \"grid_element1\": [3], \"grid_element1_element0\": [\"-774962602\"], \"grid_element1_element1\": [\"-779948380\"], \"grid_element1_element2\": [\"2063448779\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method Node* construct. /*FC*/class Solution {\n/*FM*/Node* construct(vector<vector<int>>& grid) {\r\n        if (grid.empty()) return NULL; \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int>> levelOrder(Node* root) {\r\n        if (!root) return {}; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSegments. /*FC*/class Solution {\n/*FM*/int countSegments(string s) {\r\n        s += \" \"; \r\n        int cnt = 0; \r\n        for (int i = 0;  i < s.size() - 1;  i++) {\r\n            if (s[i] != ' ' && s[i + 1] == ' ') {\r\n                cnt++; \r\n            }\r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSegments. /*FC*/class Solution {\n/*FM*/int countSegments(string s) {\r\n        s += \" \"; \r\n        int cnt = 0; \r\n        for (int i = 0;  i < s.size() - 1;  i++) {\r\n            if (s[i] != ' ' && s[i + 1] == ' ') {\r\n                \r\n            }\r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pathSum. /*FC*/class Solution {\n/*FM*/int pathSum(TreeNode* root, int sum) {\r\n        if (!root) return 0; \r\n        return sameRootPathSum(root, sum) +\r\n            pathSum(root->left, sum) +\r\n            pathSum(root->right, sum); \r\n    };/*F*//*C*//*M*/int sameRootPathSum(TreeNode *root, int sum) {\r\n        if (!root) return 0; \r\n        return (root->val == sum ? 1 : 0) +\r\n            sameRootPathSum(root->left, sum - root->val) +\r\n            sameRootPathSum(root->right, sum - root->val); \r\n    } int pathSum(TreeNode* root, int sum) {\r\n        if (!root) return 0; \r\n        return sameRootPathSum(root, sum) +\r\n            pathSum(root->left, sum) +\r\n            pathSum(root->right, sum); \r\n    } int pathSum(TreeNode* root, int sum) {\r\n        if (!root) return 0; \r\n        return sameRootPathSum(root, sum) +\r\n            pathSum(root->left, sum) +\r\n            pathSum(root->right, sum); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-856574381\"], \"root[0].right\": [3], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"1180382339\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"0\"], \"root[0].right[2]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right2_x\": [\"0\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1484664681\"], \"sum\": [\"-1850474081\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findAnagrams. /*FC*/class Solution {\n/*FM*/vector<int> findAnagrams(string s, string p) {\r\n        int ss = s.size(), ps = p.size(); \r\n        if (ss < ps) \r\n        \r\n        vector<int> hts(26), htp(26); \r\n        for (int i = 0;  i < ps;  i++) {\r\n            htp[p[i] - 'a']++; \r\n            hts[s[i] - 'a']++; \r\n        }\r\n        \r\n        vector<int> ans; \r\n        for (int i = ps;  i < ss;  ) {\r\n            \r\n            \r\n            \r\n        }\r\n        if (hts == htp) {\r\n            ans.push_back(ss - ps); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"], \"p\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findAnagrams. /*FC*/class Solution {\n/*FM*/vector<int> findAnagrams(string s, string p) {\r\n        int ss = s.size(), ps = p.size(); \r\n        if (ss < ps) \r\n        \r\n        vector<int> hts(26), htp(26); \r\n        for (int i = 0;  i < ps;  ) {\r\n            \r\n            \r\n        }\r\n        \r\n        vector<int> ans; \r\n        for (int i = ps;  i < ss;  ) {\r\n            \r\n            \r\n            \r\n        }\r\n        if (hts == htp) {\r\n            ans.push_back(ss - ps); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int arrangeCoins. /*FC*/class Solution {\n/*FM*/int arrangeCoins(int n) {\r\n        int lo = 0, hi = n; \r\n        while (lo <= hi) {\r\n            int mid = (lo + hi) / 2; \r\n            if ((1l + mid) * mid <= 2l * n) {\r\n                lo = mid + 1; \r\n            } else {\r\n                hi = mid - 1; \r\n            }\r\n        }\r\n        return hi; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int compress. /*FC*/class Solution {\n/*FM*/int compress(vector<char>& chars) {\r\n        int len = 0; \r\n        for (int i = 0, cnt = 1;  i < chars.size();  i++, cnt++) {\r\n            if (i + 1 == chars.size() || chars[i] != chars[i + 1]) {\r\n                chars[len++] = chars[i]; \r\n                if (cnt > 1) {\r\n                    for ( : to_string(cnt)) {\r\n                        \r\n                    }\r\n                }\r\n                cnt = 0; \r\n            }\r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"chars\": [2], \"chars_element0\": [\"31\"], \"chars_element1\": [\"95\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string frequencySort. /*FC*/class Solution {\n/*FM*/string frequencySort(string s) {\r\n        unordered_map<char, int> m; \r\n        for (char ch : s) {\r\n            m[ch]++; \r\n        }\r\n        \r\n        priority_queue<pair<int, char>> q; \r\n        for (auto &[ch, v] : m) {\r\n            q.emplace(v, ch); \r\n        }\r\n        \r\n        string ans; \r\n        for (int i = 0, n = q.size();  i < n;  i++) {\r\n            auto [v, ch] = q.top(); \r\n            q.pop(); \r\n            ans.append(v, ch); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string frequencySort. /*FC*/class Solution {\n/*FM*/string frequencySort(string s) {\r\n        unordered_map<char, int> m; \r\n        for (char ch : s) {\r\n            \r\n        }\r\n        \r\n        priority_queue<pair<int, char>> q; \r\n        for (auto &[ch, v] : m) {\r\n            \r\n        }\r\n        \r\n        string ans; \r\n        for (int i = 0, n = q.size();  i < n;  ) {\r\n            \r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int fourSumCount. /*FC*/class Solution {\n/*FM*/int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\r\n        unordered_map<int, int> index; \r\n        for (int a : A) {\r\n            for ( : B) {\r\n                \r\n            }\r\n        }\r\n        \r\n        int ans = 0; \r\n        for (int c : C) {\r\n            for ( : D) {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int fourSumCount. /*FC*/class Solution {\n/*FM*/int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\r\n        unordered_map<int, int> index; \r\n        for (int a : A) {\r\n            for (int b : B) {\r\n                index[-a - b]++; \r\n            }\r\n        }\r\n        \r\n        int ans = 0; \r\n        for (int c : C) {\r\n            for (int d : D) {\r\n                if (index.find(c + d) != index.end()) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"1724818022\"], \"A_element1\": [\"1874887967\"], \"B\": [1], \"B_element0\": [\"-1773559525\"], \"C\": [3], \"C_element0\": [\"372380402\"], \"C_element1\": [\"-942714223\"], \"C_element2\": [\"1278132510\"], \"D\": [3], \"D_element0\": [\"422225767\"], \"D_element1\": [\"36002093\"], \"D_element2\": [\"1617718508\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findContentChildren. /*FC*/class Solution {\n/*FM*/int findContentChildren(vector<int>& g, vector<int>& s) {\r\n        sort(g.begin(), g.end()); \r\n        sort(s.begin(), s.end()); \r\n        \r\n        int ans = 0; \r\n        for (int cookie : s) {\r\n            if (ans >= g.size()) {\r\n                \r\n            }\r\n            if (cookie >= g[ans]) {\r\n                ans++; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"g\": [3], \"g_element0\": [\"-2119272725\"], \"g_element1\": [\"586387288\"], \"g_element2\": [\"1004219897\"], \"s\": [2], \"s_element0\": [\"-1679999740\"], \"s_element1\": [\"225396149\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findContentChildren. /*FC*/class Solution {\n/*FM*/int findContentChildren(vector<int>& g, vector<int>& s) {\r\n        sort(g.begin(), g.end()); \r\n        sort(s.begin(), s.end()); \r\n        \r\n        int ans = 0; \r\n        for (int cookie : s) {\r\n            \r\n            if (cookie >= g[ans]) {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int hammingDistance. /*FC*/class Solution {\n/*FM*/int hammingDistance(int x, int y) {\r\n        int cnt = 0, n = x ^ y; \r\n        while (n) {\r\n            n &= n - 1; \r\n            cnt++; \r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"686024824\"], \"y\": [\"1821122932\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int islandPerimeter. /*FC*/class Solution {\n/*FM*/int islandPerimeter(vector<vector<int>>& grid) {\r\n        int perimeter = 0; \r\n        for (int i = 0;  i < grid.size();  i++) {\r\n            for (int j = 0;  j < grid[0].size();  j++) {\r\n                if (grid[i][j]) {\r\n                    if (i - 1 < 0 || grid[i - 1][j] == 0) {\r\n                        perimeter += 2; \r\n                    }\r\n                    if (j - 1 < 0 || grid[i][j - 1] == 0) {\r\n                        perimeter += 2; \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return perimeter; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [3], \"grid_element0_element0\": [\"1224559543\"], \"grid_element0_element1\": [\"-1575086685\"], \"grid_element0_element2\": [\"-2041491774\"], \"grid_element1\": [1], \"grid_element1_element0\": [\"1936843644\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int islandPerimeter. /*FC*/class Solution {\n/*FM*/int islandPerimeter(vector<vector<int>>& grid) {\r\n        int perimeter = 0; \r\n        for (int i = 0;  i < grid.size();  ) {\r\n            \r\n        }\r\n        return perimeter; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findRadius. /*FC*/class Solution {\n/*FM*/int findRadius(vector<int>& houses, vector<int>& heaters) {\r\n        sort(houses.begin(), houses.end()); \r\n        sort(heaters.begin(), heaters.end()); \r\n        \r\n        int ans = 0; \r\n        for (int i = 0, j = 0;  i < houses.size();  i++) {\r\n            while (j < heaters.size() && houses[i] > heaters[j]) {\r\n                j++; \r\n            }\r\n            int lr = j > 0 ? houses[i] - heaters[j - 1] : INT_MAX; \r\n            int rr = j < heaters.size() ? heaters[j] - houses[i] : INT_MAX; \r\n            ans = max(ans, min(lr, rr)); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"houses\": [2], \"houses_element0\": [\"198809743\"], \"houses_element1\": [\"-1847585695\"], \"heaters\": [1], \"heaters_element0\": [\"-1758539905\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findComplement. /*FC*/class Solution {\n/*FM*/int findComplement(int num) {\r\n        int mask = ~0; \r\n        while (num & mask) {\r\n            mask <<= 1; \r\n        }\r\n        return ~mask ^ num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int totalHammingDistance. /*FC*/class Solution {\n/*FM*/int totalHammingDistance(vector<int>& nums) {\r\n        int dist = 0; \r\n        for (int i = 0;  i < 8 * sizeof(int);  i++) {\r\n            int b1 = 0; \r\n            for (int n : nums) {\r\n                b1 += n >> i & 1; \r\n            }\r\n            dist += b1 * (nums.size() - b1); \r\n        }\r\n        return dist; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-252728671\"], \"nums_element1\": [\"-1583628740\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int totalHammingDistance. /*FC*/class Solution {\n/*FM*/int totalHammingDistance(vector<int>& nums) {\r\n        int dist = 0; \r\n        for (int i = 0;  i < 8 * sizeof(int);  i++) {\r\n            int b1 = 0; \r\n            for (int n : nums) {\r\n                \r\n            }\r\n            dist += b1 * (nums.size() - b1); \r\n        }\r\n        return dist; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string licenseKeyFormatting. /*FC*/class Solution {\n/*FM*/string licenseKeyFormatting(string S, int K) {\r\n        string ans; \r\n        for (int i = S.size() - 1;  i >= 0;  ) {\r\n            \r\n        }\r\n        reverse(ans.begin(), ans.end()); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"K\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string licenseKeyFormatting. /*FC*/class Solution {\n/*FM*/string licenseKeyFormatting(string S, int K) {\r\n        string ans; \r\n        for (int i = S.size() - 1;  i >= 0;  i--) {\r\n            if (S[i] != '-') {\r\n                if (ans.size() % (K + 1) == K) {\r\n                    \r\n                }\r\n                ans += toupper(S[i]); \r\n            }\r\n        }\r\n        reverse(ans.begin(), ans.end()); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"K\": [\"-1192943647\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMaxConsecutiveOnes. /*FC*/class Solution {\n/*FM*/int findMaxConsecutiveOnes(vector<int>& nums) {\r\n        int count = 0, max_len = 0; \r\n        for (int n : nums) {\r\n            count = count * n + n; \r\n            max_len = max(max_len, count); \r\n        }\r\n        return max_len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1193045471\"], \"nums_element1\": [\"515789951\"], \"nums_element2\": [\"-2095063516\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> constructRectangle. /*FC*/class Solution {\n/*FM*/vector<int> constructRectangle(int area) {\r\n        int i = sqrt(area); \r\n        while (area % i) {\r\n            i--; \r\n        }\r\n        return {area / i, i}; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"area\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findDiagonalOrder. /*FC*/class Solution {\n/*FM*/vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\r\n        if (matrix.empty() || matrix[0].empty()) return {}; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        for ( : ans) {\r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findDiagonalOrder. /*FC*/class Solution {\n/*FM*/vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\r\n        if (matrix.empty() || matrix[0].empty()) \r\n        int m = matrix.size(); \r\n        int n = matrix[0].size(); \r\n        \r\n        vector<int> ans(m * n); \r\n        int i = 0, j = 0; \r\n        for (int &num : ans) {\r\n            num = matrix[i][j]; \r\n            if ((i + j) % 2) {\r\n                if (i >= m - 1) { j++;  continue;  }\r\n                if (j <= 0)     { i++;  continue;  }\r\n                i++;  j--; \r\n            } else {\r\n                if (j >= n - 1) { i++;  continue;  }\r\n                if (i <= 0)     { j++;  continue;  }\r\n                i--;  j++; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [3], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"1208883650\"], \"matrix_element0_element1\": [\"1214689841\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"-1420519532\"], \"matrix_element1_element1\": [\"648043501\"], \"matrix_element1_element2\": [\"159415914\"], \"matrix_element2\": [2], \"matrix_element2_element0\": [\"580313180\"], \"matrix_element2_element1\": [\"912577500\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> findWords. /*FC*/class Solution {\n/*FM*/vector<string> findWords(vector<string>& words) {\r\n        vector<string> ans; \r\n        for (string &w : words) {\r\n            uint8_t byte = 7; \r\n            for (char ch : w) {\r\n                byte &= ht[tolower(ch) - 'a']; \r\n                if (!byte) {\r\n                    break; \r\n                }\r\n            }\r\n            if (byte) {\r\n                ans.push_back(w); \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [3], \"words_element0\": [\"1\"], \"words_element1\": [\"1\"], \"words_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convertToBase7. /*FC*/class Solution {\n/*FM*/string convertToBase7(int num) {\r\n        if (num == 0) return \"0\"; \r\n        if (num  < 0) \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/string convertToBase7(int num) {\r\n        if (num == 0) return \"0\"; \r\n        if (num  < 0) return \"-\" + convertToBase7(-num); \r\n        \r\n        string ans; \r\n        while (num) {\r\n            ans += num % 7 + '0'; \r\n            num /= 7; \r\n        }\r\n        reverse(ans.begin(), ans.end()); \r\n        return ans; \r\n    } string convertToBase7(int num) {\r\n        if (num == 0) return \"0\"; \r\n        if (num  < 0) return \"-\" + convertToBase7(-num); \r\n        \r\n        string ans; \r\n        while (num) {\r\n            ans += num % 7 + '0'; \r\n            num /= 7; \r\n        }\r\n        reverse(ans.begin(), ans.end()); \r\n        return ans; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convertToBase7. /*FC*/class Solution {\n/*FM*/string convertToBase7(int num) {\r\n        if (num == 0) \r\n        if (num  < 0) return \"-\" + convertToBase7(-num); \r\n        \r\n        string ans; \r\n        while (num) {\r\n            ans += num % 7 + '0'; \r\n            num /= 7; \r\n        }\r\n        reverse(ans.begin(), ans.end()); \r\n        return ans; \r\n    };/*F*//*C*//*M*/string convertToBase7(int num) {\r\n        if (num == 0) return \"0\"; \r\n        if (num  < 0) return \"-\" + convertToBase7(-num); \r\n        \r\n        string ans; \r\n        while (num) {\r\n            ans += num % 7 + '0'; \r\n            num /= 7; \r\n        }\r\n        reverse(ans.begin(), ans.end()); \r\n        return ans; \r\n    } string convertToBase7(int num) {\r\n        if (num == 0) return \"0\"; \r\n        if (num  < 0) return \"-\" + convertToBase7(-num); \r\n        \r\n        string ans; \r\n        while (num) {\r\n            ans += num % 7 + '0'; \r\n            num /= 7; \r\n        }\r\n        reverse(ans.begin(), ans.end()); \r\n        return ans; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [\"-1572093560\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int fib. /*FC*/class Solution {\n/*FM*/int fib(int N) {\r\n        vector<int> dp = {0, 1}; \r\n        for (int i = 2;  i <= N;  i++) {\r\n            dp[i % 2] = dp[0] + dp[1]; \r\n        }\r\n        return dp[N % 2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool detectCapitalUse. /*FC*/class Solution {\n/*FM*/bool detectCapitalUse(string word) {\r\n        int cap_cnt = 0; \r\n        for (char ch : word) {\r\n            if (isupper(ch)) {\r\n                \r\n            }\r\n        }\r\n        return cap_cnt == 0 ||\r\n            cap_cnt == 1 && isupper(word[0]) ||\r\n            cap_cnt == word.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string encode. /*FC*/class Solution {\n/*FM*/string encode(string longUrl) {\r\n        if (u2i.find(longUrl) != u2i.end()) {\r\n            \r\n        }\r\n        int i = u2i.size(); \r\n        u2i[longUrl] = i; \r\n        i2u.push_back(longUrl); \r\n        return pre + to_string(i); \r\n    };/*F*/unordered_map<string, int> u2i;  vector<string> i2u;/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"longUrl\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseStr. /*FC*/class Solution {\n/*FM*/string reverseStr(string s, int k) {\r\n        for (int i = 0;  i < s.size();  ) {\r\n            \r\n            \r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseStr. /*FC*/class Solution {\n/*FM*/string reverseStr(string s, int k) {\r\n        for (int i = 0;  i < s.size();  i += 2 * k) {\r\n            int l = i, r = min(i + k, (int)s.size()) - 1; \r\n            while (l < r) {\r\n                \r\n            }\r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"], \"k\": [\"1931907603\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseWords. /*FC*/class Solution {\n/*FM*/string reverseWords(string s) {\r\n        for (int i = 0, l = 0;  i <= s.size();  i++) {\r\n            if (i == s.size() || s[i] == ' ') {\r\n                int r = i - 1; \r\n                while (l < r) {\r\n                    \r\n                }\r\n                l = i + 1; \r\n            }\r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(Node* root) {\r\n        if (!root) return 0; \r\n        \r\n        for ( : root->children) {\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/int maxDepth(Node* root) {\r\n        if (!root) return 0; \r\n        int max_depth = 0; \r\n        for (Node *c : root->children) {\r\n            max_depth = max(max_depth, maxDepth(c)); \r\n        }\r\n        return max_depth + 1; \r\n    } int maxDepth(Node* root) {\r\n        if (!root) return 0; \r\n        int max_depth = 0; \r\n        for (Node *c : root->children) {\r\n            max_depth = max(max_depth, maxDepth(c)); \r\n        }\r\n        return max_depth + 1; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(Node* root) {\r\n        if (!root) \r\n        int max_depth = 0; \r\n        for (Node *c : root->children) {\r\n            max_depth = max(max_depth, maxDepth(c)); \r\n        }\r\n        return max_depth + 1; \r\n    };/*F*//*C*//*M*/int maxDepth(Node* root) {\r\n        if (!root) return 0; \r\n        int max_depth = 0; \r\n        for (Node *c : root->children) {\r\n            max_depth = max(max_depth, maxDepth(c)); \r\n        }\r\n        return max_depth + 1; \r\n    } int maxDepth(Node* root) {\r\n        if (!root) return 0; \r\n        int max_depth = 0; \r\n        for (Node *c : root->children) {\r\n            max_depth = max(max_depth, maxDepth(c)); \r\n        }\r\n        return max_depth + 1; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"Node\", \"Node(int,vector<Node*>)\"], \"root0__val\": [\"-547\"], \"root0__children\": [1], \"root0__children_element0\": [2], \"root0__children_element0[0]\": [\"Node\", \"Node()\"], \"root0__children_element0[1]\": [\"Node\", \"Node()\"], \"root[0].children\": [2]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int arrayPairSum. /*FC*/class Solution {\n/*FM*/int arrayPairSum(vector<int>& nums) {\r\n        sort(nums.begin(), nums.end()); \r\n        \r\n        int sum = 0; \r\n        for (int i = 0;  i < nums.size();  i += 2) {\r\n            sum += nums[i]; \r\n        }\r\n        return sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"458\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int arrayNesting. /*FC*/class Solution {\n/*FM*/int arrayNesting(vector<int>& nums) {\r\n        int ans = 0; \r\n        vector<bool> visit(nums.size()); \r\n        for (int i = 0;  i < nums.size();  ) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int arrayNesting. /*FC*/class Solution {\n/*FM*/int arrayNesting(vector<int>& nums) {\r\n        int ans = 0; \r\n        vector<bool> visit(nums.size()); \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (visit[i]) {\r\n                \r\n            }\r\n            int count = 0; \r\n            for (int j = i;  !visit[j];  j = nums[j]) {\r\n                visit[j] = true; \r\n                count++; \r\n            }\r\n            ans = max(ans, count); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"863\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> matrixReshape. /*FC*/class Solution {\n/*FM*/vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\r\n        int m = nums.size(); \r\n        int n = nums[0].size(); \r\n        if (m * n != r * c) return nums; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [1], \"nums_element0_element0\": [\"-356\"], \"nums_element1\": [1], \"nums_element1_element0\": [\"-183\"], \"r\": [\"-995\"], \"c\": [\"-854\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int>& nums) {\r\n        vector<int> sorted = nums; \r\n        sort(sorted.begin(), sorted.end()); \r\n        \r\n        int l = 0, r = nums.size() - 1; \r\n        while (l <= r && nums[l] == sorted[l]) {\r\n            \r\n        }\r\n        while (l <= r && nums[r] == sorted[r]) {\r\n            \r\n        }\r\n        return r - l + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1132580406\"], \"nums_element1\": [\"-2036000816\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int>& nums) {\r\n        vector<int> sorted = nums; \r\n        sort(sorted.begin(), sorted.end()); \r\n        \r\n        int l = 0, r = nums.size() - 1; \r\n        while (l <= r && nums[l] == sorted[l]) {\r\n            l++; \r\n        }\r\n        while (l <= r && nums[r] == sorted[r]) {\r\n            \r\n        }\r\n        return r - l + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-1779830576\"], \"nums_element1\": [\"-1657716400\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxCount. /*FC*/class Solution {\n/*FM*/int maxCount(int m, int n, vector<vector<int>>& ops) {\r\n        for (vector<int> &op : ops) {\r\n            m = min(m, op[0]); \r\n            n = min(n, op[1]); \r\n        }\r\n        return m * n; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"-374893953\"], \"n\": [\"-94405370\"], \"ops\": [2], \"ops_element0\": [2], \"ops_element0_element0\": [\"-108646326\"], \"ops_element0_element1\": [\"1604448199\"], \"ops_element1\": [1], \"ops_element1_element0\": [\"-765036488\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxCount. /*FC*/class Solution {\n/*FM*/int maxCount(int m, int n, vector<vector<int>>& ops) {\r\n        for (vector<int> &op : ops) {\r\n            \r\n            \r\n        }\r\n        return m * n; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"m\": [\"0\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPlaceFlowers. /*FC*/class Solution {\n/*FM*/bool canPlaceFlowers(vector<int>& flowerbed, int n) {\r\n        for (int i = 0, cnt = 0;  i < flowerbed.size();  ) {\r\n            if ((i == 0 || flowerbed[i - 1] == 0) && flowerbed[i] == 0 && \r\n                (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {\r\n                \r\n                \r\n            }\r\n            if (cnt >= n) {\r\n                return true; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"flowerbed\": [3], \"flowerbed_element0\": [\"-1942053223\"], \"flowerbed_element1\": [\"35840812\"], \"flowerbed_element2\": [\"-934292794\"], \"n\": [\"-454077596\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPlaceFlowers. /*FC*/class Solution {\n/*FM*/bool canPlaceFlowers(vector<int>& flowerbed, int n) {\r\n        for (int i = 0, cnt = 0;  i < flowerbed.size();  i++) {\r\n            if ((i == 0 || flowerbed[i - 1] == 0) && flowerbed[i] == 0 && \r\n                (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {\r\n                \r\n                \r\n            }\r\n            if (cnt >= n) {\r\n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"flowerbed\": [3], \"flowerbed_element0\": [\"-35861275\"], \"flowerbed_element1\": [\"723175454\"], \"flowerbed_element2\": [\"1121126195\"], \"n\": [\"489657366\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string tree2str. /*FC*/class Solution {\n/*FM*/string tree2str(TreeNode* t) {\r\n        if (!t) \r\n        string ans = to_string(t->val); \r\n        if (!t->left && !t->right) {\r\n            return ans; \r\n        }\r\n        ans += \"(\" + tree2str(t->left) + \")\"; \r\n        if (!t->right) {\r\n            \r\n        }\r\n        return ans + \"(\" + tree2str(t->right) + \")\"; \r\n    };/*F*//*C*//*M*/string tree2str(TreeNode* t) {\r\n        if (!t) return \"\"; \r\n        string ans = to_string(t->val); \r\n        if (!t->left && !t->right) {\r\n            return ans; \r\n        }\r\n        ans += \"(\" + tree2str(t->left) + \")\"; \r\n        if (!t->right) {\r\n            return ans; \r\n        }\r\n        return ans + \"(\" + tree2str(t->right) + \")\"; \r\n    } string tree2str(TreeNode* t) {\r\n        if (!t) return \"\"; \r\n        string ans = to_string(t->val); \r\n        if (!t->left && !t->right) {\r\n            return ans; \r\n        }\r\n        ans += \"(\" + tree2str(t->left) + \")\"; \r\n        if (!t->right) {\r\n            return ans; \r\n        }\r\n        return ans + \"(\" + tree2str(t->right) + \")\"; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"t\": [2], \"t[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"t0_x\": [\"-1283746891\"], \"t[0].val\": [\"202367921\"], \"t[0].left\": [1], \"t[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"t0_left0_x\": [\"1402111873\"], \"t[0].left[0].val\": [\"-1653797820\"], \"t[0].right\": [1], \"t[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"t0_right0_x\": [\"1350466513\"], \"t[0].right[0].val\": [\"-218853449\"], \"t[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"t1_x\": [\"1252131113\"], \"t[1].val\": [\"-1292839251\"], \"t[1].right\": [2], \"t[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"t1_right0_x\": [\"980763988\"], \"t[1].right[0].val\": [\"-1359601666\"], \"t[1].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"t1_right1_x\": [\"1979204755\"], \"t[1].right[1].val\": [\"416877341\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string tree2str. /*FC*/class Solution {\n/*FM*/string tree2str(TreeNode* t) {\r\n        if (!t) \r\n        string ans = to_string(t->val); \r\n        if (!t->left && !t->right) {\r\n            return ans; \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/string tree2str(TreeNode* t) {\r\n        if (!t) return \"\"; \r\n        string ans = to_string(t->val); \r\n        if (!t->left && !t->right) {\r\n            return ans; \r\n        }\r\n        ans += \"(\" + tree2str(t->left) + \")\"; \r\n        if (!t->right) {\r\n            return ans; \r\n        }\r\n        return ans + \"(\" + tree2str(t->right) + \")\"; \r\n    } string tree2str(TreeNode* t) {\r\n        if (!t) return \"\"; \r\n        string ans = to_string(t->val); \r\n        if (!t->left && !t->right) {\r\n            return ans; \r\n        }\r\n        ans += \"(\" + tree2str(t->left) + \")\"; \r\n        if (!t->right) {\r\n            return ans; \r\n        }\r\n        return ans + \"(\" + tree2str(t->right) + \")\"; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"t\": [1], \"t[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"t0_x\": [\"0\"], \"t[0].val\": [\"0\"], \"t[0].left\": [0], \"t[0].right\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool enQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool enQueue(int value) {\r\n        if (isFull()) {\r\n            \r\n        }\r\n        v[rear] = value; \r\n        rear = (rear + 1) % v.size(); \r\n        return true; \r\n    };/*F*/vector<int> v;/*C*/MyCircularQueue(int k) : v(k + 1) { };/*M*/bool isFull() {\r\n        return front == (rear + 1) % v.size(); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"330702734\"], \"value\": [\"-1572357786\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool enQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool enQueue(int value) {\r\n        if (isFull()) {\r\n            return false; \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*/MyCircularQueue(int k) : v(k + 1) { };/*M*/bool isFull() {\r\n        return front == (rear + 1) % v.size(); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"0\"], \"value\": [\"-2147483648\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool deQueue. /*FC*/class MyCircularQueue {\n/*FM*/bool deQueue() {\r\n        if (isEmpty()) {\r\n            return false; \r\n        }\r\n        \r\n        \r\n    };/*F*//*C*/MyCircularQueue(int k) : v(k + 1) { };/*M*/bool isEmpty() {\r\n        return front == rear; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"407941708\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int Front. /*FC*/class MyCircularQueue {\n/*FM*/int Front() {\r\n        if (isEmpty()) {\r\n            return -1; \r\n        }\r\n        \r\n    };/*F*//*C*/MyCircularQueue(int k) : v(k + 1) { };/*M*/bool isEmpty() {\r\n        return front == rear; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int Rear. /*FC*/class MyCircularQueue {\n/*FM*/int Rear() {\r\n        if (isEmpty()) {\r\n            return -1; \r\n        }\r\n        \r\n    };/*F*//*C*/MyCircularQueue(int k) : v(k + 1) { };/*M*/bool isEmpty() {\r\n        return front == rear; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___MyCircularQueue\": [\"MyCircularQueue\", \"MyCircularQueue(int)\"], \"AKA_INSTANCE___MyCircularQueue_k\": [\"262142997\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* trimBST. /*FC*/class Solution {\n/*FM*/TreeNode* trimBST(TreeNode* root, int L, int R) {\r\n        if (!root) return NULL; \r\n        if (root->val < L) \r\n        if (root->val > R) \r\n        root->left  = trimBST(root->left,  L, R); \r\n        root->right = trimBST(root->right, L, R); \r\n        return root; \r\n    };/*F*//*C*//*M*/TreeNode* trimBST(TreeNode* root, int L, int R) {\r\n        if (!root) return NULL; \r\n        if (root->val < L) return trimBST(root->right, L, R); \r\n        if (root->val > R) return trimBST(root->left,  L, R); \r\n        root->left  = trimBST(root->left,  L, R); \r\n        root->right = trimBST(root->right, L, R); \r\n        return root; \r\n    } TreeNode* trimBST(TreeNode* root, int L, int R) {\r\n        if (!root) return NULL; \r\n        if (root->val < L) return trimBST(root->right, L, R); \r\n        if (root->val > R) return trimBST(root->left,  L, R); \r\n        root->left  = trimBST(root->left,  L, R); \r\n        root->right = trimBST(root->right, L, R); \r\n        return root; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[0].val\": [\"0\"], \"L\": [\"0\"], \"R\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* trimBST. /*FC*/class Solution {\n/*FM*/TreeNode* trimBST(TreeNode* root, int L, int R) {\r\n        if (!root) return NULL; \r\n        if (root->val < L) \r\n        if (root->val > R) return trimBST(root->left,  L, R); \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/TreeNode* trimBST(TreeNode* root, int L, int R) {\r\n        if (!root) return NULL; \r\n        if (root->val < L) return trimBST(root->right, L, R); \r\n        if (root->val > R) return trimBST(root->left,  L, R); \r\n        root->left  = trimBST(root->left,  L, R); \r\n        root->right = trimBST(root->right, L, R); \r\n        return root; \r\n    } TreeNode* trimBST(TreeNode* root, int L, int R) {\r\n        if (!root) return NULL; \r\n        if (root->val < L) return trimBST(root->right, L, R); \r\n        if (root->val > R) return trimBST(root->left,  L, R); \r\n        root->left  = trimBST(root->left,  L, R); \r\n        root->right = trimBST(root->right, L, R); \r\n        return root; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[0].val\": [\"0\"], \"root[0].left\": [0], \"L\": [\"0\"], \"R\": [\"-1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* trimBST. /*FC*/class Solution {\n/*FM*/TreeNode* trimBST(TreeNode* root, int L, int R) {\r\n        if (!root) return NULL; \r\n        if (root->val < L) return trimBST(root->right, L, R); \r\n        if (root->val > R) \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/TreeNode* trimBST(TreeNode* root, int L, int R) {\r\n        if (!root) return NULL; \r\n        if (root->val < L) return trimBST(root->right, L, R); \r\n        if (root->val > R) return trimBST(root->left,  L, R); \r\n        root->left  = trimBST(root->left,  L, R); \r\n        root->right = trimBST(root->right, L, R); \r\n        return root; \r\n    } TreeNode* trimBST(TreeNode* root, int L, int R) {\r\n        if (!root) return NULL; \r\n        if (root->val < L) return trimBST(root->right, L, R); \r\n        if (root->val > R) return trimBST(root->left,  L, R); \r\n        root->left  = trimBST(root->left,  L, R); \r\n        root->right = trimBST(root->right, L, R); \r\n        return root; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"726\"], \"root[0].val\": [\"335\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-336\"], \"root[0].left[0].val\": [\"-315\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-528\"], \"root[0].right[0].val\": [\"189\"], \"L\": [\"1780763910\"], \"R\": [\"1495039855\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLengthOfLCIS. /*FC*/class Solution {\n/*FM*/int findLengthOfLCIS(vector<int>& nums) {\r\n        int ans = 0; \r\n        for (int i = 0, last = -1;  i < nums.size();  ) {\r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLengthOfLCIS. /*FC*/class Solution {\n/*FM*/int findLengthOfLCIS(vector<int>& nums) {\r\n        int ans = 0; \r\n        for (int i = 0, last = -1;  i < nums.size();  i++) {\r\n            if (i > 0 && nums[i] <= nums[i - 1]) {\r\n                \r\n            }\r\n            ans = max(ans, i - last); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-338\"], \"nums_element1\": [\"374\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validPalindrome. /*FC*/class Solution {\n/*FM*/bool validPalindrome(string s) {\r\n        int i = 0, j = s.size() - 1; \r\n        while (i < j) {\r\n            \r\n            \r\n            \r\n        }\r\n        while (i < j) {\r\n            \r\n            \r\n            \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int calPoints. /*FC*/class Solution {\n/*FM*/int calPoints(vector<string>& ops) {\r\n        vector<int> score; \r\n        for (string &str : ops) {\r\n            \r\n        }\r\n        return accumulate(score.begin(), score.end(), 0); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool judgeCircle. /*FC*/class Solution {\n/*FM*/bool judgeCircle(string moves) {\r\n        int x = 0, y = 0; \r\n        for (char move : moves) {\r\n            switch (move) {\r\n            \r\n                \r\n                \r\n            \r\n                \r\n                \r\n            \r\n                \r\n                \r\n            \r\n                \r\n            }\r\n        }\r\n        return x == 0 && y == 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"moves\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int repeatedStringMatch. /*FC*/class Solution {\n/*FM*/int repeatedStringMatch(string A, string B) {\r\n        int as = A.size(), bs = B.size(); \r\n        string nA = A; \r\n        while (nA.size() < as + bs) {\r\n            nA += A; \r\n        }\r\n        int i = nA.find(B); \r\n        return i != -1 ? (i + bs - 1) / as + 1 : -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"1\"], \"B\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getImportance. /*FC*/class Solution {\n/*FM*/int getImportance(vector<Employee*> employees, int id) {\r\n        unordered_map<int, Employee *> m; \r\n        for (Employee *e : employees) {\r\n            m[e->id] = e; \r\n        }\r\n        return dfs(m, id); \r\n    };/*F*//*C*//*M*/int dfs(unordered_map<int, Employee *> &m, int id) {\r\n        int ans = m[id]->importance; \r\n        for (int sub : m[id]->subordinates) {\r\n            ans += dfs(m, sub); \r\n        }\r\n        return ans; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"employees\": [1], \"id\": [\"576\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getImportance. /*FC*/class Solution {\n/*FM*/int getImportance(vector<Employee*> employees, int id) {\r\n        unordered_map<int, Employee *> m; \r\n        for (Employee *e : employees) {\r\n            \r\n        }\r\n        return dfs(m, id); \r\n    };/*F*//*C*//*M*/int dfs(unordered_map<int, Employee *> &m, int id) {\r\n        int ans = m[id]->importance; \r\n        for (int sub : m[id]->subordinates) {\r\n            ans += dfs(m, sub); \r\n        }\r\n        return ans; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"id\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> topKFrequent. /*FC*/class Solution {\n/*FM*/vector<string> topKFrequent(vector<string>& words, int k) {\r\n        unordered_map<string, int> m; \r\n        for (string &w : words) {\r\n            \r\n        }\r\n        \r\n        auto comp = [&m] (pair<string, int> &pa, pair<string, int> &pb) {\r\n            string &a = pa.first, &b = pb.first; \r\n            return m[a] < m[b] || m[a] == m[b] && a > b; \r\n        }; \r\n        \r\n        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(comp)> q(comp); \r\n        for (auto &p : m) {\r\n            \r\n        }\r\n        \r\n        vector<string> ans(k); \r\n        for (string &w : ans) {\r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> topKFrequent. /*FC*/class Solution {\n/*FM*/vector<string> topKFrequent(vector<string>& words, int k) {\r\n        unordered_map<string, int> m; \r\n        for (string &w : words) {\r\n            m[w]++; \r\n        }\r\n        \r\n        auto comp = [&m] (pair<string, int> &pa, pair<string, int> &pb) {\r\n            string &a = pa.first, &b = pb.first; \r\n            return m[a] < m[b] || m[a] == m[b] && a > b; \r\n        }; \r\n        \r\n        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(comp)> q(comp); \r\n        for (auto &p : m) {\r\n            q.push(p); \r\n        }\r\n        \r\n        vector<string> ans(k); \r\n        for ( : ans) {\r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [2], \"words_element0\": [\"1\"], \"words_element1\": [\"2\"], \"k\": [\"-142481783\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxAreaOfIsland. /*FC*/class Solution {\n/*FM*/int maxAreaOfIsland(vector<vector<int>>& grid) {\r\n        int max_area = 0; \r\n        for (int i = 0;  i < grid.size();  ) {\r\n            \r\n        }\r\n        return max_area; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxAreaOfIsland. /*FC*/class Solution {\n/*FM*/int maxAreaOfIsland(vector<vector<int>>& grid) {\r\n        int max_area = 0; \r\n        for (int i = 0;  i < grid.size();  i++) {\r\n            for (int j = 0;  j < grid[0].size();  j++) {\r\n                if (grid[i][j] == 1) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return max_area; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [1], \"grid_element0\": [2], \"grid_element0_element0\": [\"220\"], \"grid_element0_element1\": [\"798\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countBinarySubstrings. /*FC*/class Solution {\n/*FM*/int countBinarySubstrings(string s) {\r\n        int ans = 0, per = 0, cur = 1; \r\n        for (int i = 1;  i < s.size();  ) {\r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* searchBST. /*FC*/class Solution {\n/*FM*/TreeNode* searchBST(TreeNode* root, int val) {\r\n        if (!root) \r\n        if (root->val > val) \r\n        if (root->val < val) \r\n        return root; \r\n    };/*F*//*C*//*M*/TreeNode* searchBST(TreeNode* root, int val) {\r\n        if (!root) return NULL; \r\n        if (root->val > val) return searchBST(root->left, val); \r\n        if (root->val < val) return searchBST(root->right, val); \r\n        return root; \r\n    } TreeNode* searchBST(TreeNode* root, int val) {\r\n        if (!root) return NULL; \r\n        if (root->val > val) return searchBST(root->left, val); \r\n        if (root->val < val) return searchBST(root->right, val); \r\n        return root; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[0].val\": [\"0\"], \"val\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* searchBST. /*FC*/class Solution {\n/*FM*/TreeNode* searchBST(TreeNode* root, int val) {\r\n        if (!root) return NULL; \r\n        if (root->val > val) return searchBST(root->left, val); \r\n        if (root->val < val) return searchBST(root->right, val); \r\n        \r\n    };/*F*//*C*//*M*/TreeNode* searchBST(TreeNode* root, int val) {\r\n        if (!root) return NULL; \r\n        if (root->val > val) return searchBST(root->left, val); \r\n        if (root->val < val) return searchBST(root->right, val); \r\n        return root; \r\n    } TreeNode* searchBST(TreeNode* root, int val) {\r\n        if (!root) return NULL; \r\n        if (root->val > val) return searchBST(root->left, val); \r\n        if (root->val < val) return searchBST(root->right, val); \r\n        return root; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-739\"], \"root[0].val\": [\"-1442548997\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"446\"], \"root[0].left[0].val\": [\"-2047349888\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"212\"], \"root[0].left[1].val\": [\"-742828808\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"399\"], \"root[0].right[0].val\": [\"2036094878\"], \"val\": [\"1893670241\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* insertIntoBST. /*FC*/class Solution {\n/*FM*/TreeNode* insertIntoBST(TreeNode* root, int val) {\r\n        if (!root) return new TreeNode(val); \r\n        if (root->val > val) {\r\n            \r\n        } else {\r\n            root->right = insertIntoBST(root->right, val); \r\n        }\r\n        return root; \r\n    };/*F*//*C*//*M*/TreeNode* insertIntoBST(TreeNode* root, int val) {\r\n        if (!root) return new TreeNode(val); \r\n        if (root->val > val) {\r\n            root->left = insertIntoBST(root->left, val); \r\n        } else {\r\n            root->right = insertIntoBST(root->right, val); \r\n        }\r\n        return root; \r\n    } TreeNode* insertIntoBST(TreeNode* root, int val) {\r\n        if (!root) return new TreeNode(val); \r\n        if (root->val > val) {\r\n            root->left = insertIntoBST(root->left, val); \r\n        } else {\r\n            root->right = insertIntoBST(root->right, val); \r\n        }\r\n        return root; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-937\"], \"root[0].val\": [\"-853\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-324\"], \"root[0].left[0].val\": [\"832\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"1\"], \"root[0].left[1].val\": [\"-569\"], \"val\": [\"-506\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* insertIntoBST. /*FC*/class Solution {\n/*FM*/TreeNode* insertIntoBST(TreeNode* root, int val) {\r\n        if (!root) return new TreeNode(val); \r\n        if (root->val > val) {\r\n            root->left = insertIntoBST(root->left, val); \r\n        } else {\r\n            \r\n        }\r\n        return root; \r\n    };/*F*//*C*//*M*/TreeNode* insertIntoBST(TreeNode* root, int val) {\r\n        if (!root) return new TreeNode(val); \r\n        if (root->val > val) {\r\n            root->left = insertIntoBST(root->left, val); \r\n        } else {\r\n            root->right = insertIntoBST(root->right, val); \r\n        }\r\n        return root; \r\n    } TreeNode* insertIntoBST(TreeNode* root, int val) {\r\n        if (!root) return new TreeNode(val); \r\n        if (root->val > val) {\r\n            root->left = insertIntoBST(root->left, val); \r\n        } else {\r\n            root->right = insertIntoBST(root->right, val); \r\n        }\r\n        return root; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"943\"], \"root[0].val\": [\"510\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-571\"], \"root[0].right[0].val\": [\"256\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"580\"], \"root[0].right[1].val\": [\"375\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"605\"], \"root[1].val\": [\"38\"], \"root[1].left\": [2], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"-854\"], \"root[1].left[0].val\": [\"-718\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left1_x\": [\"-322\"], \"root[1].left[1].val\": [\"325\"], \"root[1].right\": [1], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_right0_x\": [\"243\"], \"root[1].right[0].val\": [\"-990\"], \"val\": [\"-807\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int add. /*FC*/class KthLargest {\n/*FM*/int add(int val) {\r\n        q.push(val); \r\n        if (q.size() > k) {\r\n            \r\n        }\r\n        return q.top(); \r\n    };/*F*/int k;  priority_queue<int, vector<int>, greater<int>> q;/*C*/KthLargest(int k, vector<int>& nums) : k(k) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___KthLargest\": [\"KthLargest\", \"KthLargest(int,vector<int>&)\"], \"AKA_INSTANCE___KthLargest_k\": [\"210\"], \"AKA_INSTANCE___KthLargest_nums\": [1], \"AKA_INSTANCE___KthLargest_nums_element0\": [\"-577\"], \"val\": [\"-205\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int add. /*FC*/class KthLargest {\n/*FM*/int add(int val) {\r\n        q.push(val); \r\n        if (q.size() > k) {\r\n            q.pop(); \r\n        }\r\n        return q.top(); \r\n    };/*F*/int k;  priority_queue<int, vector<int>, greater<int>> q;/*C*/KthLargest(int k, vector<int>& nums) : k(k) { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___KthLargest\": [\"KthLargest\", \"KthLargest(int,vector<int>&)\", \"STLListBaseType\"], \"AKA_INSTANCE___KthLargest_k\": [\"0\"], \"val\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& nums, int target) {\r\n        int lo = 0, hi = nums.size() - 1; \r\n        while (lo <= hi) {\r\n            int mid = (lo + hi) / 2; \r\n            if (nums[mid] < target) {\r\n                lo = mid + 1; \r\n            } else if (nums[mid] > target) {\r\n                hi = mid - 1; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-705\"], \"nums_element1\": [\"522\"], \"target\": [\"-57\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& nums, int target) {\r\n        int lo = 0, hi = nums.size() - 1; \r\n        while (lo <= hi) {\r\n            \r\n            \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string toLowerCase. /*FC*/class Solution {\n/*FM*/string toLowerCase(string str) {\r\n        for (char &ch : str) {\r\n            if (isupper(ch)) {\r\n                \r\n            }\r\n        }\r\n        return str; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string toLowerCase. /*FC*/class Solution {\n/*FM*/string toLowerCase(string str) {\r\n        for (char &ch : str) {\r\n            if (isupper(ch)) {\r\n                ch += 'a' - 'A'; \r\n            }\r\n        }\r\n        return str; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"str\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pivotIndex. /*FC*/class Solution {\n/*FM*/int pivotIndex(vector<int>& nums) {\r\n        int left_sum = 0, sum = accumulate(nums.begin(), nums.end(), 0); \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (left_sum * 2 + nums[i] == sum) {\r\n                \r\n            }\r\n            left_sum += nums[i]; \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-394\"], \"nums_element1\": [\"15\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int pivotIndex. /*FC*/class Solution {\n/*FM*/int pivotIndex(vector<int>& nums) {\r\n        int left_sum = 0, sum = accumulate(nums.begin(), nums.end(), 0); \r\n        for (int i = 0;  i < nums.size();  ) {\r\n            if (left_sum * 2 + nums[i] == sum) {\r\n                return i; \r\n            }\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"386\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<ListNode*> splitListToParts. /*FC*/class Solution {\n/*FM*/vector<ListNode*> splitListToParts(ListNode* root, int k) {\r\n        int size = 0; \r\n        ListNode *pi = root; \r\n        while (pi) {\r\n            size++; \r\n            pi = pi->next; \r\n        }\r\n        \r\n        vector<ListNode *> ans(k); \r\n        for (int i = 0;  i < k;  i++) {\r\n            if (!root) break; \r\n            ans[i] = pi = root; \r\n            for (int j = 0;  j < size / k - (i < size % k ? 0 : 1);  ) {\r\n                \r\n            }\r\n            root = pi->next; \r\n            pi->next = NULL; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"ListNode\", \"ListNode(int)\"], \"root0_x\": [\"752\"], \"root[1]\": [\"ListNode\", \"ListNode(int)\"], \"root1_x\": [\"612\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<ListNode*> splitListToParts. /*FC*/class Solution {\n/*FM*/vector<ListNode*> splitListToParts(ListNode* root, int k) {\r\n        int size = 0; \r\n        ListNode *pi = root; \r\n        while (pi) {\r\n            size++; \r\n            pi = pi->next; \r\n        }\r\n        \r\n        vector<ListNode *> ans(k); \r\n        for (int i = 0;  i < k;  i++) {\r\n            if (!root) \r\n            ans[i] = pi = root; \r\n            for (int j = 0;  j < size / k - (i < size % k ? 0 : 1);  ) {\r\n                \r\n            }\r\n            root = pi->next; \r\n            pi->next = NULL; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"ListNode\", \"ListNode(int)\"], \"root0_x\": [\"0\"], \"root[0].next\": [0], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<ListNode*> splitListToParts. /*FC*/class Solution {\n/*FM*/vector<ListNode*> splitListToParts(ListNode* root, int k) {\r\n        int size = 0; \r\n        ListNode *pi = root; \r\n        while (pi) {\r\n            \r\n            \r\n        }\r\n        \r\n        vector<ListNode *> ans(k); \r\n        for (int i = 0;  i < k;  ) {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> selfDividingNumbers. /*FC*/class Solution {\n/*FM*/vector<int> selfDividingNumbers(int left, int right) {\r\n        vector<int> ans; \r\n        for (int i = left;  i <= right;  i++) {\r\n            int n = i; \r\n            while (n % 10 && i % (n % 10) == 0) {\r\n                n /= 10; \r\n            }\r\n            if (n == 0) {\r\n                ans.push_back(i); \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"left\": [\"0\"], \"right\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> asteroidCollision. /*FC*/class Solution {\n/*FM*/vector<int> asteroidCollision(vector<int>& asteroids) {\r\n        vector<int> s; \r\n        for (int ast : asteroids) {\r\n            \r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> asteroidCollision. /*FC*/class Solution {\n/*FM*/vector<int> asteroidCollision(vector<int>& asteroids) {\r\n        vector<int> s; \r\n        for (int ast : asteroids) {\r\n            if (ast < 0) {\r\n                while (!s.empty() && 0 < s.back() && s.back() < -ast) {\r\n                    \r\n                }\r\n                if (s.empty() || s.back() < 0) {\r\n                    s.push_back(ast); \r\n                } else if (s.back() == -ast) {\r\n                    \r\n                }\r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"asteroids\": [2], \"asteroids_element0\": [\"-141\"], \"asteroids_element1\": [\"-874\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> asteroidCollision. /*FC*/class Solution {\n/*FM*/vector<int> asteroidCollision(vector<int>& asteroids) {\r\n        vector<int> s; \r\n        for (int ast : asteroids) {\r\n            if (ast < 0) {\r\n                \r\n                if (s.empty() || s.back() < 0) {\r\n                    \r\n                } else if (s.back() == -ast) {\r\n                    \r\n                }\r\n            } else {\r\n                s.push_back(ast); \r\n            }\r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"asteroids\": [1], \"asteroids_element0\": [\"744\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minCostClimbingStairs. /*FC*/class Solution {\n/*FM*/int minCostClimbingStairs(vector<int>& cost) {\r\n        vector<int> dp(2); \r\n        for (int i = 0;  i < cost.size();  i++) {\r\n            dp[i % 2] = min(dp[0], dp[1]) + cost[i]; \r\n        }\r\n        return min(dp[0], dp[1]); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"cost\": [2], \"cost_element0\": [\"-739\"], \"cost_element1\": [\"-225\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dominantIndex. /*FC*/class Solution {\n/*FM*/int dominantIndex(vector<int>& nums) {\r\n        int max_idx = 0; \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (nums[i] > nums[max_idx]) {\r\n                max_idx = i; \r\n            }\r\n        }\r\n        for (int i = 0;  i < nums.size();  ) {\r\n            if (i != max_idx && nums[i] * 2 > nums[max_idx]) {\r\n                return -1; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"229\"], \"nums_element1\": [\"396\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int dominantIndex. /*FC*/class Solution {\n/*FM*/int dominantIndex(vector<int>& nums) {\r\n        int max_idx = 0; \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (nums[i] > nums[max_idx]) {\r\n                max_idx = i; \r\n            }\r\n        }\r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (i != max_idx && nums[i] * 2 > nums[max_idx]) {\r\n                \r\n            }\r\n        }\r\n        return max_idx; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [2], \"nums_element0\": [\"-678\"], \"nums_element1\": [\"573\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string shortestCompletingWord. /*FC*/class Solution {\n/*FM*/string shortestCompletingWord(string licensePlate, vector<string>& words) {\r\n        vector<int> ht1(26); \r\n        for (char ch : licensePlate) {\r\n            if (isalpha(ch)) {\r\n                \r\n            }\r\n        }\r\n        \r\n        int wi = -1; \r\n        for (int i = 0, j;  i < words.size();  i++) {\r\n            if (wi != -1 && words[i].size() >= words[wi].size()) {\r\n                continue; \r\n            }\r\n            \r\n            vector<int> ht2(26); \r\n            for (char ch : words[i]) {\r\n                ht2[ch - 'a']++; \r\n            }\r\n            \r\n            for (j = 0;  j < 26;  j++) {\r\n                if (ht1[j] > ht2[j]) {\r\n                    \r\n                }\r\n            }\r\n            if (j >= 26) {\r\n                wi = i; \r\n            }\r\n        }\r\n        return words[wi]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"licensePlate\": [\"2\"], \"words\": [2], \"words_element0\": [\"1\"], \"words_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reachNumber. /*FC*/class Solution {\n/*FM*/int reachNumber(int target) {\r\n        target = abs(target); \r\n        int sum = 0, step = 0; \r\n        while (sum < target || (sum - target) % 2) {\r\n            sum += ++step; \r\n        }\r\n        return step; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"target\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isToeplitzMatrix. /*FC*/class Solution {\n/*FM*/bool isToeplitzMatrix(vector<vector<int>>& matrix) {\r\n        for (int i = 0;  i < matrix.size() - 1;  i++) {\r\n            for (int j = 0;  j < matrix[0].size() - 1;  ) {\r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [1], \"matrix_element0_element0\": [\"652\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"853\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isToeplitzMatrix. /*FC*/class Solution {\n/*FM*/bool isToeplitzMatrix(vector<vector<int>>& matrix) {\r\n        for (int i = 0;  i < matrix.size() - 1;  ) {\r\n            for (int j = 0;  j < matrix[0].size() - 1;  ) {\r\n                if (matrix[i][j] != matrix[i + 1][j + 1]) {\r\n                    return false; \r\n                }\r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-509\"], \"matrix_element0_element1\": [\"936\"], \"matrix_element1\": [1], \"matrix_element1_element0\": [\"-79\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numJewelsInStones. /*FC*/class Solution {\n/*FM*/int numJewelsInStones(string J, string S) {\r\n        vector<bool> ht(128); \r\n        for (char &ch : J) {\r\n            ht[ch] = true; \r\n        }\r\n        int cnt = 0; \r\n        for (char &ch : S) {\r\n            if (ht[ch]) {\r\n                \r\n            }\r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"J\": [\"1\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numJewelsInStones. /*FC*/class Solution {\n/*FM*/int numJewelsInStones(string J, string S) {\r\n        vector<bool> ht(128); \r\n        for (char &ch : J) {\r\n            ht[ch] = true; \r\n        }\r\n        int cnt = 0; \r\n        for (char &ch : S) {\r\n            if (ht[ch]) {\r\n                cnt++; \r\n            }\r\n        }\r\n        return cnt; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"J\": [\"2\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rotatedDigits. /*FC*/class Solution {\n/*FM*/int rotatedDigits(int N) {\r\n        int count = 0; \r\n        for (int i = 1;  i <= N;  i++) {\r\n            int num = i; \r\n            bool changed = false; \r\n            while (num) {\r\n                int rem = num % 10; \r\n                if (rem == 3 || rem == 4 || rem == 7) {\r\n                    break; \r\n                }\r\n                changed |= rem == 2 || rem == 5 ||\r\n                    rem == 6 || rem == 9; \r\n                num /= 10; \r\n            }\r\n            if (changed && !num) {\r\n                count++; \r\n            }\r\n        }\r\n        return count; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniqueMorseRepresentations. /*FC*/class Solution {\n/*FM*/int uniqueMorseRepresentations(vector<string>& words) {\r\n        unordered_set<string> s; \r\n        for (string &word : words) {\r\n            \r\n            for ( : word) {\r\n                \r\n            }\r\n            \r\n        }\r\n        return s.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniqueMorseRepresentations. /*FC*/class Solution {\n/*FM*/int uniqueMorseRepresentations(vector<string>& words) {\r\n        unordered_set<string> s; \r\n        for (string &word : words) {\r\n            string morse; \r\n            for (char ch : word) {\r\n                morse += e2m[ch - 'a']; \r\n            }\r\n            s.insert(morse); \r\n        }\r\n        return s.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [1], \"words_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxIncreaseKeepingSkyline. /*FC*/class Solution {\n/*FM*/int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {\r\n        int n = grid.size(); \r\n        vector<int> h(n), v(n); \r\n        for (int i = 0;  i < n;  i++) {\r\n            for (int j = 0;  j < n;  j++) {\r\n                h[i] = max(h[i], grid[i][j]); \r\n                v[j] = max(v[j], grid[i][j]); \r\n            }\r\n        }\r\n        \r\n        int ans = 0; \r\n        for (int i = 0;  i < n;  i++) {\r\n            for (int j = 0;  j < n;  j++) {\r\n                ans += min(h[i], v[j]) - grid[i][j]; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"-936\"], \"grid_element0_element1\": [\"-789\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"992\"], \"grid_element1_element1\": [\"-953\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxIncreaseKeepingSkyline. /*FC*/class Solution {\n/*FM*/int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {\r\n        int n = grid.size(); \r\n        vector<int> h(n), v(n); \r\n        for (int i = 0;  i < n;  ) {\r\n            \r\n        }\r\n        \r\n        int ans = 0; \r\n        for (int i = 0;  i < n;  ) {\r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> subdomainVisits. /*FC*/class Solution {\n/*FM*/vector<string> subdomainVisits(vector<string>& cpdomains) {\r\n        unordered_map<string, int> m; \r\n        for (string &d : cpdomains) {\r\n            \r\n            \r\n        }\r\n        \r\n        vector<string> ans(m.size()); \r\n        int i = 0; \r\n        for (auto &[k, v] : m) {\r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string toGoatLatin. /*FC*/class Solution {\n/*FM*/string toGoatLatin(string S) {\r\n        istringstream iss(S); \r\n        string ans, buf, a; \r\n        while (iss >> buf) {\r\n            if (vowels.find(buf[0]) != vowels.end()) {\r\n                \r\n            } else {\r\n                ans += buf.substr(1); \r\n                ans += buf[0]; \r\n            }\r\n            ans += \"ma\"; \r\n            ans += a += \"a\"; \r\n            ans += \" \"; \r\n        }\r\n        ans.pop_back(); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string toGoatLatin. /*FC*/class Solution {\n/*FM*/string toGoatLatin(string S) {\r\n        istringstream iss(S); \r\n        string ans, buf, a; \r\n        while (iss >> buf) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        ans.pop_back(); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> flipAndInvertImage. /*FC*/class Solution {\n/*FM*/vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\r\n        for (vector<int> &row : A) {\r\n            \r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> flipAndInvertImage. /*FC*/class Solution {\n/*FM*/vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\r\n        for (vector<int> &row : A) {\r\n            for (int i = 0;  i < (row.size() + 1) / 2;  i++) {\r\n                if (row[i] == row[row.size() - i - 1]) {\r\n                    row[i] = 1 - row[i]; \r\n                    row[row.size() - i - 1] = row[i]; \r\n                }\r\n            }\r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A_element0\": [1], \"A_element0_element0\": [\"3736803\"], \"A_element1\": [2], \"A_element1_element0\": [\"1975979610\"], \"A_element1_element1\": [\"933274166\"], \"A_element2\": [1], \"A_element2_element0\": [\"1661686215\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int scoreOfParentheses. /*FC*/class Solution {\n/*FM*/int scoreOfParentheses(string S) {\r\n        int ans = 0, open = 0; \r\n        for (int i = 0;  i < S.size();  i++) {\r\n            if (S[i] == '(') {\r\n                open++; \r\n            } else {\r\n                \r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int scoreOfParentheses. /*FC*/class Solution {\n/*FM*/int scoreOfParentheses(string S) {\r\n        int ans = 0, open = 0; \r\n        for (int i = 0;  i < S.size();  i++) {\r\n            if (S[i] == '(') {\r\n                \r\n            } else {\r\n                open--; \r\n                if (S[i - 1] == '(') {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool buddyStrings. /*FC*/class Solution {\n/*FM*/bool buddyStrings(string A, string B) {\r\n        if (A.size() != B.size()) \r\n        vector<int> ht(26); \r\n        bool sp = false, dp = false; \r\n        for (int i = 0, last = -1;  i < A.size();  i++) {\r\n            if (A[i] != B[i]) {\r\n                if (last < 0) {\r\n                    last = i; \r\n                } else if (!dp && A[last] == B[i] && A[i] == B[last]) {\r\n                    \r\n                } else {\r\n                    \r\n                }\r\n            } else if (!sp && last < 0 && ++ht[A[i] - 'a'] >= 2) {\r\n                \r\n            }\r\n        }\r\n        return dp || sp; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"1\"], \"B\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool buddyStrings. /*FC*/class Solution {\n/*FM*/bool buddyStrings(string A, string B) {\r\n        if (A.size() != B.size()) \r\n        vector<int> ht(26); \r\n        bool sp = false, dp = false; \r\n        for (int i = 0, last = -1;  i < A.size();  ) {\r\n            \r\n        }\r\n        return dp || sp; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [\"5\"], \"B\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool lemonadeChange. /*FC*/class Solution {\n/*FM*/bool lemonadeChange(vector<int>& bills) {\r\n        int c5 = 0, c10 = 0; \r\n        for (int b : bills) {\r\n            switch (b) {\r\n            \r\n                \r\n                \r\n            \r\n                \r\n                \r\n            \r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"bills\": [1], \"bills_element0\": [\"559916457\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> transpose. /*FC*/class Solution {\n/*FM*/vector<vector<int>> transpose(vector<vector<int>>& A) {\r\n        vector<vector<int>> ans(A[0].size(), vector<int>(A.size())); \r\n        for (int i = 0;  i < ans.size();  i++) {\r\n            for (int j = 0;  j < ans[0].size();  j++) {\r\n                ans[i][j] = A[j][i]; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [2], \"A_element0_element0\": [\"453\"], \"A_element0_element1\": [\"499\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int binaryGap. /*FC*/class Solution {\n/*FM*/int binaryGap(int N) {\r\n        int max_gap = 0; \r\n        for (int i = 0, last = -1;  i < 8 * sizeof(int);  i++) {\r\n            if (N >> i & 1) {\r\n                if (last >= 0) {\r\n                    max_gap = max(max_gap, i - last); \r\n                }\r\n                last = i; \r\n            }\r\n        }\r\n        return max_gap; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"-625603722\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode* middleNode. /*FC*/class Solution {\n/*FM*/ListNode* middleNode(ListNode* head) {\r\n        ListNode *slow = head, *fast = head; \r\n        while (fast && fast->next) {\r\n            \r\n            \r\n        }\r\n        return slow; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSpecialEquivGroups. /*FC*/class Solution {\n/*FM*/int numSpecialEquivGroups(vector<string>& A) {\r\n        unordered_set<string> s; \r\n        for (string &a : A) {\r\n            string odd, even; \r\n            for (int i = 0;  i < a.size();  i++) {\r\n                (i % 2 ? odd : even) += a[i]; \r\n            }\r\n            sort(odd.begin(), odd.end()); \r\n            sort(even.begin(), even.end()); \r\n            s.insert(odd + even); \r\n        }\r\n        return s.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"2\"], \"A_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSpecialEquivGroups. /*FC*/class Solution {\n/*FM*/int numSpecialEquivGroups(vector<string>& A) {\r\n        unordered_set<string> s; \r\n        for (string &a : A) {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return s.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isMonotonic. /*FC*/class Solution {\n/*FM*/bool isMonotonic(vector<int>& A) {\r\n        bool inc = false, dec = false; \r\n        for (int i = 0;  i < A.size() - 1;  i++) {\r\n            inc |= A[i] < A[i + 1]; \r\n            dec |= A[i] > A[i + 1]; \r\n            if (inc && dec) {\r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-660\"], \"A_element1\": [\"-329\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int subarrayBitwiseORs. /*FC*/class Solution {\n/*FM*/int subarrayBitwiseORs(vector<int>& A) {\r\n        unordered_set<int> s; \r\n        int max_val = 0; \r\n        for (int a : A) {\r\n            max_val |= a; \r\n            s.insert(max_val); \r\n        }\r\n        for (int i = 1;  i < A.size();  i++) {\r\n            for (int j = i, val = 0;  j < A.size();  j++) {\r\n                val |= A[j]; \r\n                if (val == max_val) {\r\n                    \r\n                }\r\n                s.insert(val); \r\n            }\r\n        }\r\n        return s.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"-765\"], \"A_element1\": [\"-118\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int subarrayBitwiseORs. /*FC*/class Solution {\n/*FM*/int subarrayBitwiseORs(vector<int>& A) {\r\n        unordered_set<int> s; \r\n        int max_val = 0; \r\n        for (int a : A) {\r\n            \r\n            \r\n        }\r\n        for (int i = 1;  i < A.size();  ) {\r\n            \r\n        }\r\n        return s.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortArrayByParity. /*FC*/class Solution {\n/*FM*/vector<int> sortArrayByParity(vector<int>& A) {\r\n        for (int i = 0, j = 0;  i < A.size();  i++) {\r\n            if (A[i] % 2 == 0) {\r\n                \r\n            }\r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"735\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortArrayByParity. /*FC*/class Solution {\n/*FM*/vector<int> sortArrayByParity(vector<int>& A) {\r\n        for (int i = 0, j = 0;  i < A.size();  i++) {\r\n            if (A[i] % 2 == 0) {\r\n                swap(A[i], A[j++]); \r\n            }\r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"846\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isLongPressedName. /*FC*/class Solution {\n/*FM*/bool isLongPressedName(string name, string typed) {\r\n        if (typed.size() < name.size()) \r\n        if (name[0] != typed[0] || name.back() != typed.back()) \r\n        \r\n        name += \"#\"; \r\n        typed += \"#\"; \r\n        \r\n        int i = 1, j = 1; \r\n        while (i < name.size() && j < typed.size()) {\r\n            \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"name\": [\"2\"], \"typed\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isLongPressedName. /*FC*/class Solution {\n/*FM*/bool isLongPressedName(string name, string typed) {\r\n        if (typed.size() < name.size()) \r\n        if (name[0] != typed[0] || name.back() != typed.back()) return false; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"name\": [\"2\"], \"typed\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isLongPressedName. /*FC*/class Solution {\n/*FM*/bool isLongPressedName(string name, string typed) {\r\n        if (typed.size() < name.size()) \r\n        if (name[0] != typed[0] || name.back() != typed.back()) \r\n        \r\n        name += \"#\"; \r\n        typed += \"#\"; \r\n        \r\n        int i = 1, j = 1; \r\n        while (i < name.size() && j < typed.size()) {\r\n            if (name[i] == typed[j]) {\r\n                i++; \r\n                j++; \r\n            } else if (typed[j] == typed[j - 1]) {\r\n                \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"name\": [\"2\"], \"typed\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numUniqueEmails. /*FC*/class Solution {\n/*FM*/int numUniqueEmails(vector<string>& emails) {\r\n        unordered_set<string> s; \r\n        for (string &email : emails) {\r\n            string format; \r\n            bool plus = false, at = false; \r\n            for (char ch : email) {\r\n                plus |= ch == '+'; \r\n                at   |= ch == '@'; \r\n                if (at || !plus && ch != '.') {\r\n                    format += ch; \r\n                }\r\n            }\r\n            s.insert(format); \r\n        }\r\n        return s.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"emails\": [2], \"emails_element0\": [\"1\"], \"emails_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int ping. /*FC*/class RecentCounter {\n/*FM*/int ping(int t) {\r\n        q.push(t); \r\n        while (q.front() + 3000 < t) {\r\n            \r\n        }\r\n        return q.size(); \r\n    };/*F*/queue<int> q;/*C*/RecentCounter() { };/*M*/\n}",
        "target": "{\"AKA_INSTANCE___RecentCounter\": [\"RecentCounter\", \"RecentCounter()\"], \"t\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rangeSumBST. /*FC*/class Solution {\n/*FM*/int rangeSumBST(TreeNode* root, int L, int R) {\r\n        if (!root) return 0; \r\n        if (root->val < L) return rangeSumBST(root->right, L, R); \r\n        if (root->val > R) \r\n        \r\n    };/*F*//*C*//*M*/int rangeSumBST(TreeNode* root, int L, int R) {\r\n        if (!root) return 0; \r\n        if (root->val < L) return rangeSumBST(root->right, L, R); \r\n        if (root->val > R) return rangeSumBST(root->left, L, R); \r\n        return root->val + rangeSumBST(root->right, L, R) + rangeSumBST(root->left, L, R); \r\n    } int rangeSumBST(TreeNode* root, int L, int R) {\r\n        if (!root) return 0; \r\n        if (root->val < L) return rangeSumBST(root->right, L, R); \r\n        if (root->val > R) return rangeSumBST(root->left, L, R); \r\n        return root->val + rangeSumBST(root->right, L, R) + rangeSumBST(root->left, L, R); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"114\"], \"root[0].val\": [\"309\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-31\"], \"root[0].right[0].val\": [\"186\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"922\"], \"root[0].right[1].val\": [\"-889\"], \"L\": [\"2050799931\"], \"R\": [\"-1099661517\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rangeSumBST. /*FC*/class Solution {\n/*FM*/int rangeSumBST(TreeNode* root, int L, int R) {\r\n        if (!root) return 0; \r\n        if (root->val < L) \r\n        if (root->val > R) \r\n        return root->val + rangeSumBST(root->right, L, R) + rangeSumBST(root->left, L, R); \r\n    };/*F*//*C*//*M*/int rangeSumBST(TreeNode* root, int L, int R) {\r\n        if (!root) return 0; \r\n        if (root->val < L) return rangeSumBST(root->right, L, R); \r\n        if (root->val > R) return rangeSumBST(root->left, L, R); \r\n        return root->val + rangeSumBST(root->right, L, R) + rangeSumBST(root->left, L, R); \r\n    } int rangeSumBST(TreeNode* root, int L, int R) {\r\n        if (!root) return 0; \r\n        if (root->val < L) return rangeSumBST(root->right, L, R); \r\n        if (root->val > R) return rangeSumBST(root->left, L, R); \r\n        return root->val + rangeSumBST(root->right, L, R) + rangeSumBST(root->left, L, R); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"610\"], \"root[0].val\": [\"539\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-443\"], \"root[0].right[0].val\": [\"-761\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"314\"], \"root[0].right[1].val\": [\"291\"], \"L\": [\"-1600919026\"], \"R\": [\"418698231\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int rangeSumBST. /*FC*/class Solution {\n/*FM*/int rangeSumBST(TreeNode* root, int L, int R) {\r\n        if (!root) return 0; \r\n        if (root->val < L) \r\n        if (root->val > R) return rangeSumBST(root->left, L, R); \r\n        \r\n    };/*F*//*C*//*M*/int rangeSumBST(TreeNode* root, int L, int R) {\r\n        if (!root) return 0; \r\n        if (root->val < L) return rangeSumBST(root->right, L, R); \r\n        if (root->val > R) return rangeSumBST(root->left, L, R); \r\n        return root->val + rangeSumBST(root->right, L, R) + rangeSumBST(root->left, L, R); \r\n    } int rangeSumBST(TreeNode* root, int L, int R) {\r\n        if (!root) return 0; \r\n        if (root->val < L) return rangeSumBST(root->right, L, R); \r\n        if (root->val > R) return rangeSumBST(root->left, L, R); \r\n        return root->val + rangeSumBST(root->right, L, R) + rangeSumBST(root->left, L, R); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"0\"], \"root[0].val\": [\"0\"], \"root[0].left\": [0], \"L\": [\"0\"], \"R\": [\"-1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validMountainArray. /*FC*/class Solution {\n/*FM*/bool validMountainArray(vector<int>& A) {\r\n        if (A.size() < 3) return false; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"-810\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> diStringMatch. /*FC*/class Solution {\n/*FM*/vector<int> diStringMatch(string S) {\r\n        int ss = S.size(), min = 0, max = ss; \r\n        vector<int> ans(ss + 1); \r\n        for (int i = 0;  i < ss;  ) {\r\n            \r\n        }\r\n        ans[ss] = max; \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> diStringMatch. /*FC*/class Solution {\n/*FM*/vector<int> diStringMatch(string S) {\r\n        int ss = S.size(), min = 0, max = ss; \r\n        vector<int> ans(ss + 1); \r\n        for (int i = 0;  i < ss;  i++) {\r\n            ans[i] = S[i] == 'I' ? min++ : max--; \r\n        }\r\n        ans[ss] = max; \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDeletionSize. /*FC*/class Solution {\n/*FM*/int minDeletionSize(vector<string>& A) {\r\n        int count = 0; \r\n        for (int j = 0;  j < A[0].size();  j++) {\r\n            for (int i = 0;  i < A.size() - 1;  ) {\r\n                if (A[i][j] > A[i + 1][j]) {\r\n                    count++; \r\n                    break; \r\n                }\r\n            }\r\n        }\r\n        return count; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"1\"], \"A_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> deckRevealedIncreasing. /*FC*/class Solution {\n/*FM*/vector<int> deckRevealedIncreasing(vector<int>& deck) {\r\n        int ds = deck.size(); \r\n        queue<int> q; \r\n        for (int i = 0;  i < ds;  i++) {\r\n            q.push(i); \r\n        }\r\n        \r\n        sort(deck.begin(), deck.end()); \r\n        vector<int> ans(ds); \r\n        for (int i = 0;  i < ds - 1;  i++) {\r\n            ans[q.front()] = deck[i]; \r\n            q.pop(); \r\n            q.push(q.front()); \r\n            q.pop(); \r\n        }\r\n        ans[q.front()] = deck.back(); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"deck\": [2], \"deck_element0\": [\"442\"], \"deck_element1\": [\"778\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUnivalTree. /*FC*/class Solution {\n/*FM*/bool isUnivalTree(TreeNode* root) {\r\n        if (!root->left && !root->right) return true; \r\n        bool ans = true; \r\n        if (root->left) {\r\n            ans &= isUnivalTree(root->left); \r\n            ans &= root->val == root->left->val; \r\n        }\r\n        if (root->right) {\r\n            ans &= isUnivalTree(root->right); \r\n            ans &= root->val == root->right->val; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/bool isUnivalTree(TreeNode* root) {\r\n        if (!root->left && !root->right) return true; \r\n        bool ans = true; \r\n        if (root->left) {\r\n            ans &= isUnivalTree(root->left); \r\n            ans &= root->val == root->left->val; \r\n        }\r\n        if (root->right) {\r\n            ans &= isUnivalTree(root->right); \r\n            ans &= root->val == root->right->val; \r\n        }\r\n        return ans; \r\n    } bool isUnivalTree(TreeNode* root) {\r\n        if (!root->left && !root->right) return true; \r\n        bool ans = true; \r\n        if (root->left) {\r\n            ans &= isUnivalTree(root->left); \r\n            ans &= root->val == root->left->val; \r\n        }\r\n        if (root->right) {\r\n            ans &= isUnivalTree(root->right); \r\n            ans &= root->val == root->right->val; \r\n        }\r\n        return ans; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-18\"], \"root[0].val\": [\"674\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"-558\"], \"root[0].left[0].val\": [\"441\"], \"root[0].right\": [2], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"-33\"], \"root[0].right[0].val\": [\"27\"], \"root[0].right[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right1_x\": [\"544\"], \"root[0].right[1].val\": [\"-75\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"983\"], \"root[1].val\": [\"-149\"], \"root[1].left\": [1], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"125\"], \"root[1].left[0].val\": [\"-36\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUnivalTree. /*FC*/class Solution {\n/*FM*/bool isUnivalTree(TreeNode* root) {\r\n        if (!root->left && !root->right) return true; \r\n        bool ans = true; \r\n        if (root->left) {\r\n            \r\n            \r\n        }\r\n        if (root->right) {\r\n            ans &= isUnivalTree(root->right); \r\n            ans &= root->val == root->right->val; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/bool isUnivalTree(TreeNode* root) {\r\n        if (!root->left && !root->right) return true; \r\n        bool ans = true; \r\n        if (root->left) {\r\n            ans &= isUnivalTree(root->left); \r\n            ans &= root->val == root->left->val; \r\n        }\r\n        if (root->right) {\r\n            ans &= isUnivalTree(root->right); \r\n            ans &= root->val == root->right->val; \r\n        }\r\n        return ans; \r\n    } bool isUnivalTree(TreeNode* root) {\r\n        if (!root->left && !root->right) return true; \r\n        bool ans = true; \r\n        if (root->left) {\r\n            ans &= isUnivalTree(root->left); \r\n            ans &= root->val == root->left->val; \r\n        }\r\n        if (root->right) {\r\n            ans &= isUnivalTree(root->right); \r\n            ans &= root->val == root->right->val; \r\n        }\r\n        return ans; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-85\"], \"root[0].val\": [\"-805\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"422\"], \"root[0].right[0].val\": [\"407\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-427\"], \"root[1].val\": [\"133\"], \"root[1].left\": [2], \"root[1].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left0_x\": [\"-359\"], \"root[1].left[0].val\": [\"172\"], \"root[1].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_left1_x\": [\"188\"], \"root[1].left[1].val\": [\"-847\"], \"root[1].right\": [1], \"root[1].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_right0_x\": [\"475\"], \"root[1].right[0].val\": [\"32\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isUnivalTree. /*FC*/class Solution {\n/*FM*/bool isUnivalTree(TreeNode* root) {\r\n        if (!root->left && !root->right) return true; \r\n        bool ans = true; \r\n        if (root->left) {\r\n            ans &= isUnivalTree(root->left); \r\n            ans &= root->val == root->left->val; \r\n        }\r\n        if (root->right) {\r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/bool isUnivalTree(TreeNode* root) {\r\n        if (!root->left && !root->right) return true; \r\n        bool ans = true; \r\n        if (root->left) {\r\n            ans &= isUnivalTree(root->left); \r\n            ans &= root->val == root->left->val; \r\n        }\r\n        if (root->right) {\r\n            ans &= isUnivalTree(root->right); \r\n            ans &= root->val == root->right->val; \r\n        }\r\n        return ans; \r\n    } bool isUnivalTree(TreeNode* root) {\r\n        if (!root->left && !root->right) return true; \r\n        bool ans = true; \r\n        if (root->left) {\r\n            ans &= isUnivalTree(root->left); \r\n            ans &= root->val == root->left->val; \r\n        }\r\n        if (root->right) {\r\n            ans &= isUnivalTree(root->right); \r\n            ans &= root->val == root->right->val; \r\n        }\r\n        return ans; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-948\"], \"root[0].val\": [\"-808\"], \"root[0].left\": [2], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"305\"], \"root[0].left[0].val\": [\"109\"], \"root[0].left[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left1_x\": [\"312\"], \"root[0].left[1].val\": [\"-989\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortArrayByParityII. /*FC*/class Solution {\n/*FM*/vector<int> sortArrayByParityII(vector<int>& A) {\r\n        for (int i = 0, j = 1;  i < A.size();  i += 2) {\r\n            if (A[i] % 2) {\r\n                while (A[j] % 2) {\r\n                    \r\n                }\r\n                swap(A[i], A[j]); \r\n            }\r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"85\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortArrayByParityII. /*FC*/class Solution {\n/*FM*/vector<int> sortArrayByParityII(vector<int>& A) {\r\n        for (int i = 0, j = 1;  i < A.size();  i += 2) {\r\n            if (A[i] % 2) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"180\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortedSquares. /*FC*/class Solution {\n/*FM*/vector<int> sortedSquares(vector<int>& A) {\r\n        vector<int> ans(A.size()); \r\n        int l = 0, r = A.size() - 1; \r\n        while (l <= r) {\r\n            if (A[l] + A[r] < 0) {\r\n                \r\n                \r\n            } else {\r\n                ans[r - l] = A[r] * A[r]; \r\n                r--; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A_element0\": [\"60\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortedSquares. /*FC*/class Solution {\n/*FM*/vector<int> sortedSquares(vector<int>& A) {\r\n        vector<int> ans(A.size()); \r\n        int l = 0, r = A.size() - 1; \r\n        while (l <= r) {\r\n            if (A[l] + A[r] < 0) {\r\n                ans[r - l] = A[l] * A[l]; \r\n                l++; \r\n            } else {\r\n                \r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"478\"], \"A_element1\": [\"-537\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> verticalTraversal. /*FC*/class Solution {\n/*FM*/vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        vector<vector<int>> locs; \r\n        dfs(locs, root, 0, 0); \r\n        sort(locs.begin(), locs.end(), [] (vector<int> &a, vector<int> &b) {\r\n            if (a[0] != b[0]) return a[0] < b[0]; \r\n            if (a[1] != b[1]) return a[1] < b[1]; \r\n            return a[2] < b[2]; \r\n        }); \r\n        \r\n        vector<vector<int>> ans; \r\n        for (int i = 0;  i < locs.size();  ) {\r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/void dfs(vector<vector<int>> &locs, TreeNode *root, int x, int y) {\r\n        if (!root) return; \r\n        locs.push_back({x, y, root->val}); \r\n        dfs(locs, root->left, x - 1, y + 1); \r\n        dfs(locs, root->right, x + 1, y + 1); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> verticalTraversal. /*FC*/class Solution {\n/*FM*/vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        vector<vector<int>> locs; \r\n        dfs(locs, root, 0, 0); \r\n        sort(locs.begin(), locs.end(), [] (vector<int> &a, vector<int> &b) {\r\n            if (a[0] != b[0]) return a[0] < b[0]; \r\n            if (a[1] != b[1]) return a[1] < b[1]; \r\n            return a[2] < b[2]; \r\n        }); \r\n        \r\n        vector<vector<int>> ans; \r\n        for (int i = 0;  i < locs.size();  i++) {\r\n            if (i == 0 || locs[i - 1][0] < locs[i][0]) {\r\n                ans.emplace_back(); \r\n            }\r\n            ans.back().push_back(locs[i][2]); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/void dfs(vector<vector<int>> &locs, TreeNode *root, int x, int y) {\r\n        if (!root) return; \r\n        locs.push_back({x, y, root->val}); \r\n        dfs(locs, root->left, x - 1, y + 1); \r\n        dfs(locs, root->right, x + 1, y + 1); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"108\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> addToArrayForm. /*FC*/class Solution {\n/*FM*/vector<int> addToArrayForm(vector<int>& A, int K) {\r\n        vector<int> ans; \r\n        int i = A.size() - 1; \r\n        while (i >= 0 || K) {\r\n            if (i >= 0) {\r\n                K += A[i--]; \r\n            }\r\n            ans.push_back(K % 10); \r\n            K /= 10; \r\n        }\r\n        reverse(ans.begin(), ans.end()); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A_element0\": [\"744\"], \"A_element1\": [\"726\"], \"K\": [\"512\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int brokenCalc. /*FC*/class Solution {\n/*FM*/int brokenCalc(int X, int Y) {\r\n        int ans = 0; \r\n        while (X < Y) {\r\n            Y = Y % 2 ? Y + 1 : Y / 2; \r\n            ans++; \r\n        }\r\n        return ans + X - Y; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"X\": [\"8\"], \"Y\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int orangesRotting. /*FC*/class Solution {\n/*FM*/int orangesRotting(vector<vector<int>>& grid) {\r\n        int m = grid.size(); \r\n        int n = grid[0].size(); \r\n        \r\n        int fresh = 0; \r\n        queue<int> q; \r\n        for (int i = 0;  i < m;  i++) {\r\n            for (int j = 0;  j < n;  j++) {\r\n                if (grid[i][j] == 1) {\r\n                    \r\n                } else if (grid[i][j] == 2) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n\r\n        int depth = 0; \r\n        while (!q.empty()) {\r\n            \r\n            \r\n        }\r\n        return fresh ? -1 : max(0, depth - 1); \r\n    };/*F*/vector<vector<int>> dirs = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"grid\": [1], \"grid_element0\": [1], \"grid_element0_element0\": [\"813\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findJudge. /*FC*/class Solution {\n/*FM*/int findJudge(int N, vector<vector<int>>& trust) {\r\n        vector<int> id(N); \r\n        vector<int> od(N); \r\n        for (vector<int> &p : trust) {\r\n            \r\n            \r\n        }\r\n        for (int i = 0;  i < N;  i++) {\r\n            if (id[i] == N - 1 && od[i] == 0) {\r\n                \r\n            }\r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findJudge. /*FC*/class Solution {\n/*FM*/int findJudge(int N, vector<vector<int>>& trust) {\r\n        vector<int> id(N); \r\n        vector<int> od(N); \r\n        for (vector<int> &p : trust) {\r\n            \r\n            \r\n        }\r\n        for (int i = 0;  i < N;  ) {\r\n            if (id[i] == N - 1 && od[i] == 0) {\r\n                return i + 1; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findJudge. /*FC*/class Solution {\n/*FM*/int findJudge(int N, vector<vector<int>>& trust) {\r\n        vector<int> id(N); \r\n        vector<int> od(N); \r\n        for (vector<int> &p : trust) {\r\n            id[p[1] - 1]++; \r\n            od[p[0] - 1]++; \r\n        }\r\n        for (int i = 0;  i < N;  i++) {\r\n            if (id[i] == N - 1 && od[i] == 0) {\r\n                \r\n            }\r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"N\": [\"7\"], \"trust\": [2], \"trust_element0\": [1], \"trust_element0_element0\": [\"-434\"], \"trust_element1\": [1], \"trust_element1_element0\": [\"-86\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* insertIntoMaxTree. /*FC*/class Solution {\n/*FM*/TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\r\n        if (!root || val > root->val) {\r\n            TreeNode *node = new TreeNode(val); \r\n            node->left = root; \r\n            return node; \r\n        }\r\n        root->right = insertIntoMaxTree(root->right, val); \r\n        return root; \r\n    };/*F*//*C*//*M*/TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\r\n        if (!root || val > root->val) {\r\n            TreeNode *node = new TreeNode(val); \r\n            node->left = root; \r\n            return node; \r\n        }\r\n        root->right = insertIntoMaxTree(root->right, val); \r\n        return root; \r\n    } TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\r\n        if (!root || val > root->val) {\r\n            TreeNode *node = new TreeNode(val); \r\n            node->left = root; \r\n            return node; \r\n        }\r\n        root->right = insertIntoMaxTree(root->right, val); \r\n        return root; \r\n    } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"675\"], \"root[0].val\": [\"787\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"757\"], \"root[1].val\": [\"-920\"], \"val\": [\"-787\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method TreeNode* insertIntoMaxTree. /*FC*/class Solution {\n/*FM*/TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\r\n        if (!root || val > root->val) {\r\n            TreeNode *node = new TreeNode(val); \r\n            node->left = root; \r\n            return node; \r\n        }\r\n        \r\n        \r\n    };/*F*//*C*//*M*/TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\r\n        if (!root || val > root->val) {\r\n            TreeNode *node = new TreeNode(val); \r\n            node->left = root; \r\n            return node; \r\n        }\r\n        root->right = insertIntoMaxTree(root->right, val); \r\n        return root; \r\n    } TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\r\n        if (!root || val > root->val) {\r\n            TreeNode *node = new TreeNode(val); \r\n            node->left = root; \r\n            return node; \r\n        }\r\n        root->right = insertIntoMaxTree(root->right, val); \r\n        return root; \r\n    } TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"900\"], \"root[0].val\": [\"-170\"], \"root[0].right\": [1], \"root[0].right[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_right0_x\": [\"991\"], \"root[0].right[0].val\": [\"521\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"376\"], \"root[1].val\": [\"-685\"], \"val\": [\"-61\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string S) {\r\n        if (S.size() % 3) return false; \r\n        \r\n        for ( : S) {\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string S) {\r\n        if (S.size() % 3) \r\n        stack<char> st; \r\n        for (char ch : S) {\r\n            \r\n        }\r\n        return st.empty(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numPairsDivisibleBy60. /*FC*/class Solution {\n/*FM*/int numPairsDivisibleBy60(vector<int>& time) {\r\n        int ans = 0; \r\n        vector<int> ht(60); \r\n        for (int t : time) {\r\n            ans += ht[(60 - t % 60) % 60]; \r\n            ht[t % 60]++; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"time\": [2], \"time_element0\": [\"-629\"], \"time_element1\": [\"719\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string removeOuterParentheses. /*FC*/class Solution {\n/*FM*/string removeOuterParentheses(string S) {\r\n        string ans; \r\n        int open = 0; \r\n        for (char ch : S) {\r\n            if (ch == ')') {\r\n                \r\n            }\r\n            if (open > 0) {\r\n                \r\n            }\r\n            if (ch == '(') {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isRobotBounded. /*FC*/class Solution {\n/*FM*/bool isRobotBounded(string instructions) {\r\n        int x = 0, y = 0, di = 0; \r\n        for (char instr : instructions) {\r\n            switch (instr) {\r\n            \r\n                \r\n                \r\n                \r\n            \r\n                \r\n                \r\n            \r\n                \r\n            }\r\n        }\r\n        return !x && !y || di; \r\n    };/*F*/vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};/*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"instructions\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lastStoneWeight. /*FC*/class Solution {\n/*FM*/int lastStoneWeight(vector<int>& stones) {\r\n        priority_queue<int> q; \r\n        for (int s : stones) {\r\n            \r\n        }\r\n        while (q.size() > 1) {\r\n            \r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return q.empty() ? 0 : q.top(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lastStoneWeight. /*FC*/class Solution {\n/*FM*/int lastStoneWeight(vector<int>& stones) {\r\n        priority_queue<int> q; \r\n        for (int s : stones) {\r\n            q.push(s); \r\n        }\r\n        while (q.size() > 1) {\r\n            int s1 = q.top(); \r\n            q.pop(); \r\n            int s2 = q.top(); \r\n            q.pop(); \r\n            if (s1 - s2) {\r\n                q.push(s1 - s2); \r\n            }\r\n        }\r\n        return q.empty() ? 0 : q.top(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"stones\": [2], \"stones_element0\": [\"345\"], \"stones_element1\": [\"-541\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string removeDuplicates. /*FC*/class Solution {\n/*FM*/string removeDuplicates(string S) {\r\n        int top = 0; \r\n        for (char ch : S) {\r\n            if (top == 0 || S[top - 1] != ch) {\r\n                S[top++] = ch; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        S.resize(top); \r\n        return S; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int heightChecker. /*FC*/class Solution {\n/*FM*/int heightChecker(vector<int>& heights) {\r\n        vector<int> sorted = heights; \r\n        sort(sorted.begin(), sorted.end()); \r\n        int ans = 0; \r\n        for (int i = 0;  i < heights.size();  i++) {\r\n            if (heights[i] != sorted[i]) {\r\n                ans++; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"heights\": [2], \"heights_element0\": [\"459\"], \"heights_element1\": [\"-803\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int heightChecker. /*FC*/class Solution {\n/*FM*/int heightChecker(vector<int>& heights) {\r\n        vector<int> sorted = heights; \r\n        sort(sorted.begin(), sorted.end()); \r\n        int ans = 0; \r\n        for (int i = 0;  i < heights.size();  i++) {\r\n            if (heights[i] != sorted[i]) {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"heights\": [2], \"heights_element0\": [\"-747\"], \"heights_element1\": [\"509\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> distributeCandies. /*FC*/class Solution {\n/*FM*/vector<int> distributeCandies(int candies, int num_people) {\r\n        vector<int> ans(num_people); \r\n        for (int i = 0;  candies > 0;  candies -= ++i) {\r\n            ans[i % num_people] += min(i + 1, candies); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"candies\": [\"10\"], \"num_people\": [\"635571369\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string defangIPaddr. /*FC*/class Solution {\n/*FM*/string defangIPaddr(string address) {\r\n        string ans; \r\n        for (char ch : address) {\r\n            if (ch == '.') {\r\n                \r\n            } else {\r\n                ans += ch; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"address\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numEquivDominoPairs. /*FC*/class Solution {\n/*FM*/int numEquivDominoPairs(vector<vector<int>>& dominoes) {\r\n        int ans = 0; \r\n        vector<int> ht(100); \r\n        for (vector<int> &d : dominoes) {\r\n            ans += ht[10 * min(d[0], d[1]) + max(d[0], d[1])]++; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"dominoes\": [1], \"dominoes_element0\": [1], \"dominoes_element0_element0\": [\"109\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numEquivDominoPairs. /*FC*/class Solution {\n/*FM*/int numEquivDominoPairs(vector<vector<int>>& dominoes) {\r\n        int ans = 0; \r\n        vector<int> ht(100); \r\n        for (vector<int> &d : dominoes) {\r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int tribonacci. /*FC*/class Solution {\n/*FM*/int tribonacci(int n) {\r\n        vector<int> dp = {0, 1, 1}; \r\n        for (int i = 3;  i <= n;  i++) {\r\n            dp[i % 3] = dp[0] + dp[1] + dp[2]; \r\n        }\r\n        return dp[n % 3]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countCharacters. /*FC*/class Solution {\n/*FM*/int countCharacters(vector<string>& words, string chars) {\r\n        vector<int> htc(26); \r\n        for (char ch : chars) {\r\n            \r\n        }\r\n        \r\n        int ans = 0; \r\n        for (string &w : words) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countCharacters. /*FC*/class Solution {\n/*FM*/int countCharacters(vector<string>& words, string chars) {\r\n        vector<int> htc(26); \r\n        for (char ch : chars) {\r\n            htc[ch - 'a']++; \r\n        }\r\n        \r\n        int ans = 0; \r\n        for (string &w : words) {\r\n            vector<int> htw(26); \r\n            int i; \r\n            for (i = 0;  i < w.size();  ) {\r\n                if (++htw[w[i] - 'a'] > htc[w[i] - 'a']) {\r\n                    break; \r\n                }\r\n            }\r\n            if (i >= w.size()) {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"words\": [2], \"words_element0\": [\"1\"], \"words_element1\": [\"1\"], \"chars\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSquares. /*FC*/class Solution {\n/*FM*/int countSquares(vector<vector<int>>& matrix) {\r\n        int ans = 0; \r\n        for (int i = 0;  i < matrix.size();  i++) {\r\n            for (int j = 0;  j < matrix[0].size();  j++) {\r\n                if (i && j && matrix[i][j]) {\r\n                    matrix[i][j] += min({matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1]}); \r\n                }\r\n                ans += matrix[i][j]; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"457891487\"], \"matrix_element0_element1\": [\"1649860855\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"1622468445\"], \"matrix_element1_element1\": [\"899613413\"], \"matrix_element1_element2\": [\"1515408286\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int countSquares. /*FC*/class Solution {\n/*FM*/int countSquares(vector<vector<int>>& matrix) {\r\n        int ans = 0; \r\n        for (int i = 0;  i < matrix.size();  ) {\r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int subtractProductAndSum. /*FC*/class Solution {\n/*FM*/int subtractProductAndSum(int n) {\r\n        int sum = 0, pro = 1; \r\n        while (n) {\r\n            sum += n % 10; \r\n            pro *= n % 10; \r\n            n /= 10; \r\n        }\r\n        return pro - sum; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"-807730923\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestDivisor. /*FC*/class Solution {\n/*FM*/int smallestDivisor(vector<int>& nums, int threshold) {\r\n        int lo = 1, hi = 1000000; \r\n        while (lo <= hi) {\r\n            int sum = 0, mid = (lo + hi) / 2; \r\n            for (int n : nums) {\r\n                sum += (n - 1) / mid + 1; \r\n            }\r\n            if (sum > threshold) {\r\n                lo = mid + 1; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return lo; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [1], \"nums_element0\": [\"638598467\"], \"threshold\": [\"-131945452\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestDivisor. /*FC*/class Solution {\n/*FM*/int smallestDivisor(vector<int>& nums, int threshold) {\r\n        int lo = 1, hi = 1000000; \r\n        while (lo <= hi) {\r\n            int sum = 0, mid = (lo + hi) / 2; \r\n            for (int n : nums) {\r\n                \r\n            }\r\n            if (sum > threshold) {\r\n                lo = mid + 1; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return lo; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"threshold\": [\"-2147483648\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestDivisor. /*FC*/class Solution {\n/*FM*/int smallestDivisor(vector<int>& nums, int threshold) {\r\n        int lo = 1, hi = 1000000; \r\n        while (lo <= hi) {\r\n            int sum = 0, mid = (lo + hi) / 2; \r\n            for (int n : nums) {\r\n                sum += (n - 1) / mid + 1; \r\n            }\r\n            if (sum > threshold) {\r\n                \r\n            } else {\r\n                hi = mid - 1; \r\n            }\r\n        }\r\n        return lo; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"-919560026\"], \"nums_element1\": [\"1900359997\"], \"nums_element2\": [\"-1785153346\"], \"threshold\": [\"766744961\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int game. /*FC*/class Solution {\n/*FM*/int game(vector<int>& guess, vector<int>& answer) {\r\n        int ans = 0; \r\n        for (int i = 0;  i < 3;  i++) {\r\n            if (guess[i] == answer[i]) {\r\n                ans++; \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"guess\": [1], \"guess_element0\": [\"690196054\"], \"answer\": [1], \"answer_element0\": [\"-1045242955\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> fraction. /*FC*/class Solution {\n/*FM*/vector<int> fraction(vector<int>& cont) {\r\n        vector<int> ans = {1, 0}; \r\n        for (int i = cont.size() - 1;  i >= 0;  i--) {\r\n            ans[1] += cont[i] * ans[0]; \r\n            swap(ans[0], ans[1]); \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"cont\": [1], \"cont_element0\": [\"21106519\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> fraction. /*FC*/class Solution {\n/*FM*/vector<int> fraction(vector<int>& cont) {\r\n        vector<int> ans = {1, 0}; \r\n        for (int i = cont.size() - 1;  i >= 0;  ) {\r\n            \r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> twoSum. /*FC*/class Solution {\n/*FM*/vector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int, int> index; \r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (index.find(nums[i]) != index.end()) {\r\n                return {index[nums[i]], i}; \r\n            }\r\n            index[target - nums[i]] = i; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [4], \"nums_element0\": [\"2\"], \"nums_element1\": [\"7\"], \"nums_element2\": [\"11\"], \"nums_element3\": [\"15\"], \"target\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n        int max_len = 0; \r\n        for (int i = 0, last = -1;  i < s.size();  i++) {\r\n            for (int j = last + 1;  j < i;  ) {\r\n                if (s[i] == s[j]) {\r\n                    last = j; \r\n                    break; \r\n                }\r\n            }\r\n            max_len = max(max_len, i - last); \r\n        }\r\n        return max_len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"bbbbb\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n        int max_len = 0; \r\n        for (int i = 0, last = -1;  i < s.size();  i++) {\r\n            for (int j = last + 1;  j < i;  j++) {\r\n                if (s[i] == s[j]) {\r\n                    last = j; \r\n                    break; \r\n                }\r\n            }\r\n            max_len = max(max_len, i - last); \r\n        }\r\n        return max_len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"abcabcbb\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n        int max_len = 0; \r\n        for (int i = 0, last = -1;  i < s.size();  i++) {\r\n            for (int j = last + 1;  j < i;  j++) {\r\n                if (s[i] == s[j]) {\r\n                    \r\n                    \r\n                }\r\n            }\r\n            max_len = max(max_len, i - last); \r\n        }\r\n        return max_len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"abcdef\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/class Solution {\n/*FM*/string convert(string s, int numRows) {\r\n        if (numRows == 1) return s; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        for ( : vec) {\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"numRows\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/class Solution {\n/*FM*/string convert(string s, int numRows) {\r\n        if (numRows == 1) \r\n        \r\n        vector<string> vec(numRows); \r\n        for (int i = 0, x = numRows - 1;  i < s.size();  i++) {\r\n            vec[x - abs(i % (2 * x) - x)] += s[i]; \r\n        }\r\n        \r\n        string ans; \r\n        for (string &str : vec) {\r\n            ans += str; \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"PAHNAPLSIIGYIR\"], \"numRows\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        int ans = 0, sign = 0; \r\n        for (char ch : str) {\r\n            if (!sign && ch == ' ') {\r\n                \r\n            } else if (!sign && ch == '-') {\r\n                \r\n            } else if (!sign && ch == '+') {\r\n                \r\n            } else if (!sign && '0' <= ch && ch <= '9') {\r\n                sign = 1; \r\n                ans = ch - '0'; \r\n            } else if ('0' <= ch && ch <= '9') {\r\n                if (sign > 0 && (INT_MAX - ch + '0') / 10 < ans) {\r\n                    return INT_MAX;      \n                }\r\n                if (sign < 0 && (INT_MIN + ch - '0') / 10 > ans) {\r\n                         \n                }\r\n                ans = ans * 10 + sign * (ch - '0'); \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"str\": [\"2147483648\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        int ans = 0, sign = 0; \r\n        for (char ch : str) {\r\n            \r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        int ans = 0, sign = 0; \r\n        for (char ch : str) {\r\n            if (!sign && ch == ' ') {\r\n                \r\n            } else if (!sign && ch == '-') {\r\n                sign = -1; \r\n            } else if (!sign && ch == '+') {\r\n                \r\n            } else if (!sign && '0' <= ch && ch <= '9') {\r\n                \r\n                \r\n            } else if ('0' <= ch && ch <= '9') {\r\n                if (sign > 0 && (INT_MAX - ch + '0') / 10 < ans) {\r\n                         \n                }\r\n                if (sign < 0 && (INT_MIN + ch - '0') / 10 > ans) {\r\n                    return INT_MIN;      \n                }\r\n                ans = ans * 10 + sign * (ch - '0'); \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"str\": [\"-91283472332\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        int ans = 0, sign = 0; \r\n        for (char ch : str) {\r\n            if (!sign && ch == ' ') {\r\n                continue; \r\n            } else if (!sign && ch == '-') {\r\n                sign = -1; \r\n            } else if (!sign && ch == '+') {\r\n                \r\n            } else if (!sign && '0' <= ch && ch <= '9') {\r\n                \r\n                \r\n            } else if ('0' <= ch && ch <= '9') {\r\n                if (sign > 0 && (INT_MAX - ch + '0') / 10 < ans) {\r\n                         \n                }\r\n                if (sign < 0 && (INT_MIN + ch - '0') / 10 > ans) {\r\n                         \n                }\r\n                ans = ans * 10 + sign * (ch - '0'); \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"str\": [\" -42\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        int ans = 0, sign = 0; \r\n        for (char ch : str) {\r\n            if (!sign && ch == ' ') {\r\n                continue; \r\n            } else if (!sign && ch == '-') {\r\n                \r\n            } else if (!sign && ch == '+') {\r\n                sign = 1; \r\n            } else if (!sign && '0' <= ch && ch <= '9') {\r\n                \r\n                \r\n            } else if ('0' <= ch && ch <= '9') {\r\n                if (sign > 0 && (INT_MAX - ch + '0') / 10 < ans) {\r\n                         \n                }\r\n                if (sign < 0 && (INT_MIN + ch - '0') / 10 > ans) {\r\n                         \n                }\r\n                ans = ans * 10 + sign * (ch - '0'); \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"str\": [\" +42\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        int ans = 0, sign = 0; \r\n        for (char ch : str) {\r\n            if (!sign && ch == ' ') {\r\n                continue; \r\n            } else if (!sign && ch == '-') {\r\n                \r\n            } else if (!sign && ch == '+') {\r\n                \r\n            } else if (!sign && '0' <= ch && ch <= '9') {\r\n                sign = 1; \r\n                ans = ch - '0'; \r\n            } else if ('0' <= ch && ch <= '9') {\r\n                if (sign > 0 && (INT_MAX - ch + '0') / 10 < ans) {\r\n                         \n                }\r\n                if (sign < 0 && (INT_MIN + ch - '0') / 10 > ans) {\r\n                         \n                }\r\n                ans = ans * 10 + sign * (ch - '0'); \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"str\": [\" 42\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int>> threeSum(vector<int>& nums) {\r\n        vector<vector<int>> ans; \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 0;  i + 2 < nums.size();  i++) {\r\n            if (i > 0 && nums[i] == nums[i - 1]) \r\n            int l = i + 1, r = nums.size() - 1, t2sum = -nums[i]; \r\n            while (l < r) {\r\n                if (nums[l] + nums[r] < t2sum) {\r\n                    \r\n                } else if (nums[l] + nums[r] > t2sum) {\r\n                    \r\n                } else {\r\n                    ans.push_back({nums[i], nums[l], nums[r]}); \r\n                    while (l < r && nums[l] == nums[l + 1]) {\r\n                        l++; \r\n                    }\r\n                    while (l < r && nums[r] == nums[r - 1]) {\r\n                        \r\n                    }\r\n                    l++; \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [3], \"nums_element0\": [\"0\"], \"nums_element1\": [\"0\"], \"nums_element2\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int>> threeSum(vector<int>& nums) {\r\n        vector<vector<int>> ans; \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 0;  i + 2 < nums.size();  i++) {\r\n            if (i > 0 && nums[i] == nums[i - 1]) \r\n            int l = i + 1, r = nums.size() - 1, t2sum = -nums[i]; \r\n            while (l < r) {\r\n                if (nums[l] + nums[r] < t2sum) {\r\n                    \r\n                } else if (nums[l] + nums[r] > t2sum) {\r\n                    r--; \r\n                } else {\r\n                    \r\n                    \r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"nums\": [3], \"nums_element0\": [\"1006782571\"], \"nums_element1\": [\"871249567\"], \"nums_element2\": [\"278731265\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int>> threeSum(vector<int>& nums) {\r\n        vector<vector<int>> ans; \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 0;  i + 2 < nums.size();  i++) {\r\n            if (i > 0 && nums[i] == nums[i - 1]) \r\n            int l = i + 1, r = nums.size() - 1, t2sum = -nums[i]; \r\n            while (l < r) {\r\n                if (nums[l] + nums[r] < t2sum) {\r\n                    \r\n                } else if (nums[l] + nums[r] > t2sum) {\r\n                    r--; \r\n                } else {\r\n                    ans.push_back({nums[i], nums[l], nums[r]}); \r\n                    while (l < r && nums[l] == nums[l + 1]) {\r\n                        l++; \r\n                    }\r\n                    while (l < r && nums[r] == nums[r - 1]) {\r\n                        \r\n                    }\r\n                    l++; \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [5], \"nums_element0\": [\"-2\"], \"nums_element1\": [\"0\"], \"nums_element2\": [\"1\"], \"nums_element3\": [\"1\"], \"nums_element4\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int>> threeSum(vector<int>& nums) {\r\n        vector<vector<int>> ans; \r\n        sort(nums.begin(), nums.end()); \r\n        for (int i = 0;  i + 2 < nums.size();  i++) {\r\n            if (i > 0 && nums[i] == nums[i - 1]) continue; \r\n            int l = i + 1, r = nums.size() - 1, t2sum = -nums[i]; \r\n            while (l < r) {\r\n                if (nums[l] + nums[r] < t2sum) {\r\n                    l++; \r\n                } else if (nums[l] + nums[r] > t2sum) {\r\n                    r--; \r\n                } else {\r\n                    ans.push_back({nums[i], nums[l], nums[r]}); \r\n                    while (l < r && nums[l] == nums[l + 1]) {\r\n                        \r\n                    }\r\n                    while (l < r && nums[r] == nums[r - 1]) {\r\n                        \r\n                    }\r\n                    l++; \r\n                }\r\n            }\r\n        }\r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [6], \"nums_element0\": [\"-1\"], \"nums_element1\": [\"0\"], \"nums_element2\": [\"1\"], \"nums_element3\": [\"2\"], \"nums_element4\": [\"-1\"], \"nums_element5\": [\"-4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        if (s.size() % 2) \r\n        stack<char> left_stack; \r\n        for (char ch : s) {\r\n            if (ch == '(' || ch == '[' || ch == '{') {\r\n                left_stack.push(ch); \r\n            } else if (left_stack.empty() ||\r\n                left_stack.top() == '(' && ch != ')' ||\r\n                left_stack.top() == '[' && ch != ']' ||\r\n                left_stack.top() == '{' && ch != '}') {\r\n                \r\n            } else {\r\n                left_stack.pop(); \r\n            }\r\n        }\r\n        return left_stack.empty(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"({[]})\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        if (s.size() % 2) \r\n        stack<char> left_stack; \r\n        for (char ch : s) {\r\n            if (ch == '(' || ch == '[' || ch == '{') {\r\n                left_stack.push(ch); \r\n            } else if (left_stack.empty() ||\r\n                left_stack.top() == '(' && ch != ')' ||\r\n                left_stack.top() == '[' && ch != ']' ||\r\n                left_stack.top() == '{' && ch != '}') {\r\n                return false; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"({[}\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        if (s.size() % 2) \r\n        stack<char> left_stack; \r\n        for (char ch : s) {\r\n            if (ch == '(' || ch == '[' || ch == '{') {\r\n                \r\n            } else if (left_stack.empty() ||\r\n                left_stack.top() == '(' && ch != ')' ||\r\n                left_stack.top() == '[' && ch != ']' ||\r\n                left_stack.top() == '{' && ch != '}') {\r\n                return false; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"){\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstMissingPositive. /*FC*/class Solution {\n/*FM*/int firstMissingPositive(vector<int>& nums) {\r\n        for (int &n : nums) {\r\n            while (0 < n && n <= nums.size() && n != nums[n - 1]) {\r\n                \r\n            }\r\n        }\r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (nums[i] != i + 1) {\r\n                return i + 1; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [2], \"nums_element0\": [\"1\"], \"nums_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int firstMissingPositive. /*FC*/class Solution {\n/*FM*/int firstMissingPositive(vector<int>& nums) {\r\n        for (int &n : nums) {\r\n            while (0 < n && n <= nums.size() && n != nums[n - 1]) {\r\n                swap(n, nums[n - 1]); \r\n            }\r\n        }\r\n        for (int i = 0;  i < nums.size();  i++) {\r\n            if (nums[i] != i + 1) {\r\n                return i + 1; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [4], \"nums_element0\": [\"3\"], \"nums_element1\": [\"4\"], \"nums_element2\": [\"-1\"], \"nums_element3\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(string s) {\r\n        int len = 0; \r\n        for (int i = s.size();  i >= 0;  i--) {\r\n            if (isalpha(s[i])) {\r\n                len++; \r\n            } else if (len > 0) {\r\n                break; \r\n            }\r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\" ewjknq gfjnk  \"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLastWord. /*FC*/class Solution {\n/*FM*/int lengthOfLastWord(string s) {\r\n        int len = 0; \r\n        for (int i = s.size();  i >= 0;  i--) {\r\n            if (isalpha(s[i])) {\r\n                len++; \r\n            } else if (len > 0) {\r\n                \r\n            }\r\n        }\r\n        return len; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(string s) {\r\n        int state = 0; \r\n        for (int i = 0;  state != -1 && i < s.size();  i++) {\r\n            switch (s[i]) {\r\n            \r\n                \r\n                \r\n            \r\n            \r\n                \r\n                \r\n            \r\n                \r\n                \r\n            case 'e':\r\n                state = trans[state][3]; \r\n                break; \r\n            \r\n                \r\n            }\r\n        }\r\n        return state >= 5; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> fullJustify. /*FC*/class Solution {\n/*FM*/vector<string> fullJustify(vector<string>& words, int maxWidth) {\r\n        vector<string> ans; \r\n        int begin = 0, width = 0; \r\n        for (int i = 0;  i < words.size();  i++) {\r\n            if (width + words[i].size() + i - begin - 1 >= maxWidth) {\r\n                ans.push_back(\"\"); \r\n                if (i - begin <= 1) {\r\n                    ans.back() += words[begin]; \r\n                    ans.back() += string(maxWidth - ans.back().size(), ' '); \r\n                } else {\r\n                    \r\n                    \r\n                    \r\n                    \r\n                }\r\n                begin = i; \r\n                width = 0; \r\n            }\r\n            width += words[i].size(); \r\n        }\r\n        ans.push_back(\"\"); \r\n        for (int i = begin;  i < words.size() - 1;  ) {\r\n            \r\n            \r\n        }\r\n        ans.back() += words.back(); \r\n        ans.back() += string(maxWidth - ans.back().size(), ' '); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"words\": [2], \"words_element0\": [\"longerwotd\"], \"words_element1\": [\"short\"], \"maxWidth\": [\"15\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> fullJustify. /*FC*/class Solution {\n/*FM*/vector<string> fullJustify(vector<string>& words, int maxWidth) {\r\n        vector<string> ans; \r\n        int begin = 0, width = 0; \r\n        for (int i = 0;  i < words.size();  i++) {\r\n            if (width + words[i].size() + i - begin - 1 >= maxWidth) {\r\n                ans.push_back(\"\"); \r\n                if (i - begin <= 1) {\r\n                    \r\n                    \r\n                } else {\r\n                    int quo = (maxWidth - width) / (i - begin - 1); \r\n                    int rem = (maxWidth - width) % (i - begin - 1); \r\n                    for (int j = begin;  j < i - 1;  j++) {\r\n                        ans.back() += words[j]; \r\n                        ans.back() += string(j < begin + rem ? quo + 1 : quo, ' '); \r\n                    }\r\n                    ans.back() += words[i - 1]; \r\n                }\r\n                begin = i; \r\n                width = 0; \r\n            }\r\n            width += words[i].size(); \r\n        }\r\n        ans.push_back(\"\"); \r\n        for (int i = begin;  i < words.size() - 1;  ) {\r\n            \r\n            \r\n        }\r\n        ans.back() += words.back(); \r\n        ans.back() += string(maxWidth - ans.back().size(), ' '); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"words\": [4], \"words_element0\": [\"This\"], \"words_element1\": [\"is\"], \"words_element2\": [\"an\"], \"words_element3\": [\"example\"], \"maxWidth\": [\"16\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> fullJustify. /*FC*/class Solution {\n/*FM*/vector<string> fullJustify(vector<string>& words, int maxWidth) {\r\n        vector<string> ans; \r\n        int begin = 0, width = 0; \r\n        for (int i = 0;  i < words.size();  i++) {\r\n            if (width + words[i].size() + i - begin - 1 >= maxWidth) {\r\n                \r\n                \r\n                \r\n                \r\n            }\r\n            width += words[i].size(); \r\n        }\r\n        ans.push_back(\"\"); \r\n        for (int i = begin;  i < words.size() - 1;  ) {\r\n            \r\n            \r\n        }\r\n        ans.back() += words.back(); \r\n        ans.back() += string(maxWidth - ans.back().size(), ' '); \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"words\": [1], \"words_element0\": [\"S\\u1ecbdji\"], \"maxWidth\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        vector<string> v; \r\n        istringstream iss(path); \r\n        string buf; \r\n        while (getline(iss, buf, '/')) {\r\n            if (!buf.empty() && buf != \".\" && buf != \"..\") {\r\n                v.push_back(buf); \r\n            } else if (!v.empty() && buf == \"..\") {\r\n                v.pop_back(); \r\n            }\r\n        }\r\n        if (v.empty()) {\r\n            \r\n        }\r\n\r\n        buf.clear(); \r\n        for (string &s : v) {\r\n            buf += \"/\"; \r\n            buf += s; \r\n        }\r\n        return buf; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"path\": [\"/a/b/c/..\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        vector<string> v; \r\n        istringstream iss(path); \r\n        string buf; \r\n        while (getline(iss, buf, '/')) {\r\n            if (!buf.empty() && buf != \".\" && buf != \"..\") {\r\n                v.push_back(buf); \r\n            } else if (!v.empty() && buf == \"..\") {\r\n                v.pop_back(); \r\n            }\r\n        }\r\n        if (v.empty()) {\r\n            return \"/\"; \r\n        }\r\n\r\n        \r\n        for ( : v) {\r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"path\": [\"/a/..\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        vector<string> v; \r\n        istringstream iss(path); \r\n        string buf; \r\n        while (getline(iss, buf, '/')) {\r\n            if (!buf.empty() && buf != \".\" && buf != \"..\") {\r\n                \r\n            } else if (!v.empty() && buf == \"..\") {\r\n                \r\n            }\r\n        }\r\n        if (v.empty()) {\r\n            return \"/\"; \r\n        }\r\n\r\n        \r\n        for ( : v) {\r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"path\": [\"..\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(int A[], int n) {\r\n        int range = 0; \r\n        for (int i = 0;  i <= range;  ++i) {\r\n            range = max(range, i + A[i]); \r\n            if (range >= n - 1) \r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A[0]\": [\"-1378206027\"], \"A[1]\": [\"-1422222354\"], \"n\": [\"1268443659\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canJump. /*FC*/class Solution {\n/*FM*/bool canJump(int A[], int n) {\r\n        int range = 0; \r\n        for (int i = 0;  i <= range;  ) {\r\n            range = max(range, i + A[i]); \r\n            if (range >= n - 1) return true; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A[0]\": [\"1293958042\"], \"A[1]\": [\"487108974\"], \"A[2]\": [\"-1988640828\"], \"n\": [\"-485776595\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/class Solution {\n/*FM*/int jump(int A[], int n) {\r\n        if (n == 1) \r\n        vector<int> steps(n, 0); \r\n        int range = 0; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            for (int pos = range + 1;  pos - i <= A[i];  ++pos) {\r\n                range = pos; \r\n                if (range == n - 1) return steps[i] + 1; \r\n                steps[range] = steps[i] + 1; \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [2], \"A[0]\": [\"-1581745151\"], \"A[1]\": [\"1350249567\"], \"n\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int jump. /*FC*/class Solution {\n/*FM*/int jump(int A[], int n) {\r\n        if (n == 1) return 0; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A[0]\": [\"1233623037\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestRectangleArea. /*FC*/class Solution {\n/*FM*/int largestRectangleArea(vector<int> &height) {\r\n        int result = 0; \r\n        stack<pair<int, int> > S; \r\n        for (int i = 0;  i < height.size();  ++i) {\r\n            int h = height[i]; \r\n            int pos = i; \r\n            while (!S.empty() && h < S.top().second) {\r\n                pos = S.top().first; \r\n                result = max(result , S.top().second * (i - pos)); \r\n                S.pop(); \r\n            }\r\n            if (S.empty() || h > S.top().second) S.push(make_pair(pos, h)); \r\n        }\r\n        while (!S.empty()) {\r\n            result = max(result , S.top().second * ((int)height.size() - S.top().first)); \r\n            S.pop(); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [3], \"height_element0\": [\"264572063\"], \"height_element1\": [\"317116757\"], \"height_element2\": [\"-1350400594\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestCommonSubsequence. /*FC*/ {\n/*FM*/int longestCommonSubsequence(const string& a, const string& b) {\r\n  int A = a.size(), B = b.size(); \r\n  int L[2][B + 1]; \r\n  for (int i = 0;  i <= 1;  ++i) L[i][0] = 0; \r\n  for (int i = 0;  i <= B;  ++i) L[0][i] = 0; \r\n  for (int i = 1;  i <= A;  ++i) {\r\n    int this_i = i % 2, pre_i = this_i ? 0 : 1; \r\n    for (int j = 1;  j <= B;  ++j) {\r\n      if (a[i - 1] == b[j - 1]) \r\n      else L[this_i][j] = max(L[pre_i][j], L[this_i][j - 1]); \r\n    }\r\n  }\r\n  return max(L[0][B], L[1][B]); \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"a\": [\"1\"], \"b\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class Solution {\n/*FM*/string longestPalindrome(string s) {\r\n    string x(2 * s.length() + 1, '#'); \r\n    for (int i = 0;  i < s.length();  ++i) x[i * 2 + 1] = s[i]; \r\n    \r\n    int N = x.length(); \r\n    vector<int> M(N, 0);  \n    \n    for (int i = 0, C = 0;  i < N;  ++i) {\r\n      int m = C + M[C] > i ? min(M[C] + C - i, M[2 * C - i]) : 0;  \r\n      \n      if (m >= M[C] + C - i) {\r\n\twhile (i - m - 1 >= 0 && i + m + 1 < N && x[i - m - 1] == x[i + m + 1]) m ++; \r\n\tM[i] = m; \r\n\tC = i; \r\n      }\r\n    }\r\n    int i = max_element(M.begin(), M.end()) - M.begin(); \r\n    return s.substr((i - M[i]) / 2, M[i]);       \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string longestPalindrome. /*FC*/class SolutionOn2 {\n/*FM*/string longestPalindrome(string s) {\r\n    string x(2 * s.length() + 1, '#'); \r\n    for (int i = 0;  i < s.length();  ++i) x[i * 2 + 1] = s[i]; \r\n    int max_length = 0, pos = 0; \r\n    for (int i = 0;  i < x.length();  ++i) {\r\n      int len = 1; \r\n      while (i - len >= 0 && i + len < x.length() && x[i - len] == x[i + len]) len ++; \r\n      len --; \r\n      if (len > max_length) {\r\n\tmax_length = len; \r\n\tpos = i; \r\n      }\r\n    }\r\n    return s.substr((pos - max_length) / 2, max_length); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionOn2\": [\"SolutionOn2\", \"SolutionOn2()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int lengthOfLongestSubstring. /*FC*/class Solution {\n/*FM*/int lengthOfLongestSubstring(string s) {\r\n        vector<bool> exist(256, false); \r\n        int left = 0, right = 0, max_length = 0; \r\n        while (right < s.size()) {\r\n            \n            while (right < s.size() && exist[s[right]] == false) exist[s[right ++]] = true; \r\n            max_length = max(max_length, right - left); \r\n            \n            if (right < s.size()) {\r\n               do {  } while (s[left - 1] != s[right]); \r\n            }\r\n        }\r\n        return max_length; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestValidParentheses. /*FC*/class Solution {\n/*FM*/int longestValidParentheses(string s) {   \r\n    int max_length = 0; \r\n    int start[] = {0, s.length() - 1}, step[] = {1, -1}, end[] = {s.length(), -1}, ok_sign[] = {1, -1}; \r\n    for (int k = 0;  k < 2;  ++k) {\r\n      int left = 0, right = 0; \r\n      for (int i = start[k];  i != end[k];  i += step[k]) {\r\n\tif (s[i] == '(') \r\n\telse right ++; \r\n\tif (left == right) {\r\n\t  \r\n\t} else if (ok_sign[k] * (left - right) < 0) {\r\n\t  left = 0; \r\n\t  right = 0; \r\n\t}\r\n      }\r\n    }\r\n    return max_length; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestValidParentheses. /*FC*/class Solution {\n/*FM*/int longestValidParentheses(string s) {   \r\n    int max_length = 0; \r\n    int start[] = {0, s.length() - 1}, step[] = {1, -1}, end[] = {s.length(), -1}, ok_sign[] = {1, -1}; \r\n    for (int k = 0;  k < 2;  ++k) {\r\n      int left = 0, right = 0; \r\n      for (int i = start[k];  i != end[k];  ) {\r\n\t\r\n\t\r\n      }\r\n    }\r\n    return max_length; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestValidParentheses. /*FC*/class SolutionStack {\n/*FM*/int longestValidParentheses(string s) {    \r\n    stack<int> S; \r\n    int max_length = 0, start = s.length(); \r\n    for (int i = 0;  i < s.length();  ++i) {\r\n      if (s[i] == '(') {\r\n\tS.push(i); \r\n      } else {\r\n\t\r\n      }\r\n    }\r\n    return max_length; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionStack\": [\"SolutionStack\", \"SolutionStack()\"], \"s\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int longestValidParentheses. /*FC*/class SolutionStack {\n/*FM*/int longestValidParentheses(string s) {    \r\n    stack<int> S; \r\n    int max_length = 0, start = s.length(); \r\n    for (int i = 0;  i < s.length();  ++i) {\r\n      if (s[i] == '(') {\r\n\t\r\n      } else {\r\n\tif (S.empty()) {\r\n\t  start = s.length(); \r\n\t} else {\r\n\t  \r\n\t  \r\n\t  \r\n\t}\r\n      }\r\n    }\r\n    return max_length; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionStack\": [\"SolutionStack\", \"SolutionStack()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestRectangleArea. /*FC*/class Solution {\n/*FM*/int largestRectangleArea(vector<int> &height) {\r\n        int result = 0; \r\n        stack<pair<int, int> > S; \r\n        for (int i = 0;  i < height.size();  ++i) {\r\n            int h = height[i]; \r\n            int pos = i; \r\n            while (!S.empty() && h < S.top().second) {\r\n                pos = S.top().first; \r\n                result = max(result , S.top().second * (i - pos)); \r\n                S.pop(); \r\n            }\r\n            if (S.empty() || h > S.top().second) S.push(make_pair(pos, h)); \r\n        }\r\n        while (!S.empty()) {\r\n            result = max(result, S.top().second * ((int)height.size() - S.top().first)); \r\n            S.pop(); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"height\": [3], \"height_element0\": [\"214765068\"], \"height_element1\": [\"-496176305\"], \"height_element2\": [\"1001982247\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int largestRectangleArea. /*FC*/class Solution {\n/*FM*/int largestRectangleArea(vector<int> &height) {\r\n        int result = 0; \r\n        stack<pair<int, int> > S; \r\n        for (int i = 0;  i < height.size();  ) {\r\n            \r\n            \r\n            \r\n            if (S.empty() || h > S.top().second) \r\n        }\r\n        while (!S.empty()) {\r\n            \r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalRectangle. /*FC*/class Solution {\n/*FM*/int maximalRectangle(vector<vector<char> > &matrix) {\r\n        int H = matrix.size(), W = H ? matrix[0].size() : 0; \r\n        if (H == 0) \r\n        \r\n        int max_rect = 0; \r\n        vector<int> hist(W, 0); \r\n        for (int i = 0;  i < H;  ++i) {\r\n            for (int j = 0;  j < W;  ++j) {\r\n                hist[j] = matrix[i][j] == '1' ? hist[j] + 1 : 0; \r\n            }\r\n            max_rect = max(max_rect, largestRectangleArea(hist)); \r\n        }\r\n        return max_rect; \r\n    };/*F*//*C*//*M*/int largestRectangleArea(vector<int> &height) {\r\n        int result = 0; \r\n        stack<pair<int, int> > S; \r\n        for (int i = 0;  i < height.size();  ++i) {\r\n            int h = height[i]; \r\n            int pos = i; \r\n            while (!S.empty() && h < S.top().second) {\r\n                pos = S.top().first; \r\n                result = max(result , S.top().second * (i - pos)); \r\n                S.pop(); \r\n            }\r\n            if (S.empty() || h > S.top().second) S.push(make_pair(pos, h)); \r\n        }\r\n        while (!S.empty()) {\r\n            result = max(result, S.top().second * ((int)height.size() - S.top().first)); \r\n            S.pop(); \r\n        }\r\n        return result; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"matrix\": [1], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"83\"], \"matrix_element0_element1\": [\"47\"], \"matrix_element0_element2\": [\"-100\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalRectangle. /*FC*/class Solution {\n/*FM*/int maximalRectangle(vector<vector<char> > &matrix) {\r\n        int H = matrix.size(), W = H ? matrix[0].size() : 0; \r\n        if (H == 0) return 0; \r\n        \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<char> And. /*FC*/class SolutionSlow {\n/*FM*/vector<char> And(const vector<char>& a, const vector<char>& b) {\r\n        vector<char> c(a.size(), '0'); \r\n        for (int i = 0;  i < c.size();  ++i) {\r\n            if (a[i] == '1' && b[i] == '1') \r\n        }\r\n        return c; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionSlow\": [\"SolutionSlow\", \"SolutionSlow()\"], \"a\": [1], \"a_element0\": [\"64\"], \"b\": [3], \"b_element0\": [\"55\"], \"b_element1\": [\"-37\"], \"b_element2\": [\"31\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxRun. /*FC*/class SolutionSlow {\n/*FM*/int maxRun(const vector<char>& v) {\r\n        int current_run = 0, max_run = 0; \r\n        for (int i = 0;  i < v.size();  ++i) {\r\n            if (v[i] == '1') {\r\n                \r\n            } else {\r\n                current_run = 0; \r\n            }\r\n        }\r\n        return max_run; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionSlow\": [\"SolutionSlow\", \"SolutionSlow()\"], \"v\": [1], \"v_element0\": [\"95\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maximalRectangle. /*FC*/class SolutionSlow {\n/*FM*/int maximalRectangle(vector<vector<char> > &matrix) {\r\n        int H = matrix.size(), W = H ? matrix[0].size() : 0; \r\n        int max_rect = 0; \r\n        for (int i = 0;  i < H;  ++i) {\r\n            vector<char> all_ones(W, '1'); \r\n            for (int j = i;  j < H;  ++j) {\r\n                all_ones = And(all_ones, matrix[j]); \r\n                \n                if ((j - i + 1) * W <= max_rect) \r\n                int max_run = maxRun(all_ones); \r\n                \n                if ((H - i) * max_run < max_rect) \r\n                max_rect = max(max_rect, (j - i + 1) * max_run); \r\n            }\r\n        }\r\n        return max_rect; \r\n    };/*F*//*C*//*M*/vector<char> And(const vector<char>& a, const vector<char>& b) {\r\n        vector<char> c(a.size(), '0'); \r\n        for (int i = 0;  i < c.size();  ++i) {\r\n            if (a[i] == '1' && b[i] == '1') c[i] = '1'; \r\n        }\r\n        return c; \r\n    } int maxRun(const vector<char>& v) {\r\n        int current_run = 0, max_run = 0; \r\n        for (int i = 0;  i < v.size();  ++i) {\r\n            if (v[i] == '1') {\r\n                max_run = max(max_run, ++current_run); \r\n            } else {\r\n                current_run = 0; \r\n            }\r\n        }\r\n        return max_run; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___SolutionSlow\": [\"SolutionSlow\", \"SolutionSlow()\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"-97\"], \"matrix_element0_element1\": [\"113\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"62\"], \"matrix_element1_element1\": [\"72\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxDepth. /*FC*/class Solution {\n/*FM*/int maxDepth(TreeNode *root) {\r\n    if (!root) return 0; \r\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));         \r\n  };/*F*//*C*//*M*/int maxDepth(TreeNode *root) {\r\n    if (!root) return 0; \r\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));         \r\n  } int maxDepth(TreeNode *root) {\r\n    if (!root) return 0; \r\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));         \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"2021719464\"], \"root[0].left\": [1], \"root[0].left[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_left0_x\": [\"1399827781\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"-1203364174\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method pair<int, char> merge. /*FC*/ {\n/*FM*/pair<int, char> merge(char a, int na, char b, int nb) {\r\n  if (a == b) \r\n  if (na % 2 == 1 && nb % 2 == 1) return make_pair(1, 'a' + 'b' + 'c' - a - b); \r\n  if (na % 2 == 1) \r\n  if (nb % 2 == 1) \r\n  if (na < nb) \r\n  \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"a\": [\"-18\"], \"na\": [\"1063148665\"], \"b\": [\"8\"], \"nb\": [\"1306425813\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method pair<int, char> merge. /*FC*/ {\n/*FM*/pair<int, char> merge(char a, int na, char b, int nb) {\r\n  if (a == b) \r\n  if (na % 2 == 1 && nb % 2 == 1) \r\n  if (na % 2 == 1) \r\n  if (nb % 2 == 1) return make_pair(1, b); \r\n  if (na < nb) \r\n  \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"a\": [\"-106\"], \"na\": [\"1447638666\"], \"b\": [\"72\"], \"nb\": [\"268713957\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method pair<int, char> merge. /*FC*/ {\n/*FM*/pair<int, char> merge(char a, int na, char b, int nb) {\r\n  if (a == b) \r\n  if (na % 2 == 1 && nb % 2 == 1) \r\n  if (na % 2 == 1) \r\n  if (nb % 2 == 1) \r\n  if (na < nb) \r\n  return make_pair(nb, b); \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"a\": [\"126\"], \"na\": [\"861562380\"], \"b\": [\"-8\"], \"nb\": [\"160261798\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method pair<int, char> merge. /*FC*/ {\n/*FM*/pair<int, char> merge(char a, int na, char b, int nb) {\r\n  if (a == b) \r\n  if (na % 2 == 1 && nb % 2 == 1) \r\n  if (na % 2 == 1) \r\n  if (nb % 2 == 1) \r\n  if (na < nb) return make_pair(na, a); \r\n  \r\n};/*F*//*C*//*M*/\n}",
        "target": "{\"a\": [\"93\"], \"na\": [\"-1335491309\"], \"b\": [\"-80\"], \"nb\": [\"-920265787\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findSubstring. /*FC*/class Solution {\n/*FM*/vector<int> findSubstring(string S, vector<string> &L) {\r\n    vector<int> result; \r\n    int N = L[0].size(); \r\n    if (N * L.size() > S.size()) return result;         \r\n    \r\n    \r\n        \r\n    \r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"L\": [2], \"L_element0\": [\"3\"], \"L_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findSubstring. /*FC*/class SolutionBruteForce {\n/*FM*/vector<int> findSubstring(string S, vector<string> &L) {\r\n    vector<int> result; \r\n    int N = L[0].size(); \r\n    if (N * L.size() > S.size()) \r\n    map<string, int> need; \r\n    for (int i = 0;  i < L.size();  ++i) need[L[i]] ++; \r\n    for (int i = 0;  i <= S.size() - N * L.size();  ++i) {\r\n      map<string, int> found; \r\n      int j = 0; \r\n      for (;  j < L.size();  ) {\r\n\tstring s = S.substr(i + j * N, N); \r\n\tif (need.count(s) == 0 || ++found[s] > need[s]) break; \r\n      }\r\n      if (j == L.size()) \r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionBruteForce\": [\"SolutionBruteForce\", \"SolutionBruteForce()\"], \"S\": [\"1\"], \"L\": [1], \"L_element0\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findSubstring. /*FC*/class SolutionBruteForce {\n/*FM*/vector<int> findSubstring(string S, vector<string> &L) {\r\n    vector<int> result; \r\n    int N = L[0].size(); \r\n    if (N * L.size() > S.size()) return result; \r\n    \r\n    \r\n    \r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionBruteForce\": [\"SolutionBruteForce\", \"SolutionBruteForce()\"], \"S\": [\"2\"], \"L\": [3], \"L_element0\": [\"3\"], \"L_element1\": [\"3\"], \"L_element2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(const char *cs) {\r\n    string s(cs); \r\n    if (s.length() == 0) \r\n\r\n    \n    int from = 0, to = s.length() - 1; \r\n    while (from < s.length() && s[from] == ' ') \r\n    while (to >= 0 && s[to] == ' ') \r\n    s = s.substr(from, max(0, to - from + 1)); \r\n\r\n    int p = s.find('e'); \r\n    string e = \"\"; \r\n    if (p != string::npos) {\r\n      \r\n      \r\n      \r\n    }\r\n\r\n    bool res = true; \r\n    if (e.length()) \r\n    res &= isNumberNoE(s); \r\n    return res; \r\n  };/*F*//*C*//*M*/bool isNumberNoE(string s) {\r\n    if (s == \"\") return false; \r\n    if (s[0] == '+' || s[0] == '-') s.erase(0, 1); \r\n    int p = s.find('.'); \r\n    string dec = \"\"; \r\n    if (p != string::npos) {\r\n      dec = s.substr(p + 1, s.length()); \r\n      s = s.substr(0, p); \r\n    }\r\n    bool res = s.length() || dec.length(); \r\n    if (s.length()) res &= isIntNoSign(s); \r\n    if (dec.length()) res &= isIntNoSign(dec); \r\n    return res; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"cs\": [1], \"cs_constantPointer[0]\": [\"-95\"], \"cs_constantPointer[1]\": [\"46\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isIntNoSign. /*FC*/class Solution {\n/*FM*/bool isIntNoSign(string s) {\r\n    if (s.length() == 0) \r\n    for (int i = 0;  i < s.length();  ) {\r\n      if (s[i] > '9' || s[i] < '0') return false; \r\n    }\r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isInt. /*FC*/class Solution {\n/*FM*/bool isInt(string s) {\r\n    if (s == \"\") \r\n    if (s[0] == '+' || s[0] == '-') \r\n    return isIntNoSign(s); \r\n  };/*F*//*C*//*M*/bool isIntNoSign(string s) {\r\n    if (s.length() == 0) return false; \r\n    for (int i = 0;  i < s.length();  ++i) {\r\n      if (s[i] > '9' || s[i] < '0') return false; \r\n    }\r\n    return true; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n    string L = \"{[(\", R = \"}])\"; \r\n    stack<char> S; \r\n    for (int i = 0;  i < s.length();  ) {\r\n      if (L.find(s[i]) != string::npos) \r\n      else if (S.empty() || L.find(S.top()) != R.find(s[i])) return false; \r\n      else \r\n    }\r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > twoSumSorted. /*FC*/class Solution {\n/*FM*/vector<vector<int> > twoSumSorted(const vector<int>& v, int L, int H, int S) {\r\n    vector<vector<int> > result; \r\n    while (L < H) {\r\n      int sum = v[L] + v[H]; \r\n      if (sum > S) H --; \r\n      else if (sum < S) L ++; \r\n      else {\r\n\t\r\n\t\r\n\t }\r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"v\": [3], \"v_element0\": [\"1049920059\"], \"v_element1\": [\"354406649\"], \"v_element2\": [\"-1740233129\"], \"L\": [\"5\"], \"H\": [\"7\"], \"S\": [\"-978623792\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > threeSum. /*FC*/class Solution {\n/*FM*/vector<vector<int> > threeSum(vector<int> &num) {\r\n    sort(num.begin(), num.end()); \r\n    vector<vector<int> > result; \r\n    for (int i = 0;  i < num.size();  ++i) {\r\n      if (i > 0 && num[i] == num[i - 1]) \r\n      vector<vector<int> > p = twoSumSorted(num, i + 1, num.size() - 1, -num[i]); \r\n      for (int j = 0;  j < p.size();  ) {\r\n\t\r\n\t\r\n      }\r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/vector<vector<int> > twoSumSorted(const vector<int>& v, int L, int H, int S) {\r\n    vector<vector<int> > result; \r\n    while (L < H) {\r\n      int sum = v[L] + v[H]; \r\n      if (sum > S) H --; \r\n      else if (sum < S) L ++; \r\n      else {\r\n\tint p[] = {v[L], v[H]}; \r\n\tresult.push_back(vector<int>(p, p + 2)); \r\n\twhile (L < v.size() && v[L] == p[0]) L ++; \r\n\twhile (H >= 0 && v[H] == p[1]) H --; \r\n      }\r\n    }\r\n    return result; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"1994561205\"], \"num_element1\": [\"-384905884\"], \"num_element2\": [\"-518873049\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n    deque<string> Q; \r\n    int pos = path.find('/'); \r\n    while (pos + 1 < path.size()) {\r\n      \r\n      \r\n      \r\n      \r\n      \r\n    }\r\n    string res = \"\"; \r\n    while (!Q.empty()) {\r\n      \r\n      \r\n    }\r\n    return res.size() ? res : \"/\"; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n    deque<string> Q; \r\n    int pos = path.find('/'); \r\n    while (pos + 1 < path.size()) {\r\n      int new_pos = path.find('/', pos + 1); \r\n      if (new_pos == string::npos) new_pos = path.size(); \r\n      string p = path.substr(pos + 1, new_pos - pos - 1); \r\n      pos = new_pos; \r\n      if (p.size()) {\r\n\tif (p == \"..\") {\r\n\t  \r\n\t}\r\n\telse if (p == \".\") \r\n\telse Q.push_back(p); \r\n      }\r\n    }\r\n    string res = \"\"; \r\n    while (!Q.empty()) {\r\n      res += \"/\" + Q.front(); \r\n      Q.pop_front(); \r\n    }\r\n    return res.size() ? res : \"/\"; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"path\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors. /*FC*/class Solution {\n/*FM*/void sortColors(int A[], int n) {\r\n    int i0 = 0, i2 = n - 1, i = 0; \r\n    while (i <= i2) {\r\n      if (A[i] == 0) \r\n      else if (A[i] == 1) \r\n      else swap(A[i], A[i2 --]); \r\n    }\r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A[0]\": [\"2021645828\"], \"n\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reverseBetweenNotContainingHead. /*FC*/class Solution {\n/*FM*/void reverseBetweenNotContainingHead(ListNode *head, int m, int n) {\r\n    n -= m;  \n    while (m -- > 2) \r\n    ListNode *start = head->next, *pre = head->next, *cur = pre->next; \r\n    \r\n     \n     \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"0\"], \"head[0].next\": [0], \"m\": [\"0\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reverseBetweenNotContainingHead. /*FC*/class Solution {\n/*FM*/void reverseBetweenNotContainingHead(ListNode *head, int m, int n) {\r\n    n -= m;  \n    while (m -- > 2) head = head->next; \r\n    \r\n    \r\n     \n     \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1139546239\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-378946424\"], \"m\": [\"9\"], \"n\": [\"-1077812565\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reverseBetweenNotContainingHead. /*FC*/class Solution {\n/*FM*/void reverseBetweenNotContainingHead(ListNode *head, int m, int n) {\r\n    n -= m;  \n    while (m -- > 2) \r\n    ListNode *start = head->next, *pre = head->next, *cur = pre->next; \r\n    while (n --) {\r\n      ListNode *cur_next = cur->next; \r\n      \r\n      \r\n      \r\n    }\r\n     \n     \n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-1910130782\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"-6027516\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"0\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-1899490683\"], \"m\": [\"0\"], \"n\": [\"-905281919\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseKGroup. /*FC*/class Solution {\n/*FM*/ListNode *reverseKGroup(ListNode *head, int k) {\r\n    ListNode dummy(0); \r\n    ListNode *tail = &dummy, *cur = head; \r\n    while (cur) {\r\n      \r\n      \r\n      east k left\r\n      if (test) {\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n      } else {\r\n\t \n\t\r\n      }\r\n    }\r\n    return dummy.next; \r\n  };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [0], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *reverseKGroup. /*FC*/class Solution {\n/*FM*/ListNode *reverseKGroup(ListNode *head, int k) {\r\n    ListNode dummy(0); \r\n    ListNode *tail = &dummy, *cur = head; \r\n    while (cur) {\r\n      int n = k - 1; \r\n      ListNode *test = cur; \r\n      while (n -- && test) test = test->next;  \n      if (test) {\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n      } else {\r\n\ttail->next = cur;  \n\tcur = NULL; \r\n      }\r\n    }\r\n    return dummy.next; \r\n  };/*F*//*C*//*M*/ListNode(int x) : val(x), next(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-15598611\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(int A[], int n) {\r\n        if (n < 2) \r\n        int write = 1; \r\n        for (int read = 1;  read < n;  ++read) {\r\n            if (A[read] != A[write - 1]) A[write++] = A[read]; \r\n        }\r\n        return write; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A[0]\": [\"61575634\"], \"n\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(int A[], int n) {\r\n        if (n < 2) \r\n        int write = 1, repeat = 0; \r\n        for (int read = 1;  read < n;  ++read) {\r\n            if (A[read] == A[write - 1]) {\r\n                \r\n            } else repeat = 0; \r\n            A[write++] = A[read]; \r\n        }\r\n        return write; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [3], \"A[0]\": [\"-196804224\"], \"A[1]\": [\"911130838\"], \"A[2]\": [\"798326552\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(int A[], int n) {\r\n        if (n < 2) return n; \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"A\": [1], \"A[0]\": [\"1753599008\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\r\n        if (!head || !head->next) return head; \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"510834018\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\r\n        if (!head || !head->next) \r\n        ListNode *write = head, *read = head->next; \r\n        write->next = NULL; \r\n        while (read) {\r\n            ListNode *next_read = read->next; \r\n            if (read->val != write->val) {\r\n                write->next = read; \r\n                write = write->next; \r\n                write->next = NULL; \r\n            } else {\r\n                \r\n            }\r\n            read = next_read; \r\n        }\r\n        return head; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [1], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-605596265\"], \"head[0].next\": [2], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"1159366243\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\r\n        ListNode *result = NULL, *tail = NULL, *read = head; \r\n        while (read) {\r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *deleteDuplicates. /*FC*/class Solution {\n/*FM*/ListNode *deleteDuplicates(ListNode *head) {\r\n        ListNode *result = NULL, *tail = NULL, *read = head; \r\n        while (read) {\r\n            if (read->next && read->val == read->next->val) {\r\n                \r\n                \r\n            } else {\r\n\t        append(result, tail, read); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/static void append(ListNode *&head, ListNode *&tail, ListNode *&node, bool cut_off = true) {\r\n        if (node == NULL) return; \r\n\tif (head == NULL) {\r\n\t    head = node; \r\n\t    tail = node; \r\n\t} else {\r\n\t    tail->next = node; \r\n\t    tail = node; \r\n\t}\r\n\tnode = node->next; \r\n\tif (cut_off) tail->next = NULL; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [2], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"2068906795\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"-2088210697\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *removeNthFromEnd. /*FC*/class Solution {\n/*FM*/ListNode *removeNthFromEnd(ListNode *head, int n) {\r\n    if (!head || n <= 0) return NULL; \r\n    \r\n    \r\n    \r\n    if (steps >= n - 1) {\r\n                \n      \r\n    }\r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [0], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *removeNthFromEnd. /*FC*/class Solution {\n/*FM*/ListNode *removeNthFromEnd(ListNode *head, int n) {\r\n    if (!head || n <= 0) \r\n    ListNode *parent = head, *cur = head, *tail = head; \r\n    int steps = 0; \r\n    while (tail->next) {\r\n      tail = tail->next; \r\n      if (steps >= n - 1) \r\n      if (steps >= n) \r\n      steps ++; \r\n    }\r\n    if (steps >= n - 1) {\r\n                \n      \r\n    }\r\n    return head; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"1146920685\"], \"head[0].next\": [3], \"head[0].next[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next0_x\": [\"1278084705\"], \"head[0].next[1]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next1_x\": [\"0\"], \"head[0].next[2]\": [\"ListNode\", \"ListNode(int)\"], \"head0_next2_x\": [\"0\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"880847312\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"-1372212966\"], \"n\": [\"1464884982\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> inorderTraversal. /*FC*/class Solution {\n/*FM*/vector<int> inorderTraversal(TreeNode *root) {\r\n    vector<int> result; \r\n    stack<TreeNode*> S; \r\n    TreeNode* n = root; \r\n    while (n || !S.empty()) { \r\n      if (n) {\r\n\tS.push(n); \r\n\tn = n->left; \r\n      }\r\n      if (!n) {\r\n\tn = S.top(); \r\n\tS.pop(); \r\n\tresult.push_back(n->val); \r\n\tn = n->right; \r\n      }\r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [1], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-318145230\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> inorderTraversal. /*FC*/class Solution {\n/*FM*/vector<int> inorderTraversal(TreeNode *root) {\r\n    vector<int> result; \r\n    stack<TreeNode*> S; \r\n    TreeNode* n = root; \r\n    while (n || !S.empty()) { \r\n      \r\n      \r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > permute. /*FC*/class Solution {\n/*FM*/vector<vector<int> > permute(vector<int> &num) {\r\n        if (num.size() == 1) return vector<vector<int> >(1, num); \r\n        vector<int> rest(num.begin() + 1, num.end()); \r\n        vector<vector<int> > part = permute(rest); \r\n        vector<vector<int> > result; \r\n        for (int i = 0;  i < part.size();  ++i) {\r\n            for (int j = 0;  j <= part[i].size();  ++j) {\r\n                vector<int> p = part[i]; \r\n                p.insert(p.begin() + j, num[0]); \r\n                result.push_back(p); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [2], \"num_element0\": [\"187702564\"], \"num_element1\": [\"-902979748\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > permute. /*FC*/class Solution2 {\n/*FM*/vector<vector<int> > permute(vector<int> &num) {\r\n        if (num.size() == 1) \r\n        vector<vector<int> > result; \r\n        for (int i = 0;  i < num.size();  ) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > permute. /*FC*/class Solution2 {\n/*FM*/vector<vector<int> > permute(vector<int> &num) {\r\n        if (num.size() == 1) return vector<vector<int> >(1, num); \r\n        vector<vector<int> > result; \r\n        for (int i = 0;  i < num.size();  ++i) {\r\n            vector<int> sub = num; \r\n            sub.erase(sub.begin() + i); \r\n            vector<vector<int> > p = permute(sub); \r\n            for (int j = 0;  j < p.size();  ++j) {\r\n                p[j].push_back(num[i]); \r\n                result.push_back(p[j]); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\", \"Solution2()\"], \"num\": [2], \"num_element0\": [\"-1098619319\"], \"num_element1\": [\"-1832636684\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int> &digits) {\r\n        int carry = 1, N = digits.size(), pos = N - 1; \r\n        while (carry && pos >= 0) {\r\n            carry += digits[pos]; \r\n            digits[pos] = carry % 10; \r\n            carry /= 10; \r\n            pos --; \r\n        }\r\n        if (carry) digits.insert(digits.begin(), carry); \r\n        return digits; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"digits\": [2], \"digits_element0\": [\"1963086599\"], \"digits_element1\": [\"1743825923\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int> &digits) {\r\n        int carry = 1, N = digits.size(), pos = N - 1; \r\n        while (carry && pos >= 0) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        if (carry) digits.insert(digits.begin(), carry); \r\n        return digits; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double pow. /*FC*/class Solution {\n/*FM*/double pow(double x, int n) {\r\n        if (n == 0) return 1; \r\n        if (n == 1) \r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/double pow(double x, int n) {\r\n        if (n == 0) return 1; \r\n        if (n == 1) return x; \r\n        double res = pow(x, abs(n) / 2); \r\n        res *= res; \r\n        if (n % 2 != 0) res *= x; \r\n        return n < 0 ? 1 / res : res; \r\n    } double pow(double x, int n) {\r\n        if (n == 0) return 1; \r\n        if (n == 1) return x; \r\n        double res = pow(x, abs(n) / 2); \r\n        res *= res; \r\n        if (n % 2 != 0) res *= x; \r\n        return n < 0 ? 1 / res : res; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"0.0\"], \"n\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double pow. /*FC*/class Solution {\n/*FM*/double pow(double x, int n) {\r\n        if (n == 0) \r\n        if (n == 1) return x; \r\n        double res = pow(x, abs(n) / 2); \r\n        res *= res; \r\n        if (n % 2 != 0) res *= x; \r\n        return n < 0 ? 1 / res : res; \r\n    };/*F*//*C*//*M*/double pow(double x, int n) {\r\n        if (n == 0) return 1; \r\n        if (n == 1) return x; \r\n        double res = pow(x, abs(n) / 2); \r\n        res *= res; \r\n        if (n % 2 != 0) res *= x; \r\n        return n < 0 ? 1 / res : res; \r\n    } double pow(double x, int n) {\r\n        if (n == 0) return 1; \r\n        if (n == 1) return x; \r\n        double res = pow(x, abs(n) / 2); \r\n        res *= res; \r\n        if (n % 2 != 0) res *= x; \r\n        return n < 0 ? 1 / res : res; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"0.77\"], \"n\": [\"1012954624\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int> > levelOrder(TreeNode *root) {\r\n        vector<vector<int> > result; \r\n        vector<int> cur; \r\n        queue<TreeNode*> Q; \r\n        if (root) {\r\n            Q.push(root); \r\n            Q.push(NULL); \r\n        }\r\n        while (!Q.empty()) {\r\n            TreeNode *top = Q.front(); \r\n            Q.pop(); \r\n            if (top == NULL) {\r\n                result.push_back(cur); \r\n                cur.clear(); \r\n                if (!Q.empty()) \r\n            } else {\r\n                cur.push_back(top->val); \r\n                if (top->left) \r\n                if (top->right) \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [2], \"root[0]\": [\"TreeNode\", \"TreeNode(int)\"], \"root0_x\": [\"-866816443\"], \"root[1]\": [\"TreeNode\", \"TreeNode(int)\"], \"root1_x\": [\"1368991174\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int> > levelOrder. /*FC*/class Solution {\n/*FM*/vector<vector<int> > levelOrder(TreeNode *root) {\r\n        vector<vector<int> > result; \r\n        vector<int> cur; \r\n        queue<TreeNode*> Q; \r\n        if (root) {\r\n            \r\n            \r\n        }\r\n        while (!Q.empty()) {\r\n            \r\n            \r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/TreeNode(int x) : val(x), left(NULL), right(NULL) {};\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"root\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int climbStairs. /*FC*/class Solution {\n/*FM*/int climbStairs(int n) {\r\n        vector<int> N(n + 1); \r\n        N[0] = 1; \r\n        N[1] = 1; \r\n        for (int i = 2;  i <= n;  ++i) {\r\n            N[i] = N[i - 1] + N[i - 2]; \r\n        }\r\n        return N.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class SolutionStormrage {\n/*FM*/string minWindow(string S, string T) {\r\n    vector<int> need(256, 0), found(256, 0); \r\n    for (int i = 0;  i < T.size();  ) \r\n    string result = \"\"; \r\n    for (int end = 0, begin = 0, L = 0, min_length = INT_MAX;  end < S.size();  ) {\r\n      \r\n      \r\n      \r\n      \r\n      \r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionStormrage\": [\"SolutionStormrage\", \"SolutionStormrage()\"], \"S\": [\"8\"], \"T\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class SolutionStormrage {\n/*FM*/string minWindow(string S, string T) {\r\n    vector<int> need(256, 0), found(256, 0); \r\n    for (int i = 0;  i < T.size();  ) \r\n    string result = \"\"; \r\n    for (int end = 0, begin = 0, L = 0, min_length = INT_MAX;  end < S.size();  ++end) {\r\n      char c = S[end]; \r\n      if (need[c] == 0) continue; \r\n      \r\n      \r\n      \r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionStormrage\": [\"SolutionStormrage\", \"SolutionStormrage()\"], \"S\": [\"expression\"], \"T\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class SolutionStormrage {\n/*FM*/string minWindow(string S, string T) {\r\n    vector<int> need(256, 0), found(256, 0); \r\n    for (int i = 0;  i < T.size();  ++i) need[T[i]]++; \r\n    string result = \"\"; \r\n    for (int end = 0, begin = 0, L = 0, min_length = INT_MAX;  end < S.size();  ++end) {\r\n      char c = S[end]; \r\n      if (need[c] == 0) continue; \r\n      \r\n      \r\n      \r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionStormrage\": [\"SolutionStormrage\", \"SolutionStormrage()\"], \"S\": [\"2\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class SolutionStormrage {\n/*FM*/string minWindow(string S, string T) {\r\n    vector<int> need(256, 0), found(256, 0); \r\n    for (int i = 0;  i < T.size();  ++i) need[T[i]]++; \r\n    string result = \"\"; \r\n    for (int end = 0, begin = 0, L = 0, min_length = INT_MAX;  end < S.size();  ++end) {\r\n      char c = S[end]; \r\n      if (need[c] == 0) \r\n      found[c] ++; \r\n      if (found[c] <= need[c]) \r\n      if (L == T.size()) {\r\n\t\r\n\t\r\n\t\t\r\n      }\r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionStormrage\": [\"SolutionStormrage\", \"SolutionStormrage()\"], \"S\": [\"3\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class SolutionStormrage {\n/*FM*/string minWindow(string S, string T) {\r\n    vector<int> need(256, 0), found(256, 0); \r\n    for (int i = 0;  i < T.size();  ++i) need[T[i]]++; \r\n    string result = \"\"; \r\n    for (int end = 0, begin = 0, L = 0, min_length = INT_MAX;  end < S.size();  ++end) {\r\n      char c = S[end]; \r\n      if (need[c] == 0) \r\n      found[c] ++; \r\n      if (found[c] <= need[c]) L ++; \r\n      if (L == T.size()) {\r\n\twhile (need[S[begin]] == 0 || need[S[begin]] < found[S[begin]]) {\r\n\t  \r\n\t  \r\n\t}\r\n\tint length = end - begin + 1; \r\n\tif (length < min_length) {\r\n\t  min_length = length; \r\n\t  result = S.substr(begin, length); \r\n\t}\t\r\n      }\r\n    }\r\n    return result; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___SolutionStormrage\": [\"SolutionStormrage\", \"SolutionStormrage()\"], \"S\": [\"1\"], \"T\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class Solution {\n/*FM*/string minWindow(string S, string T) {\r\n    vector<int> need(256, 0), found(256, 0); \r\n    for (int i = 0;  i < T.size();  ++i) need[T[i]]++; \r\n    string result = \"\"; \r\n    int begin = 0, end = 0, min_length = INT_MAX, L = 0; \r\n\r\n    \n    while (end < S.size()) {\r\n      if (++found[S[end]] <= need[S[end]]) L ++; \r\n      if (L == T.size()) break; \r\n      \r\n    }\r\n    if (L < T.size()) \r\n    \r\n    while (end < S.size()) {\r\n      \n      while (need[S[begin]] == 0 || need[S[begin]] < found[S[begin]]) {\r\n\t\r\n\t\r\n      }\r\n      int length = end - begin + 1; \r\n      if (length < min_length) {\r\n\tmin_length = length; \r\n\tresult = S.substr(begin, length); \r\n      }\r\n      \n      do {\r\n\tend ++; \r\n\tfound[S[end]] ++; \r\n      } while (end < S.length() && S[end] != S[begin]); \r\n    }\r\n    return result;       \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"2\"], \"T\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class Solution {\n/*FM*/string minWindow(string S, string T) {\r\n    vector<int> need(256, 0), found(256, 0); \r\n    for (int i = 0;  i < T.size();  ++i) need[T[i]]++; \r\n    string result = \"\"; \r\n    int begin = 0, end = 0, min_length = INT_MAX, L = 0; \r\n\r\n    \n    while (end < S.size()) {\r\n      if (++found[S[end]] <= need[S[end]]) \r\n      if (L == T.size()) \r\n      end ++; \r\n    }\r\n    if (L < T.size()) return \"\"; \r\n    \r\n    \r\n          \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"1\"], \"T\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string minWindow. /*FC*/class Solution {\n/*FM*/string minWindow(string S, string T) {\r\n    vector<int> need(256, 0), found(256, 0); \r\n    for (int i = 0;  i < T.size();  ) \r\n    string result = \"\"; \r\n    int begin = 0, end = 0, min_length = INT_MAX, L = 0; \r\n\r\n    \n    while (end < S.size()) {\r\n      \r\n      \r\n      \r\n    }\r\n    if (L < T.size()) \r\n    \r\n    while (end < S.size()) {\r\n      \n      \r\n      \r\n      \r\n      \n      do {\r\n\t\r\n\t\r\n      } while (end < S.length() && S[end] != S[begin]); \r\n    }\r\n    return result;       \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"S\": [\"19\"], \"T\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string multiply. /*FC*/class Solution {\n/*FM*/string multiply(string num1, string num2) {\r\n    string res = \"0\"; \r\n    for (int i = 0;  i < num1.size();  ) {\r\n      \r\n    }\r\n    \n    int i = 0; \r\n    while (i < res.size() && res[i] == '0') i ++; \r\n    res = res.substr(i, res.size()); \r\n    return res.size() ? res : \"0\"; \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string multiply. /*FC*/class Solution {\n/*FM*/string multiply(string num1, string num2) {\r\n    string res = \"0\"; \r\n    for (int i = 0;  i < num1.size();  ++i) {\r\n      res = add(res, multiply(num1[i] - '0', num1.size() - i - 1, num2)); \r\n    }\r\n    \n    int i = 0; \r\n    while (i < res.size() && res[i] == '0') \r\n    res = res.substr(i, res.size()); \r\n    return res.size() ? res : \"0\"; \r\n  };/*F*//*C*//*M*/string add(string a, string b) {\r\n    if (a.size() < b.size()) swap(a, b); \r\n    string s(a.size(), '0'); \r\n    int carry = 0, offset = a.size() - b.size(); \r\n    for (int i = a.size() - 1;  i >= 0;  --i) {\r\n      int sum = carry + a[i] - '0' + (i >= offset ? b[i - offset] - '0' : 0); \r\n      s[i] = (sum % 10) + '0'; \r\n      carry = sum / 10; \r\n    }\r\n    if (carry) s = string(1, carry + '0') + s; \r\n    return s; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"1\"], \"num2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string multiply. /*FC*/class Solution {\n/*FM*/string multiply(string num1, string num2) {\r\n    string res = \"0\"; \r\n    for (int i = 0;  i < num1.size();  ++i) {\r\n      res = add(res, multiply(num1[i] - '0', num1.size() - i - 1, num2)); \r\n    }\r\n    \n    int i = 0; \r\n    while (i < res.size() && res[i] == '0') i ++; \r\n    res = res.substr(i, res.size()); \r\n    return res.size() ? res : \"0\"; \r\n  };/*F*//*C*//*M*/string add(string a, string b) {\r\n    if (a.size() < b.size()) swap(a, b); \r\n    string s(a.size(), '0'); \r\n    int carry = 0, offset = a.size() - b.size(); \r\n    for (int i = a.size() - 1;  i >= 0;  --i) {\r\n      int sum = carry + a[i] - '0' + (i >= offset ? b[i - offset] - '0' : 0); \r\n      s[i] = (sum % 10) + '0'; \r\n      carry = sum / 10; \r\n    }\r\n    if (carry) s = string(1, carry + '0') + s; \r\n    return s; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num1\": [\"2\"], \"num2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector<int> &num) {\r\n    for (int i = num.size() - 2;  i >= 0;  ) {\r\n      \r\n    }\r\n    reverse(num.begin(), num.end()); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector<int> &num) {\r\n    for (int i = num.size() - 2;  i >= 0;  ) {\r\n      if (num[i] < num[i + 1]) {\r\n\tint j = num.rend() - 1 - upper_bound(num.rbegin(), num.rend() - i - 1, num[i]); \r\n\tswap(num[i], num[j]); \r\n\treverse(num.begin() + i + 1, num.end()); \r\n\treturn; \r\n      }\r\n    }\r\n    \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"438252729\"], \"num_element1\": [\"-1932044532\"], \"num_element2\": [\"-617497368\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void nextPermutation. /*FC*/class Solution {\n/*FM*/void nextPermutation(vector<int> &num) {\r\n    for (int i = num.size() - 2;  i >= 0;  --i) {\r\n      if (num[i] < num[i + 1]) {\r\n\t\r\n\t\r\n\t\r\n\t\r\n      }\r\n    }\r\n    reverse(num.begin(), num.end()); \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"num\": [3], \"num_element0\": [\"2065936438\"], \"num_element1\": [\"966052299\"], \"num_element2\": [\"-379341856\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(int x) {\r\n        if (x < 0) \r\n        int base = 1; \r\n        while (x / base > 10) \r\n        while (x > 9) {\r\n            \r\n            \r\n            \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"x\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method ListNode *partition. /*FC*/class Solution {\n/*FM*/ListNode *partition(ListNode *head, int x) {\r\n    ListNode *new_head[2] = {NULL}, *tail[2] = {NULL}; \r\n    while (head) {\r\n      int list_index = head->val < x ? 0 : 1; \r\n      append(new_head[list_index], tail[list_index], head); \r\n    }\r\n    append(new_head[0], tail[0], new_head[1], false); \r\n    return new_head[0]; \r\n  };/*F*//*C*//*M*/static void append(ListNode *&head, ListNode *&tail, ListNode *&node, bool cut_off = true) {\r\n    if (node == NULL) return; \r\n    if (head == NULL) {\r\n      head = node; \r\n      tail = node; \r\n    } else {\r\n      tail->next = node; \r\n      tail = node; \r\n    }\r\n    node = node->next; \r\n    if (cut_off) tail->next = NULL; \r\n  };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"head\": [3], \"head[0]\": [\"ListNode\", \"ListNode(int)\"], \"head0_x\": [\"-338398342\"], \"head[0].val\": [\"85504031\"], \"head[1]\": [\"ListNode\", \"ListNode(int)\"], \"head1_x\": [\"129630335\"], \"head[1].val\": [\"-1530648873\"], \"head[2]\": [\"ListNode\", \"ListNode(int)\"], \"head2_x\": [\"287174024\"], \"head[2].val\": [\"667172808\"], \"x\": [\"-894324997\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string countAndSay. /*FC*/class Solution {\n/*FM*/string countAndSay(int n) {\r\n    string s = \"1\"; \r\n    while (n -- > 1) s = countAndSay(s); \r\n    return s;         \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numDecodings. /*FC*/class Solution {\n/*FM*/int numDecodings(string s) {\r\n    if (s.size() == 0) \r\n    int n1 = 1, n2 = 1; \r\n    int i = s.size() - 1; \r\n    while (i >= 0) {\r\n      int n = 0; \r\n      if (s[i] <= '9' && s[i] >= '1') \r\n      if (i < s.size() - 1) {\r\n\t\r\n\t}\r\n      n2 = n1; \r\n      n1 = n; \r\n      i --; \r\n    }\r\n    return n1;         \r\n  };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"s\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minDistance. /*FC*/class Solution {\n/*FM*/int minDistance(string& word1, string& word2) {\r\n        int N = word1.size(), M = word2.size(); \r\n        int H[N + 1][M + 1];         \r\n        for (int i = 0;  i <= N;  ++i) H[i][0] = i; \r\n        for (int i = 0;  i <= M;  ++i) H[0][i] = i; \r\n        for (int i = 1;  i <= N;  ++i) {\r\n            for (int j = 1;  j <= M;  ++j) {\r\n                if (word1[i - 1] == word2[j - 1]) \r\n                else H[i][j] = 1 + min(min(H[i - 1][j - 1], H[i - 1][j]), H[i][j - 1]); \r\n            }\r\n        }\r\n        return H[N][M]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\", \"Solution()\"], \"word1\": [\"2\"], \"word2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numPermsDISequence. /*FC*/class Solution {\n/*FM*/int numPermsDISequence(string S) {\r\n        const int M = 1e9 + 7; \r\n        vector<vector<int>> dp(2, vector<int>(S.length() + 1, 1)); \r\n        for (int i = 0;  i < S.length();  ++i) {\r\n            if (S[i] == 'I') {\r\n                \r\n                \r\n            } else {\r\n                dp[(i + 1) % 2][S.length() - i - 1] = dp[i % 2][S.length() - i]; \r\n                for (int j = S.length() - i - 2;  j >= 0;  ) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return dp[S.length() % 2][0]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"D\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numPermsDISequence. /*FC*/class Solution {\n/*FM*/int numPermsDISequence(string S) {\r\n        const int M = 1e9 + 7; \r\n        vector<vector<int>> dp(2, vector<int>(S.length() + 1, 1)); \r\n        for (int i = 0;  i < S.length();  ++i) {\r\n            if (S[i] == 'I') {\r\n                dp[(i + 1) % 2][0] = dp[i % 2][0]; \r\n                for (int j = 1;  j < S.length() - i;  ++j) {\r\n                    dp[(i + 1) % 2][j] = (dp[(i + 1) % 2][j - 1] + dp[i % 2][j]) % M; \r\n                }\r\n            } else {\r\n                dp[(i + 1) % 2][S.length() - i - 1] = dp[i % 2][S.length() - i]; \r\n                for (int j = S.length() - i - 2;  j >= 0;  --j) {\r\n                    dp[(i + 1) % 2][j] = (dp[(i + 1) % 2][j + 1] + dp[i % 2][j + 1]) % M; \r\n                }\r\n            }\r\n        }\r\n        return dp[S.length() % 2][0]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"DID\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int robotSim. /*FC*/class Solution {\n/*FM*/int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\r\n        static const vector<pair<int, int>> directions{{0, 1}, {1, 0},\r\n                                                       {0, -1}, {-1, 0}}; \r\n        unordered_set<pair<int, int>, PairHash<int>> lookup; \r\n        for (const auto& obstacle: obstacles) {\r\n            \r\n        }\r\n        int result = 0; \r\n        int x = 0, y = 0, i = 0; \r\n        for (const auto& cmd: commands) {\r\n            if (cmd == -2) {\r\n                \r\n            } else if (cmd == -1) {\r\n                i = (i + 1) % 4; \r\n            } else {\r\n                for (int k = 0;  k < cmd;  ++k) {\r\n                    if (!lookup.count(make_pair(x + directions[i].first,\r\n                                                y + directions[i].second))) {\r\n                        x += directions[i].first; \r\n                        y += directions[i].second; \r\n                        result = max(result, x * x + y * y); \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"commands\": [3], \"commands_element0\": [\"4\"], \"commands_element1\": [\"-1\"], \"commands_element2\": [\"3\"], \"obstacles\": [0]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int robotSim. /*FC*/class Solution {\n/*FM*/int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\r\n        static const vector<pair<int, int>> directions{{0, 1}, {1, 0},\r\n                                                       {0, -1}, {-1, 0}}; \r\n        unordered_set<pair<int, int>, PairHash<int>> lookup; \r\n        for (const auto& obstacle: obstacles) {\r\n            lookup.emplace(obstacle[0], obstacle[1]); \r\n        }\r\n        int result = 0; \r\n        int x = 0, y = 0, i = 0; \r\n        for (const auto& cmd: commands) {\r\n            if (cmd == -2) {\r\n                i = (i - 1 + 4) % 4; \r\n            } else if (cmd == -1) {\r\n                i = (i + 1) % 4; \r\n            } else {\r\n                for (int k = 0;  k < cmd;  ++k) {\r\n                    if (!lookup.count(make_pair(x + directions[i].first,\r\n                                                y + directions[i].second))) {\r\n                        x += directions[i].first; \r\n                        y += directions[i].second; \r\n                        result = max(result, x * x + y * y); \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"commands\": [5], \"commands_element0\": [\"4\"], \"commands_element1\": [\"-1\"], \"commands_element2\": [\"4\"], \"commands_element3\": [\"-2\"], \"commands_element4\": [\"4\"], \"obstacles\": [1], \"obstacles_element0\": [2], \"obstacles_element0_element0\": [\"2\"], \"obstacles_element0_element1\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int robotSim. /*FC*/class Solution {\n/*FM*/int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\r\n        static const vector<pair<int, int>> directions{{0, 1}, {1, 0},\r\n                                                       {0, -1}, {-1, 0}}; \r\n        unordered_set<pair<int, int>, PairHash<int>> lookup; \r\n        for (const auto& obstacle: obstacles) {\r\n            lookup.emplace(obstacle[0], obstacle[1]); \r\n        }\r\n        int result = 0; \r\n        int x = 0, y = 0, i = 0; \r\n        for (const auto& cmd: commands) {\r\n            if (cmd == -2) {\r\n                \r\n            } else if (cmd == -1) {\r\n                i = (i + 1) % 4; \r\n            } else {\r\n                for (int k = 0;  k < cmd;  ++k) {\r\n                    if (!lookup.count(make_pair(x + directions[i].first,\r\n                                                y + directions[i].second))) {\r\n                        x += directions[i].first; \r\n                        y += directions[i].second; \r\n                        result = max(result, x * x + y * y); \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"commands\": [4], \"commands_element0\": [\"6\"], \"commands_element1\": [\"-1\"], \"commands_element2\": [\"-1\"], \"commands_element3\": [\"6\"], \"obstacles\": [1], \"obstacles_element0\": [2], \"obstacles_element0_element0\": [\"0\"], \"obstacles_element0_element1\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAlienSorted. /*FC*/class Solution {\n/*FM*/bool isAlienSorted(vector<string>& words, string order) {\r\n        vector<int> lookup(order.size()); \r\n        for (int i = 0;  i < order.size();  ++i) {\r\n            lookup[order[i] - 'a'] = i; \r\n        }\r\n        for (int i = 0;  i < words.size() - 1;  ) {\r\n            const auto& word1 = words[i]; \r\n            const auto& word2 = words[i + 1]; \r\n            int j = 0; \r\n            for (;  j < min(word1.length(), word2.length());  ++j) {\r\n                if (word1[j] != word2[j]) {\r\n                    if (lookup[word1[j] - 'a'] > lookup[word2[j] - 'a']) {\r\n                        return false; \r\n                    }\r\n                    \r\n                }\r\n            }\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"words\": [3], \"words_element0\": [\"word\"], \"words_element1\": [\"world\"], \"words_element2\": [\"row\"], \"order\": [\"worldabcefghijkmnpqstuvxyz\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isAlienSorted. /*FC*/class Solution {\n/*FM*/bool isAlienSorted(vector<string>& words, string order) {\r\n        vector<int> lookup(order.size()); \r\n        for (int i = 0;  i < order.size();  ++i) {\r\n            lookup[order[i] - 'a'] = i; \r\n        }\r\n        for (int i = 0;  i < words.size() - 1;  ) {\r\n            const auto& word1 = words[i]; \r\n            const auto& word2 = words[i + 1]; \r\n            int j = 0; \r\n            for (;  j < min(word1.length(), word2.length());  ++j) {\r\n                if (word1[j] != word2[j]) {\r\n                    \r\n                    \r\n                }\r\n            }\r\n            if (j == min(word1.length(), word2.length()) &&\r\n                word1.length() > word2.length()) {\r\n                return false; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"words\": [2], \"words_element0\": [\"apple\"], \"words_element1\": [\"app\"], \"order\": [\"abcdefghijklmnopqrstuvwxyz\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxBottlesDrunk. /*FC*/class Solution {\n/*FM*/int maxBottlesDrunk(int numBottles, int numExchange) {\r\n        int result = numBottles; \r\n        while (numBottles >= numExchange) {\r\n            numBottles -= numExchange++; \r\n            ++result; \r\n            ++numBottles; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"numBottles\": [\"10\"], \"numExchange\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void wiggleSort. /*FC*/class Solution4 {\n/*FM*/void wiggleSort(vector<int>& nums) {\r\n        int mid = (nums.size() - 1) / 2; \r\n        sort(nums.begin(), nums.end());   \n        vector<int> res(nums.size());   \n        for (int i = 0, smallEnd = mid;   i < nums.size();  i += 2, --smallEnd) {\r\n            res[i] = nums[smallEnd]; \r\n        }\r\n        for (int i = 1, largeEnd = nums.size() - 1;  i < nums.size();  i += 2, --largeEnd) {\r\n            res[i] = nums[largeEnd]; \r\n        }\r\n        nums = res; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution4\": [\"Solution4\"], \"nums\": [6], \"nums_element0\": [\"1\"], \"nums_element1\": [\"5\"], \"nums_element2\": [\"1\"], \"nums_element3\": [\"1\"], \"nums_element4\": [\"6\"], \"nums_element5\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int videoStitching. /*FC*/class Solution {\n/*FM*/int videoStitching(vector<vector<int>>& clips, int T) {\r\n        if (T == 0) {\r\n            \r\n        }\r\n        int result = 1; \r\n        int curr_reachable = 0, reachable = 0; \r\n        sort(clips.begin(), clips.end()); \r\n        for (const auto& clip : clips) {\r\n            int left = clip[0], right = clip[1]; \r\n            if (left > reachable) {\r\n                \r\n            } else if (left > curr_reachable) {\r\n                curr_reachable = reachable; \r\n                ++result; \r\n            }\r\n            reachable = max(reachable, right); \r\n            if (reachable >= T) {\r\n                \r\n            }\r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"clips\": [2], \"clips_element0\": [2], \"clips_element0_element0\": [\"0\"], \"clips_element0_element1\": [\"1\"], \"clips_element1\": [2], \"clips_element1_element0\": [\"1\"], \"clips_element1_element1\": [\"2\"], \"T\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numWaterBottles. /*FC*/class Solution {\n/*FM*/int numWaterBottles(int numBottles, int numExchange) {\r\n        int result = numBottles; \r\n        while (numBottles >= numExchange) {\r\n            result += numBottles / numExchange; \r\n            numBottles = numBottles / numExchange + numBottles % numExchange; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"numBottles\": [\"15\"], \"numExchange\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string restoreString. /*FC*/class Solution {\n/*FM*/string restoreString(string s, vector<int>& indices) {\r\n        for (int i = 0;  i < s.length();  ++i) {\r\n            if (indices[i] == i) {\r\n                continue; \r\n            }\r\n            \r\n            \r\n            \r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"abc\"], \"indices\": [3], \"indices_element0\": [\"0\"], \"indices_element1\": [\"1\"], \"indices_element2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string restoreString. /*FC*/class Solution {\n/*FM*/string restoreString(string s, vector<int>& indices) {\r\n        for (int i = 0;  i < s.length();  ++i) {\r\n            if (indices[i] == i) {\r\n                continue; \r\n            }\r\n            auto move = s[i]; \r\n            for (int j = indices[i];  j != i;  swap(indices[j], j)) {\r\n                swap(s[j], move); \r\n            }\r\n            s[i] = move; \r\n        }\r\n        return s; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"codeleet\"], \"indices\": [8], \"indices_element0\": [\"4\"], \"indices_element1\": [\"5\"], \"indices_element2\": [\"6\"], \"indices_element3\": [\"7\"], \"indices_element4\": [\"0\"], \"indices_element5\": [\"2\"], \"indices_element6\": [\"1\"], \"indices_element7\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSlidingWindow. /*FC*/class Solution {\n/*FM*/vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        vector<int> result; \r\n        deque<int> dq; \r\n        for (int i = 0;  i < nums.size();  ++i) {\r\n            if (!dq.empty() && i - dq.front() == k) {\r\n                \r\n            }\r\n            while (!dq.empty() && nums[dq.back()] <= nums[i]) {\r\n                \r\n            }\r\n            dq.emplace_back(i); \r\n            if (i >= k - 1) {\r\n                result.emplace_back(nums[dq.front()]); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [1], \"nums_element0\": [\"1\"], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> maxSlidingWindow. /*FC*/class Solution {\n/*FM*/vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        vector<int> result; \r\n        deque<int> dq; \r\n        for (int i = 0;  i < nums.size();  ++i) {\r\n            if (!dq.empty() && i - dq.front() == k) {\r\n                dq.pop_front(); \r\n            }\r\n            while (!dq.empty() && nums[dq.back()] <= nums[i]) {\r\n                dq.pop_back(); \r\n            }\r\n            dq.emplace_back(i); \r\n            if (i >= k - 1) {\r\n                result.emplace_back(nums[dq.front()]); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [8], \"nums_element0\": [\"1\"], \"nums_element1\": [\"3\"], \"nums_element2\": [\"-1\"], \"nums_element3\": [\"-3\"], \"nums_element4\": [\"5\"], \"nums_element5\": [\"3\"], \"nums_element6\": [\"6\"], \"nums_element7\": [\"7\"], \"k\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestGoodBase. /*FC*/class Solution {\n/*FM*/string smallestGoodBase(string n) {\r\n        unsigned long long num = stoll(n); \r\n        for (int l = log(num) / log(2);  l >= 2;  --l) {\r\n            unsigned long long b = pow(num, 1.0 / l), sum = 0, curr = 1; \r\n            for (int i = 0;  i <= l;  ++i, curr *= b) {\r\n                sum += curr; \r\n            }\r\n            if (sum == num) {\r\n                return to_string(b); \r\n            }\r\n        }  \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"13\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestGoodBase. /*FC*/class Solution {\n/*FM*/string smallestGoodBase(string n) {\r\n        unsigned long long num = stoll(n); \r\n        for (int l = log(num) / log(2);  l >= 2;  --l) {\r\n            unsigned long long b = pow(num, 1.0 / l), sum = 0, curr = 1; \r\n            for (int i = 0;  i <= l;  ++i, curr *= b) {\r\n                sum += curr; \r\n            }\r\n            if (sum == num) {\r\n                \r\n            }\r\n        }  \r\n        return to_string(num - 1); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"1000000000000000000\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        vector<string> names; \r\n        vector<string> tokens(move(split(path, '/'))); \r\n        for (const auto& token : tokens) {\r\n            if (token == \"..\" && !names.empty()) {\r\n                \r\n            } else if (token != \"..\" && token != \".\" && !token.empty()) {\r\n                names.emplace_back(token); \r\n            }\r\n        }\r\n        return string(\"/\").append(join(names, '/')); \r\n    };/*F*//*C*//*M*/vector<string> split(const string& s, const char delim) {\r\n        vector<string> tokens; \r\n        stringstream ss(s); \r\n        string token; \r\n        while (getline(ss, token, delim)) {\r\n            tokens.emplace_back(token); \r\n        }\r\n        return tokens; \r\n    } string join(const vector<string>& names, const char delim) {\r\n        ostringstream ss; \r\n        if (!names.empty()) {\r\n            const string delim_str(1, delim); \r\n            copy(names.cbegin(), prev(names.cend()),\r\n                 ostream_iterator<string>(ss, delim_str.c_str())); \r\n            ss << names.back(); \r\n        }\r\n        return ss.str(); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"path\": [\"/home//foo/\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        vector<string> names; \r\n        vector<string> tokens(move(split(path, '/'))); \r\n        for (const auto& token : tokens) {\r\n            if (token == \"..\" && !names.empty()) {\r\n                \r\n            } else if (token != \"..\" && token != \".\" && !token.empty()) {\r\n                \r\n            }\r\n        }\r\n        return string(\"/\").append(join(names, '/')); \r\n    };/*F*//*C*//*M*/vector<string> split(const string& s, const char delim) {\r\n        vector<string> tokens; \r\n        stringstream ss(s); \r\n        string token; \r\n        while (getline(ss, token, delim)) {\r\n            tokens.emplace_back(token); \r\n        }\r\n        return tokens; \r\n    } string join(const vector<string>& names, const char delim) {\r\n        ostringstream ss; \r\n        if (!names.empty()) {\r\n            const string delim_str(1, delim); \r\n            copy(names.cbegin(), prev(names.cend()),\r\n                 ostream_iterator<string>(ss, delim_str.c_str())); \r\n            ss << names.back(); \r\n        }\r\n        return ss.str(); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"path\": [\"/../\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string simplifyPath. /*FC*/class Solution {\n/*FM*/string simplifyPath(string path) {\r\n        vector<string> names; \r\n        vector<string> tokens(move(split(path, '/'))); \r\n        for (const auto& token : tokens) {\r\n            if (token == \"..\" && !names.empty()) {\r\n                names.pop_back(); \r\n            } else if (token != \"..\" && token != \".\" && !token.empty()) {\r\n                names.emplace_back(token); \r\n            }\r\n        }\r\n        return string(\"/\").append(join(names, '/')); \r\n    };/*F*//*C*//*M*/vector<string> split(const string& s, const char delim) {\r\n        vector<string> tokens; \r\n        stringstream ss(s); \r\n        string token; \r\n        while (getline(ss, token, delim)) {\r\n            tokens.emplace_back(token); \r\n        }\r\n        return tokens; \r\n    } string join(const vector<string>& names, const char delim) {\r\n        ostringstream ss; \r\n        if (!names.empty()) {\r\n            const string delim_str(1, delim); \r\n            copy(names.cbegin(), prev(names.cend()),\r\n                 ostream_iterator<string>(ss, delim_str.c_str())); \r\n            ss << names.back(); \r\n        }\r\n        return ss.str(); \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"path\": [\"/.../a/../b/c/../d/./\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestSubarray. /*FC*/class Solution {\n/*FM*/int shortestSubarray(vector<int>& A, int K) {\r\n        vector<int> accumulated_sum(A.size() + 1, 0); \r\n        partial_sum(A.cbegin(), A.cend(), next(accumulated_sum.begin()), plus<int>()); \r\n        \r\n        int result = numeric_limits<int>::max(); \r\n        deque<int> mono_increasing_q; \r\n        for (int i = 0;  i < accumulated_sum.size();  ++i) {\r\n            while (!mono_increasing_q.empty() &&\r\n                   accumulated_sum[i] <= accumulated_sum[mono_increasing_q.back()]) {\r\n                \r\n            }\r\n            while (!mono_increasing_q.empty() &&\r\n                   accumulated_sum[i] - accumulated_sum[mono_increasing_q.front()] >= K) {\r\n                result = min(result, i - mono_increasing_q.front()); \r\n                mono_increasing_q.pop_front(); \r\n            }\r\n            mono_increasing_q.emplace_back(i); \r\n        }\r\n        return result != numeric_limits<int>::max() ? result : -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [1], \"A_element0\": [\"1\"], \"K\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestSubarray. /*FC*/class Solution {\n/*FM*/int shortestSubarray(vector<int>& A, int K) {\r\n        vector<int> accumulated_sum(A.size() + 1, 0); \r\n        partial_sum(A.cbegin(), A.cend(), next(accumulated_sum.begin()), plus<int>()); \r\n        \r\n        int result = numeric_limits<int>::max(); \r\n        deque<int> mono_increasing_q; \r\n        for (int i = 0;  i < accumulated_sum.size();  ++i) {\r\n            while (!mono_increasing_q.empty() &&\r\n                   accumulated_sum[i] <= accumulated_sum[mono_increasing_q.back()]) {\r\n                mono_increasing_q.pop_back(); \r\n            }\r\n            while (!mono_increasing_q.empty() &&\r\n                   accumulated_sum[i] - accumulated_sum[mono_increasing_q.front()] >= K) {\r\n                result = min(result, i - mono_increasing_q.front()); \r\n                mono_increasing_q.pop_front(); \r\n            }\r\n            mono_increasing_q.emplace_back(i); \r\n        }\r\n        return result != numeric_limits<int>::max() ? result : -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [3], \"A_element0\": [\"2\"], \"A_element1\": [\"-1\"], \"A_element2\": [\"2\"], \"K\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestPathBinaryMatrix. /*FC*/class Solution {\n/*FM*/int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\r\n        static const vector<pair<int, int>> directions = {{-1, -1}, {-1, 0}, {-1, 1},\r\n                                                          { 0, -1}, { 0, 1},\r\n                                                          { 1, -1}, { 1, 0}, { 1, 1}}; \r\n        int result = 0; \r\n        queue<pair<int, int>> q({{0, 0}}); \r\n        while (!q.empty()) {\r\n            ++result; \r\n            queue<pair<int, int>> next_depth; \r\n            while (!q.empty()) {\r\n                int i, j; \r\n                tie(i, j) = q.front();  q.pop(); \r\n                if (0 <= i && i < grid.size() &&\r\n                    0 <= j && j < grid[0].size() &&\r\n                    !grid[i][j]) {\r\n                    grid[i][j] = 1; \r\n                    if (i == grid.size() - 1 && j == grid.size() - 1) {\r\n                        return result; \r\n                    }\r\n                    for (const auto& dir : directions) {\r\n                        next_depth.emplace(i + dir.first, j + dir.second); \r\n                    }\r\n                }\r\n            }\r\n            q = move(next_depth); \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"grid\": [3], \"grid_element0\": [3], \"grid_element0_element0\": [\"0\"], \"grid_element0_element1\": [\"0\"], \"grid_element0_element2\": [\"0\"], \"grid_element1\": [3], \"grid_element1_element0\": [\"1\"], \"grid_element1_element1\": [\"1\"], \"grid_element1_element2\": [\"0\"], \"grid_element2\": [3], \"grid_element2_element0\": [\"1\"], \"grid_element2_element1\": [\"1\"], \"grid_element2_element2\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int shortestPathBinaryMatrix. /*FC*/class Solution {\n/*FM*/int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\r\n        static const vector<pair<int, int>> directions = {{-1, -1}, {-1, 0}, {-1, 1},\r\n                                                          { 0, -1}, { 0, 1},\r\n                                                          { 1, -1}, { 1, 0}, { 1, 1}}; \r\n        int result = 0; \r\n        queue<pair<int, int>> q({{0, 0}}); \r\n        while (!q.empty()) {\r\n            ++result; \r\n            queue<pair<int, int>> next_depth; \r\n            while (!q.empty()) {\r\n                int i, j; \r\n                tie(i, j) = q.front();  q.pop(); \r\n                if (0 <= i && i < grid.size() &&\r\n                    0 <= j && j < grid[0].size() &&\r\n                    !grid[i][j]) {\r\n                    \r\n                    \r\n                    for ( : directions) {\r\n                        \r\n                    }\r\n                }\r\n            }\r\n            q = move(next_depth); \r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"grid\": [3], \"grid_element0\": [3], \"grid_element0_element0\": [\"1\"], \"grid_element0_element1\": [\"0\"], \"grid_element0_element2\": [\"0\"], \"grid_element1\": [3], \"grid_element1_element0\": [\"1\"], \"grid_element1_element1\": [\"1\"], \"grid_element1_element2\": [\"0\"], \"grid_element2\": [3], \"grid_element2_element0\": [\"1\"], \"grid_element2_element1\": [\"1\"], \"grid_element2_element2\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int>& nums) {\r\n        const auto n = nums.size(); \r\n        auto left = -1, right = -2; \r\n        auto max_from_left = nums[0], min_from_right = nums.back(); \r\n        for (int i = 1;  i < n;  ++i) {\r\n            max_from_left = max(max_from_left, nums[i]); \r\n            min_from_right = min(min_from_right, nums[n - 1 - i]); \r\n            if (nums[i] < max_from_left) {\r\n                \r\n            }\r\n            if (nums[n - 1 - i] > min_from_right) {\r\n                \r\n            }\r\n        }\r\n        return right - left + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [4], \"nums_element0\": [\"1\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"3\"], \"nums_element3\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int>& nums) {\r\n        const auto n = nums.size(); \r\n        auto left = -1, right = -2; \r\n        auto max_from_left = nums[0], min_from_right = nums.back(); \r\n        for (int i = 1;  i < n;  ++i) {\r\n            max_from_left = max(max_from_left, nums[i]); \r\n            min_from_right = min(min_from_right, nums[n - 1 - i]); \r\n            if (nums[i] < max_from_left) {\r\n                right = i; \r\n            }\r\n            if (nums[n - 1 - i] > min_from_right) {\r\n                left = n - 1 - i; \r\n            }\r\n        }\r\n        return right - left + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [7], \"nums_element0\": [\"2\"], \"nums_element1\": [\"6\"], \"nums_element2\": [\"4\"], \"nums_element3\": [\"8\"], \"nums_element4\": [\"10\"], \"nums_element5\": [\"9\"], \"nums_element6\": [\"15\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findUnsortedSubarray. /*FC*/class Solution {\n/*FM*/int findUnsortedSubarray(vector<int>& nums) {\r\n        const auto n = nums.size(); \r\n        auto left = -1, right = -2; \r\n        auto max_from_left = nums[0], min_from_right = nums.back(); \r\n        for (int i = 1;  i < n;  ) {\r\n            \r\n            \r\n            \r\n            \r\n        }\r\n        return right - left + 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [1], \"nums_element0\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLengthOfShortestSubarray. /*FC*/class Solution {\n/*FM*/int findLengthOfShortestSubarray(vector<int>& arr) {\r\n        int j; \r\n        for (j = arr.size() - 1;  j >= 1;  ) {\r\n            if (arr[j - 1] > arr[j]) {\r\n                break; \r\n            }\r\n        }\r\n        if (j == 0) {\r\n            \r\n        }\r\n        int result = j; \r\n        for (int i = 0;  i < arr.size();  ++i) {\r\n            if (i && arr[i - 1] > arr[i]) {\r\n                break; \r\n            }\r\n            while (j < arr.size() && arr[i] > arr[j]) {\r\n                ++j; \r\n            }\r\n            result = min(result, (j - i + 1) - 2); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"arr\": [5], \"arr_element0\": [\"5\"], \"arr_element1\": [\"4\"], \"arr_element2\": [\"3\"], \"arr_element3\": [\"2\"], \"arr_element4\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLengthOfShortestSubarray. /*FC*/class Solution {\n/*FM*/int findLengthOfShortestSubarray(vector<int>& arr) {\r\n        int j; \r\n        for (j = arr.size() - 1;  j >= 1;  --j) {\r\n            if (arr[j - 1] > arr[j]) {\r\n                \r\n            }\r\n        }\r\n        if (j == 0) {\r\n            return 0; \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"arr\": [3], \"arr_element0\": [\"1\"], \"arr_element1\": [\"2\"], \"arr_element2\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findLengthOfShortestSubarray. /*FC*/class Solution {\n/*FM*/int findLengthOfShortestSubarray(vector<int>& arr) {\r\n        int j; \r\n        for (j = arr.size() - 1;  j >= 1;  --j) {\r\n            if (arr[j - 1] > arr[j]) {\r\n                break; \r\n            }\r\n        }\r\n        if (j == 0) {\r\n            \r\n        }\r\n        int result = j; \r\n        for (int i = 0;  i < arr.size();  ++i) {\r\n            if (i && arr[i - 1] > arr[i]) {\r\n                break; \r\n            }\r\n            while (j < arr.size() && arr[i] > arr[j]) {\r\n                ++j; \r\n            }\r\n            result = min(result, (j - i + 1) - 2); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"arr\": [8], \"arr_element0\": [\"1\"], \"arr_element1\": [\"2\"], \"arr_element2\": [\"3\"], \"arr_element3\": [\"10\"], \"arr_element4\": [\"4\"], \"arr_element5\": [\"2\"], \"arr_element6\": [\"3\"], \"arr_element7\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void setZeroes. /*FC*/class Solution {\n/*FM*/void setZeroes(vector<vector<int>>& matrix) {\r\n        if (matrix.empty()) {\r\n            \r\n        }\r\n\r\n        bool has_zero = false; \r\n        int zero_i = -1, zero_j = -1; \r\n\r\n        for (int i = 0;  i < matrix.size();  ++i) {\r\n            for (int j = 0;  j < matrix[0].size();  ++j) {\r\n                if (matrix[i][j] == 0) {\r\n                    if (!has_zero) {\r\n                        zero_i = i; \r\n                        zero_j = j; \r\n                        has_zero = true; \r\n                    }\r\n                    matrix[zero_i][j] = 0; \r\n                    matrix[i][zero_j] = 0; \r\n                }\r\n            }\r\n        }\r\n\r\n        if (has_zero) {\r\n            for (int i = 0;  i < matrix.size();  ++i) {\r\n                if (i == zero_i) {\r\n                    continue; \r\n                }\r\n                for (int j = 0;  j < matrix[0].size();  ++j) {\r\n                    if (j == zero_j) {\r\n                        continue; \r\n                    }\r\n                    if (matrix[zero_i][j] == 0 || matrix[i][zero_j] == 0) {\r\n                        matrix[i][j] = 0; \r\n                    }\r\n                }\r\n            }\r\n            for (int i = 0;  i < matrix.size();  ++i) {\r\n                matrix[i][zero_j] = 0; \r\n            }\r\n            for (int j = 0;  j < matrix[0].size();  ++j) {\r\n                matrix[zero_i][j] = 0; \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"matrix\": [3], \"matrix_element0\": [4], \"matrix_element0_element0\": [\"0\"], \"matrix_element0_element1\": [\"1\"], \"matrix_element0_element2\": [\"2\"], \"matrix_element0_element3\": [\"0\"], \"matrix_element1\": [4], \"matrix_element1_element0\": [\"3\"], \"matrix_element1_element1\": [\"4\"], \"matrix_element1_element2\": [\"5\"], \"matrix_element1_element3\": [\"2\"], \"matrix_element2\": [4], \"matrix_element2_element0\": [\"1\"], \"matrix_element2_element1\": [\"3\"], \"matrix_element2_element2\": [\"1\"], \"matrix_element2_element3\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void setZeroes. /*FC*/class Solution {\n/*FM*/void setZeroes(vector<vector<int>>& matrix) {\r\n        if (matrix.empty()) {\r\n            \r\n        }\r\n\r\n        bool has_zero = false; \r\n        int zero_i = -1, zero_j = -1; \r\n\r\n        for (int i = 0;  i < matrix.size();  ++i) {\r\n            for (int j = 0;  j < matrix[0].size();  ++j) {\r\n                if (matrix[i][j] == 0) {\r\n                    if (!has_zero) {\r\n                        zero_i = i; \r\n                        zero_j = j; \r\n                        has_zero = true; \r\n                    }\r\n                    matrix[zero_i][j] = 0; \r\n                    matrix[i][zero_j] = 0; \r\n                }\r\n            }\r\n        }\r\n\r\n        if (has_zero) {\r\n            for (int i = 0;  i < matrix.size();  ++i) {\r\n                if (i == zero_i) {\r\n                    continue; \r\n                }\r\n                for (int j = 0;  j < matrix[0].size();  ++j) {\r\n                    if (j == zero_j) {\r\n                        continue; \r\n                    }\r\n                    if (matrix[zero_i][j] == 0 || matrix[i][zero_j] == 0) {\r\n                        \r\n                    }\r\n                }\r\n            }\r\n            for (int i = 0;  i < matrix.size();  ++i) {\r\n                matrix[i][zero_j] = 0; \r\n            }\r\n            for (int j = 0;  j < matrix[0].size();  ++j) {\r\n                matrix[zero_i][j] = 0; \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"matrix\": [3], \"matrix_element0\": [3], \"matrix_element0_element0\": [\"1\"], \"matrix_element0_element1\": [\"1\"], \"matrix_element0_element2\": [\"1\"], \"matrix_element1\": [3], \"matrix_element1_element0\": [\"1\"], \"matrix_element1_element1\": [\"0\"], \"matrix_element1_element2\": [\"1\"], \"matrix_element2\": [3], \"matrix_element2_element0\": [\"1\"], \"matrix_element2_element1\": [\"1\"], \"matrix_element2_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string shortestCompletingWord. /*FC*/class Solution {\n/*FM*/string shortestCompletingWord(string licensePlate, vector<string>& words) {\r\n        string result; \r\n        const auto& counter = counts(licensePlate); \r\n        for (const auto& word : words) {\r\n            if ((result.empty() || word.length() < result.length()) &&\r\n               contains(counter, word)) {\r\n                result = word; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/vector<int> counts(const string& s) const {\r\n        vector<int> count(26); \r\n        for (const auto& c : s) {\r\n            if (isalpha(c)) {\r\n                ++count[tolower(c) - 'a']; \r\n            }\r\n        }\r\n        return count; \r\n    } bool contains(const vector<int>& counter1, const string& w2) const {\r\n        const auto& counter2 = counts(w2); \r\n        for (int i = 0;  i < counter2.size();  ++i) {\r\n            if (counter1[i] > counter2[i]) {\r\n                return false; \r\n            }\r\n        }\r\n        return true; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"licensePlate\": [\"1s3 456\"], \"words\": [4], \"words_element0\": [\"looks\"], \"words_element1\": [\"pest\"], \"words_element2\": [\"stew\"], \"words_element3\": [\"show\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& nums, int target) {\r\n        int left = 0, right = nums.size() - 1; \r\n\r\n        while (left <= right) {\r\n            int mid = left + (right - left) / 2; \r\n            if (nums[mid] == target) {\r\n                \r\n            } else if ((nums[mid] >= nums[left] && nums[left] <= target && target < nums[mid]) ||\r\n                       (nums[mid] < nums[left] && !(nums[mid] < target && target <= nums[right]))) {\r\n                \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [1], \"nums_element0\": [\"1\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int search. /*FC*/class Solution {\n/*FM*/int search(vector<int>& nums, int target) {\r\n        int left = 0, right = nums.size() - 1; \r\n\r\n        while (left <= right) {\r\n            int mid = left + (right - left) / 2; \r\n            if (nums[mid] == target) {\r\n                return mid; \r\n            } else if ((nums[mid] >= nums[left] && nums[left] <= target && target < nums[mid]) ||\r\n                       (nums[mid] < nums[left] && !(nums[mid] < target && target <= nums[right]))) {\r\n                right = mid - 1; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [7], \"nums_element0\": [\"4\"], \"nums_element1\": [\"5\"], \"nums_element2\": [\"6\"], \"nums_element3\": [\"7\"], \"nums_element4\": [\"0\"], \"nums_element5\": [\"1\"], \"nums_element6\": [\"2\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int searchInsert. /*FC*/class Solution {\n/*FM*/int searchInsert(vector<int>& nums, int target) {\r\n        int left = 0; \r\n        int right = nums.size() - 1; \r\n\r\n        while (left <= right) {\r\n            const auto mid = left + (right -left) / 2; \r\n            if (nums[mid] >= target) {\r\n                right = mid - 1; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n\r\n        return left; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [4], \"nums_element0\": [\"1\"], \"nums_element1\": [\"3\"], \"nums_element2\": [\"5\"], \"nums_element3\": [\"6\"], \"target\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSelfCrossing. /*FC*/class Solution {\n/*FM*/bool isSelfCrossing(vector<int>& x) {\r\n        if (x.size() >= 5 && x[3] == x[1] && x[4] + x[0] >= x[2]) {\r\n            \n            \n            \n            \n            \n            \r\n        }\r\n\r\n        for (int i = 3;  i < x.size();  ) {\r\n            if (x[i] >= x[i - 2] && x[i - 3] >= x[i - 1]) {\r\n                \n                \n                \n                \n                \n                return true; \r\n            } else if (i >= 5 && x[i - 4] <= x[i - 2] && x[i] + x[i - 4] >= x[i - 2] &&\r\n                       x[i - 1] <= x[i - 3] && x[i - 1] + x[i - 5] >= x[i - 3]) {\r\n                \n                \n                \n                \n                \n                \n                \n                \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"x\": [4], \"x_element0\": [\"2\"], \"x_element1\": [\"1\"], \"x_element2\": [\"1\"], \"x_element3\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isSelfCrossing. /*FC*/class Solution {\n/*FM*/bool isSelfCrossing(vector<int>& x) {\r\n        if (x.size() >= 5 && x[3] == x[1] && x[4] + x[0] >= x[2]) {\r\n            \n            \n            \n            \n            \n            \r\n        }\r\n\r\n        for (int i = 3;  i < x.size();  ++i) {\r\n            if (x[i] >= x[i - 2] && x[i - 3] >= x[i - 1]) {\r\n                \n                \n                \n                \n                \n                \r\n            } else if (i >= 5 && x[i - 4] <= x[i - 2] && x[i] + x[i - 4] >= x[i - 2] &&\r\n                       x[i - 1] <= x[i - 3] && x[i - 1] + x[i - 5] >= x[i - 3]) {\r\n                \n                \n                \n                \n                \n                \n                \n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"x\": [4], \"x_element0\": [\"1\"], \"x_element1\": [\"2\"], \"x_element2\": [\"3\"], \"x_element3\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool search. /*FC*/class Solution {\n/*FM*/bool search(vector<int> &nums, int target) {\r\n        int left = 0, right = nums.size() - 1; \r\n\r\n        while (left <= right) {\r\n            int mid = left + (right - left) / 2; \r\n            if (nums[mid] == target) {\r\n                \r\n            } else if (nums[mid] == nums[left]) {\r\n                ++left; \r\n            } else if ((nums[mid] > nums[left] && nums[left] <= target && target < nums[mid]) ||\r\n                       (nums[mid] < nums[left] && !(nums[mid] < target && target <= nums[right]))) {\r\n                right = mid - 1; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [7], \"nums_element0\": [\"2\"], \"nums_element1\": [\"5\"], \"nums_element2\": [\"6\"], \"nums_element3\": [\"0\"], \"nums_element4\": [\"0\"], \"nums_element5\": [\"1\"], \"nums_element6\": [\"2\"], \"target\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool search. /*FC*/class Solution {\n/*FM*/bool search(vector<int> &nums, int target) {\r\n        int left = 0, right = nums.size() - 1; \r\n\r\n        while (left <= right) {\r\n            int mid = left + (right - left) / 2; \r\n            if (nums[mid] == target) {\r\n                return true; \r\n            } else if (nums[mid] == nums[left]) {\r\n                \r\n            } else if ((nums[mid] > nums[left] && nums[left] <= target && target < nums[mid]) ||\r\n                       (nums[mid] < nums[left] && !(nums[mid] < target && target <= nums[right]))) {\r\n                \r\n            } else {\r\n                \r\n            }\r\n        }\r\n\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [7], \"nums_element0\": [\"2\"], \"nums_element1\": [\"5\"], \"nums_element2\": [\"6\"], \"nums_element3\": [\"0\"], \"nums_element4\": [\"0\"], \"nums_element5\": [\"1\"], \"nums_element6\": [\"2\"], \"target\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reverseWords. /*FC*/class Solution {\n/*FM*/void reverseWords(string &s) {\r\n        \n        reverse(s.begin(), s.end()); \r\n\r\n        size_t begin = 0, end = 0, len = 0; \r\n        while ((begin = s.find_first_not_of(\" \", end)) != string::npos) {\r\n            if ((end = s.find(\" \", begin)) == string::npos) {\r\n                end = s.length(); \r\n            }\r\n            \n            reverse(s.begin() + begin, s.begin() + end); \r\n\r\n            \n            move(s.begin() + begin, s.begin() + end, s.begin() + len); \r\n            len += end - begin; \r\n            s[len++] = ' '; \r\n        }\r\n        s.resize(len ? len - 1 : 0); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"the sky is blue\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void reverseWords. /*FC*/class Solution {\n/*FM*/void reverseWords(string &s) {\r\n        \n        reverse(s.begin(), s.end()); \r\n\r\n        size_t begin = 0, end = 0, len = 0; \r\n        while ((begin = s.find_first_not_of(\" \", end)) != string::npos) {\r\n            if ((end = s.find(\" \", begin)) == string::npos) {\r\n                \r\n            }\r\n            \n            reverse(s.begin() + begin, s.begin() + end); \r\n\r\n            \n            move(s.begin() + begin, s.begin() + end, s.begin() + len); \r\n            len += end - begin; \r\n            s[len++] = ' '; \r\n        }\r\n        s.resize(len ? len - 1 : 0); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"  hello world  \"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool equationsPossible. /*FC*/class Solution2 {\n/*FM*/bool equationsPossible(vector<string>& equations) {\r\n        vector<vector<int>> graph(26); \r\n        for (const auto& eqn : equations) {\r\n            int x = eqn[0] - 'a'; \r\n            int y = eqn[3] - 'a'; \r\n            if (eqn[1] == '!') {\r\n                if (x == y) {\r\n                    \r\n                }\r\n            } else {\r\n                graph[x].emplace_back(y); \r\n                graph[y].emplace_back(x); \r\n            }\r\n        }\r\n\r\n        vector<int> color(26); \r\n        for (int i = 0, c = 0;  i < color.size();  ++i) {\r\n            if (color[i]) {\r\n                continue; \r\n            }\r\n            ++c; \r\n            vector<int> stack = {c}; \r\n            while (!stack.empty()) {\r\n                int node = stack.back();  stack.pop_back(); \r\n                for (const auto& nei : graph[node]) {\r\n                    if (!color[nei]) {\r\n                        color[nei] = c; \r\n                        stack.emplace_back(nei); \r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const auto& eqn : equations) {\r\n            if (eqn[1] != '!') {\r\n                continue; \r\n            }\r\n            int x = eqn[0] - 'a'; \r\n            int y = eqn[3] - 'a'; \r\n            if (color[x] && color[x] == color[y]) {\r\n                return false; \r\n            }\r\n        }\r\n         \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\"], \"equations\": [2], \"equations_element0\": [\"a==b\"], \"equations_element1\": [\"b!=a\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool equationsPossible. /*FC*/class Solution2 {\n/*FM*/bool equationsPossible(vector<string>& equations) {\r\n        vector<vector<int>> graph(26); \r\n        for (const auto& eqn : equations) {\r\n            int x = eqn[0] - 'a'; \r\n            int y = eqn[3] - 'a'; \r\n            if (eqn[1] == '!') {\r\n                \r\n            } else {\r\n                graph[x].emplace_back(y); \r\n                graph[y].emplace_back(x); \r\n            }\r\n        }\r\n\r\n        vector<int> color(26); \r\n        for (int i = 0, c = 0;  i < color.size();  ++i) {\r\n            if (color[i]) {\r\n                continue; \r\n            }\r\n            ++c; \r\n            vector<int> stack = {c}; \r\n            while (!stack.empty()) {\r\n                int node = stack.back();  stack.pop_back(); \r\n                for (const auto& nei : graph[node]) {\r\n                    if (!color[nei]) {\r\n                        color[nei] = c; \r\n                        stack.emplace_back(nei); \r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const auto& eqn : equations) {\r\n            if (eqn[1] != '!') {\r\n                continue; \r\n            }\r\n            \r\n            \r\n            \r\n        }\r\n        return true;  \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\"], \"equations\": [2], \"equations_element0\": [\"b==a\"], \"equations_element1\": [\"a==b\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isRobotBounded. /*FC*/class Solution {\n/*FM*/bool isRobotBounded(string instructions) {\r\n        static const vector<vector<int>>& directions = {{ 1, 0}, {0, -1},\r\n                                                        {-1, 0}, {0, 1}}; \r\n        int x = 0, y = 0, i = 0; \r\n        \r\n        for (const auto& instruction : instructions) {\r\n            if (instruction == 'R') {\r\n                \r\n            } else if (instruction == 'L') {\r\n                i = (4 + i - 1) % 4; \r\n            } else {\r\n                x += directions[i][0], y += directions[i][1]; \r\n            }\r\n        }\r\n        return (x == 0 && y == 0) || i > 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"instructions\": [\"GL\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isRobotBounded. /*FC*/class Solution {\n/*FM*/bool isRobotBounded(string instructions) {\r\n        static const vector<vector<int>>& directions = {{ 1, 0}, {0, -1},\r\n                                                        {-1, 0}, {0, 1}}; \r\n        int x = 0, y = 0, i = 0; \r\n        \r\n        for (const auto& instruction : instructions) {\r\n            if (instruction == 'R') {\r\n                \r\n            } else if (instruction == 'L') {\r\n                \r\n            } else {\r\n                x += directions[i][0], y += directions[i][1]; \r\n            }\r\n        }\r\n        return (x == 0 && y == 0) || i > 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"instructions\": [\"GG\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int scoreOfParentheses. /*FC*/class Solution {\n/*FM*/int scoreOfParentheses(string S) {\r\n        int result = 0, depth = 0; \r\n        for (int i = 0;  i < S.length();  ++i) {\r\n            if (S[i] == '(') {\r\n                ++depth; \r\n            } else {\r\n                --depth; \r\n                if (S[i - 1] == '(') {\r\n                    result += 1 << depth; \r\n                }\r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"(())\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int orangesRotting. /*FC*/class Solution {\n/*FM*/int orangesRotting(vector<vector<int>>& grid) {\r\n        static const vector<pair<int, int>> directions{{0, 1}, {1, 0},\r\n                                                       {0, -1}, {-1, 0}}; \r\n\r\n        int count = 0; \r\n        queue<tuple<int, int, int>> q; \r\n        for (int r = 0;  r < grid.size();  ++r) {\r\n            for (int c = 0;  c < grid[r].size();  ++c) {\r\n                if (grid[r][c] == 2) {\r\n                    q.emplace(r, c, 0); \r\n                } else if (grid[r][c]  == 1) {\r\n                    ++count; \r\n                }\r\n            }\r\n        }\r\n\r\n        int result = 0; \r\n        while (!q.empty()) {\r\n            int r, c; \r\n            tie(r, c, result) = q.front();  q.pop(); \r\n            for (const auto& d : directions) {\r\n                int nr = r + d.first, nc = c + d.second; \r\n                if  (!(0 <= nr && nr < grid.size() &&\r\n                       0 <= nc && nc < grid[r].size())) {\r\n                    continue; \r\n                }\r\n                if (grid[nr][nc] == 1) {\r\n                    --count; \r\n                    grid[nr][nc] = 2; \r\n                    q.emplace(nr, nc, result + 1); \r\n                }\r\n            }\r\n        }\r\n        return (count == 0) ? result : -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"grid\": [3], \"grid_element0\": [3], \"grid_element0_element0\": [\"2\"], \"grid_element0_element1\": [\"1\"], \"grid_element0_element2\": [\"1\"], \"grid_element1\": [3], \"grid_element1_element0\": [\"1\"], \"grid_element1_element1\": [\"1\"], \"grid_element1_element2\": [\"0\"], \"grid_element2\": [3], \"grid_element2_element0\": [\"0\"], \"grid_element2_element1\": [\"1\"], \"grid_element2_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int orangesRotting. /*FC*/class Solution {\n/*FM*/int orangesRotting(vector<vector<int>>& grid) {\r\n        static const vector<pair<int, int>> directions{{0, 1}, {1, 0},\r\n                                                       {0, -1}, {-1, 0}}; \r\n\r\n        int count = 0; \r\n        queue<tuple<int, int, int>> q; \r\n        for (int r = 0;  r < grid.size();  ++r) {\r\n            for (int c = 0;  c < grid[r].size();  ++c) {\r\n                if (grid[r][c] == 2) {\r\n                    q.emplace(r, c, 0); \r\n                } else if (grid[r][c]  == 1) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n\r\n        int result = 0; \r\n        while (!q.empty()) {\r\n            int r, c; \r\n            tie(r, c, result) = q.front();  q.pop(); \r\n            for (const auto& d : directions) {\r\n                int nr = r + d.first, nc = c + d.second; \r\n                if  (!(0 <= nr && nr < grid.size() &&\r\n                       0 <= nc && nc < grid[r].size())) {\r\n                    continue; \r\n                }\r\n                if (grid[nr][nc] == 1) {\r\n                    \r\n                    \r\n                    \r\n                }\r\n            }\r\n        }\r\n        return (count == 0) ? result : -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"grid\": [1], \"grid_element0\": [2], \"grid_element0_element0\": [\"0\"], \"grid_element0_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int matrixScore. /*FC*/class Solution {\n/*FM*/int matrixScore(vector<vector<int>>& A) {\r\n        int R = A.size(); \r\n        int C = A[0].size(); \r\n        int result = 0; \r\n        for (int c = 0;  c < C;  ++c) {\r\n            int col = 0; \r\n            for (int r = 0;  r < R;  ++r) {\r\n                col += A[r][c] ^ A[r][0]; \r\n            }\r\n            result += max(col, R - col) * (1 << (C - 1 - c)); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [1], \"A_element0\": [1], \"A_element0_element0\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reverseOnlyLetters. /*FC*/class Solution {\n/*FM*/string reverseOnlyLetters(string S) {\r\n        string result; \r\n        int i = S.length() - 1; \r\n        for (const auto& c : S) {\r\n            if (isalpha(c)) {\r\n                while (!isalpha(S[i])) {\r\n                    --i; \r\n                }\r\n                result.push_back(S[i]); \r\n                --i; \r\n            } else {\r\n                result.push_back(c); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"ab-cd\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string replaceWords. /*FC*/class Solution {\n/*FM*/string replaceWords(vector<string>& dict, string sentence) {\r\n        TrieNode trie; \r\n        string result; \r\n        for (const auto& s : dict) {\r\n            trie.Insert(s); \r\n        }\r\n        auto curr = &trie; \r\n        for (const auto& c : sentence) {\r\n            if (c == ' ' || !curr || !curr->isString) {\r\n                result += c; \r\n            }\r\n            if (c == ' ') {\r\n                curr = &trie; \r\n            } else if (curr && !curr->isString) {\r\n                curr = curr->leaves[c]; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/void Insert(const string& s) {\r\n            auto* p = this; \r\n            for (const auto& c : s) {\r\n                if (p->leaves.find(c) == p->leaves.cend()) {\r\n                    p->leaves[c] = new TrieNode; \r\n                }\r\n                p = p->leaves[c]; \r\n            }\r\n            p->isString = true; \r\n        };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"dict\": [3], \"dict_element0\": [\"a\"], \"dict_element1\": [\"b\"], \"dict_element2\": [\"c\"], \"sentence\": [\"aadsfasf absbs bbab cadsfafs\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfArrays. /*FC*/class Solution {\n/*FM*/int numberOfArrays(string s, int k) {\r\n        static const int MOD = 1e9 + 7; \r\n        int klen = to_string(k).length(); \r\n        vector<int> dp(klen + 1); \r\n        dp[s.length() % dp.size()] = 1; \r\n        for (int i = s.length() - 1;  i >= 0;  --i) {\r\n            dp[i % dp.size()] = 0; \r\n            if (s[i] == '0') {\r\n                \r\n            }\r\n            for (uint64_t j = i, curr = 0;  j < min(uint64_t(i + klen), s.length());  ++j) {\r\n                curr = curr * 10 + s[j] - '0'; \r\n                if (curr > k) {\r\n                    \r\n                }\r\n                dp[i % dp.size()] = (dp[i % dp.size()] + dp[(j + 1) % dp.size()]) % MOD; \r\n            }\r\n        }\r\n        return dp[0]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"1317\"], \"k\": [\"2000\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numberOfArrays. /*FC*/class Solution {\n/*FM*/int numberOfArrays(string s, int k) {\r\n        static const int MOD = 1e9 + 7; \r\n        int klen = to_string(k).length(); \r\n        vector<int> dp(klen + 1); \r\n        dp[s.length() % dp.size()] = 1; \r\n        for (int i = s.length() - 1;  i >= 0;  --i) {\r\n            dp[i % dp.size()] = 0; \r\n            if (s[i] == '0') {\r\n                continue; \r\n            }\r\n            for (uint64_t j = i, curr = 0;  j < min(uint64_t(i + klen), s.length());  ++j) {\r\n                curr = curr * 10 + s[j] - '0'; \r\n                if (curr > k) {\r\n                    \r\n                }\r\n                dp[i % dp.size()] = (dp[i % dp.size()] + dp[(j + 1) % dp.size()]) % MOD; \r\n            }\r\n        }\r\n        return dp[0]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"1000\"], \"k\": [\"10000\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> deckRevealedIncreasing. /*FC*/class Solution {\n/*FM*/vector<int> deckRevealedIncreasing(vector<int>& deck) {\r\n        deque<int> d; \r\n        sort(deck.begin(), deck.end(), greater<int>()); \r\n        for (const auto& i : deck) {\r\n            if (d.empty() == false) {\r\n                d.emplace_front(d.back()); \r\n                d.pop_back(); \r\n            }\r\n            d.emplace_front(i); \r\n        }\r\n        return vector<int>(d.cbegin(), d.cend()); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"deck\": [2], \"deck_element0\": [\"1\"], \"deck_element1\": [\"1000\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool reportSpam. /*FC*/class Solution {\n/*FM*/bool reportSpam(vector<string>& message, vector<string>& bannedWords) {\r\n        static const int THRESHOLD = 2; \r\n\r\n        unordered_set<string> lookup(cbegin(bannedWords), cend(bannedWords)); \r\n        int cnt = 0; \r\n        for (const auto& m : message) {\r\n            if (!lookup.count(m)) {\r\n                \r\n            }\r\n            if (++cnt == THRESHOLD) {\r\n                break; \r\n            }\r\n        }\r\n        return cnt == THRESHOLD; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"message\": [3], \"message_element0\": [\"hello\"], \"message_element1\": [\"world\"], \"message_element2\": [\"leetcode\"], \"bannedWords\": [2], \"bannedWords_element0\": [\"world\"], \"bannedWords_element1\": [\"hello\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool reportSpam. /*FC*/class Solution {\n/*FM*/bool reportSpam(vector<string>& message, vector<string>& bannedWords) {\r\n        static const int THRESHOLD = 2; \r\n\r\n        unordered_set<string> lookup(cbegin(bannedWords), cend(bannedWords)); \r\n        int cnt = 0; \r\n        for (const auto& m : message) {\r\n            if (!lookup.count(m)) {\r\n                continue; \r\n            }\r\n            if (++cnt == THRESHOLD) {\r\n                \r\n            }\r\n        }\r\n        return cnt == THRESHOLD; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"message\": [3], \"message_element0\": [\"hello\"], \"message_element1\": [\"programming\"], \"message_element2\": [\"fun\"], \"bannedWords\": [3], \"bannedWords_element0\": [\"world\"], \"bannedWords_element1\": [\"programming\"], \"bannedWords_element2\": [\"leetcode\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int reverse. /*FC*/class Solution {\n/*FM*/int reverse(int x) {\r\n        int result = 0; \r\n        while (x) {\r\n            if (result > numeric_limits<int>::max() / 10 ||\r\n                (result == numeric_limits<int>::max() / 10 && x % 10 > numeric_limits<int>::max() % 10)) {\r\n                \r\n            }\r\n            if (result < numeric_limits<int>::min() / 10 ||\r\n                (result == numeric_limits<int>::min() / 10 && x % 10 < numeric_limits<int>::min() % 10)) {\r\n                \r\n            }\r\n            result *= 10; \r\n            result += x % 10; \r\n            x /= 10; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"x\": [\"-123\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> removeComments. /*FC*/class Solution {\n/*FM*/vector<string> removeComments(vector<string>& source) {\r\n        bool in_block = false; \r\n        vector<string> result; \r\n        string newline; \r\n        for (const auto& line : source) {\r\n            for (int i = 0;  i < line.length();  ++i) {\r\n                if (!in_block && i + 1 < line.length() && line.substr(i, 2) == \"\") {\r\n                    in_block = false; \r\n                    ++i; \r\n                } else if (!in_block && i + 1 < line.length() && line.substr(i, 2) == \"\n                    \r\n                } else if (!in_block) {\r\n                    newline.push_back(line[i]); \r\n                }\r\n            }\r\n            if (!in_block && !newline.empty()) {\r\n                result.emplace_back(move(newline)); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"source\": [3], \"source_element0\": [\"a/*comment\"], \"source_element1\": [\"line\"], \"source_element2\": [\"more_comment*/b\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reformat. /*FC*/class Solution {\n/*FM*/string reformat(string s) {\r\n        unordered_map<char, int> count; \r\n        int alpha_cnt = 0; \r\n        for (const auto& c : s) {\r\n            ++count[c]; \r\n            if (isalpha(c)) {\r\n                \r\n            }\r\n        }\r\n        if (abs(int(s.length()) - 2 * alpha_cnt) > 1) {\r\n            return \"\"; \r\n        }\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (result.back() == '\\0') {\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"1229857369\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reformat. /*FC*/class Solution {\n/*FM*/string reformat(string s) {\r\n        unordered_map<char, int> count; \r\n        int alpha_cnt = 0; \r\n        for (const auto& c : s) {\r\n            ++count[c]; \r\n            if (isalpha(c)) {\r\n                ++alpha_cnt; \r\n            }\r\n        }\r\n        if (abs(int(s.length()) - 2 * alpha_cnt) > 1) {\r\n            \r\n        }\r\n        \r\n        char a = 'a', a_end = 'z'; \r\n        char b = '0', b_end = '9'; \r\n        if (alpha_cnt < s.length() - alpha_cnt) {\r\n            \r\n            \r\n        }\r\n        string result; \r\n        while (result.length() < s.length()) {\r\n            result.push_back(a = next_char(a, a_end, &count)); \r\n            result.push_back(b = next_char(b, b_end, &count)); \r\n        }\r\n        if (result.back() == '\\0') {\r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/char next_char(char start, char end, unordered_map<char, int> *count) {\r\n        for (char c = start;  c <= end;  ++c) {\r\n            if ((*count)[c]) {\r\n                --(*count)[c]; \r\n                return c; \r\n            }\r\n        }\r\n        return '\\0'; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"a0b1c2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string reformat. /*FC*/class Solution {\n/*FM*/string reformat(string s) {\r\n        unordered_map<char, int> count; \r\n        int alpha_cnt = 0; \r\n        for (const auto& c : s) {\r\n            ++count[c]; \r\n            if (isalpha(c)) {\r\n                ++alpha_cnt; \r\n            }\r\n        }\r\n        if (abs(int(s.length()) - 2 * alpha_cnt) > 1) {\r\n            return \"\"; \r\n        }\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (result.back() == '\\0') {\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"leetcode\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> reconstructMatrix. /*FC*/class Solution {\n/*FM*/vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) {\r\n        vector<int> upper_matrix(colsum.size()); \r\n        vector<int> lower_matrix(colsum.size()); \r\n        for (int i = 0;  i < colsum.size();  ++i) {\r\n            upper_matrix[i] = int(upper > 0 && colsum[i] > 0); \r\n            lower_matrix[i] = colsum[i] - upper_matrix[i]; \r\n            upper -= upper_matrix[i]; \r\n            lower -= lower_matrix[i]; \r\n        }\r\n        if (upper != 0 || lower != 0) {\r\n            return {}; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"upper\": [\"2\"], \"lower\": [\"3\"], \"colsum\": [4], \"colsum_element0\": [\"2\"], \"colsum_element1\": [\"2\"], \"colsum_element2\": [\"1\"], \"colsum_element3\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> reconstructMatrix. /*FC*/class Solution {\n/*FM*/vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) {\r\n        vector<int> upper_matrix(colsum.size()); \r\n        vector<int> lower_matrix(colsum.size()); \r\n        for (int i = 0;  i < colsum.size();  ++i) {\r\n            upper_matrix[i] = int(upper > 0 && colsum[i] > 0); \r\n            lower_matrix[i] = colsum[i] - upper_matrix[i]; \r\n            upper -= upper_matrix[i]; \r\n            lower -= lower_matrix[i]; \r\n        }\r\n        if (upper != 0 || lower != 0) {\r\n            \r\n        }\r\n        return {upper_matrix, lower_matrix}; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"upper\": [\"5\"], \"lower\": [\"5\"], \"colsum\": [10], \"colsum_element0\": [\"2\"], \"colsum_element1\": [\"1\"], \"colsum_element2\": [\"2\"], \"colsum_element3\": [\"0\"], \"colsum_element4\": [\"1\"], \"colsum_element5\": [\"0\"], \"colsum_element6\": [\"1\"], \"colsum_element7\": [\"2\"], \"colsum_element8\": [\"0\"], \"colsum_element9\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findRedundantDirectedConnection. /*FC*/class Solution {\n/*FM*/vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\r\n        vector<int> cand1, cand2; \r\n        unordered_map<int, int> parent; \r\n        for (const auto& edge : edges) {\r\n            if (!parent.count(edge[1])) {\r\n                parent[edge[1]] = edge[0]; \r\n            } else {\r\n                \r\n                \r\n            }\r\n        }\r\n\r\n        UnionFind union_find(edges.size() + 1); \r\n        for (const auto& edge : edges) {\r\n            if (edge == cand2) {\r\n                \r\n            }\r\n            if (!union_find.union_set(edge[0], edge[1])) {\r\n                return cand2.empty() ? edge : cand1; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/bool union_set(const int x, const int y) {\r\n                int x_root = find_set(x), y_root = find_set(y); \r\n                if (x_root == y_root) {\r\n                    return false; \r\n                }\r\n                set_[min(x_root, y_root)] = max(x_root, y_root); \r\n                return true; \r\n            } UnionFind(const int n) : set_(n) {\r\n                iota(set_.begin(), set_.end(), 0); \r\n            };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"edges\": [5], \"edges_element0\": [2], \"edges_element0_element0\": [\"1\"], \"edges_element0_element1\": [\"2\"], \"edges_element1\": [2], \"edges_element1_element0\": [\"2\"], \"edges_element1_element1\": [\"3\"], \"edges_element2\": [2], \"edges_element2_element0\": [\"3\"], \"edges_element2_element1\": [\"4\"], \"edges_element3\": [2], \"edges_element3_element0\": [\"4\"], \"edges_element3_element1\": [\"1\"], \"edges_element4\": [2], \"edges_element4_element0\": [\"1\"], \"edges_element4_element1\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> findRedundantDirectedConnection. /*FC*/class Solution {\n/*FM*/vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\r\n        vector<int> cand1, cand2; \r\n        unordered_map<int, int> parent; \r\n        for (const auto& edge : edges) {\r\n            if (!parent.count(edge[1])) {\r\n                parent[edge[1]] = edge[0]; \r\n            } else {\r\n                cand1 = {parent[edge[1]], edge[1]}; \r\n                cand2 = edge; \r\n            }\r\n        }\r\n\r\n        UnionFind union_find(edges.size() + 1); \r\n        for (const auto& edge : edges) {\r\n            if (edge == cand2) {\r\n                continue; \r\n            }\r\n            if (!union_find.union_set(edge[0], edge[1])) {\r\n                \r\n            }\r\n        }\r\n        return cand2; \r\n    };/*F*//*C*//*M*/bool union_set(const int x, const int y) {\r\n                int x_root = find_set(x), y_root = find_set(y); \r\n                if (x_root == y_root) {\r\n                    return false; \r\n                }\r\n                set_[min(x_root, y_root)] = max(x_root, y_root); \r\n                return true; \r\n            } UnionFind(const int n) : set_(n) {\r\n                iota(set_.begin(), set_.end(), 0); \r\n            };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"edges\": [3], \"edges_element0\": [2], \"edges_element0_element0\": [\"1\"], \"edges_element0_element1\": [\"2\"], \"edges_element1\": [2], \"edges_element1_element0\": [\"1\"], \"edges_element1_element1\": [\"3\"], \"edges_element2\": [2], \"edges_element2_element0\": [\"2\"], \"edges_element2_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int removeDuplicates. /*FC*/class Solution {\n/*FM*/int removeDuplicates(vector<int>& nums) {\r\n        if (nums.empty()) {\r\n            \r\n        }\r\n\r\n        const int k = 2;  \n\r\n        int left = 0; \r\n        int right = 1; \r\n\r\n        while (right < nums.size()) {\r\n            if (nums[left] != nums[right] ||\r\n                (left - k + 1 < 0 || nums[left] != nums[left - k + 1])) {\r\n                ++left; \r\n                nums[left] = nums[right]; \r\n            }\r\n            ++right; \r\n        }\r\n\r\n        return left + 1;  \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [10], \"nums_element0\": [\"0\"], \"nums_element1\": [\"0\"], \"nums_element2\": [\"1\"], \"nums_element3\": [\"1\"], \"nums_element4\": [\"1\"], \"nums_element5\": [\"2\"], \"nums_element6\": [\"2\"], \"nums_element7\": [\"3\"], \"nums_element8\": [\"3\"], \"nums_element9\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool reachingPoints. /*FC*/class Solution {\n/*FM*/bool reachingPoints(int sx, int sy, int tx, int ty) {\r\n        while (tx >= sx && ty >= sy) {\r\n            if (tx < ty) {\r\n                swap(sx, sy); \r\n                swap(tx, ty); \r\n            }\r\n            if (ty > sy) {\r\n                tx %= ty; \r\n            } else {\r\n                return (tx - sx) % ty == 0; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"sx\": [\"1\"], \"sy\": [\"1\"], \"tx\": [\"3\"], \"ty\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool reachingPoints. /*FC*/class Solution {\n/*FM*/bool reachingPoints(int sx, int sy, int tx, int ty) {\r\n        while (tx >= sx && ty >= sy) {\r\n            if (tx < ty) {\r\n                \r\n                \r\n            }\r\n            if (ty > sy) {\r\n                tx %= ty; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"sx\": [\"1\"], \"sy\": [\"1\"], \"tx\": [\"2\"], \"ty\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string pushDominoes. /*FC*/class Solution {\n/*FM*/string pushDominoes(string dominoes) {\r\n        vector<int> force(dominoes.length()); \r\n\r\n        int f = 0; \r\n        for (int i = 0;  i < dominoes.length();  ++i) {\r\n            if (dominoes[i] == 'R') {\r\n                f = dominoes.length(); \r\n            } else if (dominoes[i] == 'L') {\r\n                f = 0; \r\n            } else {\r\n                f = max(f - 1, 0); \r\n            }\r\n            force[i] += f; \r\n        }\r\n\r\n        f = 0; \r\n        for (int i = dominoes.length() - 1;  i >= 0;  --i) {\r\n            if (dominoes[i] == 'L') {\r\n                f = dominoes.length(); \r\n            } else if (dominoes[i] == 'R') {\r\n                f = 0; \r\n            } else {\r\n                f = max(f - 1, 0); \r\n            }\r\n            force[i] -= f; \r\n        }\r\n        string result; \r\n        for (const auto& f : force) {\r\n            result.push_back((f == 0) ? '.' : ((f > 0) ? 'R' : 'L')); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"dominoes\": [\"RR.L\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int projectionArea. /*FC*/class Solution {\n/*FM*/int projectionArea(vector<vector<int>>& grid) {\r\n        int result = 0; \r\n        for (int i = 0;  i < grid.size();  ++i) {\r\n            int max_row = 0; \r\n            int max_col = 0; \r\n            for (int j = 0;  j < grid.size();  ++j) {\r\n                if (grid[i][j] > 0) {\r\n                    ++result; \r\n                }\r\n                max_row = max(max_row, grid[i][j]); \r\n                max_col = max(max_col, grid[j][i]); \r\n            }\r\n            result += max_row + max_col; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"1\"], \"grid_element0_element1\": [\"0\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"0\"], \"grid_element1_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> productExceptSelf. /*FC*/class Solution {\n/*FM*/vector<int> productExceptSelf(vector<int>& nums) {\r\n        if (nums.empty()) {\r\n            \r\n        }\r\n\r\n        vector<int> left_product(nums.size()); \r\n\r\n        left_product[0] = 1; \r\n        for (int i = 1;  i < nums.size();  ++i) {\r\n            left_product[i] = left_product[i - 1] * nums[i - 1]; \r\n        }\r\n\r\n        int right_product = 1; \r\n        for (int i = static_cast<int>(nums.size()) - 2;  i >= 0;  --i) {\r\n            right_product *= nums[i + 1]; \r\n            left_product[i] = left_product[i] * right_product; \r\n        }\r\n\r\n        return left_product; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [5], \"nums_element0\": [\"-1\"], \"nums_element1\": [\"1\"], \"nums_element2\": [\"0\"], \"nums_element3\": [\"-3\"], \"nums_element4\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int preimageSizeFZF. /*FC*/class Solution {\n/*FM*/int preimageSizeFZF(int K) {\r\n        const int p = 5; \r\n        int left = 0, right = p * K; \r\n        while (left <= right) {\r\n            const int mid = left + (right - left) / 2; \r\n            if (countOfFactorialPrimes(mid, p) >= K) {\r\n                right = mid - 1; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n        return countOfFactorialPrimes(left, p) == K ? p : 0; \r\n    };/*F*//*C*//*M*/int countOfFactorialPrimes(int n, int p) {\r\n        int cnt = 0; \r\n        for (;  n > 0;  n /= p) {\r\n            cnt += n / p; \r\n        }\r\n        return cnt; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"K\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int preimageSizeFZF. /*FC*/class Solution {\n/*FM*/int preimageSizeFZF(int K) {\r\n        const int p = 5; \r\n        int left = 0, right = p * K; \r\n        while (left <= right) {\r\n            const int mid = left + (right - left) / 2; \r\n            if (countOfFactorialPrimes(mid, p) >= K) {\r\n                right = mid - 1; \r\n            } else {\r\n                \r\n            }\r\n        }\r\n        return countOfFactorialPrimes(left, p) == K ? p : 0; \r\n    };/*F*//*C*//*M*/int countOfFactorialPrimes(int n, int p) {\r\n        int cnt = 0; \r\n        for (;  n > 0;  n /= p) {\r\n            cnt += n / p; \r\n        }\r\n        return cnt; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"K\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> printVertically. /*FC*/class Solution {\n/*FM*/vector<string> printVertically(string s) {\r\n        vector<string> result, words; \r\n        stringstream ss(s); \r\n        string word; \r\n        int max_len = 0; \r\n        while (ss >> word) {\r\n            words.emplace_back(word); \r\n            max_len = max(max_len, int(word.size())); \r\n        }\r\n        for (int i = 0;  i < max_len;  ++i) {\r\n            result.emplace_back(); \r\n            for (const auto& word : words) {\r\n                result.back() += i < word.length() ? word[i] : ' '; \r\n            }\r\n            while (result.back().back() == ' ') {\r\n                result.back().pop_back(); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"CONTEST IS COMING\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> printVertically. /*FC*/class Solution {\n/*FM*/vector<string> printVertically(string s) {\r\n        vector<string> result, words; \r\n        stringstream ss(s); \r\n        string word; \r\n        int max_len = 0; \r\n        while (ss >> word) {\r\n            words.emplace_back(word); \r\n            max_len = max(max_len, int(word.size())); \r\n        }\r\n        for (int i = 0;  i < max_len;  ++i) {\r\n            result.emplace_back(); \r\n            for (const auto& word : words) {\r\n                result.back() += i < word.length() ? word[i] : ' '; \r\n            }\r\n            while (result.back().back() == ' ') {\r\n                \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"HOW ARE YOU\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int primePalindrome. /*FC*/class Solution {\n/*FM*/int primePalindrome(int N) {\r\n        if (8 <= N && N <= 11) {\r\n            \n            return 11; \r\n        }\r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"N\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int primePalindrome. /*FC*/class Solution {\n/*FM*/int primePalindrome(int N) {\r\n        if (8 <= N && N <= 11) {\r\n            \n            \r\n        }\r\n        for (int i = to_string(N).length() / 2;  i < 100000;  ++i) {\r\n            const string s = to_string(i), rev_s(s.rbegin(), s.rend()); \r\n            int j = stoi(s + rev_s.substr(1)); \r\n            if (j >= N && isPrime(j)) {\r\n                return j; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/bool isPrime(int num) {\r\n        if (num < 2 || num % 2 == 0) {\r\n            return num == 2; \r\n        }\r\n        for (int i = 3;  i * i <= num;  i += 2) {\r\n            if (num % i == 0) {\r\n                return false; \r\n            }\r\n        }\r\n        return true; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"N\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool PredictTheWinner. /*FC*/class Solution {\n/*FM*/bool PredictTheWinner(vector<int>& nums) {\r\n        if (nums.size() % 2 == 0 || nums.size() == 1) {\r\n            return true; \r\n        }\r\n\r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [4], \"nums_element0\": [\"1\"], \"nums_element1\": [\"5\"], \"nums_element2\": [\"233\"], \"nums_element3\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool PredictTheWinner. /*FC*/class Solution {\n/*FM*/bool PredictTheWinner(vector<int>& nums) {\r\n        if (nums.size() % 2 == 0 || nums.size() == 1) {\r\n            \r\n        }\r\n\r\n        vector<int> dp(nums.size()); \r\n        for (int i = nums.size() - 1;  i >= 0;  --i) {\r\n            dp[i] = nums[i]; \r\n            for (int j = i + 1;  j < nums.size();  ++j) {\r\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1]); \r\n            }\r\n        }\r\n        \r\n        return dp.back() >= 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [3], \"nums_element0\": [\"1\"], \"nums_element1\": [\"5\"], \"nums_element2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method double myPow. /*FC*/class Solution {\n/*FM*/double myPow(double x, int n) {\r\n        double result = 1; \r\n        long long abs_n = abs(static_cast<long long>(n)); \r\n        while (abs_n > 0) {\r\n            if (abs_n & 1) {\r\n                result *= x; \r\n            }\r\n            abs_n >>= 1; \r\n            x *= x; \r\n        }\r\n        return n < 0 ? 1 / result : result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"x\": [\"2.00000\"], \"n\": [\"-2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkPerfectNumber. /*FC*/class Solution {\n/*FM*/bool checkPerfectNumber(int num) {\r\n        if (num <= 0) {\r\n            return false; \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [\"-1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkPerfectNumber. /*FC*/class Solution {\n/*FM*/bool checkPerfectNumber(int num) {\r\n        if (num <= 0) {\r\n            \r\n        }\r\n        int sum = 0; \r\n        for (int i = 1;  i * i <= num;  ++i) {\r\n            if (num % i == 0) {\r\n                sum += i; \r\n                if (i * i != num) {\r\n                    sum += num / i; \r\n                }\r\n            }\r\n        }\r\n        return sum - num == num; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [\"28\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkInclusion. /*FC*/class Solution {\n/*FM*/bool checkInclusion(string s1, string s2) {\r\n        vector<int> counts(256); \r\n        for (const auto& c : s1) {\r\n            ++counts[c]; \r\n        }\r\n        for (int i = 0, l = s1.length();  i < s2.length();  ++i) {\r\n            if (counts[s2[i]]-- > 0) {\r\n                --l; \r\n            }\r\n            if (l == 0) {\r\n                \r\n            }\r\n            int start = i + 1 - s1.length(); \r\n            if (start >= 0 && ++counts[s2[start]] > 0) {\r\n                ++l; \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s1\": [\"ab\"], \"s2\": [\"eidboaoo\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkInclusion. /*FC*/class Solution {\n/*FM*/bool checkInclusion(string s1, string s2) {\r\n        vector<int> counts(256); \r\n        for (const auto& c : s1) {\r\n            ++counts[c]; \r\n        }\r\n        for (int i = 0, l = s1.length();  i < s2.length();  ++i) {\r\n            if (counts[s2[i]]-- > 0) {\r\n                --l; \r\n            }\r\n            if (l == 0) {\r\n                return true; \r\n            }\r\n            int start = i + 1 - s1.length(); \r\n            if (start >= 0 && ++counts[s2[start]] > 0) {\r\n                \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s1\": [\"ab\"], \"s2\": [\"eidbaooo\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> largeGroupPositions. /*FC*/class Solution {\n/*FM*/vector<vector<int>> largeGroupPositions(string S) {\r\n        vector<vector<int>> result; \r\n        for (int i = 0, j = 0;  j < S.length();  ++j) {\r\n            if (j == S.length() - 1 || S[j] != S[j + 1]) {\r\n                if (j - i + 1 >= 3) {\r\n                    result.emplace_back(vector<int>{i, j}); \r\n                }\r\n                i = j + 1; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"abbxxxxzzy\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> largeGroupPositions. /*FC*/class Solution {\n/*FM*/vector<vector<int>> largeGroupPositions(string S) {\r\n        vector<vector<int>> result; \r\n        for (int i = 0, j = 0;  j < S.length();  ++j) {\r\n            if (j == S.length() - 1 || S[j] != S[j + 1]) {\r\n                if (j - i + 1 >= 3) {\r\n                    \r\n                }\r\n                i = j + 1; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"abc\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int>& digits) {\r\n        for (int i = digits.size() - 1;  i >= 0;  ) {\r\n            if (digits[i] == 9) {\r\n                \r\n            } else {\r\n                ++digits[i]; \r\n                return digits; \r\n            }\r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"digits\": [4], \"digits_element0\": [\"4\"], \"digits_element1\": [\"3\"], \"digits_element2\": [\"2\"], \"digits_element3\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> plusOne. /*FC*/class Solution {\n/*FM*/vector<int> plusOne(vector<int>& digits) {\r\n        for (int i = digits.size() - 1;  i >= 0;  --i) {\r\n            if (digits[i] == 9) {\r\n                digits[i] = 0; \r\n            } else {\r\n                \r\n                \r\n            }\r\n        }\r\n        digits[0] = 1; \r\n        digits.emplace_back(0); \r\n        return digits; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"digits\": [1], \"digits_element0\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string s) {\r\n        int i = 0, j = s.length() - 1; \r\n        while (i < j) {\r\n            if (!isalnum(s[i])) {\r\n                ++i; \r\n            } else if (!isalnum(s[j])) {\r\n                --j; \r\n            } else if (tolower(s[i]) != tolower(s[j])) {\r\n                \r\n            } else {\r\n                ++i, --j; \r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"A man, a plan, a canal: Panama\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string s) {\r\n        int i = 0, j = s.length() - 1; \r\n        while (i < j) {\r\n            \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\" \"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPalindrome. /*FC*/class Solution {\n/*FM*/bool isPalindrome(string s) {\r\n        int i = 0, j = s.length() - 1; \r\n        while (i < j) {\r\n            if (!isalnum(s[i])) {\r\n                \r\n            } else if (!isalnum(s[j])) {\r\n                --j; \r\n            } else if (tolower(s[i]) != tolower(s[j])) {\r\n                return false; \r\n            } else {\r\n                ++i, --j; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"race a car\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(string s) {\r\n        enum InputType {\r\n            INVALID,    \n            SPACE,      \n            SIGN,       \n            DIGIT,      \n            DOT,        \n            EXPONENT,   \n            NUM_INPUTS  \n        }; \r\n        int transitionTable[][NUM_INPUTS] = {\r\n            -1,  0,  3,  1,  2, -1,     \n            -1,  8, -1,  1,  4,  5,     \n            -1, -1, -1,  4, -1, -1,     \n            -1, -1, -1,  1,  2, -1,     \n            -1,  8, -1,  4, -1,  5,     \n            -1, -1,  6,  7, -1, -1,     \n            -1, -1, -1,  7, -1, -1,     \n            -1,  8, -1,  7, -1, -1,     \n            -1,  8, -1, -1, -1, -1,     \n        }; \r\n\r\n        int state = 0; \r\n        for (const auto& c: s) {\r\n            InputType inputType = INVALID; \r\n            if (isspace(c)) {\r\n                \r\n            } else if (c == '+' || c == '-') {\r\n                \r\n            } else if (isdigit(c)) {\r\n                \r\n            } else if (c == '.') {\r\n                inputType = DOT; \r\n            } else if (c == 'e' || c == 'E') {\r\n                \r\n            }\r\n            \n            state = transitionTable[state][inputType]; \r\n\r\n            \n            if (state == -1) {\r\n                \r\n            }\r\n        }\r\n        \n        \n        return state == 1 || state == 4 || state == 7 || state == 8; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\".\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(string s) {\r\n        enum InputType {\r\n            INVALID,    \n            SPACE,      \n            SIGN,       \n            DIGIT,      \n            DOT,        \n            EXPONENT,   \n            NUM_INPUTS  \n        }; \r\n        int transitionTable[][NUM_INPUTS] = {\r\n            -1,  0,  3,  1,  2, -1,     \n            -1,  8, -1,  1,  4,  5,     \n            -1, -1, -1,  4, -1, -1,     \n            -1, -1, -1,  1,  2, -1,     \n            -1,  8, -1,  4, -1,  5,     \n            -1, -1,  6,  7, -1, -1,     \n            -1, -1, -1,  7, -1, -1,     \n            -1,  8, -1,  7, -1, -1,     \n            -1,  8, -1, -1, -1, -1,     \n        }; \r\n\r\n        int state = 0; \r\n        for (const auto& c: s) {\r\n            InputType inputType = INVALID; \r\n            if (isspace(c)) {\r\n                \r\n            } else if (c == '+' || c == '-') {\r\n                \r\n            } else if (isdigit(c)) {\r\n                \r\n            } else if (c == '.') {\r\n                \r\n            } else if (c == 'e' || c == 'E') {\r\n                inputType = EXPONENT; \r\n            }\r\n            \n            state = transitionTable[state][inputType]; \r\n\r\n            \n            if (state == -1) {\r\n                return false; \r\n            }\r\n        }\r\n        \n        \n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"e\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isNumber. /*FC*/class Solution {\n/*FM*/bool isNumber(string s) {\r\n        enum InputType {\r\n            INVALID,    \n            SPACE,      \n            SIGN,       \n            DIGIT,      \n            DOT,        \n            EXPONENT,   \n            NUM_INPUTS  \n        }; \r\n        int transitionTable[][NUM_INPUTS] = {\r\n            -1,  0,  3,  1,  2, -1,     \n            -1,  8, -1,  1,  4,  5,     \n            -1, -1, -1,  4, -1, -1,     \n            -1, -1, -1,  1,  2, -1,     \n            -1,  8, -1,  4, -1,  5,     \n            -1, -1,  6,  7, -1, -1,     \n            -1, -1, -1,  7, -1, -1,     \n            -1,  8, -1,  7, -1, -1,     \n            -1,  8, -1, -1, -1, -1,     \n        }; \r\n\r\n        int state = 0; \r\n        for (const auto& c: s) {\r\n            InputType inputType = INVALID; \r\n            if (isspace(c)) {\r\n                \r\n            } else if (c == '+' || c == '-') {\r\n                \r\n            } else if (isdigit(c)) {\r\n                inputType = DIGIT; \r\n            } else if (c == '.') {\r\n                \r\n            } else if (c == 'e' || c == 'E') {\r\n                \r\n            }\r\n            \n            state = transitionTable[state][inputType]; \r\n\r\n            \n            if (state == -1) {\r\n                \r\n            }\r\n        }\r\n        \n        \n        return state == 1 || state == 4 || state == 7 || state == 8; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPerfectSquare. /*FC*/class Solution {\n/*FM*/bool isPerfectSquare(int num) {\r\n        int left = 1, right = num; \r\n        while (left <= right) {\r\n            const int mid = left + (right - left) / 2; \r\n            if (mid >= num / mid) {\r\n                right = mid - 1; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n        return left == num / left && num % left == 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [\"16\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validMountainArray. /*FC*/class Solution {\n/*FM*/bool validMountainArray(vector<int>& A) {\r\n        int i = 0; \r\n        while (i + 1 < A.size() && A[i] < A[i + 1]) {\r\n            ++i; \r\n        }\r\n        int j = A.size() - 1; \r\n        while (j - 1 >= 0 && A[j - 1] > A[j]) {\r\n            --j; \r\n        }\r\n        return 0 < i && i == j && j < A.size() - 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [4], \"A_element0\": [\"0\"], \"A_element1\": [\"3\"], \"A_element2\": [\"2\"], \"A_element3\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validMountainArray. /*FC*/class Solution {\n/*FM*/bool validMountainArray(vector<int>& A) {\r\n        int i = 0; \r\n        while (i + 1 < A.size() && A[i] < A[i + 1]) {\r\n            \r\n        }\r\n        int j = A.size() - 1; \r\n        while (j - 1 >= 0 && A[j - 1] > A[j]) {\r\n            --j; \r\n        }\r\n        return 0 < i && i == j && j < A.size() - 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [2], \"A_element0\": [\"2\"], \"A_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validMountainArray. /*FC*/class Solution {\n/*FM*/bool validMountainArray(vector<int>& A) {\r\n        int i = 0; \r\n        while (i + 1 < A.size() && A[i] < A[i + 1]) {\r\n            ++i; \r\n        }\r\n        int j = A.size() - 1; \r\n        while (j - 1 >= 0 && A[j - 1] > A[j]) {\r\n            \r\n        }\r\n        return 0 < i && i == j && j < A.size() - 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [3], \"A_element0\": [\"3\"], \"A_element1\": [\"5\"], \"A_element2\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validateStackSequences. /*FC*/class Solution {\n/*FM*/bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\r\n        int i = 0; \r\n        vector<int> s; \r\n        for (const auto& v : pushed) {\r\n            s.emplace_back(v); \r\n            while (!s.empty() &&\r\n                   i < popped.size() &&\r\n                   s.back() == popped[i]) {\r\n                s.pop_back(); \r\n                ++i; \r\n            }\r\n        }\r\n        return i == popped.size(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"pushed\": [5], \"pushed_element0\": [\"1\"], \"pushed_element1\": [\"2\"], \"pushed_element2\": [\"3\"], \"pushed_element3\": [\"4\"], \"pushed_element4\": [\"5\"], \"popped\": [5], \"popped_element0\": [\"4\"], \"popped_element1\": [\"5\"], \"popped_element2\": [\"3\"], \"popped_element3\": [\"2\"], \"popped_element4\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkValidString. /*FC*/class Solution {\n/*FM*/bool checkValidString(string s) {\r\n        int lower = 0, upper = 0;   \n        for (const auto& c : s) {\r\n            lower += (c == '(') ? 1 : -1; \r\n            upper -= (c == ')') ? 1 : -1; \r\n            if (upper < 0) \r\n            lower = max(lower, 0); \r\n        }\r\n        return lower == 0;   \n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"(*)\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validPalindrome. /*FC*/class Solution {\n/*FM*/bool validPalindrome(string s) {\r\n        int left = 0, right = s.length() - 1; \r\n        while (left < right) {\r\n            if (s[left] != s[right]) {\r\n                \r\n            }\r\n            ++left, --right; \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"aba\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validPalindrome. /*FC*/class Solution {\n/*FM*/bool validPalindrome(string s) {\r\n        int left = 0, right = s.length() - 1; \r\n        while (left < right) {\r\n            if (s[left] != s[right]) {\r\n                return validPalindrome(s, left, right - 1) || validPalindrome(s, left + 1, right); \r\n            }\r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"abc\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validPalindrome. /*FC*/class Solution {\n/*FM*/bool validPalindrome(string s) {\r\n        int left = 0, right = s.length() - 1; \r\n        while (left < right) {\r\n            if (s[left] != s[right]) {\r\n                return validPalindrome(s, left, right - 1) || validPalindrome(s, left + 1, right); \r\n            }\r\n            ++left, --right; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"abca\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        const  unordered_map<char, char> symbol_pair = {{')', '('},\r\n                                                        {']', '['},\r\n                                                        {'}', '{'}}; \r\n        stack<char> parentheses; \r\n        for (const auto& c: s) {\r\n            const auto& it = symbol_pair.find(c); \r\n            if (it != symbol_pair.cend()) {\r\n                if (parentheses.empty() ||\r\n                    parentheses.top() != it->second) {\r\n                    \r\n                }\r\n                parentheses.pop(); \r\n            } else {\r\n                parentheses.emplace(c); \r\n            }\r\n        }\r\n        return parentheses.empty(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"([])\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isValid. /*FC*/class Solution {\n/*FM*/bool isValid(string s) {\r\n        const  unordered_map<char, char> symbol_pair = {{')', '('},\r\n                                                        {']', '['},\r\n                                                        {'}', '{'}}; \r\n        stack<char> parentheses; \r\n        for (const auto& c: s) {\r\n            const auto& it = symbol_pair.find(c); \r\n            if (it != symbol_pair.cend()) {\r\n                if (parentheses.empty() ||\r\n                    parentheses.top() != it->second) {\r\n                    return false; \r\n                }\r\n                \r\n            } else {\r\n                parentheses.emplace(c); \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"(]\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumPartition. /*FC*/class Solution {\n/*FM*/int minimumPartition(string s, int k) {\r\n        int result = 1; \r\n        int64_t curr = 0; \r\n        for (const auto& c : s) {\r\n            if (c - '0' > k) {\r\n                \r\n            }\r\n            if (curr * 10 + (c - '0') > k) {\r\n                ++result; \r\n                curr = 0; \r\n            }\r\n            curr = curr * 10 + (c - '0'); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"165462\"], \"k\": [\"60\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumPartition. /*FC*/class Solution {\n/*FM*/int minimumPartition(string s, int k) {\r\n        int result = 1; \r\n        int64_t curr = 0; \r\n        for (const auto& c : s) {\r\n            if (c - '0' > k) {\r\n                return -1; \r\n            }\r\n            if (curr * 10 + (c - '0') > k) {\r\n                ++result; \r\n                curr = 0; \r\n            }\r\n            curr = curr * 10 + (c - '0'); \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"238182\"], \"k\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canThreePartsEqualSum. /*FC*/class Solution {\n/*FM*/bool canThreePartsEqualSum(vector<int>& A) {\r\n        const auto& total = accumulate(A.cbegin(), A.cend(), 0); \r\n        if (total % 3 != 0) {\r\n            \r\n        }\r\n        int curr = 0, parts = 0; \r\n        for (const auto& x : A) {\r\n            curr += x; \r\n            if (curr == total / 3) {\r\n                ++parts, curr = 0; \r\n            }\r\n        }\r\n        return parts >= 3; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [11], \"A_element0\": [\"0\"], \"A_element1\": [\"2\"], \"A_element2\": [\"1\"], \"A_element3\": [\"-6\"], \"A_element4\": [\"6\"], \"A_element5\": [\"-7\"], \"A_element6\": [\"9\"], \"A_element7\": [\"1\"], \"A_element8\": [\"2\"], \"A_element9\": [\"0\"], \"A_element10\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canThreePartsEqualSum. /*FC*/class Solution {\n/*FM*/bool canThreePartsEqualSum(vector<int>& A) {\r\n        const auto& total = accumulate(A.cbegin(), A.cend(), 0); \r\n        if (total % 3 != 0) {\r\n            \r\n        }\r\n        int curr = 0, parts = 0; \r\n        for (const auto& x : A) {\r\n            curr += x; \r\n            if (curr == total / 3) {\r\n                \r\n            }\r\n        }\r\n        return parts >= 3; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [11], \"A_element0\": [\"0\"], \"A_element1\": [\"2\"], \"A_element2\": [\"1\"], \"A_element3\": [\"-6\"], \"A_element4\": [\"6\"], \"A_element5\": [\"7\"], \"A_element6\": [\"9\"], \"A_element7\": [\"-1\"], \"A_element8\": [\"2\"], \"A_element9\": [\"0\"], \"A_element10\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPartition. /*FC*/class Solution {\n/*FM*/bool canPartition(vector<int>& nums) {\r\n       const auto sum = accumulate(nums.cbegin(), nums.cend(), 0); \r\n       if (sum % 2) {\r\n           return false; \r\n       }\r\n       \r\n       \r\n       \r\n       for ( : nums) {\r\n           \r\n       }\r\n       \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [4], \"nums_element0\": [\"1\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"3\"], \"nums_element3\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool canPartition. /*FC*/class Solution {\n/*FM*/bool canPartition(vector<int>& nums) {\r\n       const auto sum = accumulate(nums.cbegin(), nums.cend(), 0); \r\n       if (sum % 2) {\r\n           \r\n       }\r\n       \r\n       vector<bool> dp(sum / 2 + 1); \r\n       dp[0]  = true; \r\n       for (const auto& num : nums) {\r\n           for (int i = dp.size() - 1;  i >= 0;  --i) {\r\n               if (num <= i) {\r\n                   dp[i] = dp[i] || dp[i - num]; \r\n               }\r\n           }\r\n       }\r\n       return dp.back(); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [4], \"nums_element0\": [\"1\"], \"nums_element1\": [\"5\"], \"nums_element2\": [\"11\"], \"nums_element3\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> generate. /*FC*/class Solution {\n/*FM*/vector<vector<int>> generate(int numRows) {\r\n        vector<vector<int>> result; \r\n        for (int i = 0;  i < numRows;  ++i) {\r\n            result.push_back({}); \r\n            for (int j = 0;  j <= i;  ++j) {\r\n                if (j == 0 || j == i) {\r\n                    result[i].emplace_back(1); \r\n                } else {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"numRows\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<vector<int>> generate. /*FC*/class Solution {\n/*FM*/vector<vector<int>> generate(int numRows) {\r\n        vector<vector<int>> result; \r\n        for (int i = 0;  i < numRows;  ++i) {\r\n            result.push_back({}); \r\n            for (int j = 0;  j <= i;  ++j) {\r\n                if (j == 0 || j == i) {\r\n                    result[i].emplace_back(1); \r\n                } else {\r\n                    result[i].emplace_back(result[i - 1][j - 1] +\r\n                                           result[i - 1][j]); \r\n                }\r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"numRows\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> partitionLabels. /*FC*/class Solution {\n/*FM*/vector<int> partitionLabels(string S) {\r\n        unordered_map<int, int> lookup; \r\n        for (int i = 0;  i < S.length();  ++i) {\r\n            lookup[S[i]] = i; \r\n        }\r\n        int first = 0, last = 0; \r\n        vector<int> result; \r\n        for (int i = 0;  i < S.length();  ++i) {\r\n            last = max(last, lookup[S[i]]); \r\n            if (i == last) {\r\n                result.emplace_back(i - first + 1); \r\n                first = i + 1; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"S\": [\"ababcbacadefegdehijhklij\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPatches. /*FC*/class Solution {\n/*FM*/int minPatches(vector<int>& nums, int n) {\r\n        int result = 0, reachable = 0; \r\n        for (const auto& x : nums) {\r\n            if (x > n) {\r\n                \r\n            }\r\n            while (!(reachable >= x - 1)) {\r\n                \r\n                \r\n            }\r\n            if (reachable >= n - x) {\r\n                return result; \r\n            }\r\n            reachable += x; \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [3], \"nums_element0\": [\"1\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"2\"], \"n\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minPatches. /*FC*/class Solution {\n/*FM*/int minPatches(vector<int>& nums, int n) {\r\n        int result = 0, reachable = 0; \r\n        for (const auto& x : nums) {\r\n            if (x > n) {\r\n                \r\n            }\r\n            while (!(reachable >= x - 1)) {\r\n                ++result; \r\n                reachable += reachable + 1; \r\n            }\r\n            if (reachable >= n - x) {\r\n                return result; \r\n            }\r\n            reachable += x; \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [3], \"nums_element0\": [\"1\"], \"nums_element1\": [\"5\"], \"nums_element2\": [\"10\"], \"n\": [\"20\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findSubstringInWraproundString. /*FC*/class Solution {\n/*FM*/int findSubstringInWraproundString(string p) {\r\n        vector<int> letters(26, 0); \r\n        int result = 0, len = 0; \r\n        for (int i = 0;  i < p.length();  ++i) {\r\n            int curr = p[i] - 'a'; \r\n            if (i > 0 && p[i - 1] != (curr + 26 - 1) % 26 + 'a') {\r\n                \r\n            }\r\n            if (++len > letters[curr]) {\r\n                result += len - letters[curr]; \r\n                letters[curr] = len; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"p\": [\"zab\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findSubstringInWraproundString. /*FC*/class Solution {\n/*FM*/int findSubstringInWraproundString(string p) {\r\n        vector<int> letters(26, 0); \r\n        int result = 0, len = 0; \r\n        for (int i = 0;  i < p.length();  ++i) {\r\n            int curr = p[i] - 'a'; \r\n            if (i > 0 && p[i - 1] != (curr + 26 - 1) % 26 + 'a') {\r\n                len = 0; \r\n            }\r\n            if (++len > letters[curr]) {\r\n                result += len - letters[curr]; \r\n                letters[curr] = len; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"p\": [\"cac\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int uniquePathsWithObstacles. /*FC*/class Solution {\n/*FM*/int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\r\n            const int m = obstacleGrid.size(); \r\n            const int n = obstacleGrid[0].size(); \r\n            vector<int> v(n, 0); \r\n\r\n            v[0] = 1; \r\n            for(int i = 0;  i < m;  ++i) {\r\n                if(obstacleGrid[i][0] != 0)\r\n                    \r\n                for(int j = 1;  j < n;  ++j) {\r\n                    if(obstacleGrid[i][j] == 0)\r\n                        v[j] += v[j - 1]; \r\n                    else\r\n                        v[j] = 0; \r\n                }\r\n            }\r\n\r\n            return v[n - 1]; \r\n        };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"obstacleGrid\": [3], \"obstacleGrid_element0\": [3], \"obstacleGrid_element0_element0\": [\"0\"], \"obstacleGrid_element0_element1\": [\"0\"], \"obstacleGrid_element0_element2\": [\"0\"], \"obstacleGrid_element1\": [3], \"obstacleGrid_element1_element0\": [\"0\"], \"obstacleGrid_element1_element1\": [\"1\"], \"obstacleGrid_element1_element2\": [\"0\"], \"obstacleGrid_element2\": [3], \"obstacleGrid_element2_element0\": [\"0\"], \"obstacleGrid_element2_element1\": [\"0\"], \"obstacleGrid_element2_element2\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validUtf8. /*FC*/class Solution {\n/*FM*/bool validUtf8(vector<int>& data) {\r\n        int count = 0; \r\n        for (const auto& c : data) {\r\n            if (count == 0) {\r\n                if ((c >> 5) == 0b110) {\r\n                    count = 1; \r\n                } else if ((c >> 4) == 0b1110) {\r\n                    \r\n                } else if ((c >> 3) == 0b11110) {\r\n                    \r\n                } else if (c >> 7) {\r\n                    \r\n                }\r\n            } else {\r\n                if ((c >> 6) != 0b10) {\r\n                    \r\n                }\r\n                --count; \r\n            }\r\n        }\r\n        return count == 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"data\": [3], \"data_element0\": [\"197\"], \"data_element1\": [\"130\"], \"data_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool validUtf8. /*FC*/class Solution {\n/*FM*/bool validUtf8(vector<int>& data) {\r\n        int count = 0; \r\n        for (const auto& c : data) {\r\n            if (count == 0) {\r\n                if ((c >> 5) == 0b110) {\r\n                    \r\n                } else if ((c >> 4) == 0b1110) {\r\n                    count = 2; \r\n                } else if ((c >> 3) == 0b11110) {\r\n                    \r\n                } else if ((c >> 7)) {\r\n                    \r\n                }\r\n            } else {\r\n                if ((c >> 6) != 0b10) {\r\n                    return false; \r\n                }\r\n                --count; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"data\": [3], \"data_element0\": [\"235\"], \"data_element1\": [\"140\"], \"data_element2\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> uncommonFromSentences. /*FC*/class Solution {\n/*FM*/vector<string> uncommonFromSentences(string A, string B) {\r\n        unordered_map<string, int> count; \r\n        istringstream iss(A + \" \" + B); \r\n        while (iss >> A) {\r\n            ++count[A]; \r\n        }\r\n        vector<string> result; \r\n        for (const auto& word : count) {\r\n            if (word.second == 1) {\r\n                result.emplace_back(word.first); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [\"this apple is sweet\"], \"B\": [\"this apple is sour\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string validIPAddress. /*FC*/class Solution {\n/*FM*/string validIPAddress(string IP) {\r\n    \tstringstream ss(IP); \r\n    \tstring block; \r\n    \tif (IP.substr(0, 4).find('.') != string::npos) {\r\n    \t    for (int i = 0;  i < 4;  ++i) {\r\n        \t\tif (!getline(ss, block, '.') || !isValidIPv4Block(block)) {\r\n        \t   \t    \r\n        \t\t}\r\n    \t    }\r\n    \t    if (ss.eof()) {\r\n    \t        return \"IPv4\"; \r\n    \t    }\r\n    \t} else if (IP.substr(0, 5).find(':') != string::npos) {\r\n    \t    \r\n    \t    \r\n    \t}\r\n    \r\n    \t\r\n    };/*F*//*C*//*M*/bool isValidIPv4Block(const string& block) {\r\n    \tint num = 0; \r\n    \tif (block.size() > 0 && block.size() <= 3) {\r\n    \t    for (int i = 0;  i < block.size();  ++i) {\r\n    \t        char c = block[i]; \r\n    \t        if (!isdigit(c) || (i == 0 && c == '0' && block.size() > 1)) {\r\n    \t            return false; \r\n    \t        } else {\r\n        \t\t    num *= 10; \r\n        \t\t    num += c - '0'; \r\n    \t        }\r\n    \t    }\r\n    \t    return num <= 255; \r\n    \t}\r\n    \treturn false; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"IP\": [\"172.16.254.1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string validIPAddress. /*FC*/class Solution {\n/*FM*/string validIPAddress(string IP) {\r\n    \tstringstream ss(IP); \r\n    \tstring block; \r\n    \tif (IP.substr(0, 4).find('.') != string::npos) {\r\n    \t    for (int i = 0;  i < 4;  ) {\r\n        \t\tif (!getline(ss, block, '.') || !isValidIPv4Block(block)) {\r\n        \t   \t    return \"Neither\"; \r\n        \t\t}\r\n    \t    }\r\n    \t    \r\n    \t} else if (IP.substr(0, 5).find(':') != string::npos) {\r\n    \t    \r\n    \t    \r\n    \t}\r\n    \r\n    \t\r\n    };/*F*//*C*//*M*/bool isValidIPv4Block(const string& block) {\r\n    \tint num = 0; \r\n    \tif (block.size() > 0 && block.size() <= 3) {\r\n    \t    for (int i = 0;  i < block.size();  ++i) {\r\n    \t        char c = block[i]; \r\n    \t        if (!isdigit(c) || (i == 0 && c == '0' && block.size() > 1)) {\r\n    \t            return false; \r\n    \t        } else {\r\n        \t\t    num *= 10; \r\n        \t\t    num += c - '0'; \r\n    \t        }\r\n    \t    }\r\n    \t    return num <= 255; \r\n    \t}\r\n    \treturn false; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"IP\": [\"256.256.256.256\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string validIPAddress. /*FC*/class Solution {\n/*FM*/string validIPAddress(string IP) {\r\n    \tstringstream ss(IP); \r\n    \tstring block; \r\n    \tif (IP.substr(0, 4).find('.') != string::npos) {\r\n    \t    \r\n    \t    \r\n    \t} else if (IP.substr(0, 5).find(':') != string::npos) {\r\n    \t    for (int i = 0;  i < 8;  ++i) {\r\n        \t\tif (!getline(ss, block, ':') || !isValidIPv6Block(block)) {\r\n        \t\t    \r\n        \t\t}\r\n    \t    }\r\n    \t    if (ss.eof()) {\r\n    \t        return \"IPv6\"; \r\n    \t    }\r\n    \t}\r\n    \r\n    \t\r\n    };/*F*//*C*//*M*/bool isValidIPv6Block(const string& block) {\r\n    \tif (block.size() > 0 && block.size() <= 4) {\r\n    \t    for (int i = 0;  i < block.size();  ++i) {\r\n    \t        char c = block[i]; \r\n    \t        if (!isxdigit(c)) {\r\n    \t    \t    return false; \r\n    \t        }\r\n    \t    }\r\n    \t    return true; \r\n    \t}\r\n    \treturn false; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"IP\": [\"2001:0db8:85a3:0:0:8A2E:0370:7334\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> twoSum. /*FC*/class Solution {\n/*FM*/vector<int> twoSum(vector<int>& numbers, int target) {\r\n        int left = 0, right = numbers.size() - 1; \r\n        \r\n        while (left != right) {\r\n            const auto sum = numbers[left] + numbers[right]; \r\n            if (sum > target) {\r\n                \r\n            } else if (sum < target) {\r\n                \r\n            } else {\r\n                return {left + 1, right + 1}; \r\n            }\r\n        }\r\n\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"numbers\": [3], \"numbers_element0\": [\"2\"], \"numbers_element1\": [\"3\"], \"numbers_element2\": [\"4\"], \"target\": [\"6\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> twoSum. /*FC*/class Solution {\n/*FM*/vector<int> twoSum(vector<int>& numbers, int target) {\r\n        int left = 0, right = numbers.size() - 1; \r\n        \r\n        while (left != right) {\r\n            const auto sum = numbers[left] + numbers[right]; \r\n            if (sum > target) {\r\n                --right; \r\n            } else if (sum < target) {\r\n                \r\n            } else {\r\n                return {left + 1, right + 1}; \r\n            }\r\n        }\r\n\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"numbers\": [4], \"numbers_element0\": [\"2\"], \"numbers_element1\": [\"7\"], \"numbers_element2\": [\"11\"], \"numbers_element3\": [\"15\"], \"target\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int trap. /*FC*/class Solution2 {\n/*FM*/int trap(vector<int>& height) {\r\n        if (height.empty()) {\r\n            \r\n        }\r\n\r\n        int i = 0, j = height.size() - 1; \r\n        int left_height = height[0]; \r\n        int right_height = height[height.size() - 1]; \r\n        int trap = 0; \r\n\r\n        while (i < j) {\r\n            if (left_height < right_height) {\r\n                ++i; \r\n                \n                trap += max(0, left_height - height[i]); \r\n                \n                left_height = max(left_height, height[i]); \r\n            }\r\n            else {\r\n                \r\n                \n                \r\n                \n                \r\n            }\r\n        }\r\n\r\n        return trap; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\"], \"height\": [6], \"height_element0\": [\"4\"], \"height_element1\": [\"2\"], \"height_element2\": [\"0\"], \"height_element3\": [\"3\"], \"height_element4\": [\"2\"], \"height_element5\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int trap. /*FC*/class Solution2 {\n/*FM*/int trap(vector<int>& height) {\r\n        if (height.empty()) {\r\n            \r\n        }\r\n\r\n        int i = 0, j = height.size() - 1; \r\n        int left_height = height[0]; \r\n        int right_height = height[height.size() - 1]; \r\n        int trap = 0; \r\n\r\n        while (i < j) {\r\n            if (left_height < right_height) {\r\n                ++i; \r\n                \n                trap += max(0, left_height - height[i]); \r\n                \n                left_height = max(left_height, height[i]); \r\n            }\r\n            else {\r\n                --j; \r\n                \n                trap += max(0, right_height - height[j]); \r\n                \n                right_height = max(right_height, height[j]); \r\n            }\r\n        }\r\n\r\n        return trap; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\"], \"height\": [12], \"height_element0\": [\"0\"], \"height_element1\": [\"1\"], \"height_element2\": [\"0\"], \"height_element3\": [\"2\"], \"height_element4\": [\"1\"], \"height_element5\": [\"0\"], \"height_element6\": [\"1\"], \"height_element7\": [\"3\"], \"height_element8\": [\"2\"], \"height_element9\": [\"1\"], \"height_element10\": [\"2\"], \"height_element11\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthUglyNumber. /*FC*/class Solution {\n/*FM*/int nthUglyNumber(int n) {\r\n        vector<int> uglies(n); \r\n        uglies[0] = 1; \r\n    \r\n        int f2 = 2, f3 = 3, f5 = 5; \r\n        int idx2 = 0, idx3 = 0, idx5 = 0; \r\n    \r\n        for (int i = 1;  i < n;  ) {\r\n            \r\n            \r\n    \r\n            \r\n            \r\n            \r\n        }\r\n    \r\n        return uglies[n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthUglyNumber. /*FC*/class Solution {\n/*FM*/int nthUglyNumber(int n) {\r\n        vector<int> uglies(n); \r\n        uglies[0] = 1; \r\n    \r\n        int f2 = 2, f3 = 3, f5 = 5; \r\n        int idx2 = 0, idx3 = 0, idx5 = 0; \r\n    \r\n        for (int i = 1;  i < n;  ++i) {\r\n            int min_val = min(min(f2, f3), f5); \r\n            uglies[i] = min_val; \r\n    \r\n            if (min_val == f2) {\r\n                f2 = 2 * uglies[++idx2]; \r\n            }\r\n            if (min_val == f3) {\r\n                f3 = 3 * uglies[++idx3]; \r\n            }\r\n            if (min_val == f5) {\r\n                f5 = 5 * uglies[++idx5]; \r\n            }\r\n        }\r\n    \r\n        return uglies[n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"10\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isToeplitzMatrix. /*FC*/class Solution {\n/*FM*/bool isToeplitzMatrix(vector<vector<int>>& matrix) {\r\n        for (int i = 0;  i < matrix.size();  ++i) {\r\n            for (int j = 0;  j < matrix[i].size();  ++j) {\r\n                if (i != 0 && j != 0 &&\r\n                    matrix[i - 1][j - 1] != matrix[i][j]) {\r\n                    return false; \r\n                }\r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"matrix\": [2], \"matrix_element0\": [2], \"matrix_element0_element0\": [\"1\"], \"matrix_element0_element1\": [\"2\"], \"matrix_element1\": [2], \"matrix_element1_element0\": [\"2\"], \"matrix_element1_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isToeplitzMatrix. /*FC*/class Solution {\n/*FM*/bool isToeplitzMatrix(vector<vector<int>>& matrix) {\r\n        for (int i = 0;  i < matrix.size();  ++i) {\r\n            for (int j = 0;  j < matrix[i].size();  ++j) {\r\n                if (i != 0 && j != 0 &&\r\n                    matrix[i - 1][j - 1] != matrix[i][j]) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"matrix\": [3], \"matrix_element0\": [4], \"matrix_element0_element0\": [\"1\"], \"matrix_element0_element1\": [\"2\"], \"matrix_element0_element2\": [\"3\"], \"matrix_element0_element3\": [\"4\"], \"matrix_element1\": [4], \"matrix_element1_element0\": [\"5\"], \"matrix_element1_element1\": [\"1\"], \"matrix_element1_element2\": [\"2\"], \"matrix_element1_element3\": [\"3\"], \"matrix_element2\": [4], \"matrix_element2_element0\": [\"9\"], \"matrix_element2_element1\": [\"5\"], \"matrix_element2_element2\": [\"1\"], \"matrix_element2_element3\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int totalHammingDistance. /*FC*/class Solution {\n/*FM*/int totalHammingDistance(vector<int>& nums) {\r\n        int result = 0; \r\n        for (int i = 0;  i < 8 * sizeof(int);  ++i) {\r\n            vector<int> counts(2); \r\n            for (const auto& num : nums) {\r\n                ++counts[(num >> i) & 1]; \r\n            }\r\n            result += counts[0] * counts[1]; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [3], \"nums_element0\": [\"4\"], \"nums_element1\": [\"14\"], \"nums_element2\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> topKFrequent. /*FC*/class Solution {\n/*FM*/vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> counts; \r\n        for (const auto& i : nums) {\r\n            ++counts[i]; \r\n        }\r\n        vector<vector<int>> buckets(nums.size() + 1); \r\n        for (const auto& kvp : counts) {\r\n            buckets[kvp.second].emplace_back(kvp.first); \r\n        }\r\n\r\n        vector<int> result; \r\n        for (int i = buckets.size() - 1;  i >= 0;  --i) {\r\n            for (int j = 0;  j < buckets[i].size();  ++j){\r\n                result.emplace_back(buckets[i][j]); \r\n                if (result.size() == k) {\r\n                    return result; \r\n                }\r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [10], \"nums_element0\": [\"1\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"1\"], \"nums_element3\": [\"2\"], \"nums_element4\": [\"1\"], \"nums_element5\": [\"2\"], \"nums_element6\": [\"3\"], \"nums_element7\": [\"1\"], \"nums_element8\": [\"3\"], \"nums_element9\": [\"2\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> topKFrequent. /*FC*/class Solution {\n/*FM*/vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> counts; \r\n        for (const auto& i : nums) {\r\n            ++counts[i]; \r\n        }\r\n        vector<vector<int>> buckets(nums.size() + 1); \r\n        for (const auto& kvp : counts) {\r\n            buckets[kvp.second].emplace_back(kvp.first); \r\n        }\r\n\r\n        vector<int> result; \r\n        for (int i = buckets.size() - 1;  i >= 0;  ) {\r\n            for (int j = 0;  j < buckets[i].size();  ){\r\n                result.emplace_back(buckets[i][j]); \r\n                if (result.size() == k) {\r\n                    return result; \r\n                }\r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [1], \"nums_element0\": [\"1\"], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> fullJustify. /*FC*/class Solution {\n/*FM*/vector<string> fullJustify(vector<string>& words, int maxWidth) {\r\n        vector<string> res; \r\n        const int n = words.size(); \r\n        int begin = 0, len = 0; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            if (len + words[i].size() + (i - begin) > maxWidth) {\r\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false)); \r\n                begin = i; \r\n                len = 0; \r\n            }\r\n            len += words[i].size(); \r\n        }\r\n        \n        res.emplace_back(connect(words, maxWidth, begin, n, len, true)); \r\n        return res; \r\n    };/*F*//*C*//*M*/string connect(const vector<string>& words, int maxWidth,\r\n                   int begin, int end, int len,\r\n                   bool is_last) {\r\n        string s; \r\n        int n = end - begin; \r\n        for (int i = 0;  i < n;  ++i) {\r\n            s += words[begin + i]; \r\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s); \r\n        }\r\n        \n        if (s.size() < maxWidth) {\r\n            s.append(maxWidth - s.size(), ' '); \r\n        }\r\n        return s; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"words\": [6], \"words_element0\": [\"What\"], \"words_element1\": [\"must\"], \"words_element2\": [\"be\"], \"words_element3\": [\"acknowledgment\"], \"words_element4\": [\"shall\"], \"words_element5\": [\"be\"], \"maxWidth\": [\"16\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method long long taskSchedulerII. /*FC*/class Solution {\n/*FM*/long long taskSchedulerII(vector<int>& tasks, int space) {\r\n        unordered_map<int, int64_t> lookup; \r\n        int64_t result = 0; \r\n        for (const auto& t : tasks) {\r\n            result = max(lookup[t], result + 1); \r\n            lookup[t] = result + space + 1; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"tasks\": [6], \"tasks_element0\": [\"1\"], \"tasks_element1\": [\"2\"], \"tasks_element2\": [\"1\"], \"tasks_element3\": [\"2\"], \"tasks_element4\": [\"3\"], \"tasks_element5\": [\"1\"], \"space\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> threeEqualParts. /*FC*/class Solution {\n/*FM*/vector<int> threeEqualParts(vector<int>& A) {\r\n        int total = accumulate(A.cbegin(), A.cend(), 0); \r\n        if (total % 3 != 0) {\r\n            \r\n        }\r\n        if (total == 0) {\r\n            \r\n        }\r\n\r\n        const auto count = total / 3; \r\n        vector<int> nums(3); \r\n        int c = 0; \r\n        for (int i = 0;  i < A.size();  ++i) {\r\n            if (A[i] == 1) {\r\n                if (c % count == 0) {\r\n                    nums[c / count] = i; \r\n                }\r\n                ++c; \r\n            } \r\n        }\r\n\r\n        while (nums[2] != A.size()) {   \r\n            if (A[nums[0]] != A[nums[1]] ||\r\n                A[nums[0]] != A[nums[2]]) {\r\n                \r\n            }\r\n            ++nums[0], ++nums[1], ++nums[2]; \r\n        }\r\n        return {nums[0] - 1, nums[1]}; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [5], \"A_element0\": [\"1\"], \"A_element1\": [\"1\"], \"A_element2\": [\"0\"], \"A_element3\": [\"0\"], \"A_element4\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> threeEqualParts. /*FC*/class Solution {\n/*FM*/vector<int> threeEqualParts(vector<int>& A) {\r\n        int total = accumulate(A.cbegin(), A.cend(), 0); \r\n        if (total % 3 != 0) {\r\n            return {-1, -1}; \r\n        }\r\n        if (total == 0) {\r\n            \r\n        }\r\n\r\n        \r\n        \r\n        \r\n        \r\n\r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [5], \"A_element0\": [\"1\"], \"A_element1\": [\"1\"], \"A_element2\": [\"0\"], \"A_element3\": [\"1\"], \"A_element4\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int secondsToRemoveOccurrences. /*FC*/class Solution {\n/*FM*/int secondsToRemoveOccurrences(string s) {\r\n        int result = 0, cnt = 0; \r\n        for (const auto& c : s) {\r\n            if (c == '0') {\r\n                ++cnt; \r\n                continue; \r\n            }\r\n            if (cnt) {\r\n                \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"11100\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int secondsToRemoveOccurrences. /*FC*/class Solution {\n/*FM*/int secondsToRemoveOccurrences(string s) {\r\n        int result = 0, cnt = 0; \r\n        for (const auto& c : s) {\r\n            if (c == '0') {\r\n                ++cnt; \r\n                continue; \r\n            }\r\n            if (cnt) {\r\n                result = max(result + 1, cnt); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"0110101\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int thirdMax. /*FC*/class Solution {\n/*FM*/int thirdMax(vector<int>& nums) {\r\n        int count = 0; \r\n        vector<int64_t> top(3, numeric_limits<int64_t>::min()); \r\n\r\n        for (const auto& num : nums) {\r\n            if (num > top[0]) {\r\n                top[2] = top[1]; \r\n                top[1] = top[0]; \r\n                top[0] = num; \r\n                ++count; \r\n            } else if (num != top[0] && num > top[1]) {\r\n                \r\n                \r\n                \r\n            } else if (num != top[0] && num != top[1] && num >= top[2]) {\r\n                top[2] = num; \r\n                ++count; \r\n            }\r\n        }\r\n\r\n        if (count < 3) { \r\n            \r\n        }\r\n        return top[2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [4], \"nums_element0\": [\"2\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"3\"], \"nums_element3\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int thirdMax. /*FC*/class Solution {\n/*FM*/int thirdMax(vector<int>& nums) {\r\n        int count = 0; \r\n        vector<int64_t> top(3, numeric_limits<int64_t>::min()); \r\n\r\n        for (const auto& num : nums) {\r\n            if (num > top[0]) {\r\n                top[2] = top[1]; \r\n                top[1] = top[0]; \r\n                top[0] = num; \r\n                ++count; \r\n            } else if (num != top[0] && num > top[1]) {\r\n                \r\n                \r\n                \r\n            } else if (num != top[0] && num != top[1] && num >= top[2]) {\r\n                \r\n                \r\n            }\r\n        }\r\n\r\n        if (count < 3) { \r\n            return top[0]; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [2], \"nums_element0\": [\"1\"], \"nums_element1\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int thirdMax. /*FC*/class Solution {\n/*FM*/int thirdMax(vector<int>& nums) {\r\n        int count = 0; \r\n        vector<int64_t> top(3, numeric_limits<int64_t>::min()); \r\n\r\n        for (const auto& num : nums) {\r\n            if (num > top[0]) {\r\n                top[2] = top[1]; \r\n                top[1] = top[0]; \r\n                top[0] = num; \r\n                ++count; \r\n            } else if (num != top[0] && num > top[1]) {\r\n                top[2] = top[1]; \r\n                top[1] = num; \r\n                ++count; \r\n            } else if (num != top[0] && num != top[1] && num >= top[2]) {\r\n                top[2] = num; \r\n                ++count; \r\n            }\r\n        }\r\n\r\n        if (count < 3) { \r\n            \r\n        }\r\n        return top[2]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [3], \"nums_element0\": [\"3\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string getHappyString. /*FC*/class Solution {\n/*FM*/string getHappyString(int n, int k) {\r\n        auto base = 1 << (n - 1); \r\n        if (k > 3 * base) {\r\n            \r\n        }\r\n        string result = string(1, 'a' + (k - 1) / base); \r\n        while (base > 1) {\r\n            k -=  ((k - 1) / base) * base; \r\n            base >>= 1; \r\n            result += (k - 1) / base == 0\r\n                      ? (result.back() != 'a' ? 'a' : 'b')\r\n                      : (result.back() != 'c' ? 'c' : 'b'); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"13\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string getHappyString. /*FC*/class Solution {\n/*FM*/string getHappyString(int n, int k) {\r\n        auto base = 1 << (n - 1); \r\n        if (k > 3 * base) {\r\n            \r\n        }\r\n        string result = string(1, 'a' + (k - 1) / base); \r\n        while (base > 1) {\r\n            \r\n            \r\n            \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"1\"], \"k\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool threeConsecutiveOdds. /*FC*/class Solution {\n/*FM*/bool threeConsecutiveOdds(vector<int>& arr) {\r\n        int count = 0; \r\n        for (const auto& x : arr) {\r\n            count = x % 2 ? count + 1 : 0; \r\n            if (count == 3) {\r\n                return true; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"arr\": [9], \"arr_element0\": [\"1\"], \"arr_element1\": [\"2\"], \"arr_element2\": [\"34\"], \"arr_element3\": [\"3\"], \"arr_element4\": [\"4\"], \"arr_element5\": [\"5\"], \"arr_element6\": [\"7\"], \"arr_element7\": [\"23\"], \"arr_element8\": [\"12\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool threeConsecutiveOdds. /*FC*/class Solution {\n/*FM*/bool threeConsecutiveOdds(vector<int>& arr) {\r\n        int count = 0; \r\n        for (const auto& x : arr) {\r\n            count = x % 2 ? count + 1 : 0; \r\n            if (count == 3) {\r\n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"arr\": [4], \"arr_element0\": [\"2\"], \"arr_element1\": [\"6\"], \"arr_element2\": [\"4\"], \"arr_element3\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string thousandSeparator. /*FC*/class Solution {\n/*FM*/string thousandSeparator(int n) {\r\n        string result; \r\n        const auto& s = to_string(n); \r\n        for (int i = 0;  i < s.length();  ++i) {\r\n            if (i > 0 && (s.length() - i) % 3 == 0) {\r\n                result += \".\"; \r\n            }\r\n            result += s[i]; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"1234\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string thousandSeparator. /*FC*/class Solution {\n/*FM*/string thousandSeparator(int n) {\r\n        string result; \r\n        const auto& s = to_string(n); \r\n        for (int i = 0;  i < s.length();  ++i) {\r\n            if (i > 0 && (s.length() - i) % 3 == 0) {\r\n                \r\n            }\r\n            result += s[i]; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"987\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int leastInterval. /*FC*/class Solution {\n/*FM*/int leastInterval(vector<char>& tasks, int n) {\r\n        unordered_map<char,int> count; \r\n        int max_count = 0; \r\n        for (const auto& task : tasks) {\r\n            ++count[task]; \r\n            max_count = max(max_count, count[task]); \r\n        }\r\n        \r\n        auto result = (max_count - 1) * (n + 1); \r\n        for (const auto& kvp : count) {\r\n            if (kvp.second == max_count) {\r\n                ++result; \r\n            }\r\n        }\r\n        return max(result, static_cast<int>(tasks.size())); \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"tasks\": [6], \"tasks_element0\": [\"65\"], \"tasks_element1\": [\"67\"], \"tasks_element2\": [\"65\"], \"tasks_element3\": [\"66\"], \"tasks_element4\": [\"68\"], \"tasks_element5\": [\"66\"], \"n\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int surfaceArea. /*FC*/class Solution {\n/*FM*/int surfaceArea(vector<vector<int>>& grid) {\r\n        int result = 0; \r\n        for (int i = 0;  i < grid.size();  ++i) {\r\n            for (int j = 0;  j < grid.size();  ++j) {\r\n                if (grid[i][j]) {\r\n                    result += grid[i][j] * 4 + 2; \r\n                }\r\n                if (i) {\r\n                    result -= min(grid[i][j], grid[i - 1][j]) * 2; \r\n                }\r\n                if (j) {\r\n                    result -= min(grid[i][j], grid[i][j - 1]) * 2; \r\n                }\r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"grid\": [2], \"grid_element0\": [2], \"grid_element0_element0\": [\"1\"], \"grid_element0_element1\": [\"2\"], \"grid_element1\": [2], \"grid_element1_element0\": [\"3\"], \"grid_element1_element1\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int superpalindromesInRange. /*FC*/class Solution {\n/*FM*/int superpalindromesInRange(string L, string R) {\r\n        const auto K = static_cast<int>(pow(10, (R.length() + 1) * 0.25)); \r\n        const int64_t l = stol(L), r = stol(R); \r\n        int result = 0; \r\n\r\n        \n        for (int k = 0;  k < K;  ++k) {\r\n            const string s = to_string(k), rev_s(s.rbegin(), s.rend()); \r\n            int64_t v = stol(s + rev_s.substr(1)); \r\n            v *= v; \r\n            if (v > r) {\r\n                break; \r\n            }\r\n            if (v >= l && is_palindrome(v)) {\r\n                ++result; \r\n            }\r\n        }\r\n\r\n        \n        for (int k = 0;  k < K;  ++k) {\r\n            const string s = to_string(k), rev_s(s.rbegin(), s.rend()); \r\n            int64_t v = stol(s + rev_s); \r\n            v *= v; \r\n            if (v > r) {\r\n                break; \r\n            }\r\n            if (v >= l && is_palindrome(v)) {\r\n                \r\n            }\r\n        }\r\n\r\n        return result; \r\n    };/*F*//*C*//*M*/bool is_palindrome(int64_t k) {\r\n        const string s = to_string(k), rev_s(s.rbegin(), s.rend()); \r\n        return s == rev_s; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"L\": [\"1\"], \"R\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int superpalindromesInRange. /*FC*/class Solution {\n/*FM*/int superpalindromesInRange(string L, string R) {\r\n        const auto K = static_cast<int>(pow(10, (R.length() + 1) * 0.25)); \r\n        const int64_t l = stol(L), r = stol(R); \r\n        int result = 0; \r\n\r\n        \n        for (int k = 0;  k < K;  ++k) {\r\n            const string s = to_string(k), rev_s(s.rbegin(), s.rend()); \r\n            int64_t v = stol(s + rev_s.substr(1)); \r\n            v *= v; \r\n            if (v > r) {\r\n                break; \r\n            }\r\n            if (v >= l && is_palindrome(v)) {\r\n                ++result; \r\n            }\r\n        }\r\n\r\n        \n        for (int k = 0;  k < K;  ++k) {\r\n            const string s = to_string(k), rev_s(s.rbegin(), s.rend()); \r\n            int64_t v = stol(s + rev_s); \r\n            v *= v; \r\n            if (v > r) {\r\n                break; \r\n            }\r\n            if (v >= l && is_palindrome(v)) {\r\n                ++result; \r\n            }\r\n        }\r\n\r\n        return result; \r\n    };/*F*//*C*//*M*/bool is_palindrome(int64_t k) {\r\n        const string s = to_string(k), rev_s(s.rbegin(), s.rend()); \r\n        return s == rev_s; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"L\": [\"4\"], \"R\": [\"1000\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxRepOpt1. /*FC*/class Solution {\n/*FM*/int maxRepOpt1(string text) {\r\n        static const int K = 1; \r\n        int result = 0, max_count = 0; \r\n        unordered_map<char, int> total_count, count; \r\n        int left = 0; \r\n        for (int i = 0;  i < text.length();  ++i) {\r\n            ++total_count[text[i]]; \r\n            ++count[text[i]]; \r\n            max_count = max(max_count, count[text[i]]); \r\n            if (i - left + 1 - max_count > K) {\r\n                \r\n            }\r\n            result = max(result, min(i - left + 1, total_count[text[i]])); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"text\": [\"aaaaa\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int maxRepOpt1. /*FC*/class Solution {\n/*FM*/int maxRepOpt1(string text) {\r\n        static const int K = 1; \r\n        int result = 0, max_count = 0; \r\n        unordered_map<char, int> total_count, count; \r\n        int left = 0; \r\n        for (int i = 0;  i < text.length();  ++i) {\r\n            ++total_count[text[i]]; \r\n            ++count[text[i]]; \r\n            max_count = max(max_count, count[text[i]]); \r\n            if (i - left + 1 - max_count > K) {\r\n                --count[text[left++]]; \r\n            }\r\n            result = max(result, min(i - left + 1, total_count[text[i]])); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"text\": [\"ababa\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumNumbers. /*FC*/class Solution {\n/*FM*/int minimumNumbers(int num, int k) {\r\n        if (!num) {\r\n            \r\n        }\r\n        const int d = k != 0 ? min(num / k, 10) : 1; \r\n        for (int i = 1;  i <= d;  ++i) {\r\n            if ((num - i * k) % 10 == 0) {\r\n                \r\n            }\r\n        }\r\n        return -1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [\"37\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumNumbers. /*FC*/class Solution {\n/*FM*/int minimumNumbers(int num, int k) {\r\n        if (!num) {\r\n            \r\n        }\r\n        const int d = k != 0 ? min(num / k, 10) : 1; \r\n        for (int i = 1;  i <= d;  ++i) {\r\n            if ((num - i * k) % 10 == 0) {\r\n                return i; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [\"58\"], \"k\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int minimumNumbers. /*FC*/class Solution {\n/*FM*/int minimumNumbers(int num, int k) {\r\n        if (!num) {\r\n            return 0; \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"num\": [\"0\"], \"k\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthSuperUglyNumber. /*FC*/class Solution {\n/*FM*/int nthSuperUglyNumber(int n, vector<int>& primes) {\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> heap; \r\n        vector<int> uglies(n), idx(primes.size()), ugly_by_last_prime(n); \r\n        uglies[0] = 1; \r\n\r\n        for (int i = 0;  i < primes.size();  ++i) {\r\n            heap.emplace(primes[i], i); \r\n        }\r\n        for (int i = 1;  i < n;  ) {\r\n            \r\n            \r\n            \r\n            \r\n            while (ugly_by_last_prime[++idx[k]] > k);   \n            \r\n        }\r\n        return uglies[n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"1\"], \"primes\": [3], \"primes_element0\": [\"2\"], \"primes_element1\": [\"3\"], \"primes_element2\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int nthSuperUglyNumber. /*FC*/class Solution {\n/*FM*/int nthSuperUglyNumber(int n, vector<int>& primes) {\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> heap; \r\n        vector<int> uglies(n), idx(primes.size()), ugly_by_last_prime(n); \r\n        uglies[0] = 1; \r\n\r\n        for (int i = 0;  i < primes.size();  ++i) {\r\n            heap.emplace(primes[i], i); \r\n        }\r\n        for (int i = 1;  i < n;  ++i) {\r\n            int k; \r\n            tie(uglies[i], k) = heap.top(); \r\n            heap.pop(); \r\n            ugly_by_last_prime[i] = k; \r\n            while (ugly_by_last_prime[++idx[k]] > k);   \n            heap.emplace(uglies[idx[k]] * primes[k], k); \r\n        }\r\n        return uglies[n - 1]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"12\"], \"primes\": [4], \"primes_element0\": [\"2\"], \"primes_element1\": [\"7\"], \"primes_element2\": [\"13\"], \"primes_element3\": [\"19\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int sumSubarrayMins. /*FC*/class Solution {\n/*FM*/int sumSubarrayMins(vector<int>& A) {\r\n        static const int M = 1e9 + 7; \r\n\r\n        vector<int> left(A.size()); \r\n        stack<pair<int, int>> s1; \r\n        for (int i = 0;  i < A.size();  ++i) {\r\n            int count = 1; \r\n            while (!s1.empty() && s1.top().first > A[i]) {\r\n                count += s1.top().second; \r\n                s1.pop(); \r\n            }\r\n            s1.emplace(A[i], count); \r\n            left[i] = count; \r\n        }\r\n\r\n        vector<int> right(A.size()); \r\n        stack<pair<int, int>> s2; \r\n        for (int i = A.size() - 1;  i >= 0;  --i) {\r\n            int count = 1; \r\n            while (!s2.empty() && s2.top().first >= A[i]) {\r\n                count += s2.top().second; \r\n                s2.pop(); \r\n            }\r\n            s2.emplace(A[i], count); \r\n            right[i] = count; \r\n        }\r\n\r\n        int result = 0; \r\n        for (int i = 0;  i < A.size();  ++i) {\r\n            result = (result + A[i] * left[i] * right[i]) % M; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [5], \"A_element0\": [\"11\"], \"A_element1\": [\"81\"], \"A_element2\": [\"94\"], \"A_element3\": [\"43\"], \"A_element4\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void solve. /*FC*/class Solution {\n/*FM*/void solve(vector<vector<char>>& board) {\r\n        if (board.empty()) {\r\n            \r\n        }\r\n\r\n        queue<pair<int, int>> q; \r\n        for (int i = 0;  i < board.size();  ++i) {\r\n            if (board[i][0] == 'O') {\r\n                \r\n                \r\n            }\r\n            if (board[i][board[0].size() - 1] == 'O') {\r\n                \r\n                \r\n            }\r\n        }\r\n\r\n        for (int j = 1;  j < board[0].size() - 1;  ) {\r\n            \r\n            \r\n        }\r\n        while (!q.empty()) {\r\n            \r\n            \r\n            \r\n            \r\n            for ( : directions) {\r\n                \r\n                \r\n            }\r\n        }\r\n        for (int i = 0;  i < board.size();  ++i) {\r\n            for (int j = 0;  j < board[0].size();  ++j) {\r\n                if (board[i][j] != 'V') {\r\n                    board[i][j] = 'X'; \r\n                } else {\r\n                    \r\n                }\r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"board\": [1], \"board_element0\": [1], \"board_element0_element0\": [\"88\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMinMoves. /*FC*/class Solution {\n/*FM*/int findMinMoves(vector<int>& machines) {\r\n        int sum = accumulate(machines.begin(), machines.end(), 0); \r\n        if (sum % machines.size() != 0) {\r\n            \r\n        }\r\n        \r\n        int result = 0, target = sum / machines.size(), curr = 0; \r\n        for (const auto& n : machines) {\r\n            curr += n - target; \r\n            result = max(result, max(n - target, abs(curr))); \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"machines\": [3], \"machines_element0\": [\"0\"], \"machines_element1\": [\"3\"], \"machines_element2\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int findMinMoves. /*FC*/class Solution {\n/*FM*/int findMinMoves(vector<int>& machines) {\r\n        int sum = accumulate(machines.begin(), machines.end(), 0); \r\n        if (sum % machines.size() != 0) {\r\n            return -1; \r\n        }\r\n        \r\n        \r\n        for ( : machines) {\r\n            \r\n            \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"machines\": [3], \"machines_element0\": [\"0\"], \"machines_element1\": [\"2\"], \"machines_element2\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> summaryRanges. /*FC*/class Solution {\n/*FM*/vector<string> summaryRanges(vector<int>& nums) {\r\n        vector<string> ranges; \r\n        if (nums.empty()) {\r\n            \r\n        }\r\n\r\n        int start = nums[0], end = nums[0]; \r\n        for (int i = 1;  i <= nums.size();  ++i) {\r\n            if (i < nums.size() && nums[i] == end + 1) {\r\n                end = nums[i]; \r\n            } else  {\r\n                auto&& range = to_string(start); \r\n                if (start != end) {\r\n                    range.append(\"->\" + to_string(end)); \r\n                }\r\n                ranges.emplace_back(range); \r\n                if (i < nums.size()) {\r\n                    start = end = nums[i]; \r\n                }\r\n            }\r\n        }\r\n\r\n        return ranges; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [7], \"nums_element0\": [\"0\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"3\"], \"nums_element3\": [\"4\"], \"nums_element4\": [\"6\"], \"nums_element5\": [\"8\"], \"nums_element6\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool checkRecord. /*FC*/class Solution {\n/*FM*/bool checkRecord(string s) {\r\n        int count_A = 0; \r\n        for (int i = 0;  i < s.length();  ++i) {\r\n            if (s[i] == 'A') {\r\n                if (++count_A == 2) {\r\n                    \r\n                }\r\n            }\r\n            if (i + 2 < s.length() && s[i] == 'L' && s[i + 1] == 'L' && s[i + 2] == 'L') {\r\n                return false; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"PPALLL\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getLengthOfOptimalCompression. /*FC*/class Solution {\n/*FM*/int getLengthOfOptimalCompression(string s, int k) {\r\n        vector<vector<int>> dp(s.length() + 1, vector<int>(k + 1, s.length())); \r\n        dp[0][0] = 0; \r\n        for (int i = 1;  i <= s.length();  ++i) {\r\n            for (int j = 0;  j <= k;  ++j) {\r\n                if (i - 1 >= 0 && j - 1 >= 0) {\r\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]); \r\n                }\r\n                int keep = 0, del = 0; \r\n                for (int m = i;  m <= s.length();  ++m) {\r\n                    if (s[i - 1] == s[m - 1]) {\r\n                        ++keep; \r\n                    } else {\r\n                        ++del; \r\n                    }\r\n                    if (j + del <= k) {\r\n                        dp[m][j + del] = min(dp[m][j + del], dp[i - 1][j] + length(keep)); \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dp[s.length()][k]; \r\n    };/*F*//*C*//*M*/int length(int cnt) {\r\n        int l = ((cnt >= 2) ? 2 : 1); \r\n        for (;  cnt >= 10;  cnt /= 10, ++l); \r\n        return l; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"aabbaa\"], \"k\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int getLengthOfOptimalCompression. /*FC*/class Solution {\n/*FM*/int getLengthOfOptimalCompression(string s, int k) {\r\n        vector<vector<int>> dp(s.length() + 1, vector<int>(k + 1, s.length())); \r\n        dp[0][0] = 0; \r\n        for (int i = 1;  i <= s.length();  ++i) {\r\n            for (int j = 0;  j <= k;  ++j) {\r\n                if (i - 1 >= 0 && j - 1 >= 0) {\r\n                    \r\n                }\r\n                int keep = 0, del = 0; \r\n                for (int m = i;  m <= s.length();  ++m) {\r\n                    if (s[i - 1] == s[m - 1]) {\r\n                        ++keep; \r\n                    } else {\r\n                        \r\n                    }\r\n                    if (j + del <= k) {\r\n                        dp[m][j + del] = min(dp[m][j + del], dp[i - 1][j] + length(keep)); \r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dp[s.length()][k]; \r\n    };/*F*//*C*//*M*/int length(int cnt) {\r\n        int l = ((cnt >= 2) ? 2 : 1); \r\n        for (;  cnt >= 10;  cnt /= 10, ++l); \r\n        return l; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"aaaaaaaaaaa\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int compress. /*FC*/class Solution {\n/*FM*/int compress(vector<char>& chars) {\r\n        int write = 0, anchor = 0; \r\n        for (int read = 0;  read < chars.size();  ++read) {\r\n            if (read + 1 == chars.size() || chars[read + 1] != chars[read]) {\r\n                chars[write++] = chars[read]; \r\n                if (read - anchor > 0) {\r\n                    auto n = read - anchor + 1, cnt = 0; \r\n                    while (n > 0) {\r\n                        chars[write++] = n % 10 + '0'; \r\n                        n /= 10; \r\n                        ++cnt; \r\n                    }\r\n                    reverse(chars.begin() + write - cnt, chars.begin() + write); \r\n                }\r\n                anchor = read + 1; \r\n            }\r\n        }\r\n        return write; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"chars\": [7], \"chars_element0\": [\"97\"], \"chars_element1\": [\"97\"], \"chars_element2\": [\"98\"], \"chars_element3\": [\"98\"], \"chars_element4\": [\"99\"], \"chars_element5\": [\"99\"], \"chars_element6\": [\"99\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int compress. /*FC*/class Solution {\n/*FM*/int compress(vector<char>& chars) {\r\n        int write = 0, anchor = 0; \r\n        for (int read = 0;  read < chars.size();  ++read) {\r\n            if (read + 1 == chars.size() || chars[read + 1] != chars[read]) {\r\n                chars[write++] = chars[read]; \r\n                if (read - anchor > 0) {\r\n                    \r\n                    \r\n                    \r\n                }\r\n                anchor = read + 1; \r\n            }\r\n        }\r\n        return write; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"chars\": [1], \"chars_element0\": [\"97\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int numSubarrayProductLessThanK. /*FC*/class Solution {\n/*FM*/int numSubarrayProductLessThanK(vector<int>& nums, int k) {\r\n        if (k <= 1) {\r\n            return 0; \r\n        }\r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [3], \"nums_element0\": [\"1\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"3\"], \"k\": [\"0\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<string> subdomainVisits. /*FC*/class Solution {\n/*FM*/vector<string> subdomainVisits(vector<string>& cpdomains) {\r\n        unordered_map<string, int> counts; \r\n        for (const auto& cpdomain : cpdomains) {\r\n            int i = cpdomain.find(\" \"); \r\n            const int count = stoi(cpdomain.substr(0, i)); \r\n            const auto& domain = cpdomain.substr(i + 1); \r\n            for (int i = -1;  i < static_cast<int>(domain.length());  ++i) {\r\n                if (i != -1 && domain[i] != '.') {\r\n                    continue; \r\n                }\r\n                counts[domain.substr(i + 1)] += count; \r\n            }\r\n        }\r\n\r\n        vector<string> result; \r\n        for (const auto& count : counts) {\r\n            result.emplace_back(to_string(count.second)); \r\n            result.back() += \" \"; \r\n            result.back() += count.first; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"cpdomains\": [1], \"cpdomains_element0\": [\"9001 discuss.leetcode.com\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string strWithout3a3b. /*FC*/class Solution {\n/*FM*/string strWithout3a3b(int A, int B) {\r\n        string result; \r\n        bool put_A = false; \r\n        while (A || B) {\r\n            if (result.length() >= 2 &&\r\n                result.back() == result[result.length() - 2]) {\r\n                \r\n            } else {\r\n                put_A = (A >= B); \r\n            }\r\n            if (put_A) {\r\n                --A; \r\n                result.push_back('a'); \r\n            } else {\r\n                --B; \r\n                result.push_back('b'); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [\"1\"], \"B\": [\"2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string strWithout3a3b. /*FC*/class Solution {\n/*FM*/string strWithout3a3b(int A, int B) {\r\n        string result; \r\n        bool put_A = false; \r\n        while (A || B) {\r\n            if (result.length() >= 2 &&\r\n                result.back() == result[result.length() - 2]) {\r\n                put_A = (result.back() == 'b'); \r\n            } else {\r\n                put_A = (A >= B); \r\n            }\r\n            if (put_A) {\r\n                --A; \r\n                result.push_back('a'); \r\n            } else {\r\n                --B; \r\n                result.push_back('b'); \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [\"4\"], \"B\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        if (str.empty()) {\r\n            \r\n        }\r\n\r\n        int ans = 0; \r\n        int sign = 1; \r\n        int i = 0; \r\n\r\n        \n        while (str[i] == ' ' || str[i] == '\\t') {\r\n            \r\n        }\r\n\r\n        if (i == str.length()) {\r\n            \r\n        }\r\n\r\n        \n        if (str[i] == '+') {\r\n            \r\n        } else if (str[i] == '-') {\r\n            \r\n            \r\n        }\r\n\r\n        \n        for (;  i < str.length() && isdigit(str[i]);  ++i) {\r\n            if (ans > (numeric_limits<int>::max() - (str[i] - '0')) / 10) { \r\n                \r\n            }\r\n            ans *= 10; \r\n            ans += str[i] - '0'; \r\n        }\r\n\r\n        ans *= sign; \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"str\": [\"0-1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        if (str.empty()) {\r\n            \r\n        }\r\n\r\n        int ans = 0; \r\n        int sign = 1; \r\n        int i = 0; \r\n\r\n        \n        while (str[i] == ' ' || str[i] == '\\t') {\r\n            \r\n        }\r\n\r\n        if (i == str.length()) {\r\n            \r\n        }\r\n\r\n        \n        if (str[i] == '+') {\r\n            \r\n        } else if (str[i] == '-') {\r\n            \r\n            \r\n        }\r\n\r\n        \n        for (;  i < str.length() && isdigit(str[i]);  ) {\r\n            \r\n            \r\n            \r\n        }\r\n\r\n        ans *= sign; \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"str\": [\"words and 987\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int myAtoi. /*FC*/class Solution {\n/*FM*/int myAtoi(string str) {\r\n        if (str.empty()) {\r\n            \r\n        }\r\n\r\n        int ans = 0; \r\n        int sign = 1; \r\n        int i = 0; \r\n\r\n        \n        while (str[i] == ' ' || str[i] == '\\t') {\r\n            ++i; \r\n        }\r\n\r\n        if (i == str.length()) {\r\n            \r\n        }\r\n\r\n        \n        if (str[i] == '+') {\r\n            \r\n        } else if (str[i] == '-') {\r\n            sign = -1; \r\n            ++i; \r\n        }\r\n\r\n        \n        for (;  i < str.length() && isdigit(str[i]);  ++i) {\r\n            if (ans > (numeric_limits<int>::max() - (str[i] - '0')) / 10) { \r\n                \r\n            }\r\n            ans *= 10; \r\n            ans += str[i] - '0'; \r\n        }\r\n\r\n        ans *= sign; \r\n        return ans; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"str\": [\"   -042\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool splitArraySameAverage. /*FC*/class Solution {\n/*FM*/bool splitArraySameAverage(vector<int>& A) {\r\n        const int n = A.size(); \r\n        const int sum = accumulate(A.cbegin(), A.cend(), 0); \r\n        if (!possible(n, sum)) {\r\n            \r\n        }\r\n        \r\n        vector<unordered_set<int>> sums(n / 2 + 1); \r\n        sums[0].emplace(0); \r\n        for (const auto& num: A) {                      \n            for (int i = n / 2;  i >= 1;  --i) {          \n                for (const auto& prev : sums[i - 1]) {  \n                    sums[i].emplace(prev + num); \r\n                }\r\n            }\r\n        }\r\n        for (int i = 1;  i <= n / 2;  ++i) {\r\n            if (sum * i % n == 0 &&\r\n                sums[i].count(sum * i / n)) {\r\n                \r\n            }\r\n        }\r\n        return false; \r\n    };/*F*//*C*//*M*/bool possible(int n, int sum) {\r\n        for (int i = 1;  i <= n / 2;  ++i)  {\r\n            if (sum * i % n == 0) {\r\n                return true; \r\n            }\r\n        }\r\n        return false; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [2], \"A_element0\": [\"3\"], \"A_element1\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool splitArraySameAverage. /*FC*/class Solution {\n/*FM*/bool splitArraySameAverage(vector<int>& A) {\r\n        const int n = A.size(); \r\n        const int sum = accumulate(A.cbegin(), A.cend(), 0); \r\n        if (!possible(n, sum)) {\r\n            \r\n        }\r\n        \r\n        vector<unordered_set<int>> sums(n / 2 + 1); \r\n        sums[0].emplace(0); \r\n        for (const auto& num: A) {                      \n            for (int i = n / 2;  i >= 1;  --i) {          \n                for (const auto& prev : sums[i - 1]) {  \n                    sums[i].emplace(prev + num); \r\n                }\r\n            }\r\n        }\r\n        for (int i = 1;  i <= n / 2;  ++i) {\r\n            if (sum * i % n == 0 &&\r\n                sums[i].count(sum * i / n)) {\r\n                return true; \r\n            }\r\n        }\r\n        \r\n    };/*F*//*C*//*M*/bool possible(int n, int sum) {\r\n        for (int i = 1;  i <= n / 2;  ++i)  {\r\n            if (sum * i % n == 0) {\r\n                return true; \r\n            }\r\n        }\r\n        return false; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [8], \"A_element0\": [\"1\"], \"A_element1\": [\"2\"], \"A_element2\": [\"3\"], \"A_element3\": [\"4\"], \"A_element4\": [\"5\"], \"A_element5\": [\"6\"], \"A_element6\": [\"7\"], \"A_element7\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortedSquares. /*FC*/class Solution {\n/*FM*/vector<int> sortedSquares(vector<int>& A) {\r\n        int right = distance(A.cbegin(), lower_bound(A.cbegin(), A.cend(), 0)); \r\n        int left = right - 1; \r\n        vector<int> result; \r\n        while (0 <= left || right < A.size()) {\r\n            if (right == A.size() ||\r\n                (0 <= left && A[left] * A[left] < A[right] * A[right])) {\r\n                result.emplace_back(A[left] * A[left]); \r\n                --left; \r\n            } else {\r\n                result.emplace_back(A[right] * A[right]); \r\n                ++right; \r\n            }\r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [5], \"A_element0\": [\"-7\"], \"A_element1\": [\"-3\"], \"A_element2\": [\"2\"], \"A_element3\": [\"3\"], \"A_element4\": [\"11\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mySqrt. /*FC*/class Solution {\n/*FM*/int mySqrt(int x) {\r\n        if (x < 2) {\r\n            \r\n        }\r\n        \r\n        int left = 1, right = x / 2; \r\n        while (left <= right) {\r\n            const auto mid = left + (right - left) / 2; \r\n            if (mid > x / mid) {\r\n                \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n\r\n        return left - 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"x\": [\"4\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int mySqrt. /*FC*/class Solution {\n/*FM*/int mySqrt(int x) {\r\n        if (x < 2) {\r\n            \r\n        }\r\n        \r\n        int left = 1, right = x / 2; \r\n        while (left <= right) {\r\n            const auto mid = left + (right - left) / 2; \r\n            if (mid > x / mid) {\r\n                right = mid - 1; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n\r\n        return left - 1; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"x\": [\"8\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool isPossible. /*FC*/class Solution {\n/*FM*/bool isPossible(vector<int>& nums) {\r\n        auto pre = numeric_limits<int>::min(), cur = 0; \r\n        auto cnt1 = 0, cnt2 = 0, cnt3 = 0;   \n        for (int i = 0;  i < nums.size();  pre = cur) {\r\n            auto cnt = 0; \r\n            for (cur = nums[i];  i < nums.size() && cur == nums[i];  ++cnt, ++i); \r\n\r\n            if (cur != pre + 1) {\r\n                if (cnt1 != 0 || cnt2 != 0) {\r\n                    \r\n                }\r\n                tie(cnt1, cnt2, cnt3) = make_tuple(cnt, 0, 0); \r\n            } else {\r\n                if (cnt < cnt1 + cnt2) {\r\n                    \r\n                }\r\n                tie(cnt1, cnt2, cnt3) = make_tuple(max(0, cnt - (cnt1 + cnt2 + cnt3)),\r\n                                                   cnt1,\r\n                                                   cnt2 + min(cnt3, cnt - (cnt1 + cnt2))); \r\n            }\r\n        }\r\n        return cnt1 == 0 && cnt2 == 0; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [6], \"nums_element0\": [\"1\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"3\"], \"nums_element3\": [\"4\"], \"nums_element4\": [\"4\"], \"nums_element5\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestValue. /*FC*/class Solution {\n/*FM*/int smallestValue(int n) {\r\n        while (true) {\r\n            int curr = n, new_n =0; \r\n            for (const auto& p : PRIMES) {\r\n                if (p * p > curr) {\r\n                    continue; \r\n                }\r\n                while (curr % p == 0) {\r\n                    curr /= p; \r\n                    new_n += p; \r\n                }\r\n            }\r\n            if (curr > 1) {  \n                new_n += curr; \r\n            }\r\n            if (new_n == n) {\r\n                break; \r\n            }\r\n            n = new_n; \r\n        }\r\n        return n; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"15\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int smallestValue. /*FC*/class Solution {\n/*FM*/int smallestValue(int n) {\r\n        while (true) {\r\n            int curr = n, new_n =0; \r\n            for (const auto& p : PRIMES) {\r\n                if (p * p > curr) {\r\n                    continue; \r\n                }\r\n                \r\n            }\r\n            if (curr > 1) {  \n                new_n += curr; \r\n            }\r\n            if (new_n == n) {\r\n                break; \r\n            }\r\n            \r\n        }\r\n        return n; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"n\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method void sortColors. /*FC*/class Solution {\n/*FM*/void sortColors(vector<int>& nums) {\r\n        static const int target = 1; \r\n        for (int i = 0, left = 0, right = nums.size() - 1;  i <= right; ) {\r\n            if (nums[i] > target) {\r\n                swap(nums[i], nums[right--]); \r\n            } else {\r\n                if (nums[i] < target) {\r\n                    swap(nums[left++], nums[i]); \r\n                } \r\n                ++i; \r\n            }\r\n        }\r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [3], \"nums_element0\": [\"2\"], \"nums_element1\": [\"0\"], \"nums_element2\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string solveEquation. /*FC*/class Solution {\n/*FM*/string solveEquation(string equation) {\r\n        auto a = 0, b = 0; \r\n        auto side = 1; \r\n        int submatches[] = { 1, 2, 3, 4 }; \r\n        auto e = regex(\"(=)|([-+]?)(\\\\d*)(x?)\"); \r\n        for (regex_token_iterator<string::iterator> it(equation.begin(), equation.end(), e, submatches), end; \r\n             it != end; ) {\r\n            auto eq = (it++)->str(); \r\n            auto sign = (it++)->str(); \r\n            auto num = (it++)->str(); \r\n            auto isx = (it++)->str(); \r\n            if (!eq.empty()) {\r\n                side = -1; \r\n            } else if (!isx.empty()) {\r\n                a += side * stoi(sign + \"1\") * stoi(num.empty() ? \"1\" : num); \r\n            } else if (!num.empty()) {\r\n                b -= side * stoi(sign + num); \r\n            }\r\n        }\r\n        return a != 0 ? \"x=\" + to_string(b / a) : b != 0 ? \"No solution\" : \"Infinite solutions\"; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"equation\": [\"x+5-3+x=6+x-2\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string solveEquation. /*FC*/class Solution {\n/*FM*/string solveEquation(string equation) {\r\n        auto a = 0, b = 0; \r\n        auto side = 1; \r\n        int submatches[] = { 1, 2, 3, 4 }; \r\n        auto e = regex(\"(=)|([-+]?)(\\\\d*)(x?)\"); \r\n        for (regex_token_iterator<string::iterator> it(equation.begin(), equation.end(), e, submatches), end; \r\n             it != end; ) {\r\n            auto eq = (it++)->str(); \r\n            auto sign = (it++)->str(); \r\n            auto num = (it++)->str(); \r\n            auto isx = (it++)->str(); \r\n            if (!eq.empty()) {\r\n                side = -1; \r\n            } else if (!isx.empty()) {\r\n                a += side * stoi(sign + \"1\") * stoi(num.empty() ? \"1\" : num); \r\n            } else if (!num.empty()) {\r\n                \r\n            }\r\n        }\r\n        return a != 0 ? \"x=\" + to_string(b / a) : b != 0 ? \"No solution\" : \"Infinite solutions\"; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"equation\": [\"2x=x\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortArrayByParityII. /*FC*/class Solution {\n/*FM*/vector<int> sortArrayByParityII(vector<int>& A) {\r\n        int j = 1; \r\n        for (int i = 0;  i < A.size();  i += 2) {\r\n            if (A[i] % 2) {\r\n                \r\n                \r\n            }\r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [2], \"A_element0\": [\"2\"], \"A_element1\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method vector<int> sortArrayByParityII. /*FC*/class Solution {\n/*FM*/vector<int> sortArrayByParityII(vector<int>& A) {\r\n        int j = 1; \r\n        for (int i = 0;  i < A.size();  i += 2) {\r\n            if (A[i] % 2) {\r\n                while (A[j] % 2) {\r\n                    \r\n                }\r\n                swap(A[i], A[j]); \r\n            }\r\n        }\r\n        return A; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"A\": [4], \"A_element0\": [\"4\"], \"A_element1\": [\"2\"], \"A_element2\": [\"5\"], \"A_element3\": [\"7\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string smallestSubsequence. /*FC*/class Solution {\n/*FM*/string smallestSubsequence(string text) {\r\n        const int k = 26; \r\n        vector<int> count(k); \r\n        for (const auto& c : text) {\r\n            ++count[c - 'a']; \r\n        }\r\n\r\n        vector<bool> lookup(k); \r\n        string stk; \r\n        for (const auto& c : text) {\r\n            if (!lookup[c - 'a']) {\r\n                while (!stk.empty() && stk.back() > c &&\r\n                       count[stk.back() - 'a']) {\r\n                    lookup[stk.back() - 'a'] = false; \r\n                    stk.pop_back(); \r\n                }\r\n                stk.push_back(c); \r\n                lookup[c - 'a'] = true; \r\n            }\r\n            --count[c - 'a']; \r\n        }\r\n        return stk;  \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"text\": [\"cbacdcbc\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/class Solution {\n/*FM*/string convert(string s, int numRows) {\r\n        if (numRows == 1) {\r\n            return s; \r\n        }\r\n        \r\n        \r\n        \r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"A\"], \"numRows\": [\"1\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method string convert. /*FC*/class Solution {\n/*FM*/string convert(string s, int numRows) {\r\n        if (numRows == 1) {\r\n            \r\n        }\r\n        const int step = 2 * numRows - 2; \r\n        string zigzag; \r\n        for (int i = 0;  i < numRows;  ++i) {\r\n            for (int j = i;  j < s.length();  j += step) {\r\n                zigzag.push_back(s[j]); \r\n                if (0 < i && i < numRows - 1 &&\r\n                    j + step - 2 * i < s.length()) {\r\n                    zigzag.push_back(s[j + step - 2 * i]); \r\n                }\r\n            }\r\n        }\r\n        return zigzag; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"PAYPALISHIRING\"], \"numRows\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool hasGroupsSizeX. /*FC*/class Solution {\n/*FM*/bool hasGroupsSizeX(vector<int>& deck) {\r\n        unordered_map<int, int> count; \r\n        for (const auto& i : deck) {\r\n            ++count[i]; \r\n        }\r\n        int result = 0; \r\n        for (const auto& kvp : count) {\r\n            result = gcd(result, kvp.second); \r\n        }\r\n        return result > 1; \r\n    };/*F*//*C*//*M*/int gcd(int a, int b) {\r\n        while (b != 0) {\r\n            int tmp = b; \r\n            b = a % b; \r\n            a = tmp; \r\n        }\r\n        return a; \r\n    };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"deck\": [8], \"deck_element0\": [\"1\"], \"deck_element1\": [\"1\"], \"deck_element2\": [\"1\"], \"deck_element3\": [\"2\"], \"deck_element4\": [\"2\"], \"deck_element5\": [\"2\"], \"deck_element6\": [\"3\"], \"deck_element7\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool exist. /*FC*/class Solution {\n/*FM*/bool exist(vector<vector<char> > &board, string word) {\r\n            const int m = board.size(); \r\n            const int n = board.front().size(); \r\n            vector<vector<bool> > visited(m, vector<bool> (n, false) ); \r\n            for(int i = 0;  i < m;  ) {\r\n                for(int j = 0;  j < n;  ) {\r\n                    if(dfs(board, word, 0,  i, j, visited))\r\n                        return true; \r\n                }\r\n            }\r\n\r\n            \r\n        };/*F*//*C*//*M*/bool dfs(vector<vector<char> > &board, string word, int index, int i, int j,  vector<vector<bool> > &visited) {\r\n            if(index == word.size()) return true;  \n\r\n            if(i < 0 || j < 0 || i >= board.size() || j >= board.front().size()  \n                    || visited[i][j] || board[i][j] != word[index])\r\n                return false; \r\n\r\n            visited[i][j] = true;   \n            bool ret = dfs(board, word, index + 1,  i + 1, j, visited) \r\n                || dfs(board, word, index + 1,  i, j + 1, visited) \r\n                || dfs(board, word, index + 1,  i - 1, j, visited) \r\n                || dfs(board, word, index + 1,  i, j - 1, visited); \r\n            visited[i][j] = false;  \n\r\n            return ret; \r\n        };\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"board\": [3], \"board_element0\": [4], \"board_element0_element0\": [\"65\"], \"board_element0_element1\": [\"66\"], \"board_element0_element2\": [\"67\"], \"board_element0_element3\": [\"69\"], \"board_element1\": [4], \"board_element1_element0\": [\"83\"], \"board_element1_element1\": [\"70\"], \"board_element1_element2\": [\"67\"], \"board_element1_element3\": [\"83\"], \"board_element2\": [4], \"board_element2_element0\": [\"65\"], \"board_element2_element1\": [\"68\"], \"board_element2_element2\": [\"69\"], \"board_element2_element3\": [\"69\"], \"word\": [\"ABCCED\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int xorOperation. /*FC*/class Solution2 {\n/*FM*/int xorOperation(int n, int start) {\r\n        int result = 0; \r\n        for (int i = start + 2 * n - 2;  i >= start;  i -= 2) {\r\n            result ^= i; \r\n        }\r\n        return result; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution2\": [\"Solution2\"], \"n\": [\"4\"], \"start\": [\"3\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int wiggleMaxLength. /*FC*/class Solution {\n/*FM*/int wiggleMaxLength(vector<int>& nums) {\r\n        if (nums.size() < 2) {\r\n            \r\n        }\r\n        \r\n        int length = 1, up = 0; \r\n\r\n        for (int i = 1;  i < nums.size();  ++i) {\r\n            if (nums[i - 1] < nums[i] && (up == 0 || up == 1)) {\r\n                ++length; \r\n                up = -1; \r\n            } else if (nums[i - 1] > nums[i] && (up == 0 || up == -1)) {\r\n                ++length; \r\n                up = 1; \r\n            }\r\n        }\r\n\r\n        return length; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [6], \"nums_element0\": [\"1\"], \"nums_element1\": [\"7\"], \"nums_element2\": [\"4\"], \"nums_element3\": [\"9\"], \"nums_element4\": [\"2\"], \"nums_element5\": [\"5\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method int wiggleMaxLength. /*FC*/class Solution {\n/*FM*/int wiggleMaxLength(vector<int>& nums) {\r\n        if (nums.size() < 2) {\r\n            \r\n        }\r\n        \r\n        int length = 1, up = 0; \r\n\r\n        for (int i = 1;  i < nums.size();  ++i) {\r\n            if (nums[i - 1] < nums[i] && (up == 0 || up == 1)) {\r\n                ++length; \r\n                up = -1; \r\n            } else if (nums[i - 1] > nums[i] && (up == 0 || up == -1)) {\r\n                \r\n                \r\n            }\r\n        }\r\n\r\n        return length; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"nums\": [9], \"nums_element0\": [\"1\"], \"nums_element1\": [\"2\"], \"nums_element2\": [\"3\"], \"nums_element3\": [\"4\"], \"nums_element4\": [\"5\"], \"nums_element5\": [\"6\"], \"nums_element6\": [\"7\"], \"nums_element7\": [\"8\"], \"nums_element8\": [\"9\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool wordPattern. /*FC*/class Solution {\n/*FM*/bool wordPattern(string pattern, string str) {\r\n        \n        int cnt = str.empty() ? 0 : 1; \r\n        for (const auto& c : str) {\r\n            if (c == ' ') {\r\n                ++cnt; \r\n            }\r\n        }\r\n        if (pattern.size() != cnt) {\r\n            \r\n        }\r\n\r\n        unordered_map<string, char> w2p; \r\n        unordered_map<char, string> p2w; \r\n        int i = 0, j = 0; \r\n        for (const auto& p : pattern) {\r\n            \n            j = str.find(\" \", i); \r\n            if (j == string::npos) {\r\n                j = str.length(); \r\n            }\r\n            const string w = str.substr(i, j - i); \r\n    \r\n            if (!w2p.count(w) && !p2w.count(p)) { \r\n                \n                w2p[w] = p;  \r\n                p2w[p] = w;  \r\n            } else if (!w2p.count(w) || w2p[w] != p) {\r\n                \n                \r\n            }\r\n            i = j + 1; \r\n        }\r\n        return true; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"pattern\": [\"abba\"], \"str\": [\"dog cat cat dog\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool wordPattern. /*FC*/class Solution {\n/*FM*/bool wordPattern(string pattern, string str) {\r\n        \n        int cnt = str.empty() ? 0 : 1; \r\n        for (const auto& c : str) {\r\n            if (c == ' ') {\r\n                ++cnt; \r\n            }\r\n        }\r\n        if (pattern.size() != cnt) {\r\n            \r\n        }\r\n\r\n        unordered_map<string, char> w2p; \r\n        unordered_map<char, string> p2w; \r\n        int i = 0, j = 0; \r\n        for (const auto& p : pattern) {\r\n            \n            j = str.find(\" \", i); \r\n            if (j == string::npos) {\r\n                \r\n            }\r\n            const string w = str.substr(i, j - i); \r\n    \r\n            if (!w2p.count(w) && !p2w.count(p)) { \r\n                \n                w2p[w] = p;  \r\n                p2w[p] = w;  \r\n            } else if (!w2p.count(w) || w2p[w] != p) {\r\n                \n                return false; \r\n            }\r\n            i = j + 1; \r\n        }\r\n        \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"pattern\": [\"aaaa\"], \"str\": [\"dog cat cat dog\"]}"
    },
    {
        "source": "Generate a test data input to maximize statement coverage for focal method bool wordBreak. /*FC*/class Solution {\n/*FM*/bool wordBreak(string s, unordered_set<string>& wordDict) {\r\n        const int n = s.length(); \r\n\r\n        size_t max_len = 0; \r\n        for (const auto& str: wordDict) {\r\n            max_len = max(max_len, str.length()); \r\n        }\r\n\r\n        vector<bool> canBreak(n + 1, false); \r\n        canBreak[0] = true; \r\n        for (int i = 1;  i <= n;  ++i) {\r\n            for (int l = 1;  l <= max_len && i - l >= 0;  ++l) {\r\n                if (canBreak[i - l] && wordDict.count(s.substr(i - l, l))) {\r\n                    canBreak[i] = true; \r\n                    break; \r\n                }\r\n            }\r\n        }\r\n\r\n        return canBreak[n]; \r\n    };/*F*//*C*//*M*/\n}",
        "target": "{\"AKA_INSTANCE___Solution\": [\"Solution\"], \"s\": [\"applepenapple\"], \"wordDict\": [2], \"wordDict_element0\": [\"apple\"], \"wordDict_element1\": [\"pen\"]}"
    }
]